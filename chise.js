/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["chise"] = factory();
	else
		root["chise"] = factory();
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("(function () {\n  var chise = function chise(_options) {\n    var param = {}; // Access the libs\n\n    var libs = (__webpack_require__(/*! ./utilities/lib-utilities */ \"./src/utilities/lib-utilities.js\").getLibs)();\n\n    var optionUtilities = __webpack_require__(/*! ./utilities/option-utilities-factory */ \"./src/utilities/option-utilities-factory.js\")();\n\n    var options = optionUtilities.extendOptions(_options); // Extends the default options with the given options\n    // Create an sbgnviz instance\n\n    var sbgnvizInstanceUtilities = __webpack_require__(/*! ./utilities/sbgnviz-instance-utilities-factory */ \"./src/utilities/sbgnviz-instance-utilities-factory.js\")();\n\n    var sbgnvizInstance = sbgnvizInstanceUtilities(options); // Register undo/redo actions\n\n    var registerUndoRedoActions = __webpack_require__(/*! ./utilities/register-undo-redo-actions-factory */ \"./src/utilities/register-undo-redo-actions-factory.js\")();\n\n    var mainUtilities = __webpack_require__(/*! ./utilities/main-utilities-factory */ \"./src/utilities/main-utilities-factory.js\")();\n\n    var elementUtilitiesExtender = __webpack_require__(/*! ./utilities/element-utilities-extender-factory */ \"./src/utilities/element-utilities-extender-factory.js\")();\n\n    var undoRedoActionFunctionsExtender = __webpack_require__(/*! ./utilities/ur-action-functions-extender-factory */ \"./src/utilities/ur-action-functions-extender-factory.js\")();\n\n    var sifTopologyGrouping = __webpack_require__(/*! ./utilities/topology-grouping-factory */ \"./src/utilities/topology-grouping-factory.js\")();\n\n    var elementUtilities = sbgnvizInstance.elementUtilities;\n    var undoRedoActionFunctions = sbgnvizInstance.undoRedoActionFunctions;\n    param.sbgnvizInstanceUtilities = sbgnvizInstanceUtilities;\n    param.optionUtilities = optionUtilities;\n    param.elementUtilities = elementUtilities;\n    param.undoRedoActionFunctions = undoRedoActionFunctions;\n    param.sifTopologyGrouping = sifTopologyGrouping;\n\n    var shouldApply = function shouldApply() {\n      return param.elementUtilities.mapType === 'SIF';\n    };\n\n    undoRedoActionFunctionsExtender(param);\n    elementUtilitiesExtender(param);\n    registerUndoRedoActions(param);\n    mainUtilities(param);\n    sifTopologyGrouping(param, {\n      metaEdgeIdentifier: 'sif-meta',\n      lockGraphTopology: true,\n      shouldApply: shouldApply\n    }); // Expose the api\n\n    var api = {}; // Expose the properties inherited from sbgnviz\n    // then override some of these properties and expose some new properties\n\n    for (var prop in sbgnvizInstance) {\n      api[prop] = sbgnvizInstance[prop];\n    } // Expose each main utility seperately\n\n\n    for (var prop in mainUtilities) {\n      api[prop] = mainUtilities[prop];\n    } // Expose getSbgnvizInstance()\n\n\n    api.getSbgnvizInstance = sbgnvizInstanceUtilities.getInstance; // Expose elementUtilities and undoRedoActionFunctions as is\n\n    api.elementUtilities = elementUtilities;\n    api.undoRedoActionFunctions = undoRedoActionFunctions;\n    api.sifTopologyGrouping = sifTopologyGrouping;\n    return api;\n  }; // Register chise with given libraries\n\n\n  chise.register = function (_libs) {\n    var libs = {};\n    libs.jQuery = _libs.jQuery || jQuery;\n    libs.cytoscape = _libs.cytoscape || cytoscape;\n    libs.sbgnviz = _libs.sbgnviz || sbgnviz;\n    libs.saveAs = _libs.filesaver ? _libs.filesaver.saveAs : saveAs;\n    libs.sbgnviz.register(_libs); // Register sbgnviz with the given libs\n    // inherit exposed static properties of sbgnviz other than register\n\n    for (var prop in libs.sbgnviz) {\n      if (prop !== 'register') {\n        chise[prop] = libs.sbgnviz[prop];\n      }\n    } // Set the libraries to access them from any file\n\n\n    var libUtilities = __webpack_require__(/*! ./utilities/lib-utilities */ \"./src/utilities/lib-utilities.js\");\n\n    libUtilities.setLibs(libs);\n  };\n\n  if ( true && module.exports) {\n    module.exports = chise;\n  }\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RVQ7OztFQUNBdEIsS0FBSyxDQUFDMEIsUUFBTixHQUFpQixVQUFVQyxLQUFWLEVBQWlCO0lBRWhDLElBQUl4QixJQUFJLEdBQUcsRUFBWDtJQUNBQSxJQUFJLENBQUN5QixNQUFMLEdBQWNELEtBQUssQ0FBQ0MsTUFBTixJQUFnQkEsTUFBOUI7SUFDQXpCLElBQUksQ0FBQzBCLFNBQUwsR0FBaUJGLEtBQUssQ0FBQ0UsU0FBTixJQUFtQkEsU0FBcEM7SUFDQTFCLElBQUksQ0FBQzJCLE9BQUwsR0FBZUgsS0FBSyxDQUFDRyxPQUFOLElBQWlCQSxPQUFoQztJQUNBM0IsSUFBSSxDQUFDNEIsTUFBTCxHQUFjSixLQUFLLENBQUNLLFNBQU4sR0FBa0JMLEtBQUssQ0FBQ0ssU0FBTixDQUFnQkQsTUFBbEMsR0FBMkNBLE1BQXpEO0lBRUE1QixJQUFJLENBQUMyQixPQUFMLENBQWFKLFFBQWIsQ0FBc0JDLEtBQXRCLEVBUmdDLENBUUY7SUFFOUI7O0lBQ0EsS0FBSyxJQUFJSixJQUFULElBQWlCcEIsSUFBSSxDQUFDMkIsT0FBdEIsRUFBK0I7TUFDN0IsSUFBSVAsSUFBSSxLQUFLLFVBQWIsRUFBeUI7UUFDdkJ2QixLQUFLLENBQUN1QixJQUFELENBQUwsR0FBY3BCLElBQUksQ0FBQzJCLE9BQUwsQ0FBYVAsSUFBYixDQUFkO01BQ0Q7SUFDRixDQWYrQixDQWlCaEM7OztJQUNBLElBQUlVLFlBQVksR0FBRzdCLG1CQUFPLENBQUMsbUVBQUQsQ0FBMUI7O0lBQ0E2QixZQUFZLENBQUNDLE9BQWIsQ0FBcUIvQixJQUFyQjtFQUNELENBcEJEOztFQXNCQSxJQUFLLFNBQWlDZ0MsTUFBTSxDQUFDQyxPQUE3QyxFQUF1RDtJQUNyREQsTUFBTSxDQUFDQyxPQUFQLEdBQWlCcEMsS0FBakI7RUFDRDtBQUNGLENBN0ZEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2hpc2UvLi9zcmMvaW5kZXguanM/YjYzNSJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtcbiAgdmFyIGNoaXNlID0gZnVuY3Rpb24oX29wdGlvbnMpIHtcblxuICAgIHZhciBwYXJhbSA9IHt9O1xuXG4gICAgLy8gQWNjZXNzIHRoZSBsaWJzXG4gICAgdmFyIGxpYnMgPSByZXF1aXJlKCcuL3V0aWxpdGllcy9saWItdXRpbGl0aWVzJykuZ2V0TGlicygpO1xuXG4gICAgdmFyIG9wdGlvblV0aWxpdGllcyA9IHJlcXVpcmUoJy4vdXRpbGl0aWVzL29wdGlvbi11dGlsaXRpZXMtZmFjdG9yeScpKCk7XG4gICAgdmFyIG9wdGlvbnMgPSBvcHRpb25VdGlsaXRpZXMuZXh0ZW5kT3B0aW9ucyhfb3B0aW9ucyk7IC8vIEV4dGVuZHMgdGhlIGRlZmF1bHQgb3B0aW9ucyB3aXRoIHRoZSBnaXZlbiBvcHRpb25zXG5cbiAgICAvLyBDcmVhdGUgYW4gc2JnbnZpeiBpbnN0YW5jZVxuICAgIHZhciBzYmdudml6SW5zdGFuY2VVdGlsaXRpZXMgPSByZXF1aXJlKCcuL3V0aWxpdGllcy9zYmdudml6LWluc3RhbmNlLXV0aWxpdGllcy1mYWN0b3J5JykoKTtcbiAgICB2YXIgc2JnbnZpekluc3RhbmNlID0gc2JnbnZpekluc3RhbmNlVXRpbGl0aWVzKG9wdGlvbnMpO1xuXG4gICAgLy8gUmVnaXN0ZXIgdW5kby9yZWRvIGFjdGlvbnNcbiAgICB2YXIgcmVnaXN0ZXJVbmRvUmVkb0FjdGlvbnMgPSByZXF1aXJlKCcuL3V0aWxpdGllcy9yZWdpc3Rlci11bmRvLXJlZG8tYWN0aW9ucy1mYWN0b3J5JykoKTtcblxuICAgIHZhciBtYWluVXRpbGl0aWVzID0gcmVxdWlyZSgnLi91dGlsaXRpZXMvbWFpbi11dGlsaXRpZXMtZmFjdG9yeScpKCk7XG4gICAgdmFyIGVsZW1lbnRVdGlsaXRpZXNFeHRlbmRlciA9IHJlcXVpcmUoJy4vdXRpbGl0aWVzL2VsZW1lbnQtdXRpbGl0aWVzLWV4dGVuZGVyLWZhY3RvcnknKSgpO1xuICAgIHZhciB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9uc0V4dGVuZGVyID0gcmVxdWlyZSgnLi91dGlsaXRpZXMvdXItYWN0aW9uLWZ1bmN0aW9ucy1leHRlbmRlci1mYWN0b3J5JykoKTtcbiAgICB2YXIgc2lmVG9wb2xvZ3lHcm91cGluZyA9IHJlcXVpcmUoJy4vdXRpbGl0aWVzL3RvcG9sb2d5LWdyb3VwaW5nLWZhY3RvcnknKSgpO1xuXG4gICAgdmFyIGVsZW1lbnRVdGlsaXRpZXMgPSAgc2JnbnZpekluc3RhbmNlLmVsZW1lbnRVdGlsaXRpZXM7XG4gICAgdmFyIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zID0gc2JnbnZpekluc3RhbmNlLnVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zO1xuXG4gICAgcGFyYW0uc2JnbnZpekluc3RhbmNlVXRpbGl0aWVzID0gc2JnbnZpekluc3RhbmNlVXRpbGl0aWVzO1xuICAgIHBhcmFtLm9wdGlvblV0aWxpdGllcyA9IG9wdGlvblV0aWxpdGllcztcbiAgICBwYXJhbS5lbGVtZW50VXRpbGl0aWVzID0gZWxlbWVudFV0aWxpdGllcztcbiAgICBwYXJhbS51bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucyA9IHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zO1xuICAgIHBhcmFtLnNpZlRvcG9sb2d5R3JvdXBpbmcgPSBzaWZUb3BvbG9neUdyb3VwaW5nO1xuXG4gICAgdmFyIHNob3VsZEFwcGx5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcGFyYW0uZWxlbWVudFV0aWxpdGllcy5tYXBUeXBlID09PSAnU0lGJztcbiAgICB9O1xuXG4gICAgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnNFeHRlbmRlcihwYXJhbSk7XG4gICAgZWxlbWVudFV0aWxpdGllc0V4dGVuZGVyKHBhcmFtKTtcbiAgICByZWdpc3RlclVuZG9SZWRvQWN0aW9ucyhwYXJhbSk7XG4gICAgbWFpblV0aWxpdGllcyhwYXJhbSk7XG4gICAgc2lmVG9wb2xvZ3lHcm91cGluZyhwYXJhbSwge21ldGFFZGdlSWRlbnRpZmllcjogJ3NpZi1tZXRhJywgbG9ja0dyYXBoVG9wb2xvZ3k6IHRydWUsIHNob3VsZEFwcGx5fSk7XG5cbiAgICAvLyBFeHBvc2UgdGhlIGFwaVxuICAgIHZhciBhcGkgPSB7fTtcblxuICAgIC8vIEV4cG9zZSB0aGUgcHJvcGVydGllcyBpbmhlcml0ZWQgZnJvbSBzYmdudml6XG4gICAgLy8gdGhlbiBvdmVycmlkZSBzb21lIG9mIHRoZXNlIHByb3BlcnRpZXMgYW5kIGV4cG9zZSBzb21lIG5ldyBwcm9wZXJ0aWVzXG4gICAgZm9yICh2YXIgcHJvcCBpbiBzYmdudml6SW5zdGFuY2UpIHtcbiAgICAgIGFwaVtwcm9wXSA9IHNiZ252aXpJbnN0YW5jZVtwcm9wXTtcbiAgICB9XG5cbiAgICAvLyBFeHBvc2UgZWFjaCBtYWluIHV0aWxpdHkgc2VwZXJhdGVseVxuICAgIGZvciAodmFyIHByb3AgaW4gbWFpblV0aWxpdGllcykge1xuICAgICAgYXBpW3Byb3BdID0gbWFpblV0aWxpdGllc1twcm9wXTtcbiAgICB9XG5cbiAgICAvLyBFeHBvc2UgZ2V0U2JnbnZpekluc3RhbmNlKClcbiAgICBhcGkuZ2V0U2JnbnZpekluc3RhbmNlID0gc2JnbnZpekluc3RhbmNlVXRpbGl0aWVzLmdldEluc3RhbmNlO1xuXG4gICAgLy8gRXhwb3NlIGVsZW1lbnRVdGlsaXRpZXMgYW5kIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zIGFzIGlzXG4gICAgYXBpLmVsZW1lbnRVdGlsaXRpZXMgPSBlbGVtZW50VXRpbGl0aWVzO1xuICAgIGFwaS51bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucyA9IHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zO1xuICAgIGFwaS5zaWZUb3BvbG9neUdyb3VwaW5nID0gc2lmVG9wb2xvZ3lHcm91cGluZztcblxuICAgIHJldHVybiBhcGk7XG4gIH07XG5cbiAgLy8gUmVnaXN0ZXIgY2hpc2Ugd2l0aCBnaXZlbiBsaWJyYXJpZXNcbiAgY2hpc2UucmVnaXN0ZXIgPSBmdW5jdGlvbiAoX2xpYnMpIHtcblxuICAgIHZhciBsaWJzID0ge307XG4gICAgbGlicy5qUXVlcnkgPSBfbGlicy5qUXVlcnkgfHwgalF1ZXJ5O1xuICAgIGxpYnMuY3l0b3NjYXBlID0gX2xpYnMuY3l0b3NjYXBlIHx8IGN5dG9zY2FwZTtcbiAgICBsaWJzLnNiZ252aXogPSBfbGlicy5zYmdudml6IHx8IHNiZ252aXo7XG4gICAgbGlicy5zYXZlQXMgPSBfbGlicy5maWxlc2F2ZXIgPyBfbGlicy5maWxlc2F2ZXIuc2F2ZUFzIDogc2F2ZUFzO1xuXG4gICAgbGlicy5zYmdudml6LnJlZ2lzdGVyKF9saWJzKTsgLy8gUmVnaXN0ZXIgc2JnbnZpeiB3aXRoIHRoZSBnaXZlbiBsaWJzXG5cbiAgICAvLyBpbmhlcml0IGV4cG9zZWQgc3RhdGljIHByb3BlcnRpZXMgb2Ygc2JnbnZpeiBvdGhlciB0aGFuIHJlZ2lzdGVyXG4gICAgZm9yICh2YXIgcHJvcCBpbiBsaWJzLnNiZ252aXopIHtcbiAgICAgIGlmIChwcm9wICE9PSAncmVnaXN0ZXInKSB7XG4gICAgICAgIGNoaXNlW3Byb3BdID0gbGlicy5zYmdudml6W3Byb3BdO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNldCB0aGUgbGlicmFyaWVzIHRvIGFjY2VzcyB0aGVtIGZyb20gYW55IGZpbGVcbiAgICB2YXIgbGliVXRpbGl0aWVzID0gcmVxdWlyZSgnLi91dGlsaXRpZXMvbGliLXV0aWxpdGllcycpO1xuICAgIGxpYlV0aWxpdGllcy5zZXRMaWJzKGxpYnMpO1xuICB9O1xuXG4gIGlmICggdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMgKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBjaGlzZTtcbiAgfVxufSkoKTtcbiJdLCJuYW1lcyI6WyJjaGlzZSIsIl9vcHRpb25zIiwicGFyYW0iLCJsaWJzIiwicmVxdWlyZSIsImdldExpYnMiLCJvcHRpb25VdGlsaXRpZXMiLCJvcHRpb25zIiwiZXh0ZW5kT3B0aW9ucyIsInNiZ252aXpJbnN0YW5jZVV0aWxpdGllcyIsInNiZ252aXpJbnN0YW5jZSIsInJlZ2lzdGVyVW5kb1JlZG9BY3Rpb25zIiwibWFpblV0aWxpdGllcyIsImVsZW1lbnRVdGlsaXRpZXNFeHRlbmRlciIsInVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zRXh0ZW5kZXIiLCJzaWZUb3BvbG9neUdyb3VwaW5nIiwiZWxlbWVudFV0aWxpdGllcyIsInVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zIiwic2hvdWxkQXBwbHkiLCJtYXBUeXBlIiwibWV0YUVkZ2VJZGVudGlmaWVyIiwibG9ja0dyYXBoVG9wb2xvZ3kiLCJhcGkiLCJwcm9wIiwiZ2V0U2JnbnZpekluc3RhbmNlIiwiZ2V0SW5zdGFuY2UiLCJyZWdpc3RlciIsIl9saWJzIiwialF1ZXJ5IiwiY3l0b3NjYXBlIiwic2JnbnZpeiIsInNhdmVBcyIsImZpbGVzYXZlciIsImxpYlV0aWxpdGllcyIsInNldExpYnMiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/index.js\n");

/***/ }),

/***/ "./src/utilities/element-utilities-extender-factory.js":
/*!*************************************************************!*\
  !*** ./src/utilities/element-utilities-extender-factory.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\n// Extends sbgnviz.elementUtilities\nvar libs = (__webpack_require__(/*! ./lib-utilities */ \"./src/utilities/lib-utilities.js\").getLibs)();\n\nvar jQuery = $ = libs.jQuery;\n\nmodule.exports = function () {\n  var options, sbgnvizInstance, elementUtilities, cy;\n\n  function elementUtilitiesExtender(param) {\n    sbgnvizInstance = param.sbgnvizInstanceUtilities.getInstance();\n    options = param.optionUtilities.getOptions();\n    elementUtilities = sbgnvizInstance.elementUtilities;\n    cy = param.sbgnvizInstanceUtilities.getCy();\n    extend(); // Return the extended elementUtilities\n\n    return elementUtilities;\n  } // Extends elementUtilities with chise specific facilities\n\n\n  function extend() {\n    // Section Start\n    // Add remove utilities\n    elementUtilities.addNode = function (x, y, nodeParams, id, parent, visibility) {\n      if (_typeof(nodeParams) != 'object') {\n        var sbgnclass = nodeParams;\n      } else {\n        var sbgnclass = nodeParams[\"class\"];\n        var language = nodeParams.language;\n      }\n\n      var css = {}; //('sbgnclass', sbgnclass)\n      // if there is no specific default width or height for\n      // sbgnclass these sizes are used\n\n      var defaultWidth = 50;\n      var defaultHeight = 50;\n\n      if (visibility) {\n        css.visibility = visibility;\n      }\n\n      var data = {\n        \"class\": sbgnclass,\n        language: language,\n        bbox: {\n          w: defaultWidth,\n          h: defaultHeight,\n          x: x,\n          y: y\n        },\n        statesandinfos: [],\n        ports: []\n      }; //console.log(\"data\", data)\n\n      if (id) {\n        data.id = id;\n      } else {\n        data.id = elementUtilities.generateNodeId();\n      }\n\n      if (parent) {\n        data.parent = parent;\n      }\n\n      this.extendNodeDataWithClassDefaults(data, sbgnclass); // some defaults are not set by extendNodeDataWithClassDefaults()\n      //console.log(\"sbgnclass\", sbgnclass)\n\n      var defaults = this.getDefaultProperties(sbgnclass);\n\n      if (defaults['multimer']) {\n        data[\"class\"] += ' multimer';\n      }\n\n      if (defaults['clonemarker']) {\n        data['clonemarker'] = true;\n      }\n\n      if (defaults['active']) {\n        data[\"class\"] = 'active ' + data[\"class\"];\n      }\n\n      if (defaults['hypothetical']) {\n        data[\"class\"] = 'hypothetical ' + data[\"class\"];\n      }\n\n      data.bbox['w'] = defaults['width'];\n      data.bbox['h'] = defaults['height']; //console.log(\"data\", data)\n\n      var eles = cy.add({\n        group: \"nodes\",\n        data: data,\n        css: css,\n        position: {\n          x: x,\n          y: y\n        }\n      }); //console.log('eles', eles)\n\n      var newNode = eles[eles.length - 1]; // Get the default ports ordering for the nodes with given sbgnclass\n\n      var ordering = defaults['ports-ordering']; // If there is a default ports ordering for the nodes with given sbgnclass and it is different than 'none' set the ports ordering to that ordering\n\n      if (ordering && ordering !== 'none') {\n        this.setPortsOrdering(newNode, ordering);\n      }\n\n      if (language == \"AF\" && !elementUtilities.canHaveMultipleUnitOfInformation(newNode)) {\n        if (sbgnclass != \"BA plain\") {\n          // if AF node can have label i.e: not plain biological activity\n          var uoi_obj = {\n            clazz: \"unit of information\"\n          };\n          uoi_obj.label = {\n            text: \"\"\n          };\n          uoi_obj.bbox = {\n            w: 12,\n            h: 12\n          };\n          elementUtilities.addStateOrInfoBox(newNode, uoi_obj);\n        }\n      } // node bg image was unexpectedly not rendered until it is clicked\n      // use this dirty hack until finding a solution to the problem\n\n\n      var bgImage = newNode.data('background-image'); //alert('bgImage', bgImage)\n\n      if (bgImage) {\n        newNode.data('background-image', bgImage);\n      }\n\n      return newNode;\n    }; //Saves old aux units of given node\n\n\n    elementUtilities.saveUnits = function (node) {\n      var tempData = [];\n      var index = 0;\n      node.data('statesandinfos').forEach(function (ele) {\n        tempData.push({\n          x: ele.bbox.x,\n          y: ele.bbox.y,\n          anchorSide: ele.anchorSide\n        });\n        index++;\n      });\n      return tempData;\n    }; //Restores from given data\n\n\n    elementUtilities.restoreUnits = function (node, data) {\n      var index = 0;\n      node.data('statesandinfos').forEach(function (ele) {\n        if (data !== undefined) {\n          ele.bbox.x = data[index].x;\n          ele.bbox.y = data[index].y;\n          var anchorSide = ele.anchorSide;\n          ele.anchorSide = data[index].anchorSide;\n          elementUtilities.modifyUnits(node, ele, anchorSide);\n          index++;\n        }\n      });\n    }; //Modify aux unit layouts\n\n\n    elementUtilities.modifyUnits = function (node, ele, anchorSide) {\n      console.log(\"elementUtilities.modifyUnits\", node);\n      instance.classes.AuxUnitLayout.modifyUnits(node, ele, anchorSide, cy);\n    }; //For reversible reactions both side of the process can be input/output\n    //Group ID identifies to which group of nodes the edge is going to be connected for reversible reactions(0: group 1 ID and 1:group 2 ID)\n\n\n    elementUtilities.addEdge = function (source, target, edgeParams, id, visibility, groupID) {\n      if (_typeof(edgeParams) != 'object') {\n        var sbgnclass = edgeParams;\n      } else {\n        var sbgnclass = edgeParams[\"class\"];\n        var language = edgeParams.language;\n      }\n\n      var css = {};\n\n      if (visibility) {\n        css.visibility = visibility;\n      }\n\n      var data = {\n        source: source,\n        target: target,\n        \"class\": sbgnclass,\n        language: language\n      };\n      var defaults = elementUtilities.getDefaultProperties(sbgnclass); // extend the data with default properties of edge style\n\n      Object.keys(defaults).forEach(function (prop) {\n        data[prop] = defaults[prop];\n      });\n\n      if (id) {\n        data.id = id;\n      } else {\n        data.id = elementUtilities.generateEdgeId();\n      }\n\n      if (elementUtilities.canHaveSBGNCardinality(sbgnclass)) {\n        data.cardinality = 0;\n      }\n\n      var sourceNode = cy.getElementById(source); // The original source node\n\n      var targetNode = cy.getElementById(target); // The original target node\n\n      var sourceHasPorts = sourceNode.data('ports').length === 2;\n      var targetHasPorts = targetNode.data('ports').length === 2; // The portsource and porttarget variables\n\n      var portsource;\n      var porttarget;\n      /*\n       * Get input/output port id's of a node with the assumption that the node has valid ports.\n       */\n\n      var getIOPortIds = function getIOPortIds(node) {\n        var nodeInputPortId, nodeOutputPortId;\n        var nodePortsOrdering = sbgnvizInstance.elementUtilities.getPortsOrdering(node);\n        var nodePorts = node.data('ports');\n\n        if (nodePortsOrdering === 'L-to-R' || nodePortsOrdering === 'R-to-L') {\n          var leftPortId = nodePorts[0].x < 0 ? nodePorts[0].id : nodePorts[1].id; // The x value of left port is supposed to be negative\n\n          var rightPortId = nodePorts[0].x > 0 ? nodePorts[0].id : nodePorts[1].id; // The x value of right port is supposed to be positive\n\n          /*\n           * If the port ordering is left to right then the input port is the left port and the output port is the right port.\n           * Else if it is right to left it is vice versa\n           */\n\n          nodeInputPortId = nodePortsOrdering === 'L-to-R' ? leftPortId : rightPortId;\n          nodeOutputPortId = nodePortsOrdering === 'R-to-L' ? leftPortId : rightPortId;\n        } else if (nodePortsOrdering === 'T-to-B' || nodePortsOrdering === 'B-to-T') {\n          var topPortId = nodePorts[0].y < 0 ? nodePorts[0].id : nodePorts[1].id; // The y value of top port is supposed to be negative\n\n          var bottomPortId = nodePorts[0].y > 0 ? nodePorts[0].id : nodePorts[1].id; // The y value of bottom port is supposed to be positive\n\n          /*\n           * If the port ordering is top to bottom then the input port is the top port and the output port is the bottom port.\n           * Else if it is right to left it is vice versa\n           */\n\n          nodeInputPortId = nodePortsOrdering === 'T-to-B' ? topPortId : bottomPortId;\n          nodeOutputPortId = nodePortsOrdering === 'B-to-T' ? topPortId : bottomPortId;\n        } // Return an object containing the IO ports of the node\n\n\n        return {\n          inputPortId: nodeInputPortId,\n          outputPortId: nodeOutputPortId\n        };\n      }; // If at least one end of the edge has ports then we should determine the ports where the edge should be connected.\n\n\n      if (sourceHasPorts || targetHasPorts) {\n        var sourceNodeInputPortId, sourceNodeOutputPortId, targetNodeInputPortId, targetNodeOutputPortId; // If source node has ports set the variables dedicated for its IO ports\n\n        if (sourceHasPorts) {\n          var ioPorts = getIOPortIds(sourceNode);\n          sourceNodeInputPortId = ioPorts.inputPortId;\n          sourceNodeOutputPortId = ioPorts.outputPortId;\n        } // If target node has ports set the variables dedicated for its IO ports\n\n\n        if (targetHasPorts) {\n          var ioPorts = getIOPortIds(targetNode);\n          targetNodeInputPortId = ioPorts.inputPortId;\n          targetNodeOutputPortId = ioPorts.outputPortId;\n        }\n\n        if (sbgnclass === 'consumption') {\n          // A consumption edge should be connected to the input port of the target node which is supposed to be a process (any kind of)\n          portsource = sourceNodeOutputPortId;\n          porttarget = targetNodeInputPortId;\n        } else if (sbgnclass === 'production') {\n          // A production edge should be connected to the output port of the source node which is supposed to be a process (any kind of)\n          // A modulation edge may have a logical operator as source node in this case the edge should be connected to the output port of it\n          // The below assignment satisfy all of these condition\n          if (groupID == 0 || groupID == undefined) {\n            // groupID 0 for reversible reactions group 0\n            portsource = sourceNodeOutputPortId;\n            porttarget = targetNodeInputPortId;\n          } else {\n            //if reaction is reversible and edge belongs to group 1\n            portsource = sourceNodeInputPortId;\n          }\n        } else if (elementUtilities.isModulationArcClass(sbgnclass) || elementUtilities.isAFArcClass(sbgnclass)) {\n          portsource = sourceNodeOutputPortId;\n        } else if (sbgnclass === 'logic arc') {\n          var srcClass = sourceNode.data('class');\n          var tgtClass = targetNode.data('class');\n          var isSourceLogicalOp = srcClass === 'and' || srcClass === 'or' || srcClass === 'not';\n          var isTargetLogicalOp = tgtClass === 'and' || tgtClass === 'or' || tgtClass === 'not';\n\n          if (isSourceLogicalOp && isTargetLogicalOp) {\n            // If both end are logical operators then the edge should be connected to the input port of the target and the output port of the input\n            porttarget = targetNodeInputPortId;\n            portsource = sourceNodeOutputPortId;\n          } // If just one end of logical operator then the edge should be connected to the input port of the logical operator\n          else if (isSourceLogicalOp) {\n            portsource = sourceNodeInputPortId;\n            porttarget = targetNodeOutputPortId;\n          } else if (isTargetLogicalOp) {\n            portsource = sourceNodeOutputPortId;\n            porttarget = targetNodeInputPortId;\n          }\n        }\n      } // The default portsource/porttarget are the source/target themselves. If they are not set use these defaults.\n      // The portsource and porttarget are determined set them in data object.\n\n\n      data.portsource = portsource || source;\n      data.porttarget = porttarget || target;\n      var eles = cy.add({\n        group: \"edges\",\n        data: data,\n        css: css\n      });\n      var newEdge = eles[eles.length - 1];\n      return newEdge;\n    };\n\n    elementUtilities.addProcessWithConvenientEdges = function (_source, _target, nodeParams) {\n      // If source and target IDs are given get the elements by IDs\n      var source = typeof _source === 'string' ? cy.getElementById(_source) : _source;\n      var target = typeof _target === 'string' ? cy.getElementById(_target) : _target; // Process parent should be the closest common ancestor of the source and target nodes\n\n      var processParent = cy.collection([source[0], target[0]]).commonAncestors().first(); // Process should be at the middle of the source and target nodes\n\n      var x = (source.position('x') + target.position('x')) / 2;\n      var y = (source.position('y') + target.position('y')) / 2; // Create the process with given/calculated variables\n\n      var process = elementUtilities.addNode(x, y, nodeParams, undefined, processParent.id());\n      var xdiff = source.position('x') - target.position('x');\n      var ydiff = source.position('y') - target.position('y');\n\n      if (Math.abs(xdiff) >= Math.abs(ydiff)) {\n        if (xdiff < 0) elementUtilities.setPortsOrdering(process, 'L-to-R');else elementUtilities.setPortsOrdering(process, 'R-to-L');\n      } else {\n        if (ydiff < 0) elementUtilities.setPortsOrdering(process, 'T-to-B');else elementUtilities.setPortsOrdering(process, 'B-to-T');\n      } // Create the edges one is between the process and the source node (which should be a consumption),\n      // the other one is between the process and the target node (which should be a production).\n      // For more information please refer to SBGN-PD reference card.\n\n\n      var edgeBtwSrc = elementUtilities.addEdge(source.id(), process.id(), {\n        \"class\": 'consumption',\n        language: nodeParams.language\n      });\n      var edgeBtwTgt = elementUtilities.addEdge(process.id(), target.id(), {\n        \"class\": 'production',\n        language: nodeParams.language\n      }); // Create a collection including the elements and to be returned\n\n      var collection = cy.collection([process[0], edgeBtwSrc[0], edgeBtwTgt[0]]);\n      return collection;\n    };\n    /*\n     * This method assumes that param.nodesToMakeCompound contains at least one node\n     * and all of the nodes including in it have the same parent. It creates a compound fot the given nodes an having the given type.\n     */\n\n\n    elementUtilities.createCompoundForGivenNodes = function (nodesToMakeCompound, compoundType) {\n      var oldParentId = nodesToMakeCompound[0].data(\"parent\");\n      var language = nodesToMakeCompound[0].data(\"language\"); // if nodesToMakeCompound contain both PD and AF nodes, then set language of compound as Unknown\n\n      for (var i = 1; i < nodesToMakeCompound.length; i++) {\n        if (nodesToMakeCompound[i] != language) {\n          language = \"Unknown\";\n          break;\n        }\n      } // The parent of new compound will be the old parent of the nodes to make compound. x, y and id parameters are not set.\n\n\n      var newCompound = elementUtilities.addNode(undefined, undefined, {\n        \"class\": compoundType,\n        language: language\n      }, undefined, oldParentId);\n      var newCompoundId = newCompound.id();\n      var newEles = elementUtilities.changeParent(nodesToMakeCompound, newCompoundId);\n      newEles = newEles.union(newCompound);\n      return newEles;\n    };\n\n    elementUtilities.createTranslationReaction = function (mRnaName, proteinName, processPosition, edgeLength) {\n      var defaultProcessProperties = elementUtilities.getDefaultProperties(\"translation\");\n      var defaultSourceAndSinkProperties = elementUtilities.getDefaultProperties(\"empty set\");\n      var defaultNucleicAcidFeatureProperties = elementUtilities.getDefaultProperties(\"nucleic acid feature\");\n      var defaultMacromoleculeProperties = elementUtilities.getDefaultProperties(\"macromolecule\");\n      var macromoleculeWidth = defaultMacromoleculeProperties.width || 50;\n      var sourceAndSinkWidth = defaultSourceAndSinkProperties.width || 50;\n      var nucleicAcidFeatureHeight = defaultNucleicAcidFeatureProperties.height || 50;\n      var processWidth = defaultProcessProperties.width || 50;\n      var processHeight = defaultProcessProperties.height || 50;\n      var processPosition = processPosition || elementUtilities.convertToModelPosition({\n        x: cy.width() / 2,\n        y: cy.height() / 2\n      });\n      var edgeLength = edgeLength || 60;\n      cy.startBatch();\n\n      if (!elementUtilities.getMapType()) {\n        elementUtilities.setMapType(\"PD\");\n      }\n\n      var processNode = elementUtilities.addNode(processPosition.x, processPosition.y, {\n        \"class\": \"process\",\n        language: \"PD\"\n      });\n      elementUtilities.setPortsOrdering(processNode, \"L-to-R\");\n      processNode.data('justAdded', true);\n      var xPosOfSourceAndSinkNode = processPosition.x - edgeLength - processWidth / 2 - sourceAndSinkWidth / 2;\n      var yPosOfSourceAndSinkNode = processPosition.y;\n      var sourceAndSinkNode = elementUtilities.addNode(xPosOfSourceAndSinkNode, yPosOfSourceAndSinkNode, {\n        \"class\": 'empty set',\n        language: 'PD'\n      });\n      sourceAndSinkNode.data('justAdded', true);\n      var consumptionEdge = elementUtilities.addEdge(sourceAndSinkNode.id(), processNode.id(), {\n        \"class\": 'consumption',\n        language: 'PD'\n      });\n      consumptionEdge.data('justAdded', true);\n      var xPosOfmRnaNode = processPosition.x;\n      var yPosOfmRnaNode = processPosition.y - edgeLength - processHeight / 2 - nucleicAcidFeatureHeight / 2;\n      var mRnaNode = elementUtilities.addNode(xPosOfmRnaNode, yPosOfmRnaNode, {\n        \"class\": 'nucleic acid feature',\n        language: 'PD'\n      });\n      mRnaNode.data('justAdded', true);\n      mRnaNode.data('label', mRnaName);\n      var infoboxObjectOfGene = {\n        clazz: \"unit of information\",\n        label: {\n          text: 'ct:mRNA'\n        },\n        bbox: {\n          w: 45,\n          h: 15\n        }\n      };\n      elementUtilities.addStateOrInfoBox(mRnaNode, infoboxObjectOfGene);\n      var necessaryStimulationEdge = elementUtilities.addEdge(mRnaNode.id(), processNode.id(), {\n        \"class\": 'necessary stimulation',\n        language: 'PD'\n      });\n      necessaryStimulationEdge.data('justAdded', true);\n      var xPosOfProteinNode = processPosition.x + edgeLength + processWidth / 2 + macromoleculeWidth / 2;\n      var yPostOfProteinNode = processPosition.y;\n      var proteinNode = elementUtilities.addNode(xPosOfProteinNode, yPostOfProteinNode, {\n        \"class\": 'macromolecule',\n        language: 'PD'\n      });\n      proteinNode.data('justAdded', true);\n      proteinNode.data('label', proteinName);\n      var productionEdge = elementUtilities.addEdge(processNode.id(), proteinNode.id(), {\n        \"class\": 'production',\n        language: 'PD'\n      });\n      productionEdge.data('justAdded', true);\n      cy.endBatch(); //filter the just added elememts to return them and remove just added mark\n\n      var eles = cy.elements('[justAdded]');\n      eles.removeData('justAdded');\n      cy.elements().unselect();\n      eles.select();\n      return eles; // Return the just added elements\n    };\n\n    elementUtilities.createTranscriptionReaction = function (geneName, mRnaName, processPosition, edgeLength) {\n      var defaultProcessProperties = elementUtilities.getDefaultProperties(\"transcription\");\n      var defaultSourceAndSinkProperties = elementUtilities.getDefaultProperties(\"empty set\");\n      var defaultNucleicAcidFeatureProperties = elementUtilities.getDefaultProperties(\"nucleic acid feature\");\n      var sourceAndSinkWidth = defaultSourceAndSinkProperties.width || 50;\n      var nucleicAcidFeatureHeight = defaultNucleicAcidFeatureProperties.height || 50;\n      var nucleicAcidFeatureWidth = defaultNucleicAcidFeatureProperties.width || 50;\n      var processWidth = defaultProcessProperties.width || 50;\n      var processHeight = defaultProcessProperties.height || 50;\n      var processPosition = processPosition || elementUtilities.convertToModelPosition({\n        x: cy.width() / 2,\n        y: cy.height() / 2\n      });\n      var edgeLength = edgeLength || 60;\n      cy.startBatch();\n\n      if (!elementUtilities.getMapType()) {\n        elementUtilities.setMapType(\"PD\");\n      }\n\n      var processNode = elementUtilities.addNode(processPosition.x, processPosition.y, {\n        \"class\": \"process\",\n        language: \"PD\"\n      });\n      elementUtilities.setPortsOrdering(processNode, \"L-to-R\");\n      processNode.data('justAdded', true);\n      var xPosOfSourceAndSinkNode = processPosition.x - edgeLength - processWidth / 2 - sourceAndSinkWidth / 2;\n      var yPosOfSourceAndSinkNode = processPosition.y;\n      var sourceAndSinkNode = elementUtilities.addNode(xPosOfSourceAndSinkNode, yPosOfSourceAndSinkNode, {\n        \"class\": 'empty set',\n        language: 'PD'\n      });\n      sourceAndSinkNode.data('justAdded', true);\n      var consumptionEdge = elementUtilities.addEdge(sourceAndSinkNode.id(), processNode.id(), {\n        \"class\": 'consumption',\n        language: 'PD'\n      });\n      consumptionEdge.data('justAdded', true);\n      var xPosOfGeneNode = processPosition.x;\n      var yPosOfGeneNode = processPosition.y - edgeLength - processHeight / 2 - nucleicAcidFeatureHeight / 2;\n      var geneNode = elementUtilities.addNode(xPosOfGeneNode, yPosOfGeneNode, {\n        \"class\": 'nucleic acid feature',\n        language: 'PD'\n      });\n      geneNode.data('justAdded', true);\n      geneNode.data('label', geneName);\n      var infoboxObjectOfGene = {\n        clazz: \"unit of information\",\n        label: {\n          text: 'ct:gene'\n        },\n        bbox: {\n          w: 36,\n          h: 15\n        }\n      };\n      elementUtilities.addStateOrInfoBox(geneNode, infoboxObjectOfGene);\n      var necessaryStimulationEdge = elementUtilities.addEdge(geneNode.id(), processNode.id(), {\n        \"class\": 'necessary stimulation',\n        language: 'PD'\n      });\n      necessaryStimulationEdge.data('justAdded', true);\n      var xPosOfmRnaNode = processPosition.x + edgeLength + processWidth / 2 + nucleicAcidFeatureWidth / 2;\n      var yPostOfmRnaNode = processPosition.y;\n      var mRnaNode = elementUtilities.addNode(xPosOfmRnaNode, yPostOfmRnaNode, {\n        \"class\": 'nucleic acid feature',\n        language: 'PD'\n      });\n      mRnaNode.data('justAdded', true);\n      mRnaNode.data('label', mRnaName);\n      var infoboxObjectOfmRna = {\n        clazz: \"unit of information\",\n        label: {\n          text: 'ct:mRNA'\n        },\n        bbox: {\n          w: 45,\n          h: 15\n        }\n      };\n      elementUtilities.addStateOrInfoBox(mRnaNode, infoboxObjectOfmRna);\n      var productionEdge = elementUtilities.addEdge(processNode.id(), mRnaNode.id(), {\n        \"class\": 'production',\n        language: 'PD'\n      });\n      productionEdge.data('justAdded', true);\n      cy.endBatch(); //filter the just added elememts to return them and remove just added mark\n\n      var eles = cy.elements('[justAdded]');\n      eles.removeData('justAdded');\n      cy.elements().unselect();\n      eles.select();\n      return eles; // Return the just added elements\n    };\n\n    elementUtilities.rotate90 = function (point, center) {\n      var relativeX = center.x - point.x;\n      var relativeY = center.y - point.y;\n      var relativeRotatedX = relativeY;\n      var relativeRotatedY = -1 * relativeX;\n      var resultX = relativeRotatedX + center.x;\n      var resultY = relativeRotatedY + center.y;\n      return {\n        x: resultX,\n        y: resultY\n      };\n    };\n\n    elementUtilities.createTranslation = function (regulatorLabel, outputLabel, orientation) {\n      var defaultSourceAndSinkProperties = elementUtilities.getDefaultProperties(\"empty set\");\n      var defaultNucleicAcidFeatureProperties = elementUtilities.getDefaultProperties(\"nucleic acid feature\");\n      var defaultMacromoleculePropeties = elementUtilities.getDefaultProperties(\"macromolecule\");\n      var defaultProcessProperties = elementUtilities.getDefaultProperties(\"process\");\n      var sourceAndSinkWidth = defaultSourceAndSinkProperties.width || 50;\n      var nucleicAcidFeatureWidth = defaultNucleicAcidFeatureProperties.width || 50;\n      var nucleicAcidFeatureHeight = defaultNucleicAcidFeatureProperties.height || 50;\n      var macromoleculeWidth = defaultMacromoleculePropeties.width || 50;\n      var processWidth = defaultProcessProperties.width || 50;\n      var processHeight = defaultProcessProperties.height || 50;\n      var processPosition = elementUtilities.convertToModelPosition({\n        x: cy.width() / 2,\n        y: cy.height() / 2\n      });\n      var edgeLength = 30;\n      var vertical = orientation === \"vertical\";\n      var processPortsOrdering = vertical ? \"T-to-B\" : \"L-to-R\";\n      var minInfoboxDimension = 15;\n      var widthPerChar = 6;\n      var regulatorInfoboxLabel = \"ct:mRNA\";\n      cy.startBatch();\n\n      if (!elementUtilities.getMapType()) {\n        elementUtilities.setMapType(\"PD\");\n      }\n\n      var processNode = elementUtilities.addNode(processPosition.x, processPosition.y, {\n        \"class\": \"process\",\n        language: \"PD\"\n      });\n      elementUtilities.setPortsOrdering(processNode, processPortsOrdering);\n      processNode.data('justAdded', true);\n      var xPosOfInput = processPosition.x - edgeLength - processWidth / 2 - sourceAndSinkWidth / 2;\n      var xPosOfOutput = processPosition.x + edgeLength + processWidth / 2 + macromoleculeWidth / 2;\n      var yPosOfInput = processPosition.y;\n      var yPosOfOutput = processPosition.y;\n      var nodePosition = {\n        x: xPosOfInput,\n        y: yPosOfInput\n      };\n\n      if (vertical) {\n        nodePosition = elementUtilities.rotate90(nodePosition, processPosition);\n      }\n\n      var inputNode = elementUtilities.addNode(nodePosition.x, nodePosition.y, {\n        \"class\": 'empty set',\n        language: 'PD'\n      });\n      inputNode.data(\"justAdded\", true);\n      inputNode.data(\"label\", label);\n      var inputEdge = elementUtilities.addEdge(inputNode.id(), processNode.id(), {\n        \"class\": 'consumption',\n        language: 'PD'\n      });\n      inputEdge.data(\"justAdded\", true);\n      nodePosition = {\n        x: xPosOfOutput,\n        y: yPosOfOutput\n      };\n\n      if (vertical) {\n        nodePosition = elementUtilities.rotate90(nodePosition, processPosition);\n      }\n\n      var outputNode = elementUtilities.addNode(nodePosition.x, nodePosition.y, {\n        \"class\": \"macromolecule\",\n        language: 'PD'\n      });\n      outputNode.data(\"justAdded\", true);\n      outputNode.data(\"label\", outputLabel);\n      var outputEdge = elementUtilities.addEdge(processNode.id(), outputNode.id(), {\n        \"class\": 'production',\n        language: 'PD'\n      });\n      outputEdge.data(\"justAdded\", true);\n      var xPosOfRegulator = processPosition.x;\n      var dimension = vertical ? nucleicAcidFeatureWidth : nucleicAcidFeatureHeight;\n      var yPosOfRegulator = processPosition.y - (processHeight / 2 + dimension / 2 + edgeLength);\n      nodePosition = {\n        x: xPosOfRegulator,\n        y: yPosOfRegulator\n      };\n\n      if (vertical) {\n        nodePosition = elementUtilities.rotate90(nodePosition, processPosition);\n      }\n\n      var regulatorNode = elementUtilities.addNode(nodePosition.x, nodePosition.y, {\n        \"class\": \"nucleic acid feature\",\n        language: 'PD'\n      });\n      regulatorNode.data('justAdded', true);\n      regulatorNode.data('label', regulatorLabel);\n      infoboxObject = {\n        clazz: \"unit of information\",\n        label: {\n          text: regulatorInfoboxLabel\n        },\n        bbox: {\n          w: Math.max(regulatorInfoboxLabel.length * widthPerChar, minInfoboxDimension),\n          h: minInfoboxDimension\n        }\n      };\n      elementUtilities.addStateOrInfoBox(regulatorNode, infoboxObject);\n      var regulatorEdge = elementUtilities.addEdge(regulatorNode.id(), processNode.id(), {\n        \"class\": 'necessary stimulation',\n        language: 'PD'\n      });\n      regulatorEdge.data('justAdded', true);\n      cy.endBatch();\n      var eles = cy.elements('[justAdded]');\n      eles.removeData('justAdded');\n      cy.elements().unselect();\n      eles.select();\n      return eles;\n    };\n\n    elementUtilities.createTranscription = function (label, orientation) {\n      var defaultSourceAndSinkProperties = elementUtilities.getDefaultProperties(\"empty set\");\n      var defaultNucleicAcidFeatureProperties = elementUtilities.getDefaultProperties(\"nucleic acid feature\");\n      var defaultProcessProperties = elementUtilities.getDefaultProperties(\"process\");\n      var sourceAndSinkWidth = defaultSourceAndSinkProperties.width || 50;\n      var nucleicAcidFeatureWidth = defaultNucleicAcidFeatureProperties.width || 50;\n      var nucleicAcidFeatureHeight = defaultNucleicAcidFeatureProperties.height || 50;\n      var processWidth = defaultProcessProperties.width || 50;\n      var processHeight = defaultProcessProperties.height || 50;\n      var processPosition = elementUtilities.convertToModelPosition({\n        x: cy.width() / 2,\n        y: cy.height() / 2\n      });\n      var edgeLength = 30;\n      var vertical = orientation === \"vertical\";\n      var processPortsOrdering = vertical ? \"T-to-B\" : \"L-to-R\";\n      var minInfoboxDimension = 15;\n      var widthPerChar = 6;\n      var outputInfoboxLabel = \"ct:mRNA\";\n      var regulatorInfoboxLabel = \"ct:gene\";\n      cy.startBatch();\n\n      if (!elementUtilities.getMapType()) {\n        elementUtilities.setMapType(\"PD\");\n      }\n\n      var processNode = elementUtilities.addNode(processPosition.x, processPosition.y, {\n        \"class\": \"process\",\n        language: \"PD\"\n      });\n      elementUtilities.setPortsOrdering(processNode, processPortsOrdering);\n      processNode.data('justAdded', true);\n      var xPosOfInput = processPosition.x - edgeLength - processWidth / 2 - sourceAndSinkWidth / 2;\n      var xPosOfOutput = processPosition.x + edgeLength + processWidth / 2 + nucleicAcidFeatureWidth / 2;\n      var yPosOfInput = processPosition.y;\n      var yPosOfOutput = processPosition.y;\n      var nodePosition = {\n        x: xPosOfInput,\n        y: yPosOfInput\n      };\n\n      if (vertical) {\n        nodePosition = elementUtilities.rotate90(nodePosition, processPosition);\n      }\n\n      var inputNode = elementUtilities.addNode(nodePosition.x, nodePosition.y, {\n        \"class\": 'empty set',\n        language: 'PD'\n      });\n      inputNode.data(\"justAdded\", true);\n      var inputEdge = elementUtilities.addEdge(inputNode.id(), processNode.id(), {\n        \"class\": 'consumption',\n        language: 'PD'\n      });\n      inputEdge.data(\"justAdded\", true);\n      nodePosition = {\n        x: xPosOfOutput,\n        y: yPosOfOutput\n      };\n\n      if (vertical) {\n        nodePosition = elementUtilities.rotate90(nodePosition, processPosition);\n      }\n\n      var outputNode = elementUtilities.addNode(nodePosition.x, nodePosition.y, {\n        \"class\": 'nucleic acid feature',\n        language: 'PD'\n      });\n      outputNode.data(\"justAdded\", true);\n      outputNode.data(\"label\", label);\n      infoboxObject = {\n        clazz: \"unit of information\",\n        label: {\n          text: outputInfoboxLabel\n        },\n        bbox: {\n          w: Math.max(outputInfoboxLabel.length * widthPerChar, minInfoboxDimension),\n          h: minInfoboxDimension\n        }\n      };\n      elementUtilities.addStateOrInfoBox(outputNode, infoboxObject);\n      var outputEdge = elementUtilities.addEdge(processNode.id(), outputNode.id(), {\n        \"class\": 'production',\n        language: 'PD'\n      });\n      outputEdge.data(\"justAdded\", true);\n      var xPosOfRegulator = processPosition.x;\n      var dimension = vertical ? nucleicAcidFeatureWidth : nucleicAcidFeatureHeight;\n      var yPosOfRegulator = processPosition.y - (processHeight / 2 + dimension / 2 + edgeLength);\n      nodePosition = {\n        x: xPosOfRegulator,\n        y: yPosOfRegulator\n      };\n\n      if (vertical) {\n        nodePosition = elementUtilities.rotate90(nodePosition, processPosition);\n      }\n\n      var regulatorNode = elementUtilities.addNode(nodePosition.x, nodePosition.y, {\n        \"class\": \"nucleic acid feature\",\n        language: 'PD'\n      });\n      regulatorNode.data('justAdded', true);\n      regulatorNode.data('label', label);\n      infoboxObject = {\n        clazz: \"unit of information\",\n        label: {\n          text: regulatorInfoboxLabel\n        },\n        bbox: {\n          w: Math.max(regulatorInfoboxLabel.length * widthPerChar, minInfoboxDimension),\n          h: minInfoboxDimension\n        }\n      };\n      elementUtilities.addStateOrInfoBox(regulatorNode, infoboxObject);\n      var regulatorEdge = elementUtilities.addEdge(regulatorNode.id(), processNode.id(), {\n        \"class\": 'necessary stimulation',\n        language: 'PD'\n      });\n      regulatorEdge.data('justAdded', true);\n      cy.endBatch();\n      var eles = cy.elements('[justAdded]');\n      eles.removeData('justAdded');\n      cy.elements().unselect();\n      eles.select();\n      return eles;\n    };\n\n    elementUtilities.createDegradation = function (macromolecule, orientation) {\n      var macromoleculeName = macromolecule.name;\n      var defaultMacromoleculeProperties = elementUtilities.getDefaultProperties(\"macromolecule\");\n      var macromoleculeWidth = defaultMacromoleculeProperties.width || 50;\n      var defaultProcessProperties = elementUtilities.getDefaultProperties(\"catalytic\");\n      var processWidth = defaultProcessProperties.width || 50;\n      var processPosition = elementUtilities.convertToModelPosition({\n        x: cy.width() / 2,\n        y: cy.height() / 2\n      });\n      var edgeLength = 30;\n      var vertical = orientation === \"vertical\";\n      var processPortsOrdering = vertical ? \"T-to-B\" : \"L-to-R\";\n      cy.startBatch();\n\n      if (!elementUtilities.getMapType()) {\n        elementUtilities.setMapType(\"PD\");\n      }\n\n      var processNode = elementUtilities.addNode(processPosition.x, processPosition.y, {\n        \"class\": \"process\",\n        language: \"PD\"\n      });\n      elementUtilities.setPortsOrdering(processNode, processPortsOrdering);\n      processNode.data('justAdded', true);\n      var xPosOfInput = processPosition.x - edgeLength - processWidth / 2 - macromoleculeWidth / 2;\n      var xPosOfOutput = processPosition.x + edgeLength + processWidth / 2 + macromoleculeWidth / 2;\n      var yPosOfInput = processPosition.y;\n      var yPosOfOutput = processPosition.y;\n      var nodePosition = {\n        x: xPosOfInput,\n        y: yPosOfInput\n      };\n\n      if (vertical) {\n        nodePosition = elementUtilities.rotate90(nodePosition, processPosition);\n      }\n\n      var inputNode = elementUtilities.addNode(nodePosition.x, nodePosition.y, {\n        \"class\": 'macromolecule',\n        language: 'PD'\n      });\n      inputNode.data(\"justAdded\", true);\n      inputNode.data(\"label\", macromoleculeName);\n      var inputEdge = elementUtilities.addEdge(inputNode.id(), processNode.id(), {\n        \"class\": 'consumption',\n        language: 'PD'\n      });\n      inputEdge.data(\"justAdded\", true);\n      nodePosition = {\n        x: xPosOfOutput,\n        y: yPosOfOutput\n      };\n\n      if (vertical) {\n        nodePosition = elementUtilities.rotate90(nodePosition, processPosition);\n      }\n\n      var outputNode = elementUtilities.addNode(nodePosition.x, nodePosition.y, {\n        \"class\": 'empty set',\n        language: 'PD'\n      });\n      outputNode.data(\"justAdded\", true);\n      var outputEdge = elementUtilities.addEdge(processNode.id(), outputNode.id(), {\n        \"class\": 'production',\n        language: 'PD'\n      });\n      outputEdge.data(\"justAdded\", true);\n      cy.endBatch();\n      var eles = cy.elements('[justAdded]');\n      eles.removeData('justAdded');\n      cy.elements().unselect();\n      eles.select();\n      return eles;\n    };\n\n    elementUtilities.createComplexProteinFormation = function (proteinLabels, complexLabel, regulator, orientation, reverse) {\n      var hasRegulator = regulator.name !== undefined;\n      var defaultMacromoleculeProperties = elementUtilities.getDefaultProperties(\"macromolecule\");\n      var defaultRegulatorProperties = hasRegulator ? elementUtilities.getDefaultProperties(regulator.type) : {};\n      var defaultProcessProperties = elementUtilities.getDefaultProperties(\"catalytic\");\n      var processWidth = defaultProcessProperties.width || 50;\n      var macromoleculeWidth = defaultMacromoleculeProperties.width || 50;\n      var macromoleculeHeight = defaultMacromoleculeProperties.height || 50;\n      var processHeight = defaultProcessProperties.height || 50;\n      var regulatorHeight = defaultRegulatorProperties.height || 50;\n      var processPosition = elementUtilities.convertToModelPosition({\n        x: cy.width() / 2,\n        y: cy.height() / 2\n      });\n      var edgeLength = 30;\n      var processPortsOrdering = orientation === \"vertical\" ? \"T-to-B\" : \"L-to-R\";\n      var minInfoboxDimension = 20;\n      var widthPerChar = 6;\n      var tilingPaddingVertical = 15;\n      var tilingPaddingHorizontal = 15;\n      var multimerOffset = 6;\n      cy.startBatch();\n\n      if (!elementUtilities.getMapType()) {\n        elementUtilities.setMapType(\"PD\");\n      }\n\n      var processNode = elementUtilities.addNode(processPosition.x, processPosition.y, {\n        \"class\": \"process\",\n        language: \"PD\"\n      });\n      elementUtilities.setPortsOrdering(processNode, processPortsOrdering);\n      processNode.data('justAdded', true);\n      var offsetX = processWidth / 2 + edgeLength + macromoleculeWidth / 2;\n      var xPosOfProtein = reverse ? processPosition.x + offsetX : processPosition.x - offsetX;\n      var proteinCount = proteinLabels.length;\n      var macromoleculeDimension = orientation === \"vertical\" ? macromoleculeWidth : macromoleculeHeight;\n      var stepOffset = macromoleculeDimension + tilingPaddingVertical;\n      var offsetY = (proteinCount - 1) / 2 * (macromoleculeDimension + tilingPaddingVertical);\n      var horizontalOffsetX = (proteinCount - 1) / 2 * (macromoleculeDimension + tilingPaddingHorizontal);\n      var yPosOfProtein = processPosition.y - offsetY;\n      proteinLabels.forEach(function (label) {\n        var nodePosition = {\n          x: xPosOfProtein,\n          y: yPosOfProtein\n        };\n\n        if (orientation === \"vertical\") {\n          nodePosition = elementUtilities.rotate90(nodePosition, processPosition);\n        }\n\n        var node = elementUtilities.addNode(nodePosition.x, nodePosition.y, {\n          \"class\": \"macromolecule\",\n          language: \"PD\"\n        });\n        node.data(\"label\", label);\n        node.data(\"justAdded\", true);\n        yPosOfProtein += stepOffset;\n        var source = reverse ? processNode.id() : node.id();\n        var target = reverse ? node.id() : processNode.id();\n        var edgeClass = reverse ? \"production\" : \"consumption\";\n        var edge = elementUtilities.addEdge(source, target, {\n          \"class\": edgeClass,\n          language: \"PD\"\n        });\n        edge.data(\"justAdded\", true);\n      });\n      var complexPos = {\n        x: processPosition.x + (reverse ? -1 : 1) * offsetX,\n        y: processPosition.y\n      };\n\n      if (orientation === \"vertical\") {\n        complexPos = elementUtilities.rotate90(complexPos, processPosition);\n      }\n\n      var complex = elementUtilities.addNode(complexPos.x, complexPos.y, {\n        \"class\": \"complex\",\n        language: \"PD\"\n      });\n      complex.data(\"label\", complexLabel);\n      complex.data(\"justAdded\", true);\n      var source = reverse ? complex.id() : processNode.id();\n      var target = reverse ? processNode.id() : complex.id();\n      var edgeClass = reverse ? \"consumption\" : \"production\";\n      var complexEdge = elementUtilities.addEdge(source, target, {\n        \"class\": edgeClass,\n        language: \"PD\"\n      });\n      complexEdge.data(\"justAdded\", true);\n\n      if (orientation === \"vertical\") {\n        xPosOfProtein = complex.position(\"x\") - horizontalOffsetX;\n        yPosOfProtein = complex.position(\"y\");\n      } else {\n        xPosOfProtein = complex.position(\"x\");\n        yPosOfProtein = complex.position(\"y\") - offsetY;\n      }\n\n      proteinLabels.forEach(function (label) {\n        var nodePosition = {\n          x: xPosOfProtein,\n          y: yPosOfProtein\n        };\n        var node = elementUtilities.addNode(nodePosition.x, nodePosition.y, {\n          \"class\": \"macromolecule\",\n          language: \"PD\"\n        }, undefined, complex.id());\n        node.data(\"label\", label);\n        node.data(\"justAdded\", true);\n\n        if (orientation === \"vertical\") {\n          xPosOfProtein += stepOffset;\n        } else {\n          yPosOfProtein += stepOffset;\n        }\n      });\n\n      if (hasRegulator) {\n        var regulatorName = regulator.name;\n        var regulatorType = regulator.type;\n        var regulatorEdgeType = regulator.edgeType;\n        var regulatorMultimer = regulator.multimer;\n        var xPosOfRegulator = processPosition.x;\n\n        if (regulatorMultimer.enabled && orientation === \"horizontal\") {\n          xPosOfRegulator -= multimerOffset;\n        }\n\n        var yPosOfRegulator = processPosition.y - (processHeight / 2 + regulatorHeight / 2 + edgeLength);\n        nodePosition = {\n          x: xPosOfRegulator,\n          y: yPosOfRegulator\n        };\n\n        if (orientation === \"vertical\") {\n          nodePosition = elementUtilities.rotate90(nodePosition, processPosition);\n        }\n\n        var regulatorNode = elementUtilities.addNode(nodePosition.x, nodePosition.y, {\n          \"class\": regulatorType,\n          language: 'PD'\n        });\n        regulatorNode.data('justAdded', true);\n        regulatorNode.data('label', regulatorName);\n\n        if (regulatorMultimer.enabled) {\n          elementUtilities.setMultimerStatus(regulatorNode, true);\n          var cardinality = regulatorMultimer.cardinality;\n\n          if (cardinality != '') {\n            var infoboxLabel = \"N:\" + cardinality;\n            infoboxObject = {\n              clazz: \"unit of information\",\n              label: {\n                text: infoboxLabel\n              },\n              bbox: {\n                w: infoboxLabel.length * widthPerChar,\n                h: minInfoboxDimension\n              }\n            };\n            elementUtilities.addStateOrInfoBox(regulatorNode, infoboxObject);\n          }\n        }\n\n        var regulatorEdge = elementUtilities.addEdge(regulatorNode.id(), processNode.id(), {\n          \"class\": regulatorEdgeType,\n          language: 'PD'\n        });\n        regulatorEdge.data('justAdded', true);\n      }\n\n      cy.endBatch();\n      var eles = cy.elements('[justAdded]');\n      eles.removeData('justAdded');\n      cy.elements().unselect();\n      eles.select();\n      return eles;\n    };\n\n    elementUtilities.createMultimerization = function (macromolecule, regulator, regulatorMultimer, orientation) {\n      var hasRegulator = regulator.name !== undefined;\n      var macromoleculeName = macromolecule.name;\n      var macromoleculeMultimerCardinality = macromolecule.cardinality;\n      var defaultMacromoleculeProperties = elementUtilities.getDefaultProperties(\"macromolecule\");\n      var defaultRegulatorProperties = hasRegulator ? elementUtilities.getDefaultProperties(regulator.type) : {};\n      var defaultProcessProperties = elementUtilities.getDefaultProperties(\"catalytic\");\n      var processWidth = defaultProcessProperties.width || 50;\n      var macromoleculeWidth = defaultMacromoleculeProperties.width || 50;\n      var macromoleculeHeight = defaultMacromoleculeProperties.height || 50;\n      var processHeight = defaultProcessProperties.height || 50;\n      var regulatorHeight = defaultRegulatorProperties.height || 50;\n      var processPosition = elementUtilities.convertToModelPosition({\n        x: cy.width() / 2,\n        y: cy.height() / 2\n      });\n      var edgeLength = 30;\n      var processPortsOrdering = orientation === \"vertical\" ? \"T-to-B\" : \"L-to-R\";\n      var minInfoboxDimension = 20;\n      var widthPerChar = 6;\n      var multimerOffset = 6;\n      cy.startBatch();\n\n      if (!elementUtilities.getMapType()) {\n        elementUtilities.setMapType(\"PD\");\n      }\n\n      var xPosOfInput = processPosition.x - edgeLength - processWidth / 2 - macromoleculeWidth / 2;\n      var xPosOfOutput = processPosition.x + edgeLength + processWidth / 2 + macromoleculeWidth / 2;\n      var yPosOfInput = processPosition.y;\n      var yPosOfOutput = processPosition.y;\n      var processNode = elementUtilities.addNode(processPosition.x, processPosition.y, {\n        \"class\": \"process\",\n        language: \"PD\"\n      });\n      elementUtilities.setPortsOrdering(processNode, processPortsOrdering);\n      processNode.data('justAdded', true);\n      var nodePosition = {\n        x: xPosOfInput,\n        y: yPosOfInput\n      };\n\n      if (orientation === \"vertical\") {\n        nodePosition = elementUtilities.rotate90(nodePosition, processPosition);\n      }\n\n      var inputNode = elementUtilities.addNode(nodePosition.x, nodePosition.y, {\n        \"class\": 'macromolecule',\n        language: 'PD'\n      });\n      inputNode.data(\"justAdded\", true);\n      inputNode.data(\"label\", macromoleculeName);\n      var inputEdge = elementUtilities.addEdge(inputNode.id(), processNode.id(), {\n        \"class\": 'consumption',\n        language: 'PD'\n      });\n      inputEdge.data(\"justAdded\", true);\n      var cardinality = macromoleculeMultimerCardinality;\n\n      if (cardinality !== '') {\n        inputEdge.data(\"cardinality\", cardinality);\n      }\n\n      nodePosition = {\n        x: xPosOfOutput,\n        y: yPosOfOutput\n      };\n\n      if (orientation === \"vertical\") {\n        nodePosition = elementUtilities.rotate90(nodePosition, processPosition);\n      }\n\n      var outputNode = elementUtilities.addNode(nodePosition.x, nodePosition.y, {\n        \"class\": 'macromolecule',\n        language: 'PD'\n      });\n      outputNode.data(\"justAdded\", true);\n      outputNode.data(\"label\", macromoleculeName);\n      elementUtilities.setMultimerStatus(outputNode, true);\n\n      if (cardinality !== '') {\n        var infoboxLabel = \"N:\" + cardinality;\n        infoboxObject = {\n          clazz: \"unit of information\",\n          label: {\n            text: infoboxLabel\n          },\n          bbox: {\n            w: infoboxLabel.length * widthPerChar,\n            h: minInfoboxDimension\n          }\n        };\n        elementUtilities.addStateOrInfoBox(outputNode, infoboxObject);\n      }\n\n      var outputEdge = elementUtilities.addEdge(processNode.id(), outputNode.id(), {\n        \"class\": 'production',\n        language: 'PD'\n      });\n      outputEdge.data(\"justAdded\", true);\n\n      if (hasRegulator) {\n        var regulatorName = regulator.name;\n        var regulatorType = regulator.type;\n        var regulatorEdgeType = regulator.edgeType;\n        var xPosOfRegulator = processPosition.x;\n\n        if (regulatorMultimer.enabled && orientation === \"horizontal\") {\n          xPosOfRegulator -= multimerOffset;\n        }\n\n        var yPosOfRegulator = processPosition.y - (processHeight / 2 + regulatorHeight / 2 + edgeLength);\n        nodePosition = {\n          x: xPosOfRegulator,\n          y: yPosOfRegulator\n        };\n\n        if (orientation === \"vertical\") {\n          nodePosition = elementUtilities.rotate90(nodePosition, processPosition);\n        }\n\n        var regulatorNode = elementUtilities.addNode(nodePosition.x, nodePosition.y, {\n          \"class\": regulatorType,\n          language: 'PD'\n        });\n        regulatorNode.data('justAdded', true);\n        regulatorNode.data('label', regulatorName);\n\n        if (regulatorMultimer.enabled) {\n          elementUtilities.setMultimerStatus(regulatorNode, true);\n          var _cardinality = regulatorMultimer.cardinality;\n\n          if (_cardinality != '') {\n            var _infoboxLabel = \"N:\" + _cardinality;\n\n            infoboxObject = {\n              clazz: \"unit of information\",\n              label: {\n                text: _infoboxLabel\n              },\n              bbox: {\n                w: _infoboxLabel.length * widthPerChar,\n                h: minInfoboxDimension\n              }\n            };\n            elementUtilities.addStateOrInfoBox(regulatorNode, infoboxObject);\n          }\n        }\n\n        var regulatorEdge = elementUtilities.addEdge(regulatorNode.id(), processNode.id(), {\n          \"class\": regulatorEdgeType,\n          language: 'PD'\n        });\n        regulatorEdge.data('justAdded', true);\n      }\n\n      cy.endBatch();\n      var eles = cy.elements('[justAdded]');\n      eles.removeData('justAdded');\n      cy.elements().unselect();\n      eles.select();\n      return eles;\n    };\n\n    elementUtilities.createConversion = function (macromolecule, regulator, regulatorMultimer, orientation, inputInfoboxLabels, outputInfoboxLabels) {\n      var hasRegulator = regulator.name !== undefined;\n      var macromoleculeName = macromolecule.name;\n      var macromoleculeIsMultimer = macromolecule.multimer.enabled;\n      var macromoleculeMultimerCardinality = macromolecule.multimer.cardinality;\n      var defaultMacromoleculeProperties = elementUtilities.getDefaultProperties(\"macromolecule\");\n      var defaultRegulatorProperties = hasRegulator ? elementUtilities.getDefaultProperties(regulator.type) : {};\n      var defaultProcessProperties = elementUtilities.getDefaultProperties(\"catalytic\");\n      var processWidth = defaultProcessProperties.width || 50;\n      var macromoleculeWidth = defaultMacromoleculeProperties.width || 50;\n      var macromoleculeHeight = defaultMacromoleculeProperties.height || 50;\n      var processHeight = defaultProcessProperties.height || 50;\n      var regulatorHeight = defaultRegulatorProperties.height || 50;\n      var processPosition = elementUtilities.convertToModelPosition({\n        x: cy.width() / 2,\n        y: cy.height() / 2\n      });\n      var edgeLength = 30;\n      var processPortsOrdering = orientation === \"vertical\" ? \"T-to-B\" : \"L-to-R\";\n      var minInfoboxDimension = 20;\n      var widthPerChar = 6;\n      var multimerOffset = 6;\n      cy.startBatch();\n\n      if (!elementUtilities.getMapType()) {\n        elementUtilities.setMapType(\"PD\");\n      }\n\n      var xPosOfInput = processPosition.x - edgeLength - processWidth / 2 - macromoleculeWidth / 2;\n      var xPosOfOutput = processPosition.x + edgeLength + processWidth / 2 + macromoleculeWidth / 2;\n      var yPosOfInput = processPosition.y;\n      var yPosOfOutput = processPosition.y;\n      var processNode = elementUtilities.addNode(processPosition.x, processPosition.y, {\n        \"class\": \"process\",\n        language: \"PD\"\n      });\n      elementUtilities.setPortsOrdering(processNode, processPortsOrdering);\n      processNode.data('justAdded', true);\n      var nodePosition = {\n        x: xPosOfInput,\n        y: yPosOfInput\n      };\n\n      if (orientation === \"vertical\") {\n        nodePosition = elementUtilities.rotate90(nodePosition, processPosition);\n      }\n\n      var inputNode = elementUtilities.addNode(nodePosition.x, nodePosition.y, {\n        \"class\": 'macromolecule',\n        language: 'PD'\n      });\n      inputNode.data(\"justAdded\", true);\n      inputNode.data(\"label\", macromoleculeName);\n\n      if (macromoleculeIsMultimer) {\n        elementUtilities.setMultimerStatus(inputNode, true);\n        var cardinality = macromoleculeMultimerCardinality;\n\n        if (cardinality != '') {\n          var infoboxLabel = \"N:\" + cardinality;\n          infoboxObject = {\n            clazz: \"unit of information\",\n            label: {\n              text: infoboxLabel\n            },\n            bbox: {\n              w: infoboxLabel.length * widthPerChar,\n              h: minInfoboxDimension\n            }\n          };\n          elementUtilities.addStateOrInfoBox(inputNode, infoboxObject);\n        }\n      }\n\n      inputInfoboxLabels.forEach(function (label) {\n        var inputInfoboxWidth = label.length > 0 ? Math.max(widthPerChar * label.length, minInfoboxDimension) : minInfoboxDimension;\n        var infoboxObject = {\n          clazz: \"unit of information\",\n          label: {\n            text: label\n          },\n          bbox: {\n            w: inputInfoboxWidth,\n            h: minInfoboxDimension\n          },\n          style: {\n            \"shape-name\": \"ellipse\"\n          }\n        };\n        elementUtilities.addStateOrInfoBox(inputNode, infoboxObject);\n      });\n      var inputEdge = elementUtilities.addEdge(inputNode.id(), processNode.id(), {\n        \"class\": 'consumption',\n        language: 'PD'\n      });\n      inputEdge.data(\"justAdded\", true);\n      nodePosition = {\n        x: xPosOfOutput,\n        y: yPosOfOutput\n      };\n\n      if (orientation === \"vertical\") {\n        nodePosition = elementUtilities.rotate90(nodePosition, processPosition);\n      }\n\n      var outputNode = elementUtilities.addNode(nodePosition.x, nodePosition.y, {\n        \"class\": 'macromolecule',\n        language: 'PD'\n      });\n      outputNode.data(\"justAdded\", true);\n      outputNode.data(\"label\", macromoleculeName);\n\n      if (macromoleculeIsMultimer) {\n        elementUtilities.setMultimerStatus(outputNode, true);\n        var _cardinality2 = macromoleculeMultimerCardinality;\n\n        if (_cardinality2 != '') {\n          var _infoboxLabel2 = \"N:\" + _cardinality2;\n\n          infoboxObject = {\n            clazz: \"unit of information\",\n            label: {\n              text: _infoboxLabel2\n            },\n            bbox: {\n              w: _infoboxLabel2.length * widthPerChar,\n              h: minInfoboxDimension\n            }\n          };\n          elementUtilities.addStateOrInfoBox(outputNode, infoboxObject);\n        }\n      }\n\n      outputInfoboxLabels.forEach(function (label) {\n        var outputInfoboxWidth = label.length > 0 ? Math.max(widthPerChar * label.length, minInfoboxDimension) : minInfoboxDimension;\n        infoboxObject = {\n          clazz: \"unit of information\",\n          label: {\n            text: label\n          },\n          bbox: {\n            w: outputInfoboxWidth,\n            h: minInfoboxDimension\n          },\n          style: {\n            \"shape-name\": \"ellipse\"\n          }\n        };\n        elementUtilities.addStateOrInfoBox(outputNode, infoboxObject);\n      });\n      [inputNode, outputNode].forEach(function (node) {\n        var width = elementUtilities.calculateMinWidth(node);\n        elementUtilities.resizeNodes(node, width, macromoleculeHeight, false, true);\n      });\n\n      if (orientation === \"horizontal\") {\n        var newInputXPos = processPosition.x - edgeLength - processWidth / 2 - inputNode.data('bbox').w / 2;\n        inputNode.position('x', newInputXPos);\n        var newOutputXPos = processPosition.x + edgeLength + processWidth / 2 + outputNode.data('bbox').w / 2;\n        outputNode.position('x', newOutputXPos);\n      } else {\n        var newInputYPos = processPosition.y - edgeLength - processWidth / 2 - inputNode.data('bbox').h / 2;\n        inputNode.position('y', newInputYPos);\n        var newOutputYPos = processPosition.y + edgeLength + processWidth / 2 + outputNode.data('bbox').h / 2;\n        outputNode.position('y', newOutputYPos);\n      }\n\n      var outputEdge = elementUtilities.addEdge(processNode.id(), outputNode.id(), {\n        \"class\": 'production',\n        language: 'PD'\n      });\n      outputEdge.data(\"justAdded\", true);\n\n      if (hasRegulator) {\n        var regulatorName = regulator.name;\n        var regulatorType = regulator.type;\n        var xPosOfRegulator = processPosition.x;\n\n        if (regulatorMultimer.enabled && orientation === \"horizontal\") {\n          xPosOfRegulator -= multimerOffset;\n        }\n\n        var yPosOfRegulator = processPosition.y - (processHeight / 2 + regulatorHeight / 2 + edgeLength);\n        nodePosition = {\n          x: xPosOfRegulator,\n          y: yPosOfRegulator\n        };\n\n        if (orientation === \"vertical\") {\n          nodePosition = elementUtilities.rotate90(nodePosition, processPosition);\n        }\n\n        var regulatorNode = elementUtilities.addNode(nodePosition.x, nodePosition.y, {\n          \"class\": regulatorType,\n          language: 'PD'\n        });\n        regulatorNode.data('justAdded', true);\n        regulatorNode.data('label', regulatorName);\n\n        if (regulatorMultimer.enabled) {\n          elementUtilities.setMultimerStatus(regulatorNode, true);\n          var _cardinality3 = regulatorMultimer.cardinality;\n\n          if (_cardinality3 != '') {\n            var _infoboxLabel3 = \"N:\" + _cardinality3;\n\n            infoboxObject = {\n              clazz: \"unit of information\",\n              label: {\n                text: _infoboxLabel3\n              },\n              bbox: {\n                w: _infoboxLabel3.length * widthPerChar,\n                h: minInfoboxDimension\n              }\n            };\n            elementUtilities.addStateOrInfoBox(regulatorNode, infoboxObject);\n          }\n        }\n\n        var regulatorEdge = elementUtilities.addEdge(regulatorNode.id(), processNode.id(), {\n          \"class\": 'catalysis',\n          language: 'PD'\n        });\n        regulatorEdge.data('justAdded', true);\n      }\n\n      cy.endBatch();\n      var eles = cy.elements('[justAdded]');\n      eles.removeData('justAdded');\n      cy.elements().unselect();\n      eles.select();\n      return eles;\n    };\n\n    elementUtilities.createMetabolicReaction = function (inputs, outputs, reversible, regulator, regulatorMultimer, orientation) {\n      var rotate90 = function rotate90(point, center) {\n        var relativeX = center.x - point.x;\n        var relativeY = center.y - point.y;\n        var relativeRotatedX = relativeY;\n        var relativeRotatedY = -1 * relativeX;\n        var resultX = relativeRotatedX + center.x;\n        var resultY = relativeRotatedY + center.y;\n        return {\n          x: resultX,\n          y: resultY\n        };\n      };\n\n      var hasRegulator = regulator.name !== undefined;\n      var defaultSimpleChemicalProperties = elementUtilities.getDefaultProperties(\"simple chemical\");\n      var defaultRegulatorProperties = hasRegulator ? elementUtilities.getDefaultProperties(regulator.type) : {};\n      var defaultProcessProperties = elementUtilities.getDefaultProperties(\"catalytic\");\n      var processWidth = defaultProcessProperties.width || 50;\n      var processHeight = defaultProcessProperties.height || 50;\n      var simpleChemicalHeight = defaultSimpleChemicalProperties.height || 35;\n      var simpleChemicalWidth = defaultSimpleChemicalProperties.width || 35;\n      var regulatorHeight = defaultRegulatorProperties.height || 50;\n      var processPosition = elementUtilities.convertToModelPosition({\n        x: cy.width() / 2,\n        y: cy.height() / 2\n      });\n      var tilingPaddingVertical = 15;\n      var edgeLength = 30;\n      var processLeftSideEdgeType = reversible ? \"production\" : \"consumption\";\n      var processRightSideEdgeType = \"production\";\n      var processPortsOrdering = orientation === \"vertical\" ? \"T-to-B\" : \"L-to-R\";\n      var multimerOffset = 6;\n      cy.startBatch();\n\n      if (!elementUtilities.getMapType()) {\n        elementUtilities.setMapType(\"PD\");\n      }\n\n      var xPosOfInput = processPosition.x - edgeLength - processWidth / 2 - simpleChemicalWidth / 2;\n      var xPosOfOutput = processPosition.x + edgeLength + processWidth / 2 + simpleChemicalWidth / 2;\n      var processNode = elementUtilities.addNode(processPosition.x, processPosition.y, {\n        \"class\": \"process\",\n        language: \"PD\"\n      });\n      elementUtilities.setPortsOrdering(processNode, processPortsOrdering);\n      processNode.data('justAdded', true);\n      var numOfInputNodes = inputs.length;\n      var numOfOutputNodes = outputs.length;\n      var yPosOfInput = processPosition.y - (numOfInputNodes - 1) / 2 * (simpleChemicalHeight + tilingPaddingVertical);\n      inputs.forEach(function (data, index) {\n        var nodeName = data.name;\n        var nodeType = data.type;\n\n        if (index === 0) {\n          yPosOfInput = processPosition.y;\n        } else if (index % 2 === 1) {\n          yPosOfInput = processPosition.y - (simpleChemicalHeight + tilingPaddingVertical) * Math.ceil(index / 2);\n        } else {\n          yPosOfInput = processPosition.y + (simpleChemicalHeight + tilingPaddingVertical) * (index / 2);\n        }\n\n        var nodePosition = {\n          x: xPosOfInput,\n          y: yPosOfInput\n        };\n\n        if (orientation === \"vertical\") {\n          nodePosition = rotate90(nodePosition, processPosition);\n        }\n\n        var newNode = elementUtilities.addNode(nodePosition.x, nodePosition.y, {\n          \"class\": nodeType.toLowerCase(),\n          language: \"PD\"\n        });\n        newNode.data(\"justAdded\", true);\n        newNode.data(\"label\", nodeName);\n        var newEdge;\n\n        if (reversible) {\n          newEdge = elementUtilities.addEdge(processNode.id(), newNode.id(), {\n            \"class\": processLeftSideEdgeType,\n            language: \"PD\"\n          }, undefined, undefined, 1);\n        } else {\n          newEdge = elementUtilities.addEdge(newNode.id(), processNode.id(), {\n            \"class\": processLeftSideEdgeType,\n            language: \"PD\"\n          });\n        }\n\n        newEdge.data(\"justAdded\", true);\n      });\n      var yPosOfOutput = processPosition.y - (numOfOutputNodes - 1) / 2 * (simpleChemicalHeight + tilingPaddingVertical);\n      outputs.forEach(function (data, index) {\n        var nodeName = data.name;\n        var nodeType = data.type;\n\n        if (index === 0) {\n          yPosOfOutput = processPosition.y;\n        } else if (index % 2 === 1) {\n          yPosOfOutput = processPosition.y - (simpleChemicalHeight + tilingPaddingVertical) * Math.ceil(index / 2);\n        } else {\n          yPosOfOutput = processPosition.y + (simpleChemicalHeight + tilingPaddingVertical) * (index / 2);\n        }\n\n        var nodePosition = {\n          x: xPosOfOutput,\n          y: yPosOfOutput\n        };\n\n        if (orientation === \"vertical\") {\n          nodePosition = rotate90(nodePosition, processPosition);\n        }\n\n        var newNode = elementUtilities.addNode(nodePosition.x, nodePosition.y, {\n          \"class\": nodeType.toLowerCase(),\n          language: \"PD\"\n        });\n        newNode.data(\"justAdded\", true);\n        newNode.data(\"label\", nodeName);\n        var newEdge = elementUtilities.addEdge(processNode.id(), newNode.id(), {\n          \"class\": processRightSideEdgeType,\n          language: \"PD\"\n        }, undefined, undefined, 0);\n        newEdge.data(\"justAdded\", true);\n      }); // add regulator node\n\n      if (hasRegulator) {\n        var regulatorName = regulator.name;\n        var regulatorType = regulator.type;\n        var xPosOfRegulator = processPosition.x;\n\n        if (regulatorMultimer.enabled && orientation === \"horizontal\") {\n          xPosOfRegulator -= multimerOffset;\n        }\n\n        var yPosOfRegulator = processPosition.y - (processHeight / 2 + regulatorHeight / 2 + edgeLength);\n        var _nodePosition = {\n          x: xPosOfRegulator,\n          y: yPosOfRegulator\n        };\n\n        if (orientation === \"vertical\") {\n          _nodePosition = rotate90(_nodePosition, processPosition);\n        }\n\n        var regulatorNode = elementUtilities.addNode(_nodePosition.x, _nodePosition.y, {\n          \"class\": regulatorType,\n          language: 'PD'\n        });\n        regulatorNode.data('justAdded', true);\n        regulatorNode.data('label', regulatorName);\n\n        if (regulatorMultimer.enabled) {\n          elementUtilities.setMultimerStatus(regulatorNode, true);\n          var cardinality = regulatorMultimer.cardinality;\n\n          if (cardinality != '') {\n            var infoboxLabel = \"N:\" + cardinality;\n            infoboxObject = {\n              clazz: \"unit of information\",\n              label: {\n                text: infoboxLabel\n              },\n              bbox: {\n                w: infoboxLabel.length * 6,\n                h: 15\n              }\n            };\n            elementUtilities.addStateOrInfoBox(regulatorNode, infoboxObject);\n          }\n        }\n\n        var regulatorEdge = elementUtilities.addEdge(regulatorNode.id(), processNode.id(), {\n          \"class\": 'catalysis',\n          language: 'PD'\n        });\n        regulatorEdge.data('justAdded', true);\n      }\n\n      cy.endBatch();\n      var eles = cy.elements('[justAdded]');\n      eles.removeData('justAdded');\n      cy.elements().unselect();\n      eles.select();\n      return eles;\n    };\n\n    elementUtilities.createMetabolicCatalyticActivity = function (inputNodeList, outputNodeList, catalystName, catalystType, processPosition, tilingPaddingVertical, tilingPaddingHorizontal, edgeLength) {\n      var defaultMacromoleculProperties = elementUtilities.getDefaultProperties(\"macromolecule\");\n      var defaultSimpleChemicalProperties = elementUtilities.getDefaultProperties(\"simple chemical\");\n      var defaultCatalystTypeProperties = elementUtilities.getDefaultProperties(catalystType);\n      var defaultProcessProperties = elementUtilities.getDefaultProperties(\"catalytic\");\n      var processWidth = defaultProcessProperties.width || 50;\n      var processHeight = defaultProcessProperties.height || 50;\n      var simpleChemicalHeight = defaultSimpleChemicalProperties.height || 35;\n      var macromoleculeWidth = defaultMacromoleculProperties.width || 50;\n      var macromoleculeHeight = defaultMacromoleculProperties.height || 50;\n      var catalystHeight = defaultCatalystTypeProperties.height || 50;\n      var processPosition = processPosition || elementUtilities.convertToModelPosition({\n        x: cy.width() / 2,\n        y: cy.height() / 2\n      });\n      var tilingPaddingVertical = tilingPaddingVertical || 15;\n      var tilingPaddingHorizontal = tilingPaddingHorizontal || 15;\n      var edgeLength = edgeLength || 60;\n      cy.startBatch();\n\n      if (!elementUtilities.getMapType()) {\n        elementUtilities.setMapType(\"PD\");\n      }\n\n      var xPosOfInput = processPosition.x - edgeLength - processWidth / 2 - macromoleculeWidth / 2;\n      var xPosOfOutput = processPosition.x + edgeLength + processWidth / 2 + macromoleculeWidth / 2;\n      var processNode = elementUtilities.addNode(processPosition.x, processPosition.y, {\n        \"class\": \"process\",\n        language: \"PD\"\n      });\n      elementUtilities.setPortsOrdering(processNode, \"L-to-R\");\n      processNode.data('justAdded', true);\n      var numOfInputNodes = inputNodeList.length;\n      var numOfOutputNodes = outputNodeList.length;\n      var yPosOfInput = processPosition.y - (numOfInputNodes - 1) / 2 * (macromoleculeHeight + tilingPaddingVertical); // add input side nodes\n\n      for (var i = 0; i < numOfInputNodes; i++) {\n        if (inputNodeList[i].type == \"Simple Chemical\") {\n          var newNode = elementUtilities.addNode(xPosOfInput, yPosOfInput, {\n            \"class\": 'simple chemical',\n            language: 'PD'\n          });\n          yPosOfInput += simpleChemicalHeight + tilingPaddingVertical;\n        } else {\n          var newNode = elementUtilities.addNode(xPosOfInput, yPosOfInput, {\n            \"class\": 'macromolecule',\n            language: 'PD'\n          }); //update the y position\n\n          yPosOfInput += macromoleculeHeight + tilingPaddingVertical;\n        }\n\n        newNode.data('justAdded', true);\n        newNode.data('label', inputNodeList[i].name);\n        var newEdge = elementUtilities.addEdge(newNode.id(), processNode.id(), {\n          \"class\": 'consumption',\n          language: 'PD'\n        });\n        newEdge.data('justAdded', true);\n      }\n\n      var yPosOfOutput = processPosition.y - (numOfOutputNodes - 1) / 2 * (macromoleculeHeight + tilingPaddingVertical); // add output side nodes\n\n      for (var i = 0; i < numOfOutputNodes; i++) {\n        if (outputNodeList[i].type == \"Simple Chemical\") {\n          var newNode = elementUtilities.addNode(xPosOfOutput, yPosOfOutput, {\n            \"class\": 'simple chemical',\n            language: 'PD'\n          });\n          yPosOfOutput += simpleChemicalHeight + tilingPaddingVertical;\n        } else {\n          var newNode = elementUtilities.addNode(xPosOfOutput, yPosOfOutput, {\n            \"class\": 'macromolecule',\n            language: 'PD'\n          }); //update the y position\n\n          yPosOfOutput += macromoleculeHeight + tilingPaddingVertical;\n        }\n\n        newNode.data('justAdded', true);\n        newNode.data('label', outputNodeList[i].name);\n        var newEdge = elementUtilities.addEdge(processNode.id(), newNode.id(), {\n          \"class\": 'production',\n          language: 'PD'\n        });\n        newEdge.data('justAdded', true);\n      } // add catalyst node\n\n\n      var xPosOfCatalyst = processPosition.x;\n      var yPosOfCatalyst = processPosition.y - (processHeight + catalystHeight + tilingPaddingVertical);\n      var catalystNode = elementUtilities.addNode(xPosOfCatalyst, yPosOfCatalyst, {\n        \"class\": catalystType,\n        language: 'PD'\n      });\n      catalystNode.data('justAdded', true);\n      catalystNode.data('label', catalystName);\n      var catalystEdge = elementUtilities.addEdge(catalystNode.id(), processNode.id(), {\n        \"class\": 'catalysis',\n        language: 'PD'\n      });\n      catalystEdge.data('justAdded', true);\n      cy.endBatch(); //filter the just added elememts to return them and remove just added mark\n\n      var eles = cy.elements('[justAdded]');\n      eles.removeData('justAdded');\n      cy.elements().unselect();\n      eles.select();\n      return eles; // Return the just added elements\n    };\n\n    elementUtilities.createActivationReaction = function (proteinName, processPosition, edgeLength, reverse) {\n      var defaultMacromoleculProperties = elementUtilities.getDefaultProperties(\"macromolecule\");\n      var defaultProcessProperties = elementUtilities.getDefaultProperties(\"activation\");\n      var processWidth = defaultProcessProperties.width || 50;\n      var macromoleculeWidth = defaultMacromoleculProperties.width || 50;\n      var processPosition = processPosition || elementUtilities.convertToModelPosition({\n        x: cy.width() / 2,\n        y: cy.height() / 2\n      });\n      var edgeLength = edgeLength || 60;\n      cy.startBatch();\n\n      if (!elementUtilities.getMapType()) {\n        elementUtilities.setMapType(\"PD\");\n      }\n\n      var xPosOfInput = processPosition.x - edgeLength - processWidth / 2 - macromoleculeWidth / 2;\n      var xPosOfOutput = processPosition.x + edgeLength + processWidth / 2 + macromoleculeWidth / 2;\n      var processNode = elementUtilities.addNode(processPosition.x, processPosition.y, {\n        \"class\": \"process\",\n        language: \"PD\"\n      });\n      elementUtilities.setPortsOrdering(processNode, \"L-to-R\");\n      processNode.data('justAdded', true);\n      var yPosition = processPosition.y;\n      var inputNode = elementUtilities.addNode(xPosOfInput, yPosition, {\n        \"class\": \"macromolecule\",\n        language: \"PD\"\n      });\n      inputNode.data(\"justAdded\", true);\n      inputNode.data(\"label\", proteinName);\n      var infoboxObject = {\n        clazz: \"unit of information\",\n        label: {\n          text: reverse ? \"active\" : \"inactive\"\n        },\n        style: {\n          \"shape-name\": \"ellipse\"\n        },\n        bbox: {\n          w: 36,\n          h: 15\n        }\n      };\n      elementUtilities.addStateOrInfoBox(inputNode, infoboxObject);\n      var outputNode = elementUtilities.addNode(xPosOfOutput, yPosition, {\n        \"class\": \"macromolecule\",\n        language: \"PD\"\n      });\n      outputNode.data(\"justAdded\", true);\n      outputNode.data(\"label\", proteinName);\n      infoboxObject = {\n        clazz: \"unit of information\",\n        label: {\n          text: reverse ? \"inactive\" : \"active\"\n        },\n        style: {\n          \"shape-name\": \"ellipse\"\n        },\n        bbox: {\n          w: 36,\n          h: 15\n        }\n      };\n      elementUtilities.addStateOrInfoBox(outputNode, infoboxObject);\n      var inputSideEdge = elementUtilities.addEdge(inputNode.id(), processNode.id(), {\n        \"class\": \"consumption\",\n        language: \"PD\"\n      });\n      inputSideEdge.data(\"justAdded\", true);\n      var outputSideEdge = elementUtilities.addEdge(processNode.id(), outputNode.id(), {\n        \"class\": \"production\",\n        language: \"PD\"\n      });\n      outputSideEdge.data(\"justAdded\", true);\n      cy.endBatch(); //filter the just added elememts to return them and remove just added mark\n\n      var eles = cy.elements('[justAdded]');\n      eles.removeData('justAdded');\n      cy.elements().unselect();\n      eles.select();\n      return eles; // Return the just added elements\n    };\n    /*\n     * Creates a template reaction with given parameters. Requires cose-bilkent layout to tile the free macromolecules included\n     * in the complex. Parameters are explained below.\n     * templateType: The type of the template reaction. It may be 'association', 'dissociation', 'reversible' or 'irreversible'.\n     * nodeList: The list of the names and types of molecules which will involve in the reaction.\n     * complexName: The name of the complex in the reaction.\n     * processPosition: The modal position of the process in the reaction. The default value is the center of the canvas.\n     * tilingPaddingVertical: This option will be passed to the cose-bilkent layout with the same name. The default value is 15.\n     * tilingPaddingHorizontal: This option will be passed to the cose-bilkent layout with the same name. The default value is 15.\n     * edgeLength: The distance between the process and the macromolecules at the both sides.\n     */\n\n\n    elementUtilities.createTemplateReaction = function (templateType, nodeList, complexName, processPosition, tilingPaddingVertical, tilingPaddingHorizontal, edgeLength, layoutParam) {\n      var defaultMacromoleculProperties = elementUtilities.getDefaultProperties(\"macromolecule\");\n      var defaultSimpleChemicalProperties = elementUtilities.getDefaultProperties(\"simple chemical\");\n      var defaultProcessProperties = elementUtilities.getDefaultProperties(templateType);\n      var processWidth = defaultProcessProperties.width || 50;\n      var macromoleculeWidth = defaultMacromoleculProperties.width || 50;\n      var macromoleculeHeight = defaultMacromoleculProperties.height || 50;\n      var simpleChemicalWidth = defaultSimpleChemicalProperties.width || 35;\n      var simpleChemicalHeight = defaultSimpleChemicalProperties.height || 35;\n      var processPosition = processPosition || elementUtilities.convertToModelPosition({\n        x: cy.width() / 2,\n        y: cy.height() / 2\n      });\n      var nodeList = nodeList;\n      var complexName = complexName;\n      var numOfMolecules = nodeList.length;\n      var tilingPaddingVertical = tilingPaddingVertical || 15;\n      var tilingPaddingHorizontal = tilingPaddingHorizontal || 15;\n      var edgeLength = edgeLength || 60;\n      cy.startBatch();\n\n      if (!elementUtilities.getMapType()) {\n        elementUtilities.setMapType(\"PD\");\n      }\n\n      var xPositionOfFreeMacromolecules;\n      var xPositionOfInputMacromolecules;\n\n      if (templateType === 'association') {\n        xPositionOfFreeMacromolecules = processPosition.x - edgeLength - processWidth / 2 - macromoleculeWidth / 2;\n      } else if (templateType === 'dissociation') {\n        xPositionOfFreeMacromolecules = processPosition.x + edgeLength + processWidth / 2 + macromoleculeWidth / 2;\n      } else {\n        xPositionOfFreeMacromolecules = processPosition.x - edgeLength - processWidth / 2 - macromoleculeWidth / 2;\n        xPositionOfInputMacromolecules = processPosition.x + edgeLength + processWidth / 2 + macromoleculeWidth / 2;\n      } //Create the process in template type\n\n\n      var process;\n\n      if (templateType === 'reversible' || templateType === 'irreversible') {\n        process = elementUtilities.addNode(processPosition.x, processPosition.y, {\n          \"class\": 'process',\n          language: 'PD'\n        });\n        elementUtilities.setPortsOrdering(process, 'L-to-R');\n      } else {\n        process = elementUtilities.addNode(processPosition.x, processPosition.y, {\n          \"class\": templateType,\n          language: 'PD'\n        });\n        elementUtilities.setPortsOrdering(process, 'L-to-R');\n      }\n\n      process.data('justAdded', true); //Define the starting y position\n\n      var yPosition = processPosition.y - (numOfMolecules - 1) / 2 * (macromoleculeHeight + tilingPaddingVertical); //Create the free molecules\n\n      for (var i = 0; i < numOfMolecules; i++) {\n        // node addition operation is determined by molecule type\n        if (nodeList[i].type == \"Simple Chemical\") {\n          var newNode = elementUtilities.addNode(xPositionOfFreeMacromolecules, yPosition, {\n            \"class\": 'simple chemical',\n            language: 'PD'\n          }); //update the y position\n\n          yPosition += simpleChemicalHeight + tilingPaddingVertical;\n        } else {\n          var newNode = elementUtilities.addNode(xPositionOfFreeMacromolecules, yPosition, {\n            \"class\": 'macromolecule',\n            language: 'PD'\n          }); //update the y position\n\n          yPosition += macromoleculeHeight + tilingPaddingVertical;\n        }\n\n        newNode.data('justAdded', true);\n        newNode.data('label', nodeList[i].name); //create the edge connected to the new molecule\n\n        var newEdge;\n\n        if (templateType === 'association') {\n          newEdge = elementUtilities.addEdge(newNode.id(), process.id(), {\n            \"class\": 'consumption',\n            language: 'PD'\n          });\n        } else if (templateType === 'dissociation') {\n          newEdge = elementUtilities.addEdge(process.id(), newNode.id(), {\n            \"class\": 'production',\n            language: 'PD'\n          });\n        } else {\n          //Group right or top elements in group id 1\n          if (templateType === \"irreversible\") {\n            newEdge = elementUtilities.addEdge(newNode.id(), process.id(), {\n              \"class\": \"consumption\",\n              language: 'PD'\n            });\n          } else {\n            newEdge = elementUtilities.addEdge(process.id(), newNode.id(), {\n              \"class\": \"production\",\n              language: 'PD'\n            }, undefined, undefined, 1);\n          }\n        }\n\n        newEdge.data('justAdded', true);\n      }\n\n      if (templateType === 'association' || templateType == 'dissociation') {\n        //Create the complex including macromolecules inside of it\n        //Temprorarily add it to the process position we will move it according to the last size of it\n        var complex = elementUtilities.addNode(processPosition.x, processPosition.y, {\n          \"class\": 'complex',\n          language: 'PD'\n        });\n        complex.data('justAdded', true);\n        complex.data('justAddedLayoutNode', true); //If a name is specified for the complex set its label accordingly\n\n        if (complexName) {\n          complex.data('label', complexName);\n        } //create the edge connnected to the complex\n\n\n        var edgeOfComplex;\n\n        if (templateType === 'association') {\n          edgeOfComplex = elementUtilities.addEdge(process.id(), complex.id(), {\n            \"class\": 'production',\n            language: 'PD'\n          });\n        } else {\n          edgeOfComplex = elementUtilities.addEdge(complex.id(), process.id(), {\n            \"class\": 'consumption',\n            language: 'PD'\n          });\n        }\n\n        edgeOfComplex.data('justAdded', true);\n\n        for (var i = 0; i < numOfMolecules; i++) {\n          // Add a molecule(dependent on it's type) not having a previously defined id and having the complex created in this reaction as parent\n          if (nodeList[i].type == 'Simple Chemical') {\n            var newNode = elementUtilities.addNode(complex.position('x'), complex.position('y'), {\n              \"class\": 'simple chemical',\n              language: 'PD'\n            }, undefined, complex.id());\n          } else {\n            var newNode = elementUtilities.addNode(complex.position('x'), complex.position('y'), {\n              \"class\": 'macromolecule',\n              language: 'PD'\n            }, undefined, complex.id());\n          }\n\n          newNode.data('justAdded', true);\n          newNode.data('label', nodeList[i].name);\n          newNode.data('justAddedLayoutNode', true);\n        }\n      } else {\n        //Create the input macromolecules\n        var numOfInputMacromolecules = complexName.length;\n        yPosition = processPosition.y - (numOfInputMacromolecules - 1) / 2 * (macromoleculeHeight + tilingPaddingVertical);\n\n        for (var i = 0; i < numOfInputMacromolecules; i++) {\n          if (complexName[i].type == 'Simple Chemical') {\n            var newNode = elementUtilities.addNode(xPositionOfInputMacromolecules, yPosition, {\n              \"class\": 'simple chemical',\n              language: 'PD'\n            });\n            yPosition += simpleChemicalHeight + tilingPaddingVertical;\n          } else {\n            var newNode = elementUtilities.addNode(xPositionOfInputMacromolecules, yPosition, {\n              \"class\": 'macromolecule',\n              language: 'PD'\n            });\n            yPosition += macromoleculeHeight + tilingPaddingVertical;\n          }\n\n          newNode.data('justAdded', true);\n          newNode.data('label', complexName[i].name); //create the edge connected to the new macromolecule\n\n          var newEdge; //Group the left or bottom elements in group id 0 if reversible\n\n          if (templateType === \"irreversible\") {\n            newEdge = elementUtilities.addEdge(process.id(), newNode.id(), {\n              \"class\": \"production\",\n              language: 'PD'\n            });\n          } else {\n            newEdge = elementUtilities.addEdge(process.id(), newNode.id(), {\n              \"class\": \"production\",\n              language: 'PD'\n            }, undefined, undefined, 0);\n          }\n\n          newEdge.data('justAdded', true);\n        }\n      }\n\n      cy.endBatch();\n      var layoutNodes = cy.nodes('[justAddedLayoutNode]');\n      layoutNodes.removeData('justAddedLayoutNode');\n      var layout = layoutNodes.layout({\n        name: layoutParam.name,\n        randomize: false,\n        fit: false,\n        animate: false,\n        tilingPaddingVertical: tilingPaddingVertical,\n        tilingPaddingHorizontal: tilingPaddingHorizontal,\n        stop: function stop() {\n          //If it is a reversible reaction no need to re-position complexes\n          if (templateType === 'reversible') return; //re-position the nodes inside the complex\n\n          var supposedXPosition;\n          var supposedYPosition = processPosition.y;\n\n          if (templateType === 'association') {\n            supposedXPosition = processPosition.x + edgeLength + processWidth / 2 + complex.outerWidth() / 2;\n          } else {\n            supposedXPosition = processPosition.x - edgeLength - processWidth / 2 - complex.outerWidth() / 2;\n          }\n\n          var positionDiffX = (supposedXPosition - complex.position('x')) / 2;\n          var positionDiffY = (supposedYPosition - complex.position('y')) / 2;\n          elementUtilities.moveNodes({\n            x: positionDiffX,\n            y: positionDiffY\n          }, complex);\n        }\n      }); // Do this check for cytoscape.js backward compatibility\n\n      if (layout && layout.run && templateType !== 'reversible' && templateType !== 'irreversible') {\n        layout.run();\n      } //filter the just added elememts to return them and remove just added mark\n\n\n      var eles = cy.elements('[justAdded]');\n      eles.removeData('justAdded');\n      cy.elements().unselect();\n      eles.select();\n      return eles; // Return the just added elements\n    };\n    /*\n     * Move the nodes to a new parent and change their position if possDiff params are set.\n     */\n\n\n    elementUtilities.changeParent = function (nodes, newParent, posDiffX, posDiffY) {\n      var newParentId = newParent == undefined || typeof newParent === 'string' ? newParent : newParent.id();\n      var movedEles = nodes.move({\n        \"parent\": newParentId\n      });\n\n      if (typeof posDiffX != 'undefined' || typeof posDiffY != 'undefined') {\n        elementUtilities.moveNodes({\n          x: posDiffX,\n          y: posDiffY\n        }, nodes);\n      }\n\n      elementUtilities.maintainPointer(movedEles);\n      return movedEles;\n    };\n\n    elementUtilities.updateInfoboxStyle = function (node, index, newProps) {\n      var infoboxObj = node.data('statesandinfos')[index];\n      $.extend(infoboxObj.style, newProps);\n      cy.style().update();\n    };\n\n    elementUtilities.updateInfoboxObj = function (node, index, newProps) {\n      var infoboxObj = node.data('statesandinfos')[index];\n      $.extend(infoboxObj, newProps);\n    }; // Resize given nodes if useAspectRatio is truthy one of width or height should not be set.\n\n\n    elementUtilities.resizeNodes = function (nodes, width, height, useAspectRatio, preserveRelativePos) {\n      for (var i = 0; i < nodes.length; i++) {\n        var node = nodes[i];\n        var ratio = undefined;\n        var eleMustBeSquare = elementUtilities.mustBeSquare(node.data('class'));\n\n        if (preserveRelativePos === true) {\n          var oldWidth = node.data(\"bbox\").w;\n          var oldHeight = node.data(\"bbox\").h;\n        } // Note that both width and height should not be set if useAspectRatio is truthy\n\n\n        if (!node.isParent()) {\n          if (width) {\n            if (useAspectRatio || eleMustBeSquare) {\n              ratio = width / node.width();\n            }\n\n            node.data(\"bbox\").w = width;\n          }\n\n          if (height) {\n            if (useAspectRatio || eleMustBeSquare) {\n              ratio = height / node.height();\n            }\n\n            node.data(\"bbox\").h = height;\n          }\n\n          if (ratio && !height) {\n            node.data(\"bbox\").h = node.height() * ratio;\n          } else if (ratio && !width) {\n            node.data(\"bbox\").w = node.width() * ratio;\n          }\n        } else {\n          node.data(\"minHeight\", \"\" + height);\n          node.data(\"minWidth\", \"\" + width);\n          node.data(\"minWidthBiasLeft\", \"50%\");\n          node.data(\"minWidthBiasRight\", \"50%\");\n          node.data(\"minHeightBiasTop\", \"50%\");\n          node.data(\"minHeightBiasBottom\", \"50%\");\n        }\n        /*    if (preserveRelativePos === true) {\n             var statesandinfos = node.data('statesandinfos');\n             var topBottom = statesandinfos.filter(box => (box.anchorSide === \"top\" || box.anchorSide === \"bottom\"));\n             var rightLeft = statesandinfos.filter(box => (box.anchorSide === \"right\" || box.anchorSide === \"left\"));\n              topBottom.forEach(function(box){\n               if (box.bbox.x < 0) {\n                 box.bbox.x = 0;\n               }\n               else if (box.bbox.x > oldWidth) {\n                 box.bbox.x = oldWidth;\n               }\n               box.bbox.x = node.data(\"bbox\").w * box.bbox.x / oldWidth;\n             });\n              rightLeft.forEach(function(box){\n               if (box.bbox.y < 0) {\n                 box.bbox.y = 0;\n               }\n               else if (box.bbox.y > oldHeight) {\n                 box.bbox.y = oldHeight;\n               }\n               box.bbox.y = node.data(\"bbox\").h * box.bbox.y / oldHeight;\n             });\n           } */\n\n      }\n    };\n\n    elementUtilities.calculateMinWidth = function (node) {\n      var defaultWidth = this.getDefaultProperties(node.data('class')).width; // Label width calculation\n\n      var style = node.style();\n      var fontFamiliy = style['font-family'];\n      var fontSize = style['font-size'];\n      var labelText = style['label'];\n\n      if (labelText === \"\" && node.data('label') && node.data('label') !== \"\") {\n        labelText = node.data('label');\n      }\n\n      var labelWidth = elementUtilities.getWidthByContent(labelText, fontFamiliy, fontSize);\n      var statesandinfos = node.data('statesandinfos'); //Top and bottom infoBoxes\n      //var topInfoBoxes = statesandinfos.filter(box => (box.anchorSide === \"top\" || ((box.anchorSide === \"right\" || box.anchorSide === \"left\") && (box.bbox.y <= 12))));\n      //var bottomInfoBoxes = statesandinfos.filter(box => (box.anchorSide === \"bottom\" || ((box.anchorSide === \"right\" || box.anchorSide === \"left\") && (box.bbox.y >= node.data('bbox').h - 12))));\n\n      var unitGap = 5;\n      var topIdealWidth = unitGap;\n      var bottomIdealWidth = unitGap;\n      var rightMaxWidth = 0;\n      var leftMaxWidth = 0;\n      statesandinfos.forEach(function (box) {\n        if (box.anchorSide === \"top\") {\n          topIdealWidth += box.bbox.w + unitGap;\n        } else if (box.anchorSide === \"bottom\") {\n          bottomIdealWidth += box.bbox.w + unitGap;\n        } else if (box.anchorSide === \"right\") {\n          rightMaxWidth = box.bbox.w > rightMaxWidth ? box.bbox.w : rightMaxWidth;\n        } else {\n          leftMaxWidth = box.bbox.w > leftMaxWidth ? box.bbox.w : leftMaxWidth;\n        }\n      });\n      var middleWidth = labelWidth + 2 * Math.max(rightMaxWidth / 2, leftMaxWidth / 2);\n      var compoundWidth = 0;\n\n      if (node.isParent()) {\n        compoundWidth = node.children().boundingBox().w;\n      }\n\n      return Math.max(middleWidth, defaultWidth / 2, topIdealWidth, bottomIdealWidth, compoundWidth);\n    };\n\n    elementUtilities.calculateMinHeight = function (node) {\n      var statesandinfos = node.data('statesandinfos');\n      var margin = 7;\n      var unitGap = 5;\n      var defaultHeight = this.getDefaultProperties(node.data('class')).height;\n      var leftInfoBoxes = statesandinfos.filter(function (box) {\n        return box.anchorSide === \"left\";\n      });\n      var leftHeight = unitGap;\n      leftInfoBoxes.forEach(function (box) {\n        leftHeight += box.bbox.h + unitGap;\n      });\n      var rightInfoBoxes = statesandinfos.filter(function (box) {\n        return box.anchorSide === \"right\";\n      });\n      var rightHeight = unitGap;\n      rightInfoBoxes.forEach(function (box) {\n        rightHeight += box.bbox.h + unitGap;\n      });\n      var style = node.style();\n      var labelText = style['label'].split(\"\\n\").filter(function (text) {\n        return text !== '';\n      });\n      var fontSize = parseFloat(style['font-size'].substring(0, style['font-size'].length - 2));\n      var totalHeight = labelText.length * fontSize + 2 * margin;\n      var compoundHeight = 0;\n\n      if (node.isParent()) {\n        compoundHeight = node.children().boundingBox().h;\n      }\n\n      return Math.max(totalHeight, defaultHeight / 2, leftHeight, rightHeight, compoundHeight);\n    };\n\n    elementUtilities.isResizedToContent = function (node) {\n      if (!node || !node.isNode() || !node.data('bbox')) {\n        return false;\n      } //var w = node.data('bbox').w;\n      //var h = node.data('bbox').h;\n\n\n      var w = node.width();\n      var h = node.height();\n      var minW = elementUtilities.calculateMinWidth(node);\n      var minH = elementUtilities.calculateMinHeight(node);\n      if (w === minW && h === minH) return true;else return false;\n    }; // Section End\n    // Add remove utilities\n    // Relocates state and info boxes. This function is expected to be called after add/remove state and info boxes\n\n\n    elementUtilities.relocateStateAndInfos = function (ele) {\n      var stateAndInfos = ele.isNode && ele.isNode() ? ele.data('statesandinfos') : ele;\n      var length = stateAndInfos.length;\n\n      if (length == 0) {\n        return;\n      } else if (length == 1) {\n        stateAndInfos[0].bbox.x = 0;\n        stateAndInfos[0].bbox.y = -50;\n      } else if (length == 2) {\n        stateAndInfos[0].bbox.x = 0;\n        stateAndInfos[0].bbox.y = -50;\n        stateAndInfos[1].bbox.x = 0;\n        stateAndInfos[1].bbox.y = 50;\n      } else if (length == 3) {\n        stateAndInfos[0].bbox.x = -25;\n        stateAndInfos[0].bbox.y = -50;\n        stateAndInfos[1].bbox.x = 25;\n        stateAndInfos[1].bbox.y = -50;\n        stateAndInfos[2].bbox.x = 0;\n        stateAndInfos[2].bbox.y = 50;\n      } else {\n        stateAndInfos[0].bbox.x = -25;\n        stateAndInfos[0].bbox.y = -50;\n        stateAndInfos[1].bbox.x = 25;\n        stateAndInfos[1].bbox.y = -50;\n        stateAndInfos[2].bbox.x = -25;\n        stateAndInfos[2].bbox.y = 50;\n        stateAndInfos[3].bbox.x = 25;\n        stateAndInfos[3].bbox.y = 50;\n      }\n    }; // Change state value or unit of information box of given nodes with given index.\n    // Type parameter indicates whether to change value or variable, it is valid if the box at the given index is a state variable.\n    // Value parameter is the new value to set.\n    // This method returns the old value of the changed data (We assume that the old value of the changed data was the same for all nodes).\n    // Each character assumed to occupy 8 unit\n    // Each infobox can have at most 32 units of width\n\n\n    elementUtilities.changeStateOrInfoBox = function (nodes, index, value, type) {\n      var result;\n\n      for (var i = 0; i < nodes.length; i++) {\n        var node = nodes[i];\n        var sbgnclass = node.data('class');\n        var stateAndInfos = node.data('statesandinfos');\n        var box = stateAndInfos[index];\n        var oldLength = box.bbox.w;\n        var newLength = 0;\n        var content = '';\n\n        if (box.clazz == \"state variable\") {\n          if (!result) {\n            result = box.state[type];\n          }\n\n          box.state[type] = value;\n\n          if (box.state[\"value\"] !== undefined) {\n            content += box.state[\"value\"];\n          }\n\n          if (box.state[\"variable\"] !== undefined && box.state[\"variable\"].length > 0) {\n            content += box.state[\"variable\"] + \"@\";\n          }\n        } else if (box.clazz == \"unit of information\") {\n          if (!result) {\n            result = box.label.text;\n          }\n\n          content += value;\n          box.label.text = value;\n        } else if (box.clazz == \"residue variable\") {\n          if (!result) {\n            result = box.residue[type];\n          }\n\n          box.residue[type] = value;\n\n          if (box.residue[\"variable\"] !== undefined && box.residue[\"variable\"].length > 0) {\n            content += box.residue[\"variable\"];\n          }\n        } else if (box.clazz == \"binding region\") {\n          if (!result) {\n            result = box.region[type];\n          }\n\n          box.region[type] = value;\n\n          if (box.region[\"variable\"] !== undefined && box.region[\"variable\"].length > 0) {\n            content += box.region[\"variable\"];\n          }\n        }\n\n        var min = sbgnclass === 'SIF macromolecule' || sbgnclass === 'SIF simple chemical' ? 15 : 12;\n        var fontFamily = box.style['font-family'];\n        var fontSize = box.style['font-size'];\n        var borderWidth = box.style['border-width'];\n        var opts = {\n          min: min,\n          max: 48,\n          margin: borderWidth / 2 + 0.5\n        };\n        var previousWidth = box.bbox.w;\n        box.bbox.w = elementUtilities.getWidthByContent(content, fontFamily, fontSize, opts);\n\n        if (box.anchorSide == \"top\" || box.anchorSide == \"bottom\") {\n          var unitLayout = node.data()[\"auxunitlayouts\"][box.anchorSide];\n\n          if (unitLayout.units[unitLayout.units.length - 1].id == box.id) {\n            var borderWidth = node.data()['border-width'];\n            var shiftAmount = (box.bbox.w - previousWidth) / 2 * 100 / (node.outerWidth() - borderWidth);\n\n            if (shiftAmount >= 0) {\n              if (box.bbox.x + shiftAmount <= 100) {\n                box.bbox.x = box.bbox.x + shiftAmount;\n              }\n            }\n            /*  else{\n               var previousInfoBbox = {x : 0, w:0};\n               if(unitLayout.units.length > 1){\n                 previousInfoBbox= unitLayout.units[unitLayout.units.length-2].bbox;      \n               }\n                \n               \n               sbgnvizInstance.classes.AuxUnitLayout.setIdealGap(node, box.anchorSide);\n               var idealGap = sbgnvizInstance.classes.AuxUnitLayout.getCurrentGap(box.anchorSide);\n               var newPosition = previousInfoBbox.x + (previousInfoBbox.w/2 + idealGap + box.bbox.w/2)*100 / (node.outerWidth() - borderWidth);\n               box.bbox.x = newPosition;\n               \n             } */\n\n          }\n        }\n        /* if (box.anchorSide === \"top\" || box.anchorSide === \"bottom\") {\n          box.bbox.x += (box.bbox.w - oldLength) / 2;\n          var units = (node.data('auxunitlayouts')[box.anchorSide]).units;\n          var shiftIndex = 0;\n          for (var i = 0; i < units.length; i++) {\n            if(units[i] === box){\n              shiftIndex = i;\n              break;\n            }\n          }\n          for (var j = shiftIndex+1; j < units.length; j++) {\n              units[j].bbox.x += (box.bbox.w - oldLength);\n          }\n        } */\n\n      } //TODO find a way to elimate this redundancy to update info-box positions\n\n\n      node.data('border-width', node.data('border-width'));\n      return result;\n    }; // Add a new state or info box to given nodes.\n    // The box is represented by the parameter obj.\n    // This method returns the index of the just added box.\n\n\n    elementUtilities.addStateOrInfoBox = function (nodes, obj) {\n      console.log(\"addStateOrInfoBox\");\n\n      for (var i = 0; i < nodes.length; i++) {\n        var node = nodes[i];\n        var locationObj;\n        var defaultProps = elementUtilities.getDefaultProperties(node.data('class'));\n        var infoboxProps = defaultProps[obj.clazz];\n        var bbox = obj.bbox || {\n          w: infoboxProps.width,\n          h: infoboxProps.height\n        };\n        var style = elementUtilities.getDefaultInfoboxStyle(node.data('class'), obj.clazz);\n\n        if (obj.style) {\n          $.extend(style, obj.style);\n        }\n\n        if (obj.clazz == \"unit of information\") {\n          locationObj = sbgnvizInstance.classes.UnitOfInformation.create(node, cy, obj.label.text, bbox, obj.location, obj.position, style, obj.index, obj.id);\n        } else if (obj.clazz == \"state variable\") {\n          locationObj = sbgnvizInstance.classes.StateVariable.create(node, cy, obj.state.value, obj.state.variable, bbox, obj.location, obj.position, style, obj.index, obj.id);\n        } else if (obj.clazz == \"residue variable\") {\n          locationObj = sbgnvizInstance.classes.ResidueVariable.create(node, cy, obj.residue.value, obj.residue.variable, bbox, obj.location, obj.position, style, obj.index, obj.id);\n        } else if (obj.clazz == \"binding region\") {\n          locationObj = sbgnvizInstance.classes.BindingRegion.create(node, cy, obj.region.value, obj.region.variable, bbox, obj.location, obj.position, style, obj.index, obj.id);\n        }\n      }\n\n      return locationObj;\n    }; // Remove the state or info boxes of the given nodes at given index.\n    // Returns the removed box.\n\n\n    elementUtilities.removeStateOrInfoBox = function (nodes, locationObj) {\n      var obj;\n\n      for (var i = 0; i < nodes.length; i++) {\n        var node = nodes[i];\n        var stateAndInfos = node.data('statesandinfos');\n        var unit = stateAndInfos[locationObj.index];\n        var unitClass = sbgnvizInstance.classes.getAuxUnitClass(unit);\n        obj = unitClass.remove(unit, cy);\n      }\n\n      return obj;\n    }; //Tiles informations boxes for given anchorSides\n\n\n    elementUtilities.fitUnits = function (node, locations) {\n      var obj = [];\n      node.data('statesandinfos').forEach(function (ele) {\n        obj.push({\n          x: ele.bbox.x,\n          y: ele.bbox.y,\n          anchorSide: ele.anchorSide\n        });\n      });\n      sbgnvizInstance.classes.AuxUnitLayout.fitUnits(node, cy, locations);\n      return obj;\n    }; //Check which anchorsides fits\n\n\n    elementUtilities.checkFit = function (node, location) {\n      //if no location given, it checks all possible locations\n      console.log(\"elementUtilities.checkFit\", node);\n      return sbgnvizInstance.classes.AuxUnitLayout.checkFit(node, cy, location);\n    }; //Modify array of aux layout units\n\n\n    elementUtilities.modifyUnits = function (node, unit, anchorSide) {\n      sbgnvizInstance.classes.AuxUnitLayout.modifyUnits(node, unit, anchorSide, cy);\n    }; // Set multimer status of the given nodes to the given status.\n\n\n    elementUtilities.setMultimerStatus = function (nodes, status) {\n      for (var i = 0; i < nodes.length; i++) {\n        var node = nodes[i];\n        var sbgnclass = node.data('class');\n        var isMultimer = node.data('class').endsWith(' multimer');\n\n        if (status) {\n          // Make multimer status true\n          if (!isMultimer) {\n            node.data('class', sbgnclass + ' multimer');\n          }\n        } else {\n          // Make multimer status false\n          if (isMultimer) {\n            node.data('class', sbgnclass.replace(' multimer', ''));\n          }\n        }\n      }\n    }; //Need to add this to doc : TO-DO\n\n\n    elementUtilities.setActiveStatus = function (nodes, status) {\n      for (var i = 0; i < nodes.length; i++) {\n        var node = nodes[i];\n        var sbgnclass = node.data('class');\n        var isActive = node.data('class').startsWith('active ');\n\n        if (status) {\n          // Make multimer status true\n          if (!isActive) {\n            node.data('class', 'active ' + sbgnclass); //node.data('class', sbgnclass + ' multimer');\n          }\n        } else {\n          // Make multimer status false\n          if (isActive) {\n            node.data('class', sbgnclass.replace('active ', '')); //node.data('class', sbgnclass.replace(' multimer', ''));\n          }\n        }\n      }\n    }; //Need to add this to doc : TO-DO\n\n\n    elementUtilities.setHypotheticalStatus = function (nodes, status) {\n      for (var i = 0; i < nodes.length; i++) {\n        var node = nodes[i];\n        var sbgnclass = node.data('class');\n        var isHypothetical = node.data('class').includes('hypothetical');\n        var isActive = node.data('class').startsWith('active ');\n\n        if (status) {\n          // Make multimer status true\n          if (!isHypothetical) {\n            if (isActive) {\n              var tmp = sbgnclass.substring(7);\n              node.data('class', 'active hypothetical ' + tmp);\n            } else {\n              node.data('class', 'hypothetical ' + sbgnclass);\n            } //node.data('class', sbgnclass + ' multimer');\n\n          }\n        } else {\n          // Make multimer status false\n          if (isHypothetical) {\n            node.data('class', sbgnclass.replace('hypothetical ', '')); //node.data('class', sbgnclass.replace(' multimer', ''));\n          }\n        }\n      }\n    }; // Change font properties of the given elements with given font data\n\n\n    elementUtilities.changeFontProperties = function (eles, data) {\n      for (var prop in data) {\n        eles.data(prop, data[prop]);\n      }\n    }; // This function gets an edge, and ends of that edge (Optionally it may take just the classes of the edge as well) as parameters.\n    // It may return 'valid' (that ends is valid for that edge), 'reverse' (that ends is not valid for that edge but they would be valid\n    // if you reverse the source and target), 'invalid' (that ends are totally invalid for that edge).\n\n\n    elementUtilities.validateArrowEnds = function (edge, source, target, isReplacement) {\n      // if map type is Unknown -- no rules applied\n      if (elementUtilities.getMapType() == \"HybridAny\" || elementUtilities.getMapType() == \"HybridSbgn\" || !elementUtilities.getMapType()) return \"valid\";\n      var edgeclass = typeof edge === 'string' ? edge : edge.data('class');\n      var sourceclass = source.data('class');\n      var targetclass = target.data('class');\n      var mapType = elementUtilities.getMapType();\n      var edgeConstraints = elementUtilities[mapType].connectivityConstraints[edgeclass];\n\n      if (mapType == \"AF\") {\n        if (sourceclass.startsWith(\"BA\")) // we have separate classes for each biological activity\n          sourceclass = \"biological activity\"; // but same rule applies to all of them\n\n        if (targetclass.startsWith(\"BA\")) // we have separate classes for each biological activity\n          targetclass = \"biological activity\"; // but same rule applies to all of them\n      } else if (mapType == \"PD\") {\n        sourceclass = sourceclass.replace(/\\s*multimer$/, '');\n        targetclass = targetclass.replace(/\\s*multimer$/, '');\n      } else if (mapType == \"SBML\") {\n        sourceclass = sourceclass.replace(/\\s*multimer$/, '');\n        targetclass = targetclass.replace(/\\s*multimer$/, '');\n        sourceclass = sourceclass.replace(\"active \", '');\n        targetclass = targetclass.replace(\"active \", '');\n        sourceclass = sourceclass.replace(\"hypothetical \", '');\n        targetclass = targetclass.replace(\"hypothetical \", '');\n      } // given a node, acting as source or target, returns boolean wether or not it has too many edges already\n\n\n      function hasTooManyEdges(node, sourceOrTarget) {\n        var nodeclass = node.data('class');\n        nodeclass = nodeclass.replace(/\\s*multimer$/, '');\n        nodeclass = nodeclass.replace(\"active \", '');\n        nodeclass = nodeclass.replace(\"hypothetical \", '');\n        if (nodeclass.startsWith(\"BA\")) nodeclass = \"biological activity\";\n        /*\n          On the logic below:\n           Current edge count (incoming or outgoing) of nodes should be strictly less \n          than the maximum allowed if we are adding an edge to the node. This way\n          it will never exceed the max count.\n          \n          Edges can be added in two different ways. Either they are added directly or\n          they are added by being replaced from another node, i.e disconnected from\n          one and connected to another.\n           We can detect if the edge being added is added from a replacement by checking\n          whether the source stayed the same when checking edge counts of the source node,\n          and whether the target stayed the same when checking edge counts of the\n          target node.\n           Current edge count of nodes can be allowed to be equal to the maximum in \n          cases where a replacement is made. But we should be careful that this\n          replacement operation is not also an addition operation as described above.\n        */\n\n        var totalTooMany = true;\n        var edgeTooMany = true;\n\n        if (sourceOrTarget == \"source\") {\n          var sameEdgeCountOut = node.outgoers('edge[class=\"' + edgeclass + '\"]').size();\n          var totalEdgeCountOut = node.outgoers('edge').size();\n          var maxTotal = edgeConstraints[nodeclass].asSource.maxTotal;\n          var maxEdge = edgeConstraints[nodeclass].asSource.maxEdge;\n          var compareStrict = !(isReplacement && edge.source() === source);\n          var withinLimits = !maxTotal || compareStrict && totalEdgeCountOut < maxTotal || !compareStrict && totalEdgeCountOut <= maxTotal;\n\n          if (withinLimits) {\n            totalTooMany = false;\n          } // then check limits for this specific edge class\n\n\n          withinLimits = !maxEdge || compareStrict && sameEdgeCountOut < maxEdge || !compareStrict && sameEdgeCountOut <= maxEdge;\n\n          if (withinLimits) {\n            edgeTooMany = false;\n          } // if only one of the limits is reached then edge is invalid\n\n\n          return totalTooMany || edgeTooMany;\n        } else {\n          // node is used as target\n          var sameEdgeCountIn = node.incomers('edge[class=\"' + edgeclass + '\"]').size();\n          var totalEdgeCountIn = node.incomers('edge').size();\n          var maxTotal = edgeConstraints[nodeclass].asTarget.maxTotal;\n          var maxEdge = edgeConstraints[nodeclass].asTarget.maxEdge;\n          var compareStrict = !(isReplacement && edge.target() === target);\n          var withinLimits = !maxTotal || compareStrict && totalEdgeCountIn < maxTotal || !compareStrict && totalEdgeCountIn <= maxTotal;\n\n          if (withinLimits) {\n            totalTooMany = false;\n          }\n\n          withinLimits = !maxEdge || compareStrict && sameEdgeCountIn < maxEdge || !compareStrict && sameEdgeCountIn <= maxEdge;\n\n          if (withinLimits) {\n            edgeTooMany = false;\n          }\n\n          return totalTooMany || edgeTooMany;\n        }\n      }\n\n      function isInComplex(node) {\n        var parentClass = node.parent().data('class');\n        return parentClass && parentClass.startsWith('complex');\n      }\n\n      if (isInComplex(source) || isInComplex(target)) {\n        // subunits of a complex are no longer EPNs, no connection allowed\n        return 'invalid';\n      } // check nature of connection\n\n\n      if (edgeConstraints[sourceclass].asSource.isAllowed && edgeConstraints[targetclass].asTarget.isAllowed) {\n        // check amount of connections\n        if (!hasTooManyEdges(source, \"source\") && !hasTooManyEdges(target, \"target\")) {\n          return 'valid';\n        }\n      } // try to reverse\n\n\n      if (edgeConstraints[targetclass].asSource.isAllowed && edgeConstraints[sourceclass].asTarget.isAllowed) {\n        if (!hasTooManyEdges(target, \"source\") && !hasTooManyEdges(source, \"target\")) {\n          return 'reverse';\n        }\n      }\n\n      return 'invalid';\n    };\n\n    elementUtilities.deleteAndPerformLayout = function (eles, layoutparam) {\n      var result = eles.remove();\n\n      if (typeof layoutparam === 'function') {\n        layoutparam(); // If layoutparam is a function execute it\n      } else {\n        var layout = cy.layout(layoutparam); // If layoutparam is layout options call layout with that options.\n        // Do this check for cytoscape.js backward compatibility\n\n        if (layout && layout.run) {\n          layout.run();\n        }\n      }\n\n      return result;\n    };\n    /*\n     * Hide given eles and perform given layout afterward. Layout parameter may be layout options\n     * or a function to call.\n     */\n\n\n    elementUtilities.hideAndPerformLayout = function (eles, layoutparam) {\n      var result = cy.viewUtilities().hide(eles); // Hide given eles\n\n      if (typeof layoutparam === 'function') {\n        layoutparam(); // If layoutparam is a function execute it\n      } else {\n        var layout = cy.layout(layoutparam); // If layoutparam is layout options call layout with that options.\n        // Do this check for cytoscape.js backward compatibility\n\n        if (layout && layout.run) {\n          layout.run();\n        }\n      }\n\n      return result;\n    };\n    /*\n     * Unhide given eles and perform given layout afterward. Layout parameter may be layout options\n     * or a function to call.\n     */\n\n\n    elementUtilities.showAndPerformLayout = function (eles, layoutparam) {\n      var result = cy.viewUtilities().show(eles); // Show given eles\n\n      if (typeof layoutparam === 'function') {\n        layoutparam(); // If layoutparam is a function execute it\n      } else {\n        var layout = cy.layout(layoutparam); // If layoutparam is layout options call layout with that options.\n        // Do this check for cytoscape.js backward compatibility\n\n        if (layout && layout.run) {\n          layout.run();\n        }\n      }\n\n      return result;\n    };\n    /*\n     * Change style/css of given eles by setting getting property name to the given value/values (Note that valueMap parameter may be\n     * a single string or an id to value map).\n     */\n\n\n    elementUtilities.changeCss = function (eles, name, valueMap) {\n      if (_typeof(valueMap) === 'object') {\n        cy.startBatch();\n\n        for (var i = 0; i < eles.length; i++) {\n          var ele = cy.getElementById(eles[i].id());\n          ele.css(name, valueMap[ele.id()]); // valueMap is an id to value map use it in this way\n        }\n\n        cy.endBatch();\n      } else {\n        eles.css(name, valueMap); // valueMap is just a string set css('name') for all eles to this value\n      }\n    };\n    /*\n     * Change data of given eles by setting getting property name to the given value/values (Note that valueMap parameter may be\n     * a single string or an id to value map).\n     */\n\n\n    elementUtilities.changeData = function (eles, name, valueMap) {\n      console.log(\"changing data in chise\");\n\n      if (_typeof(valueMap) === 'object') {\n        cy.startBatch();\n\n        for (var i = 0; i < eles.length; i++) {\n          var ele = cy.getElementById(eles[i].id());\n          ele.data(name, valueMap[ele.id()]); // valueMap is an id to value map use it in this way\n        }\n\n        cy.endBatch();\n      } else {\n        eles.data(name, valueMap); // valueMap is just a string set css('name') for all eles to this value\n      }\n    };\n\n    elementUtilities.updateSetField = function (ele, fieldName, toDelete, toAdd, callback) {\n      var set = ele.data(fieldName);\n\n      if (!set) {\n        return;\n      }\n\n      var updates = {};\n\n      if (toDelete != null && set[toDelete]) {\n        delete set[toDelete];\n        updates.deleted = toDelete;\n      }\n\n      if (toAdd != null) {\n        set[toAdd] = true;\n        updates.added = toAdd;\n      }\n\n      if (callback && (updates['deleted'] != null || updates['added'] != null)) {\n        callback();\n      }\n\n      return updates;\n    };\n    /*\n     * Return the set of all nodes present under the given position\n     * renderedPos must be a point defined relatively to cytoscape container\n     * (like renderedPosition field of a node)\n     */\n\n\n    elementUtilities.getNodesAt = function (renderedPos) {\n      var nodes = cy.nodes();\n      var x = renderedPos.x;\n      var y = renderedPos.y;\n      var resultNodes = [];\n\n      for (var i = 0; i < nodes.length; i++) {\n        var node = nodes[i];\n        var renderedBbox = node.renderedBoundingBox({\n          includeNodes: true,\n          includeEdges: false,\n          includeLabels: false,\n          includeShadows: false\n        });\n\n        if (x >= renderedBbox.x1 && x <= renderedBbox.x2) {\n          if (y >= renderedBbox.y1 && y <= renderedBbox.y2) {\n            resultNodes.push(node);\n          }\n        }\n      }\n\n      return resultNodes;\n    };\n\n    elementUtilities.demultimerizeClass = function (sbgnclass) {\n      return sbgnclass.replace(\" multimer\", \"\");\n    };\n    /**\n     * @param mapType - type of the current map (PD, AF or Unknown)\n     */\n\n\n    elementUtilities.setMapType = function (mapType) {\n      elementUtilities.mapType = mapType;\n      return mapType;\n    };\n    /**\n     * return - map type\n     */\n\n\n    elementUtilities.getMapType = function () {\n      return elementUtilities.mapType;\n    };\n    /**\n     * Resets map type\n     */\n\n\n    elementUtilities.resetMapType = function () {\n      elementUtilities.mapType = undefined;\n    };\n    /**\n     * Keep consistency of links to self inside the data() structure.\n     * This is needed whenever a node changes parents, for example,\n     * as it is destroyed and recreated. But the data() stays identical.\n     * This creates inconsistencies for the pointers stored in data(),\n     * as they now point to a deleted node.\n     */\n\n\n    elementUtilities.maintainPointer = function (eles) {\n      eles.nodes().forEach(function (ele) {\n        // restore background images\n        ele.emit('data'); // skip nodes without any auxiliary units\n\n        if (!ele.data('statesandinfos') || ele.data('statesandinfos').length == 0) {\n          return;\n        }\n\n        for (var side in ele.data('auxunitlayouts')) {\n          ele.data('auxunitlayouts')[side].parentNode = ele.id();\n        }\n\n        for (var i = 0; i < ele.data('statesandinfos').length; i++) {\n          ele.data('statesandinfos')[i].parent = ele.id();\n        }\n      });\n    };\n\n    elementUtilities.anyHasBackgroundImage = function (eles) {\n      var obj = elementUtilities.getBackgroundImageObjs(eles);\n      if (obj === undefined) return false;else {\n        for (var key in obj) {\n          var value = obj[key];\n          if (value && !$.isEmptyObject(value)) return true;\n        }\n\n        return false;\n      }\n    };\n\n    elementUtilities.hasBackgroundImage = function (ele) {\n      if (!ele.isNode() || !ele.data('background-image')) {\n        return false;\n      }\n\n      var bg;\n\n      if (typeof ele.data('background-image') === \"string\") {\n        bg = ele.data('background-image').split(\" \");\n      } else if (Array.isArray(obj['background-image'])) {\n        bg = ele.data('background-image');\n      }\n\n      if (!bg) return false;\n      var cloneImg = 'data:image/svg+xml;utf8,%3Csvg%20width%3D%22100%22%20height%3D%22100%22%20viewBox%3D%220%200%20100%20100%22%20style%3D%22fill%3Anone%3Bstroke%3Ablack%3Bstroke-width%3A0%3B%22%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20%3E%3Crect%20x%3D%220%22%20y%3D%220%22%20width%3D%22100%22%20height%3D%22100%22%20style%3D%22fill%3A%23838383%22/%3E%20%3C/svg%3E'; // If cloneImg is not the only image or there are multiple images there is a background image\n\n      var onlyHasCloneMarkerAsBgImage = bg.length === 1 && bg.indexOf(cloneImg) === 0;\n      if (bg.length > 1 || !onlyHasCloneMarkerAsBgImage) return true;\n      return false;\n    };\n\n    elementUtilities.getBackgroundImageURL = function (eles) {\n      'getting background images';\n      if (!eles || eles.length < 1) return;\n      var commonURL = \"\";\n\n      for (var i = 0; i < eles.length; i++) {\n        var ele = eles[i];\n        if (!ele.isNode() || !elementUtilities.hasBackgroundImage(ele)) return;\n        var url = ele.data('background-image').split(\" \").pop();\n        if (!url || url.indexOf('http') !== 0 || commonURL !== \"\" && commonURL !== url) return;else if (commonURL === \"\") commonURL = url;\n      }\n\n      return commonURL;\n    };\n\n    elementUtilities.getBackgroundImageObjs = function (eles) {\n      if (!eles || eles.length < 1) return;\n      var list = {};\n\n      for (var i = 0; i < eles.length; i++) {\n        var ele = eles[i];\n        var obj = getBgObj(ele);\n        if (Object.keys(obj).length < 1) return;\n        list[ele.data('id')] = obj;\n      }\n\n      return list;\n\n      function getBgObj(ele) {\n        if (ele.isNode() && elementUtilities.hasBackgroundImage(ele)) {\n          var keys = ['background-image', 'background-fit', 'background-image-opacity', 'background-position-x', 'background-position-y', 'background-height', 'background-width'];\n          var obj = {};\n          keys.forEach(function (key) {\n            var value;\n\n            if (ele.data(key) && typeof ele.data(key) === \"string\") {\n              value = ele.data(key).split(\" \")[0];\n            } else {\n              value = ele.data(key);\n            }\n\n            obj[key] = value;\n          });\n          return obj;\n        } else if (ele.isNode()) return {};\n      }\n    };\n\n    elementUtilities.getBackgroundFitOptions = function (eles) {\n      if (!eles || eles.length < 1) return;\n      var commonFit = \"\";\n\n      for (var i = 0; i < eles.length; i++) {\n        var node = eles[i];\n        if (!node.isNode()) return;\n        var fit = getFitOption(node);\n        if (!fit || commonFit !== \"\" && fit !== commonFit) return;else if (commonFit === \"\") commonFit = fit;\n      }\n\n      var options = '<option value=\"none\">None</option>' + '<option value=\"fit\">Fit</option>' + '<option value=\"cover\">Cover</option>' + '<option value=\"contain\">Contain</option>';\n      var searchKey = 'value=\"' + commonFit + '\"';\n      var index = options.indexOf(searchKey) + searchKey.length;\n      return options.substr(0, index) + ' selected' + options.substr(index);\n\n      function getFitOption(node) {\n        if (!elementUtilities.hasBackgroundImage(node)) return;\n        var f = node.data('background-fit');\n        var h = node.data('background-height');\n        if (!f || !h) return;\n        f = f.split(\" \");\n        h = h.split(\" \");\n        if (f[f.length - 1] === \"none\") return h[h.length - 1] === \"auto\" ? \"none\" : \"fit\";else return f[f.length - 1];\n      }\n    };\n\n    elementUtilities.updateBackgroundImage = function (nodes, bgObj) {\n      if (!nodes || nodes.length == 0 || !bgObj) return;\n\n      for (var i = 0; i < nodes.length; i++) {\n        var node = nodes[i];\n        var obj = bgObj[node.data('id')];\n        if (!obj || $.isEmptyObject(obj)) continue;\n        var imgs = node.data('background-image') ? node.data('background-image').split(\" \") : [];\n        var xPos = node.data('background-position-x') ? node.data('background-position-x').split(\" \") : [];\n        var yPos = node.data('background-position-y') ? node.data('background-position-y').split(\" \") : [];\n        var widths = node.data('background-width') ? node.data('background-width').split(\" \") : [];\n        var heights = node.data('background-height') ? node.data('background-height').split(\" \") : [];\n        var fits = node.data('background-fit') ? node.data('background-fit').split(\" \") : [];\n        var opacities = node.data('background-image-opacity') ? (\"\" + node.data('background-image-opacity')).split(\" \") : [];\n        var index = -1;\n        if (typeof obj['background-image'] === \"string\") index = imgs.indexOf(obj['background-image']);else if (Array.isArray(obj['background-image'])) index = imgs.indexOf(obj['background-image'][0]);\n        if (index < 0) continue;\n\n        if (obj['background-image'] && imgs.length > index) {\n          var tmp = imgs[index];\n          imgs[index] = obj['background-image'];\n          obj['background-image'] = tmp;\n        }\n\n        if (obj['background-fit'] && fits.length > index) {\n          var tmp = fits[index];\n          fits[index] = obj['background-fit'];\n          obj['background-fit'] = tmp;\n        }\n\n        if (obj['background-width'] && widths.length > index) {\n          var tmp = widths[index];\n          widths[index] = obj['background-width'];\n          obj['background-width'] = tmp;\n        }\n\n        if (obj['background-height'] && heights.length > index) {\n          var tmp = heights[index];\n          heights[index] = obj['background-height'];\n          obj['background-height'] = tmp;\n        }\n\n        if (obj['background-position-x'] && xPos.length > index) {\n          var tmp = xPos[index];\n          xPos[index] = obj['background-position-x'];\n          obj['background-position-x'] = tmp;\n        }\n\n        if (obj['background-position-y'] && yPos.length > index) {\n          var tmp = yPos[index];\n          yPos[index] = obj['background-position-y'];\n          obj['background-position-y'] = tmp;\n        }\n\n        if (obj['background-image-opacity'] && opacities.length > index) {\n          var tmp = opacities[index];\n          opacities[index] = obj['background-image-opacity'];\n          obj['background-image-opacity'] = tmp;\n        }\n\n        node.data('background-image', imgs.join(\" \"));\n        node.data('background-position-x', xPos.join(\" \"));\n        node.data('background-position-y', yPos.join(\" \"));\n        node.data('background-width', widths.join(\" \"));\n        node.data('background-height', heights.join(\" \"));\n        node.data('background-fit', fits.join(\" \"));\n        node.data('background-image-opacity', opacities.join(\" \"));\n      }\n\n      return bgObj;\n    };\n\n    elementUtilities.changeBackgroundImage = function (nodes, oldImg, newImg, firstTime, updateInfo, promptInvalidImage, validateURL) {\n      if (!nodes || nodes.length == 0 || !oldImg || !newImg) return;\n      elementUtilities.removeBackgroundImage(nodes, oldImg);\n\n      for (var key in newImg) {\n        newImg[key]['firstTime'] = firstTime;\n      }\n\n      elementUtilities.addBackgroundImage(nodes, newImg, updateInfo, promptInvalidImage, validateURL);\n      return {\n        nodes: nodes,\n        oldImg: newImg,\n        newImg: oldImg,\n        firstTime: false,\n        promptInvalidImage: promptInvalidImage,\n        validateURL: validateURL\n      };\n    }; // Add a background image to given nodes.\n\n\n    elementUtilities.addBackgroundImage = function (nodes, bgObj, updateInfo, promptInvalidImage, validateURL) {\n      if (!nodes || nodes.length == 0 || !bgObj) return;\n\n      for (var i = 0; i < nodes.length; i++) {\n        var node = nodes[i];\n        var obj = bgObj[node.data('id')];\n        if (!obj || $.isEmptyObject(obj)) continue; // Load the image from local, else just put the URL\n\n        if (obj['fromFile']) loadBackgroundThenApply(node, obj); // Validity of given URL should be checked before applying it\n        else if (obj['firstTime']) {\n          if (typeof validateURL === 'function') validateURL(node, obj, applyBackground, promptInvalidImage);else checkGivenURL(node, obj);\n        } else applyBackground(node, obj);\n      }\n\n      function loadBackgroundThenApply(node, bgObj) {\n        var reader = new FileReader();\n        var imgFile = bgObj['background-image']; // Check whether given file is an image file\n\n        if (imgFile.type.indexOf(\"image\") !== 0) {\n          if (promptInvalidImage) promptInvalidImage(\"Invalid image file is given!\");\n          return;\n        }\n\n        reader.readAsDataURL(imgFile);\n\n        reader.onload = function (e) {\n          var img = reader.result;\n\n          if (img) {\n            bgObj['background-image'] = img;\n            bgObj['fromFile'] = false;\n            applyBackground(node, bgObj);\n          } else {\n            if (promptInvalidImage) promptInvalidImage(\"Given file could not be read!\");\n          }\n        };\n      }\n\n      function checkGivenURL(node, bgObj) {\n        var url = bgObj['background-image'];\n        var extension = url.split(/[?#]/)[0].split(\".\").pop();\n        var validExtensions = [\"png\", \"svg\", \"jpg\", \"jpeg\"];\n\n        if (!validExtensions.includes(extension)) {\n          if (typeof promptInvalidImage === 'function') promptInvalidImage(\"Invalid URL is given!\");\n          return;\n        }\n\n        $.ajax({\n          url: url,\n          type: 'GET',\n          success: function success(result, status, xhr) {\n            applyBackground(node, bgObj);\n          },\n          error: function error(xhr, status, _error) {\n            if (promptInvalidImage) promptInvalidImage(\"Invalid URL is given!\");\n          }\n        });\n      }\n\n      function applyBackground(node, bgObj) {\n        if (elementUtilities.hasBackgroundImage(node)) return;\n        var imgs = node.data('background-image') ? node.data('background-image').split(\" \") : [];\n        var xPos = node.data('background-position-x') ? node.data('background-position-x').split(\" \") : [];\n        var yPos = node.data('background-position-y') ? node.data('background-position-y').split(\" \") : [];\n        var widths = node.data('background-width') ? node.data('background-width').split(\" \") : [];\n        var heights = node.data('background-height') ? node.data('background-height').split(\" \") : [];\n        var fits = node.data('background-fit') ? node.data('background-fit').split(\" \") : [];\n        var opacities = node.data('background-image-opacity') ? (\"\" + node.data('background-image-opacity')).split(\" \") : [];\n        var indexToInsert = imgs.length; // insert to length-1\n\n        if (elementUtilities.hasCloneMarker(imgs)) {\n          indexToInsert--;\n        }\n\n        imgs.splice(indexToInsert, 0, bgObj['background-image']);\n        fits.splice(indexToInsert, 0, bgObj['background-fit']);\n        opacities.splice(indexToInsert, 0, bgObj['background-image-opacity']);\n        xPos.splice(indexToInsert, 0, bgObj['background-position-x']);\n        yPos.splice(indexToInsert, 0, bgObj['background-position-y']);\n        widths.splice(indexToInsert, 0, bgObj['background-width']);\n        heights.splice(indexToInsert, 0, bgObj['background-height']);\n        node.data('background-image', imgs.join(\" \"));\n        node.data('background-position-x', xPos.join(\" \"));\n        node.data('background-position-y', yPos.join(\" \"));\n        node.data('background-width', widths.join(\" \"));\n        node.data('background-height', heights.join(\" \"));\n        node.data('background-fit', fits.join(\" \"));\n        node.data('background-image-opacity', opacities.join(\" \"));\n        bgObj['firstTime'] = false;\n        if (updateInfo) updateInfo();\n      }\n    };\n\n    elementUtilities.hasCloneMarker = function (imgs) {\n      var cloneImg = 'data:image/svg+xml;utf8,%3Csvg%20width%3D%22100%22%20height%3D%22100%22%20viewBox%3D%220%200%20100%20100%22%20style%3D%22fill%3Anone%3Bstroke%3Ablack%3Bstroke-width%3A0%3B%22%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20%3E%3Crect%20x%3D%220%22%20y%3D%220%22%20width%3D%22100%22%20height%3D%22100%22%20style%3D%22fill%3A%23838383%22/%3E%20%3C/svg%3E';\n      return imgs.indexOf(cloneImg) > -1;\n    }; // Remove a background image from given nodes.\n\n\n    elementUtilities.removeBackgroundImage = function (nodes, bgObj) {\n      if (!nodes || nodes.length == 0 || !bgObj) return;\n\n      for (var i = 0; i < nodes.length; i++) {\n        var node = nodes[i];\n        var obj = bgObj[node.data('id')];\n        if (!obj) continue;\n        var imgs = node.data('background-image') ? node.data('background-image').split(\" \") : [];\n        var xPos = node.data('background-position-x') ? node.data('background-position-x').split(\" \") : [];\n        var yPos = node.data('background-position-y') ? node.data('background-position-y').split(\" \") : [];\n        var widths = node.data('background-width') ? node.data('background-width').split(\" \") : [];\n        var heights = node.data('background-height') ? node.data('background-height').split(\" \") : [];\n        var fits = node.data('background-fit') ? node.data('background-fit').split(\" \") : [];\n        var opacities = node.data('background-image-opacity') ? (\"\" + node.data('background-image-opacity')).split(\" \") : [];\n        var index = -1;\n        if (typeof obj['background-image'] === \"string\") index = imgs.indexOf(obj['background-image'].split(\" \")[0]);else if (Array.isArray(obj['background-image'])) index = imgs.indexOf(obj['background-image'][0]);\n\n        if (index > -1) {\n          imgs.splice(index, 1);\n          fits.splice(index, 1);\n          opacities.splice(index, 1);\n          xPos.splice(index, 1);\n          yPos.splice(index, 1);\n          widths.splice(index, 1);\n          heights.splice(index, 1);\n        }\n\n        node.data('background-image', imgs.join(\" \"));\n        node.data('background-position-x', xPos.join(\" \"));\n        node.data('background-position-y', yPos.join(\" \"));\n        node.data('background-width', widths.join(\" \"));\n        node.data('background-height', heights.join(\" \"));\n        node.data('background-fit', fits.join(\" \"));\n        node.data('background-image-opacity', opacities.join(\" \"));\n        bgObj['firstTime'] = false;\n      }\n    };\n\n    elementUtilities.reverseEdge = function (edge) {\n      var oldSource = edge.source().id();\n      var oldTarget = edge.target().id();\n      var oldPortSource = edge.data(\"portsource\");\n      var oldPortTarget = edge.data(\"porttarget\");\n      var segmentPoints = edge.segmentPoints();\n      var controlPoints = edge.controlPoints();\n      edge.data().source = oldTarget;\n      edge.data().target = oldSource;\n      edge.data().portsource = oldPortTarget;\n      edge.data().porttarget = oldPortSource;\n      edge = edge.move({\n        target: oldSource,\n        source: oldTarget\n      });\n\n      if (Array.isArray(segmentPoints)) {\n        segmentPoints.reverse();\n        edge.data().bendPointPositions = segmentPoints;\n\n        if (Array.isArray(controlPoints)) {\n          controlPoints.reverse();\n          edge.data().controlPointPositions = controlPoints;\n        }\n\n        var edgeEditing = cy.edgeEditing('get');\n        edgeEditing.initAnchorPoints(edge);\n      }\n\n      return edge;\n    };\n  }\n\n  return elementUtilitiesExtender;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdXRpbGl0aWVzL2VsZW1lbnQtdXRpbGl0aWVzLWV4dGVuZGVyLWZhY3RvcnkuanMuanMiLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBLElBQUlBLElBQUksR0FBR0Msd0ZBQUEsRUFBWDs7QUFDQSxJQUFJRSxNQUFNLEdBQUdDLENBQUMsR0FBR0osSUFBSSxDQUFDRyxNQUF0Qjs7QUFFQUUsTUFBTSxDQUFDQyxPQUFQLEdBQWlCLFlBQVk7RUFDM0IsSUFBSUMsT0FBSixFQUFhQyxlQUFiLEVBQThCQyxnQkFBOUIsRUFBZ0RDLEVBQWhEOztFQUVBLFNBQVNDLHdCQUFULENBQW1DQyxLQUFuQyxFQUEwQztJQUN4Q0osZUFBZSxHQUFHSSxLQUFLLENBQUNDLHdCQUFOLENBQStCQyxXQUEvQixFQUFsQjtJQUNBUCxPQUFPLEdBQUdLLEtBQUssQ0FBQ0csZUFBTixDQUFzQkMsVUFBdEIsRUFBVjtJQUNBUCxnQkFBZ0IsR0FBR0QsZUFBZSxDQUFDQyxnQkFBbkM7SUFDQUMsRUFBRSxHQUFHRSxLQUFLLENBQUNDLHdCQUFOLENBQStCSSxLQUEvQixFQUFMO0lBRUFDLE1BQU0sR0FOa0MsQ0FReEM7O0lBQ0EsT0FBT1QsZ0JBQVA7RUFDRCxDQWIwQixDQWUzQjs7O0VBQ0EsU0FBU1MsTUFBVCxHQUFtQjtJQUNqQjtJQUNBO0lBRUFULGdCQUFnQixDQUFDVSxPQUFqQixHQUEyQixVQUFVQyxDQUFWLEVBQWFDLENBQWIsRUFBZ0JDLFVBQWhCLEVBQTRCQyxFQUE1QixFQUFnQ0MsTUFBaEMsRUFBd0NDLFVBQXhDLEVBQW9EO01BRTdFLElBQUksUUFBT0gsVUFBUCxLQUFxQixRQUF6QixFQUFrQztRQUNoQyxJQUFJSSxTQUFTLEdBQUdKLFVBQWhCO01BQ0QsQ0FGRCxNQUVPO1FBQ0gsSUFBSUksU0FBUyxHQUFHSixVQUFVLFNBQTFCO1FBQ0EsSUFBSUssUUFBUSxHQUFHTCxVQUFVLENBQUNLLFFBQTFCO01BQ0g7O01BRUQsSUFBSUMsR0FBRyxHQUFHLEVBQVYsQ0FUNkUs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R0FBWXdoQixrQkFBWixHQUFpQ0YsYUFBakM7O1FBQ0EsSUFBRzVELEtBQUssQ0FBQ0MsT0FBTixDQUFjNEQsYUFBZCxDQUFILEVBQWlDO1VBQy9CQSxhQUFhLENBQUNoVixPQUFkO1VBQ0FrQixJQUFJLENBQUN6TixJQUFMLEdBQVl5aEIscUJBQVosR0FBb0NGLGFBQXBDO1FBQ0Q7O1FBQ0QsSUFBSUcsV0FBVyxHQUFHL2lCLEVBQUUsQ0FBQytpQixXQUFILENBQWUsS0FBZixDQUFsQjtRQUNBQSxXQUFXLENBQUNDLGdCQUFaLENBQTZCbFUsSUFBN0I7TUFDRDs7TUFHRCxPQUFPQSxJQUFQO0lBQ0QsQ0E5QkQ7RUFnQ0Q7O0VBRUQsT0FBTzdPLHdCQUFQO0FBQ0QsQ0FydEdEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2hpc2UvLi9zcmMvdXRpbGl0aWVzL2VsZW1lbnQtdXRpbGl0aWVzLWV4dGVuZGVyLWZhY3RvcnkuanM/YmJmYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBFeHRlbmRzIHNiZ252aXouZWxlbWVudFV0aWxpdGllc1xudmFyIGxpYnMgPSByZXF1aXJlKCcuL2xpYi11dGlsaXRpZXMnKS5nZXRMaWJzKCk7XG52YXIgalF1ZXJ5ID0gJCA9IGxpYnMualF1ZXJ5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG9wdGlvbnMsIHNiZ252aXpJbnN0YW5jZSwgZWxlbWVudFV0aWxpdGllcywgY3k7XG5cbiAgZnVuY3Rpb24gZWxlbWVudFV0aWxpdGllc0V4dGVuZGVyIChwYXJhbSkge1xuICAgIHNiZ252aXpJbnN0YW5jZSA9IHBhcmFtLnNiZ252aXpJbnN0YW5jZVV0aWxpdGllcy5nZXRJbnN0YW5jZSgpO1xuICAgIG9wdGlvbnMgPSBwYXJhbS5vcHRpb25VdGlsaXRpZXMuZ2V0T3B0aW9ucygpO1xuICAgIGVsZW1lbnRVdGlsaXRpZXMgPSBzYmdudml6SW5zdGFuY2UuZWxlbWVudFV0aWxpdGllcztcbiAgICBjeSA9IHBhcmFtLnNiZ252aXpJbnN0YW5jZVV0aWxpdGllcy5nZXRDeSgpO1xuXG4gICAgZXh0ZW5kKCk7XG5cbiAgICAvLyBSZXR1cm4gdGhlIGV4dGVuZGVkIGVsZW1lbnRVdGlsaXRpZXNcbiAgICByZXR1cm4gZWxlbWVudFV0aWxpdGllcztcbiAgfVxuXG4gIC8vIEV4dGVuZHMgZWxlbWVudFV0aWxpdGllcyB3aXRoIGNoaXNlIHNwZWNpZmljIGZhY2lsaXRpZXNcbiAgZnVuY3Rpb24gZXh0ZW5kICgpIHtcbiAgICAvLyBTZWN0aW9uIFN0YXJ0XG4gICAgLy8gQWRkIHJlbW92ZSB1dGlsaXRpZXNcblxuICAgIGVsZW1lbnRVdGlsaXRpZXMuYWRkTm9kZSA9IGZ1bmN0aW9uICh4LCB5LCBub2RlUGFyYW1zLCBpZCwgcGFyZW50LCB2aXNpYmlsaXR5KSB7XG4gICBcbiAgICAgIGlmICh0eXBlb2Ygbm9kZVBhcmFtcyAhPSAnb2JqZWN0Jyl7XG4gICAgICAgIHZhciBzYmduY2xhc3MgPSBub2RlUGFyYW1zO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgc2JnbmNsYXNzID0gbm9kZVBhcmFtcy5jbGFzcztcbiAgICAgICAgICB2YXIgbGFuZ3VhZ2UgPSBub2RlUGFyYW1zLmxhbmd1YWdlO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3NzID0ge307XG4gICAgICAvLygnc2JnbmNsYXNzJywgc2JnbmNsYXNzKVxuICAgICAgLy8gaWYgdGhlcmUgaXMgbm8gc3BlY2lmaWMgZGVmYXVsdCB3aWR0aCBvciBoZWlnaHQgZm9yXG4gICAgICAvLyBzYmduY2xhc3MgdGhlc2Ugc2l6ZXMgYXJlIHVzZWRcbiAgICAgIHZhciBkZWZhdWx0V2lkdGggPSA1MDtcbiAgICAgIHZhciBkZWZhdWx0SGVpZ2h0ID0gNTA7XG4gICAgXG5cbiAgICAgIGlmICh2aXNpYmlsaXR5KSB7XG4gICAgICAgIGNzcy52aXNpYmlsaXR5ID0gdmlzaWJpbGl0eTtcbiAgICAgIH1cblxuICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgIGNsYXNzOiBzYmduY2xhc3MsXG4gICAgXHQgIGxhbmd1YWdlOiBsYW5ndWFnZSxcbiAgICAgICAgYmJveDoge1xuICAgICAgICAgIHc6IGRlZmF1bHRXaWR0aCxcbiAgICAgICAgICBoOiBkZWZhdWx0SGVpZ2h0LFxuICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgeTogeVxuICAgICAgICB9LFxuICAgICAgICBzdGF0ZXNhbmRpbmZvczogW10sXG4gICAgICAgIHBvcnRzOiBbXVxuICAgICAgfTtcblxuICAgICAgLy9jb25zb2xlLmxvZyhcImRhdGFcIiwgZGF0YSlcbiAgICAgIGlmKGlkKSB7XG4gICAgICAgIGRhdGEuaWQgPSBpZDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBkYXRhLmlkID0gZWxlbWVudFV0aWxpdGllcy5nZW5lcmF0ZU5vZGVJZCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIGRhdGEucGFyZW50ID0gcGFyZW50O1xuICAgICAgfVxuXG4gICAgICB0aGlzLmV4dGVuZE5vZGVEYXRhV2l0aENsYXNzRGVmYXVsdHMoIGRhdGEsIHNiZ25jbGFzcyApO1xuXG4gICAgICAvLyBzb21lIGRlZmF1bHRzIGFyZSBub3Qgc2V0IGJ5IGV4dGVuZE5vZGVEYXRhV2l0aENsYXNzRGVmYXVsdHMoKVxuICAgICAgLy9jb25zb2xlLmxvZyhcInNiZ25jbGFzc1wiLCBzYmduY2xhc3MpXG4gICAgICB2YXIgZGVmYXVsdHMgPSB0aGlzLmdldERlZmF1bHRQcm9wZXJ0aWVzKCBzYmduY2xhc3MgKTtcblxuICAgICAgaWYgKCBkZWZhdWx0c1sgJ211bHRpbWVyJyBdICkge1xuICAgICAgICBkYXRhLmNsYXNzICs9ICcgbXVsdGltZXInO1xuICAgICAgfVxuXG4gICAgICBpZiAoIGRlZmF1bHRzWyAnY2xvbmVtYXJrZXInIF0gKSB7XG4gICAgICAgIGRhdGFbICdjbG9uZW1hcmtlcicgXSA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoIGRlZmF1bHRzWyAnYWN0aXZlJyBdICkge1xuICAgICAgICBkYXRhLmNsYXNzID0gJ2FjdGl2ZSAnKyBkYXRhLmNsYXNzO1xuICAgICAgfVxuXG4gICAgICBpZiAoIGRlZmF1bHRzWyAnaHlwb3RoZXRpY2FsJyBdICkge1xuICAgICAgICBkYXRhLmNsYXNzID0gJ2h5cG90aGV0aWNhbCAnKyBkYXRhLmNsYXNzO1xuICAgICAgfVxuXG4gICAgICBkYXRhLmJib3hbICd3JyBdID0gZGVmYXVsdHNbICd3aWR0aCcgXTtcbiAgICAgIGRhdGEuYmJveFsgJ2gnIF0gPSBkZWZhdWx0c1sgJ2hlaWdodCcgXTtcblxuICAgICAgLy9jb25zb2xlLmxvZyhcImRhdGFcIiwgZGF0YSlcbiAgICAgIHZhciBlbGVzID0gY3kuYWRkKHtcbiAgICAgICAgZ3JvdXA6IFwibm9kZXNcIixcbiAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgY3NzOiBjc3MsXG4gICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgeDogeCxcbiAgICAgICAgICB5OiB5XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvL2NvbnNvbGUubG9nKCdlbGVzJywgZWxlcylcblxuICAgICAgdmFyIG5ld05vZGUgPSBlbGVzW2VsZXMubGVuZ3RoIC0gMV07XG4gICAgICAvLyBHZXQgdGhlIGRlZmF1bHQgcG9ydHMgb3JkZXJpbmcgZm9yIHRoZSBub2RlcyB3aXRoIGdpdmVuIHNiZ25jbGFzc1xuICAgICAgdmFyIG9yZGVyaW5nID0gZGVmYXVsdHNbJ3BvcnRzLW9yZGVyaW5nJ107XG5cbiAgICAgIC8vIElmIHRoZXJlIGlzIGEgZGVmYXVsdCBwb3J0cyBvcmRlcmluZyBmb3IgdGhlIG5vZGVzIHdpdGggZ2l2ZW4gc2JnbmNsYXNzIGFuZCBpdCBpcyBkaWZmZXJlbnQgdGhhbiAnbm9uZScgc2V0IHRoZSBwb3J0cyBvcmRlcmluZyB0byB0aGF0IG9yZGVyaW5nXG4gICAgICBpZiAob3JkZXJpbmcgJiYgb3JkZXJpbmcgIT09ICdub25lJykge1xuICAgICAgICB0aGlzLnNldFBvcnRzT3JkZXJpbmcobmV3Tm9kZSwgb3JkZXJpbmcpO1xuICAgICAgfVxuXG4gICAgICBpZiAobGFuZ3VhZ2UgPT0gXCJBRlwiICYmICFlbGVtZW50VXRpbGl0aWVzLmNhbkhhdmVNdWx0aXBsZVVuaXRPZkluZm9ybWF0aW9uKG5ld05vZGUpKXtcbiAgICAgICAgaWYgKHNiZ25jbGFzcyAhPSBcIkJBIHBsYWluXCIpIHsgLy8gaWYgQUYgbm9kZSBjYW4gaGF2ZSBsYWJlbCBpLmU6IG5vdCBwbGFpbiBiaW9sb2dpY2FsIGFjdGl2aXR5XG4gICAgICAgICAgdmFyIHVvaV9vYmogPSB7XG4gICAgICAgICAgICBjbGF6ejogXCJ1bml0IG9mIGluZm9ybWF0aW9uXCJcbiAgICAgICAgICB9O1xuICAgICAgICAgIHVvaV9vYmoubGFiZWwgPSB7XG4gICAgICAgICAgICB0ZXh0OiBcIlwiXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHVvaV9vYmouYmJveCA9IHtcbiAgICAgICAgICAgICB3OiAxMixcbiAgICAgICAgICAgICBoOiAxMlxuICAgICAgICAgIH07XG4gICAgICAgICAgZWxlbWVudFV0aWxpdGllcy5hZGRTdGF0ZU9ySW5mb0JveChuZXdOb2RlLCB1b2lfb2JqKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBub2RlIGJnIGltYWdlIHdhcyB1bmV4cGVjdGVkbHkgbm90IHJlbmRlcmVkIHVudGlsIGl0IGlzIGNsaWNrZWRcbiAgICAgIC8vIHVzZSB0aGlzIGRpcnR5IGhhY2sgdW50aWwgZmluZGluZyBhIHNvbHV0aW9uIHRvIHRoZSBwcm9ibGVtXG4gICAgICB2YXIgYmdJbWFnZSA9IG5ld05vZGUuZGF0YSgnYmFja2dyb3VuZC1pbWFnZScpO1xuICAgICAgLy9hbGVydCgnYmdJbWFnZScsIGJnSW1hZ2UpXG4gICAgICBpZiAoIGJnSW1hZ2UgKSB7XG4gICAgICAgIG5ld05vZGUuZGF0YSggJ2JhY2tncm91bmQtaW1hZ2UnLCBiZ0ltYWdlICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXdOb2RlO1xuICAgIH07XG5cbiAgICAvL1NhdmVzIG9sZCBhdXggdW5pdHMgb2YgZ2l2ZW4gbm9kZVxuICAgIGVsZW1lbnRVdGlsaXRpZXMuc2F2ZVVuaXRzID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgdmFyIHRlbXBEYXRhID0gW107XG4gICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgbm9kZS5kYXRhKCdzdGF0ZXNhbmRpbmZvcycpLmZvckVhY2goIGZ1bmN0aW9uKGVsZSkge1xuICAgICAgICB0ZW1wRGF0YS5wdXNoKHtcbiAgICAgICAgICB4OiBlbGUuYmJveC54LFxuICAgICAgICAgIHk6IGVsZS5iYm94LnksXG4gICAgICAgICAgYW5jaG9yU2lkZTogZWxlLmFuY2hvclNpZGUsXG4gICAgICAgIH0pO1xuICAgICAgICBpbmRleCsrO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGVtcERhdGE7XG4gICAgfTtcblxuICAgIC8vUmVzdG9yZXMgZnJvbSBnaXZlbiBkYXRhXG4gICAgZWxlbWVudFV0aWxpdGllcy5yZXN0b3JlVW5pdHMgPSBmdW5jdGlvbihub2RlLCBkYXRhKSB7XG4gICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgbm9kZS5kYXRhKCdzdGF0ZXNhbmRpbmZvcycpLmZvckVhY2goIGZ1bmN0aW9uKGVsZSkge1xuICAgICAgICBpZiAoZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZWxlLmJib3gueCA9IGRhdGFbaW5kZXhdLng7XG4gICAgICAgICAgZWxlLmJib3gueSA9IGRhdGFbaW5kZXhdLnlcbiAgICAgICAgICB2YXIgYW5jaG9yU2lkZSA9IGVsZS5hbmNob3JTaWRlO1xuICAgICAgICAgIGVsZS5hbmNob3JTaWRlID0gZGF0YVtpbmRleF0uYW5jaG9yU2lkZTtcbiAgICAgICAgICBlbGVtZW50VXRpbGl0aWVzLm1vZGlmeVVuaXRzKG5vZGUsIGVsZSwgYW5jaG9yU2lkZSk7XG4gICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vTW9kaWZ5IGF1eCB1bml0IGxheW91dHNcbiAgICBlbGVtZW50VXRpbGl0aWVzLm1vZGlmeVVuaXRzID0gZnVuY3Rpb24gKG5vZGUsIGVsZSwgYW5jaG9yU2lkZSkge1xuICAgICAgY29uc29sZS5sb2coXCJlbGVtZW50VXRpbGl0aWVzLm1vZGlmeVVuaXRzXCIsIG5vZGUpXG4gICAgICBpbnN0YW5jZS5jbGFzc2VzLkF1eFVuaXRMYXlvdXQubW9kaWZ5VW5pdHMobm9kZSwgZWxlLCBhbmNob3JTaWRlLCBjeSk7XG4gICAgfTtcblxuXG4gICAgLy9Gb3IgcmV2ZXJzaWJsZSByZWFjdGlvbnMgYm90aCBzaWRlIG9mIHRoZSBwcm9jZXNzIGNhbiBiZSBpbnB1dC9vdXRwdXRcbiAgICAvL0dyb3VwIElEIGlkZW50aWZpZXMgdG8gd2hpY2ggZ3JvdXAgb2Ygbm9kZXMgdGhlIGVkZ2UgaXMgZ29pbmcgdG8gYmUgY29ubmVjdGVkIGZvciByZXZlcnNpYmxlIHJlYWN0aW9ucygwOiBncm91cCAxIElEIGFuZCAxOmdyb3VwIDIgSUQpXG4gICAgZWxlbWVudFV0aWxpdGllcy5hZGRFZGdlID0gZnVuY3Rpb24gKHNvdXJjZSwgdGFyZ2V0LCBlZGdlUGFyYW1zLCBpZCwgdmlzaWJpbGl0eSwgZ3JvdXBJRCApIHtcbiAgICAgIGlmICh0eXBlb2YgZWRnZVBhcmFtcyAhPSAnb2JqZWN0Jyl7XG4gICAgICAgIHZhciBzYmduY2xhc3MgPSBlZGdlUGFyYW1zO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgc2JnbmNsYXNzID0gZWRnZVBhcmFtcy5jbGFzcztcbiAgICAgICAgICB2YXIgbGFuZ3VhZ2UgPSBlZGdlUGFyYW1zLmxhbmd1YWdlO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3NzID0ge307XG5cbiAgICAgIGlmICh2aXNpYmlsaXR5KSB7XG4gICAgICAgIGNzcy52aXNpYmlsaXR5ID0gdmlzaWJpbGl0eTtcbiAgICAgIH1cblxuICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICAgICAgY2xhc3M6IHNiZ25jbGFzcyxcbiAgICAgICAgICBsYW5ndWFnZTogbGFuZ3VhZ2UsXG4gICAgICB9O1xuXG4gICAgICB2YXIgZGVmYXVsdHMgPSBlbGVtZW50VXRpbGl0aWVzLmdldERlZmF1bHRQcm9wZXJ0aWVzKCBzYmduY2xhc3MgKTtcblxuICAgICAgLy8gZXh0ZW5kIHRoZSBkYXRhIHdpdGggZGVmYXVsdCBwcm9wZXJ0aWVzIG9mIGVkZ2Ugc3R5bGVcbiAgICAgIE9iamVjdC5rZXlzKCBkZWZhdWx0cyApLmZvckVhY2goIGZ1bmN0aW9uKCBwcm9wICkge1xuICAgICAgICBkYXRhWyBwcm9wIF0gPSBkZWZhdWx0c1sgcHJvcCBdO1xuICAgICAgfSApO1xuXG4gICAgICBpZihpZCkge1xuICAgICAgICBkYXRhLmlkID0gaWQ7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZGF0YS5pZCA9IGVsZW1lbnRVdGlsaXRpZXMuZ2VuZXJhdGVFZGdlSWQoKTtcbiAgICAgIH1cblxuICAgICAgaWYoZWxlbWVudFV0aWxpdGllcy5jYW5IYXZlU0JHTkNhcmRpbmFsaXR5KHNiZ25jbGFzcykpe1xuICAgICAgICBkYXRhLmNhcmRpbmFsaXR5ID0gMDtcbiAgICAgIH1cblxuICAgICAgdmFyIHNvdXJjZU5vZGUgPSBjeS5nZXRFbGVtZW50QnlJZChzb3VyY2UpOyAvLyBUaGUgb3JpZ2luYWwgc291cmNlIG5vZGVcbiAgICAgIHZhciB0YXJnZXROb2RlID0gY3kuZ2V0RWxlbWVudEJ5SWQodGFyZ2V0KTsgLy8gVGhlIG9yaWdpbmFsIHRhcmdldCBub2RlXG4gICAgICB2YXIgc291cmNlSGFzUG9ydHMgPSBzb3VyY2VOb2RlLmRhdGEoJ3BvcnRzJykubGVuZ3RoID09PSAyO1xuICAgICAgdmFyIHRhcmdldEhhc1BvcnRzID0gdGFyZ2V0Tm9kZS5kYXRhKCdwb3J0cycpLmxlbmd0aCA9PT0gMjtcbiAgICAgIC8vIFRoZSBwb3J0c291cmNlIGFuZCBwb3J0dGFyZ2V0IHZhcmlhYmxlc1xuICAgICAgdmFyIHBvcnRzb3VyY2U7XG4gICAgICB2YXIgcG9ydHRhcmdldDtcblxuICAgICAgLypcbiAgICAgICAqIEdldCBpbnB1dC9vdXRwdXQgcG9ydCBpZCdzIG9mIGEgbm9kZSB3aXRoIHRoZSBhc3N1bXB0aW9uIHRoYXQgdGhlIG5vZGUgaGFzIHZhbGlkIHBvcnRzLlxuICAgICAgICovXG4gICAgICB2YXIgZ2V0SU9Qb3J0SWRzID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIG5vZGVJbnB1dFBvcnRJZCwgbm9kZU91dHB1dFBvcnRJZDtcbiAgICAgICAgdmFyIG5vZGVQb3J0c09yZGVyaW5nID0gc2JnbnZpekluc3RhbmNlLmVsZW1lbnRVdGlsaXRpZXMuZ2V0UG9ydHNPcmRlcmluZyhub2RlKTtcbiAgICAgICAgdmFyIG5vZGVQb3J0cyA9IG5vZGUuZGF0YSgncG9ydHMnKTtcbiAgICAgICAgaWYgKCBub2RlUG9ydHNPcmRlcmluZyA9PT0gJ0wtdG8tUicgfHwgbm9kZVBvcnRzT3JkZXJpbmcgPT09ICdSLXRvLUwnICkge1xuICAgICAgICAgIHZhciBsZWZ0UG9ydElkID0gbm9kZVBvcnRzWzBdLnggPCAwID8gbm9kZVBvcnRzWzBdLmlkIDogbm9kZVBvcnRzWzFdLmlkOyAvLyBUaGUgeCB2YWx1ZSBvZiBsZWZ0IHBvcnQgaXMgc3VwcG9zZWQgdG8gYmUgbmVnYXRpdmVcbiAgICAgICAgICB2YXIgcmlnaHRQb3J0SWQgPSBub2RlUG9ydHNbMF0ueCA+IDAgPyBub2RlUG9ydHNbMF0uaWQgOiBub2RlUG9ydHNbMV0uaWQ7IC8vIFRoZSB4IHZhbHVlIG9mIHJpZ2h0IHBvcnQgaXMgc3VwcG9zZWQgdG8gYmUgcG9zaXRpdmVcbiAgICAgICAgICAvKlxuICAgICAgICAgICAqIElmIHRoZSBwb3J0IG9yZGVyaW5nIGlzIGxlZnQgdG8gcmlnaHQgdGhlbiB0aGUgaW5wdXQgcG9ydCBpcyB0aGUgbGVmdCBwb3J0IGFuZCB0aGUgb3V0cHV0IHBvcnQgaXMgdGhlIHJpZ2h0IHBvcnQuXG4gICAgICAgICAgICogRWxzZSBpZiBpdCBpcyByaWdodCB0byBsZWZ0IGl0IGlzIHZpY2UgdmVyc2FcbiAgICAgICAgICAgKi9cbiAgICAgICAgICBub2RlSW5wdXRQb3J0SWQgPSBub2RlUG9ydHNPcmRlcmluZyA9PT0gJ0wtdG8tUicgPyBsZWZ0UG9ydElkIDogcmlnaHRQb3J0SWQ7XG4gICAgICAgICAgbm9kZU91dHB1dFBvcnRJZCA9IG5vZGVQb3J0c09yZGVyaW5nID09PSAnUi10by1MJyA/IGxlZnRQb3J0SWQgOiByaWdodFBvcnRJZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICggbm9kZVBvcnRzT3JkZXJpbmcgPT09ICdULXRvLUInIHx8IG5vZGVQb3J0c09yZGVyaW5nID09PSAnQi10by1UJyApe1xuICAgICAgICAgIHZhciB0b3BQb3J0SWQgPSBub2RlUG9ydHNbMF0ueSA8IDAgPyBub2RlUG9ydHNbMF0uaWQgOiBub2RlUG9ydHNbMV0uaWQ7IC8vIFRoZSB5IHZhbHVlIG9mIHRvcCBwb3J0IGlzIHN1cHBvc2VkIHRvIGJlIG5lZ2F0aXZlXG4gICAgICAgICAgdmFyIGJvdHRvbVBvcnRJZCA9IG5vZGVQb3J0c1swXS55ID4gMCA/IG5vZGVQb3J0c1swXS5pZCA6IG5vZGVQb3J0c1sxXS5pZDsgLy8gVGhlIHkgdmFsdWUgb2YgYm90dG9tIHBvcnQgaXMgc3VwcG9zZWQgdG8gYmUgcG9zaXRpdmVcbiAgICAgICAgICAvKlxuICAgICAgICAgICAqIElmIHRoZSBwb3J0IG9yZGVyaW5nIGlzIHRvcCB0byBib3R0b20gdGhlbiB0aGUgaW5wdXQgcG9ydCBpcyB0aGUgdG9wIHBvcnQgYW5kIHRoZSBvdXRwdXQgcG9ydCBpcyB0aGUgYm90dG9tIHBvcnQuXG4gICAgICAgICAgICogRWxzZSBpZiBpdCBpcyByaWdodCB0byBsZWZ0IGl0IGlzIHZpY2UgdmVyc2FcbiAgICAgICAgICAgKi9cbiAgICAgICAgICBub2RlSW5wdXRQb3J0SWQgPSBub2RlUG9ydHNPcmRlcmluZyA9PT0gJ1QtdG8tQicgPyB0b3BQb3J0SWQgOiBib3R0b21Qb3J0SWQ7XG4gICAgICAgICAgbm9kZU91dHB1dFBvcnRJZCA9IG5vZGVQb3J0c09yZGVyaW5nID09PSAnQi10by1UJyA/IHRvcFBvcnRJZCA6IGJvdHRvbVBvcnRJZDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJldHVybiBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgSU8gcG9ydHMgb2YgdGhlIG5vZGVcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpbnB1dFBvcnRJZDogbm9kZUlucHV0UG9ydElkLFxuICAgICAgICAgIG91dHB1dFBvcnRJZDogbm9kZU91dHB1dFBvcnRJZFxuICAgICAgICB9O1xuICAgICAgfTtcblxuICAgICAgLy8gSWYgYXQgbGVhc3Qgb25lIGVuZCBvZiB0aGUgZWRnZSBoYXMgcG9ydHMgdGhlbiB3ZSBzaG91bGQgZGV0ZXJtaW5lIHRoZSBwb3J0cyB3aGVyZSB0aGUgZWRnZSBzaG91bGQgYmUgY29ubmVjdGVkLlxuICAgICAgaWYgKHNvdXJjZUhhc1BvcnRzIHx8IHRhcmdldEhhc1BvcnRzKSB7XG4gICAgICAgIHZhciBzb3VyY2VOb2RlSW5wdXRQb3J0SWQsIHNvdXJjZU5vZGVPdXRwdXRQb3J0SWQsIHRhcmdldE5vZGVJbnB1dFBvcnRJZCwgdGFyZ2V0Tm9kZU91dHB1dFBvcnRJZDtcblxuICAgICAgICAvLyBJZiBzb3VyY2Ugbm9kZSBoYXMgcG9ydHMgc2V0IHRoZSB2YXJpYWJsZXMgZGVkaWNhdGVkIGZvciBpdHMgSU8gcG9ydHNcbiAgICAgICAgaWYgKCBzb3VyY2VIYXNQb3J0cyApIHtcbiAgICAgICAgICB2YXIgaW9Qb3J0cyA9IGdldElPUG9ydElkcyhzb3VyY2VOb2RlKTtcbiAgICAgICAgICBzb3VyY2VOb2RlSW5wdXRQb3J0SWQgPSBpb1BvcnRzLmlucHV0UG9ydElkO1xuICAgICAgICAgIHNvdXJjZU5vZGVPdXRwdXRQb3J0SWQgPSBpb1BvcnRzLm91dHB1dFBvcnRJZDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRhcmdldCBub2RlIGhhcyBwb3J0cyBzZXQgdGhlIHZhcmlhYmxlcyBkZWRpY2F0ZWQgZm9yIGl0cyBJTyBwb3J0c1xuICAgICAgICBpZiAoIHRhcmdldEhhc1BvcnRzICkge1xuICAgICAgICAgIHZhciBpb1BvcnRzID0gZ2V0SU9Qb3J0SWRzKHRhcmdldE5vZGUpO1xuICAgICAgICAgIHRhcmdldE5vZGVJbnB1dFBvcnRJZCA9IGlvUG9ydHMuaW5wdXRQb3J0SWQ7XG4gICAgICAgICAgdGFyZ2V0Tm9kZU91dHB1dFBvcnRJZCA9IGlvUG9ydHMub3V0cHV0UG9ydElkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNiZ25jbGFzcyA9PT0gJ2NvbnN1bXB0aW9uJykge1xuICAgICAgICAgIC8vIEEgY29uc3VtcHRpb24gZWRnZSBzaG91bGQgYmUgY29ubmVjdGVkIHRvIHRoZSBpbnB1dCBwb3J0IG9mIHRoZSB0YXJnZXQgbm9kZSB3aGljaCBpcyBzdXBwb3NlZCB0byBiZSBhIHByb2Nlc3MgKGFueSBraW5kIG9mKVxuICAgICAgICAgIHBvcnRzb3VyY2UgPSBzb3VyY2VOb2RlT3V0cHV0UG9ydElkO1xuICAgICAgICAgIHBvcnR0YXJnZXQgPSB0YXJnZXROb2RlSW5wdXRQb3J0SWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2JnbmNsYXNzID09PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAvLyBBIHByb2R1Y3Rpb24gZWRnZSBzaG91bGQgYmUgY29ubmVjdGVkIHRvIHRoZSBvdXRwdXQgcG9ydCBvZiB0aGUgc291cmNlIG5vZGUgd2hpY2ggaXMgc3VwcG9zZWQgdG8gYmUgYSBwcm9jZXNzIChhbnkga2luZCBvZilcbiAgICAgICAgICAvLyBBIG1vZHVsYXRpb24gZWRnZSBtYXkgaGF2ZSBhIGxvZ2ljYWwgb3BlcmF0b3IgYXMgc291cmNlIG5vZGUgaW4gdGhpcyBjYXNlIHRoZSBlZGdlIHNob3VsZCBiZSBjb25uZWN0ZWQgdG8gdGhlIG91dHB1dCBwb3J0IG9mIGl0XG4gICAgICAgICAgLy8gVGhlIGJlbG93IGFzc2lnbm1lbnQgc2F0aXNmeSBhbGwgb2YgdGhlc2UgY29uZGl0aW9uXG4gICAgICAgICAgaWYoZ3JvdXBJRCA9PSAwIHx8IGdyb3VwSUQgPT0gdW5kZWZpbmVkKSB7IC8vIGdyb3VwSUQgMCBmb3IgcmV2ZXJzaWJsZSByZWFjdGlvbnMgZ3JvdXAgMFxuICAgICAgICAgICAgcG9ydHNvdXJjZSA9IHNvdXJjZU5vZGVPdXRwdXRQb3J0SWQ7XG4gICAgICAgICAgICBwb3J0dGFyZ2V0ID0gdGFyZ2V0Tm9kZUlucHV0UG9ydElkO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHsgLy9pZiByZWFjdGlvbiBpcyByZXZlcnNpYmxlIGFuZCBlZGdlIGJlbG9uZ3MgdG8gZ3JvdXAgMVxuICAgICAgICAgICAgcG9ydHNvdXJjZSA9IHNvdXJjZU5vZGVJbnB1dFBvcnRJZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZihlbGVtZW50VXRpbGl0aWVzLmlzTW9kdWxhdGlvbkFyY0NsYXNzKHNiZ25jbGFzcykgfHwgZWxlbWVudFV0aWxpdGllcy5pc0FGQXJjQ2xhc3Moc2JnbmNsYXNzKSl7XG4gICAgICAgICAgcG9ydHNvdXJjZSA9IHNvdXJjZU5vZGVPdXRwdXRQb3J0SWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2JnbmNsYXNzID09PSAnbG9naWMgYXJjJykge1xuICAgICAgICAgIHZhciBzcmNDbGFzcyA9IHNvdXJjZU5vZGUuZGF0YSgnY2xhc3MnKTtcbiAgICAgICAgICB2YXIgdGd0Q2xhc3MgPSB0YXJnZXROb2RlLmRhdGEoJ2NsYXNzJyk7XG4gICAgICAgICAgdmFyIGlzU291cmNlTG9naWNhbE9wID0gc3JjQ2xhc3MgPT09ICdhbmQnIHx8IHNyY0NsYXNzID09PSAnb3InIHx8IHNyY0NsYXNzID09PSAnbm90JztcbiAgICAgICAgICB2YXIgaXNUYXJnZXRMb2dpY2FsT3AgPSB0Z3RDbGFzcyA9PT0gJ2FuZCcgfHwgdGd0Q2xhc3MgPT09ICdvcicgfHwgdGd0Q2xhc3MgPT09ICdub3QnO1xuXG4gICAgICAgICAgaWYgKGlzU291cmNlTG9naWNhbE9wICYmIGlzVGFyZ2V0TG9naWNhbE9wKSB7XG4gICAgICAgICAgICAvLyBJZiBib3RoIGVuZCBhcmUgbG9naWNhbCBvcGVyYXRvcnMgdGhlbiB0aGUgZWRnZSBzaG91bGQgYmUgY29ubmVjdGVkIHRvIHRoZSBpbnB1dCBwb3J0IG9mIHRoZSB0YXJnZXQgYW5kIHRoZSBvdXRwdXQgcG9ydCBvZiB0aGUgaW5wdXRcbiAgICAgICAgICAgIHBvcnR0YXJnZXQgPSB0YXJnZXROb2RlSW5wdXRQb3J0SWQ7XG4gICAgICAgICAgICBwb3J0c291cmNlID0gc291cmNlTm9kZU91dHB1dFBvcnRJZDtcbiAgICAgICAgICB9Ly8gSWYganVzdCBvbmUgZW5kIG9mIGxvZ2ljYWwgb3BlcmF0b3IgdGhlbiB0aGUgZWRnZSBzaG91bGQgYmUgY29ubmVjdGVkIHRvIHRoZSBpbnB1dCBwb3J0IG9mIHRoZSBsb2dpY2FsIG9wZXJhdG9yXG4gICAgICAgICAgZWxzZSBpZiAoaXNTb3VyY2VMb2dpY2FsT3ApIHtcbiAgICAgICAgICAgIHBvcnRzb3VyY2UgPSBzb3VyY2VOb2RlSW5wdXRQb3J0SWQ7XG4gICAgICAgICAgICBwb3J0dGFyZ2V0ID0gdGFyZ2V0Tm9kZU91dHB1dFBvcnRJZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoaXNUYXJnZXRMb2dpY2FsT3ApIHtcbiAgICAgICAgICAgIHBvcnRzb3VyY2UgPSBzb3VyY2VOb2RlT3V0cHV0UG9ydElkO1xuICAgICAgICAgICAgcG9ydHRhcmdldCA9IHRhcmdldE5vZGVJbnB1dFBvcnRJZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGRlZmF1bHQgcG9ydHNvdXJjZS9wb3J0dGFyZ2V0IGFyZSB0aGUgc291cmNlL3RhcmdldCB0aGVtc2VsdmVzLiBJZiB0aGV5IGFyZSBub3Qgc2V0IHVzZSB0aGVzZSBkZWZhdWx0cy5cbiAgICAgIC8vIFRoZSBwb3J0c291cmNlIGFuZCBwb3J0dGFyZ2V0IGFyZSBkZXRlcm1pbmVkIHNldCB0aGVtIGluIGRhdGEgb2JqZWN0LlxuICAgICAgZGF0YS5wb3J0c291cmNlID0gcG9ydHNvdXJjZSB8fCBzb3VyY2U7XG4gICAgICBkYXRhLnBvcnR0YXJnZXQgPSBwb3J0dGFyZ2V0IHx8IHRhcmdldDtcblxuICAgICAgdmFyIGVsZXMgPSBjeS5hZGQoe1xuICAgICAgICBncm91cDogXCJlZGdlc1wiLFxuICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICBjc3M6IGNzc1xuICAgICAgfSk7XG5cbiAgICAgIHZhciBuZXdFZGdlID0gZWxlc1tlbGVzLmxlbmd0aCAtIDFdO1xuXG4gICAgICByZXR1cm4gbmV3RWRnZTtcbiAgICB9O1xuXG4gICAgZWxlbWVudFV0aWxpdGllcy5hZGRQcm9jZXNzV2l0aENvbnZlbmllbnRFZGdlcyA9IGZ1bmN0aW9uKF9zb3VyY2UsIF90YXJnZXQsIG5vZGVQYXJhbXMpIHtcbiAgICAgIC8vIElmIHNvdXJjZSBhbmQgdGFyZ2V0IElEcyBhcmUgZ2l2ZW4gZ2V0IHRoZSBlbGVtZW50cyBieSBJRHNcbiAgICAgIHZhciBzb3VyY2UgPSB0eXBlb2YgX3NvdXJjZSA9PT0gJ3N0cmluZycgPyBjeS5nZXRFbGVtZW50QnlJZChfc291cmNlKSA6IF9zb3VyY2U7XG4gICAgICB2YXIgdGFyZ2V0ID0gdHlwZW9mIF90YXJnZXQgPT09ICdzdHJpbmcnID8gY3kuZ2V0RWxlbWVudEJ5SWQoX3RhcmdldCkgOiBfdGFyZ2V0O1xuXG4gICAgICAvLyBQcm9jZXNzIHBhcmVudCBzaG91bGQgYmUgdGhlIGNsb3Nlc3QgY29tbW9uIGFuY2VzdG9yIG9mIHRoZSBzb3VyY2UgYW5kIHRhcmdldCBub2Rlc1xuICAgICAgdmFyIHByb2Nlc3NQYXJlbnQgPSBjeS5jb2xsZWN0aW9uKFtzb3VyY2VbMF0sIHRhcmdldFswXV0pLmNvbW1vbkFuY2VzdG9ycygpLmZpcnN0KCk7XG5cbiAgICAgIC8vIFByb2Nlc3Mgc2hvdWxkIGJlIGF0IHRoZSBtaWRkbGUgb2YgdGhlIHNvdXJjZSBhbmQgdGFyZ2V0IG5vZGVzXG4gICAgICB2YXIgeCA9ICggc291cmNlLnBvc2l0aW9uKCd4JykgKyB0YXJnZXQucG9zaXRpb24oJ3gnKSApIC8gMjtcbiAgICAgIHZhciB5ID0gKCBzb3VyY2UucG9zaXRpb24oJ3knKSArIHRhcmdldC5wb3NpdGlvbigneScpICkgLyAyO1xuXG4gICAgICAvLyBDcmVhdGUgdGhlIHByb2Nlc3Mgd2l0aCBnaXZlbi9jYWxjdWxhdGVkIHZhcmlhYmxlc1xuICAgICAgdmFyIHByb2Nlc3MgPSBlbGVtZW50VXRpbGl0aWVzLmFkZE5vZGUoeCwgeSwgbm9kZVBhcmFtcywgdW5kZWZpbmVkLCBwcm9jZXNzUGFyZW50LmlkKCkpO1xuICAgICAgICB2YXIgeGRpZmYgPSBzb3VyY2UucG9zaXRpb24oJ3gnKSAtIHRhcmdldC5wb3NpdGlvbigneCcpO1xuICAgICAgICB2YXIgeWRpZmYgPSBzb3VyY2UucG9zaXRpb24oJ3knKSAtIHRhcmdldC5wb3NpdGlvbigneScpXG4gICAgICAgIGlmIChNYXRoLmFicyh4ZGlmZikgPj0gTWF0aC5hYnMoeWRpZmYpKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoeGRpZmYgPCAwKVxuICAgICAgICAgICAgICAgIGVsZW1lbnRVdGlsaXRpZXMuc2V0UG9ydHNPcmRlcmluZyhwcm9jZXNzLCAnTC10by1SJyk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZWxlbWVudFV0aWxpdGllcy5zZXRQb3J0c09yZGVyaW5nKHByb2Nlc3MsICdSLXRvLUwnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh5ZGlmZiA8IDApXG4gICAgICAgICAgICAgICAgZWxlbWVudFV0aWxpdGllcy5zZXRQb3J0c09yZGVyaW5nKHByb2Nlc3MsICdULXRvLUInKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBlbGVtZW50VXRpbGl0aWVzLnNldFBvcnRzT3JkZXJpbmcocHJvY2VzcywgJ0ItdG8tVCcpO1xuICAgICAgICB9XG5cblxuICAgICAgLy8gQ3JlYXRlIHRoZSBlZGdlcyBvbmUgaXMgYmV0d2VlbiB0aGUgcHJvY2VzcyBhbmQgdGhlIHNvdXJjZSBub2RlICh3aGljaCBzaG91bGQgYmUgYSBjb25zdW1wdGlvbiksXG4gICAgICAvLyB0aGUgb3RoZXIgb25lIGlzIGJldHdlZW4gdGhlIHByb2Nlc3MgYW5kIHRoZSB0YXJnZXQgbm9kZSAod2hpY2ggc2hvdWxkIGJlIGEgcHJvZHVjdGlvbikuXG4gICAgICAvLyBGb3IgbW9yZSBpbmZvcm1hdGlvbiBwbGVhc2UgcmVmZXIgdG8gU0JHTi1QRCByZWZlcmVuY2UgY2FyZC5cbiAgICAgIHZhciBlZGdlQnR3U3JjID0gZWxlbWVudFV0aWxpdGllcy5hZGRFZGdlKHNvdXJjZS5pZCgpLCBwcm9jZXNzLmlkKCksIHtjbGFzcyA6ICdjb25zdW1wdGlvbicsIGxhbmd1YWdlIDogbm9kZVBhcmFtcy5sYW5ndWFnZX0pO1xuICAgICAgdmFyIGVkZ2VCdHdUZ3QgPSBlbGVtZW50VXRpbGl0aWVzLmFkZEVkZ2UocHJvY2Vzcy5pZCgpLCB0YXJnZXQuaWQoKSwge2NsYXNzIDogJ3Byb2R1Y3Rpb24nLCBsYW5ndWFnZSA6IG5vZGVQYXJhbXMubGFuZ3VhZ2V9KTtcblxuICAgICAgLy8gQ3JlYXRlIGEgY29sbGVjdGlvbiBpbmNsdWRpbmcgdGhlIGVsZW1lbnRzIGFuZCB0byBiZSByZXR1cm5lZFxuICAgICAgdmFyIGNvbGxlY3Rpb24gPSBjeS5jb2xsZWN0aW9uKFtwcm9jZXNzWzBdLCBlZGdlQnR3U3JjWzBdLCBlZGdlQnR3VGd0WzBdXSk7XG4gICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICB9O1xuXG4gICAgLypcbiAgICAgKiBUaGlzIG1ldGhvZCBhc3N1bWVzIHRoYXQgcGFyYW0ubm9kZXNUb01ha2VDb21wb3VuZCBjb250YWlucyBhdCBsZWFzdCBvbmUgbm9kZVxuICAgICAqIGFuZCBhbGwgb2YgdGhlIG5vZGVzIGluY2x1ZGluZyBpbiBpdCBoYXZlIHRoZSBzYW1lIHBhcmVudC4gSXQgY3JlYXRlcyBhIGNvbXBvdW5kIGZvdCB0aGUgZ2l2ZW4gbm9kZXMgYW4gaGF2aW5nIHRoZSBnaXZlbiB0eXBlLlxuICAgICAqL1xuICAgIGVsZW1lbnRVdGlsaXRpZXMuY3JlYXRlQ29tcG91bmRGb3JHaXZlbk5vZGVzID0gZnVuY3Rpb24gKG5vZGVzVG9NYWtlQ29tcG91bmQsIGNvbXBvdW5kVHlwZSkge1xuICAgICAgdmFyIG9sZFBhcmVudElkID0gbm9kZXNUb01ha2VDb21wb3VuZFswXS5kYXRhKFwicGFyZW50XCIpO1xuICAgICAgdmFyIGxhbmd1YWdlID0gbm9kZXNUb01ha2VDb21wb3VuZFswXS5kYXRhKFwibGFuZ3VhZ2VcIik7XG4gICAgICAvLyBpZiBub2Rlc1RvTWFrZUNvbXBvdW5kIGNvbnRhaW4gYm90aCBQRCBhbmQgQUYgbm9kZXMsIHRoZW4gc2V0IGxhbmd1YWdlIG9mIGNvbXBvdW5kIGFzIFVua25vd25cbiAgICAgIGZvciggdmFyIGk9MTsgaTxub2Rlc1RvTWFrZUNvbXBvdW5kLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgaWYobm9kZXNUb01ha2VDb21wb3VuZFtpXSAhPSBsYW5ndWFnZSl7XG4gICAgICAgICAgbGFuZ3VhZ2UgPSBcIlVua25vd25cIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gVGhlIHBhcmVudCBvZiBuZXcgY29tcG91bmQgd2lsbCBiZSB0aGUgb2xkIHBhcmVudCBvZiB0aGUgbm9kZXMgdG8gbWFrZSBjb21wb3VuZC4geCwgeSBhbmQgaWQgcGFyYW1ldGVycyBhcmUgbm90IHNldC5cbiAgICAgIHZhciBuZXdDb21wb3VuZCA9IGVsZW1lbnRVdGlsaXRpZXMuYWRkTm9kZSh1bmRlZmluZWQsIHVuZGVmaW5lZCwge2NsYXNzIDogY29tcG91bmRUeXBlLCBsYW5ndWFnZSA6IGxhbmd1YWdlfSwgdW5kZWZpbmVkLCBvbGRQYXJlbnRJZCk7XG4gICAgICB2YXIgbmV3Q29tcG91bmRJZCA9IG5ld0NvbXBvdW5kLmlkKCk7XG4gICAgICB2YXIgbmV3RWxlcyA9IGVsZW1lbnRVdGlsaXRpZXMuY2hhbmdlUGFyZW50KG5vZGVzVG9NYWtlQ29tcG91bmQsIG5ld0NvbXBvdW5kSWQpO1xuICAgICAgbmV3RWxlcyA9IG5ld0VsZXMudW5pb24obmV3Q29tcG91bmQpO1xuICAgICAgcmV0dXJuIG5ld0VsZXM7XG4gICAgfTtcblxuICAgIGVsZW1lbnRVdGlsaXRpZXMuY3JlYXRlVHJhbnNsYXRpb25SZWFjdGlvbiA9IGZ1bmN0aW9uKG1SbmFOYW1lLCBwcm90ZWluTmFtZSwgcHJvY2Vzc1Bvc2l0aW9uLCBlZGdlTGVuZ3RoKSB7XG4gICAgICBjb25zdCBkZWZhdWx0UHJvY2Vzc1Byb3BlcnRpZXMgPSBlbGVtZW50VXRpbGl0aWVzLmdldERlZmF1bHRQcm9wZXJ0aWVzKFwidHJhbnNsYXRpb25cIik7XG4gICAgICBjb25zdCBkZWZhdWx0U291cmNlQW5kU2lua1Byb3BlcnRpZXMgPSBlbGVtZW50VXRpbGl0aWVzLmdldERlZmF1bHRQcm9wZXJ0aWVzKFwiZW1wdHkgc2V0XCIpO1xuICAgICAgY29uc3QgZGVmYXVsdE51Y2xlaWNBY2lkRmVhdHVyZVByb3BlcnRpZXMgPSBlbGVtZW50VXRpbGl0aWVzLmdldERlZmF1bHRQcm9wZXJ0aWVzKFwibnVjbGVpYyBhY2lkIGZlYXR1cmVcIik7XG4gICAgICBjb25zdCBkZWZhdWx0TWFjcm9tb2xlY3VsZVByb3BlcnRpZXMgPSBlbGVtZW50VXRpbGl0aWVzLmdldERlZmF1bHRQcm9wZXJ0aWVzKFwibWFjcm9tb2xlY3VsZVwiKTtcbiAgICAgIGNvbnN0IG1hY3JvbW9sZWN1bGVXaWR0aCA9IGRlZmF1bHRNYWNyb21vbGVjdWxlUHJvcGVydGllcy53aWR0aCB8fCA1MDtcbiAgICAgIGNvbnN0IHNvdXJjZUFuZFNpbmtXaWR0aCA9IGRlZmF1bHRTb3VyY2VBbmRTaW5rUHJvcGVydGllcy53aWR0aCAgfHwgNTA7XG4gICAgICBjb25zdCBudWNsZWljQWNpZEZlYXR1cmVIZWlnaHQgPSBkZWZhdWx0TnVjbGVpY0FjaWRGZWF0dXJlUHJvcGVydGllcy5oZWlnaHQgfHwgNTA7XG4gICAgICBjb25zdCBwcm9jZXNzV2lkdGggPSBkZWZhdWx0UHJvY2Vzc1Byb3BlcnRpZXMud2lkdGggfHwgNTA7XG4gICAgICBjb25zdCBwcm9jZXNzSGVpZ2h0ID0gZGVmYXVsdFByb2Nlc3NQcm9wZXJ0aWVzLmhlaWdodCB8fCA1MDtcbiAgICAgIHZhciBwcm9jZXNzUG9zaXRpb24gPSBwcm9jZXNzUG9zaXRpb24gfHwgZWxlbWVudFV0aWxpdGllcy5jb252ZXJ0VG9Nb2RlbFBvc2l0aW9uKHt4OiBjeS53aWR0aCgpIC8gMiwgeTogY3kuaGVpZ2h0KCkgLyAyfSk7XG4gICAgICB2YXIgZWRnZUxlbmd0aCA9IGVkZ2VMZW5ndGggfHwgNjA7XG5cbiAgICAgIGN5LnN0YXJ0QmF0Y2goKTtcbiAgICAgIGlmICghZWxlbWVudFV0aWxpdGllcy5nZXRNYXBUeXBlKCkpIHtcbiAgICAgICAgZWxlbWVudFV0aWxpdGllcy5zZXRNYXBUeXBlKFwiUERcIik7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcm9jZXNzTm9kZSA9IGVsZW1lbnRVdGlsaXRpZXMuYWRkTm9kZShwcm9jZXNzUG9zaXRpb24ueCwgcHJvY2Vzc1Bvc2l0aW9uLnksIHtjbGFzczogXCJwcm9jZXNzXCIsIGxhbmd1YWdlOiBcIlBEXCJ9KTtcbiAgICAgIGVsZW1lbnRVdGlsaXRpZXMuc2V0UG9ydHNPcmRlcmluZyhwcm9jZXNzTm9kZSwgXCJMLXRvLVJcIik7XG4gICAgICBwcm9jZXNzTm9kZS5kYXRhKCdqdXN0QWRkZWQnLCB0cnVlKTtcblxuICAgICAgY29uc3QgeFBvc09mU291cmNlQW5kU2lua05vZGUgPSBwcm9jZXNzUG9zaXRpb24ueCAtIGVkZ2VMZW5ndGggLSBwcm9jZXNzV2lkdGggLyAyIC0gc291cmNlQW5kU2lua1dpZHRoIC8gMjtcbiAgICAgIGNvbnN0IHlQb3NPZlNvdXJjZUFuZFNpbmtOb2RlID0gcHJvY2Vzc1Bvc2l0aW9uLnk7XG4gICAgICB2YXIgc291cmNlQW5kU2lua05vZGUgPSBlbGVtZW50VXRpbGl0aWVzLmFkZE5vZGUoeFBvc09mU291cmNlQW5kU2lua05vZGUsIHlQb3NPZlNvdXJjZUFuZFNpbmtOb2RlLCB7Y2xhc3M6ICdlbXB0eSBzZXQnLCBsYW5ndWFnZTogJ1BEJ30pO1xuICAgICAgc291cmNlQW5kU2lua05vZGUuZGF0YSgnanVzdEFkZGVkJywgdHJ1ZSk7XG5cbiAgICAgIHZhciBjb25zdW1wdGlvbkVkZ2UgPSBlbGVtZW50VXRpbGl0aWVzLmFkZEVkZ2Uoc291cmNlQW5kU2lua05vZGUuaWQoKSwgcHJvY2Vzc05vZGUuaWQoKSwge2NsYXNzOiAnY29uc3VtcHRpb24nLCBsYW5ndWFnZTogJ1BEJ30pO1xuICAgICAgY29uc3VtcHRpb25FZGdlLmRhdGEoJ2p1c3RBZGRlZCcsIHRydWUpO1xuXG4gICAgICBjb25zdCB4UG9zT2ZtUm5hTm9kZSA9IHByb2Nlc3NQb3NpdGlvbi54O1xuICAgICAgY29uc3QgeVBvc09mbVJuYU5vZGUgPSBwcm9jZXNzUG9zaXRpb24ueSAtIGVkZ2VMZW5ndGggLSBwcm9jZXNzSGVpZ2h0IC8gMiAtIG51Y2xlaWNBY2lkRmVhdHVyZUhlaWdodCAvIDI7XG4gICAgICB2YXIgbVJuYU5vZGUgPSBlbGVtZW50VXRpbGl0aWVzLmFkZE5vZGUoeFBvc09mbVJuYU5vZGUsIHlQb3NPZm1SbmFOb2RlLCB7Y2xhc3M6ICdudWNsZWljIGFjaWQgZmVhdHVyZScsIGxhbmd1YWdlOiAnUEQnfSk7XG4gICAgICBtUm5hTm9kZS5kYXRhKCdqdXN0QWRkZWQnLCB0cnVlKTtcbiAgICAgIG1SbmFOb2RlLmRhdGEoJ2xhYmVsJywgbVJuYU5hbWUpO1xuICAgICAgY29uc3QgaW5mb2JveE9iamVjdE9mR2VuZSA9IHtcbiAgICAgICAgY2xheno6IFwidW5pdCBvZiBpbmZvcm1hdGlvblwiLFxuICAgICAgICBsYWJlbDoge1xuICAgICAgICAgIHRleHQ6ICdjdDptUk5BJ1xuICAgICAgICB9LFxuICAgICAgICBiYm94OiB7XG4gICAgICAgICAgdzogNDUsXG4gICAgICAgICAgaDogMTVcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGVsZW1lbnRVdGlsaXRpZXMuYWRkU3RhdGVPckluZm9Cb3gobVJuYU5vZGUsIGluZm9ib3hPYmplY3RPZkdlbmUpO1xuXG4gICAgICB2YXIgbmVjZXNzYXJ5U3RpbXVsYXRpb25FZGdlID0gZWxlbWVudFV0aWxpdGllcy5hZGRFZGdlKG1SbmFOb2RlLmlkKCksIHByb2Nlc3NOb2RlLmlkKCksIHtjbGFzczogJ25lY2Vzc2FyeSBzdGltdWxhdGlvbicsIGxhbmd1YWdlOiAnUEQnfSk7XG4gICAgICBuZWNlc3NhcnlTdGltdWxhdGlvbkVkZ2UuZGF0YSgnanVzdEFkZGVkJywgdHJ1ZSk7XG5cbiAgICAgIGNvbnN0IHhQb3NPZlByb3RlaW5Ob2RlID0gcHJvY2Vzc1Bvc2l0aW9uLnggKyBlZGdlTGVuZ3RoICsgcHJvY2Vzc1dpZHRoIC8gMiArIG1hY3JvbW9sZWN1bGVXaWR0aCAvIDI7XG4gICAgICBjb25zdCB5UG9zdE9mUHJvdGVpbk5vZGUgPSBwcm9jZXNzUG9zaXRpb24ueTtcbiAgICAgIHZhciBwcm90ZWluTm9kZSA9IGVsZW1lbnRVdGlsaXRpZXMuYWRkTm9kZSh4UG9zT2ZQcm90ZWluTm9kZSwgeVBvc3RPZlByb3RlaW5Ob2RlLCB7Y2xhc3M6ICdtYWNyb21vbGVjdWxlJywgbGFuZ3VhZ2U6ICdQRCd9KTtcbiAgICAgIHByb3RlaW5Ob2RlLmRhdGEoJ2p1c3RBZGRlZCcsIHRydWUpO1xuICAgICAgcHJvdGVpbk5vZGUuZGF0YSgnbGFiZWwnLCBwcm90ZWluTmFtZSk7XG4gIFxuICAgICAgdmFyIHByb2R1Y3Rpb25FZGdlID0gZWxlbWVudFV0aWxpdGllcy5hZGRFZGdlKHByb2Nlc3NOb2RlLmlkKCksIHByb3RlaW5Ob2RlLmlkKCksIHtjbGFzczogJ3Byb2R1Y3Rpb24nLCBsYW5ndWFnZTogJ1BEJ30pO1xuICAgICAgcHJvZHVjdGlvbkVkZ2UuZGF0YSgnanVzdEFkZGVkJywgdHJ1ZSk7XG5cbiAgICAgIGN5LmVuZEJhdGNoKCk7XG5cbiAgICAgIC8vZmlsdGVyIHRoZSBqdXN0IGFkZGVkIGVsZW1lbXRzIHRvIHJldHVybiB0aGVtIGFuZCByZW1vdmUganVzdCBhZGRlZCBtYXJrXG4gICAgICB2YXIgZWxlcyA9IGN5LmVsZW1lbnRzKCdbanVzdEFkZGVkXScpO1xuICAgICAgZWxlcy5yZW1vdmVEYXRhKCdqdXN0QWRkZWQnKTtcblxuICAgICAgY3kuZWxlbWVudHMoKS51bnNlbGVjdCgpO1xuICAgICAgZWxlcy5zZWxlY3QoKTtcblxuICAgICAgcmV0dXJuIGVsZXM7IC8vIFJldHVybiB0aGUganVzdCBhZGRlZCBlbGVtZW50c1xuICAgIH07XG5cbiAgICBlbGVtZW50VXRpbGl0aWVzLmNyZWF0ZVRyYW5zY3JpcHRpb25SZWFjdGlvbiA9IGZ1bmN0aW9uKGdlbmVOYW1lLCBtUm5hTmFtZSwgcHJvY2Vzc1Bvc2l0aW9uLCBlZGdlTGVuZ3RoKSB7XG4gICAgICBjb25zdCBkZWZhdWx0UHJvY2Vzc1Byb3BlcnRpZXMgPSBlbGVtZW50VXRpbGl0aWVzLmdldERlZmF1bHRQcm9wZXJ0aWVzKFwidHJhbnNjcmlwdGlvblwiKTtcbiAgICAgIGNvbnN0IGRlZmF1bHRTb3VyY2VBbmRTaW5rUHJvcGVydGllcyA9IGVsZW1lbnRVdGlsaXRpZXMuZ2V0RGVmYXVsdFByb3BlcnRpZXMoXCJlbXB0eSBzZXRcIik7XG4gICAgICBjb25zdCBkZWZhdWx0TnVjbGVpY0FjaWRGZWF0dXJlUHJvcGVydGllcyA9IGVsZW1lbnRVdGlsaXRpZXMuZ2V0RGVmYXVsdFByb3BlcnRpZXMoXCJudWNsZWljIGFjaWQgZmVhdHVyZVwiKTtcbiAgICAgIGNvbnN0IHNvdXJjZUFuZFNpbmtXaWR0aCA9IGRlZmF1bHRTb3VyY2VBbmRTaW5rUHJvcGVydGllcy53aWR0aCAgfHwgNTA7XG4gICAgICBjb25zdCBudWNsZWljQWNpZEZlYXR1cmVIZWlnaHQgPSBkZWZhdWx0TnVjbGVpY0FjaWRGZWF0dXJlUHJvcGVydGllcy5oZWlnaHQgfHwgNTA7XG4gICAgICBjb25zdCBudWNsZWljQWNpZEZlYXR1cmVXaWR0aCA9IGRlZmF1bHROdWNsZWljQWNpZEZlYXR1cmVQcm9wZXJ0aWVzLndpZHRoIHx8IDUwO1xuICAgICAgY29uc3QgcHJvY2Vzc1dpZHRoID0gZGVmYXVsdFByb2Nlc3NQcm9wZXJ0aWVzLndpZHRoIHx8IDUwO1xuICAgICAgY29uc3QgcHJvY2Vzc0hlaWdodCA9IGRlZmF1bHRQcm9jZXNzUHJvcGVydGllcy5oZWlnaHQgfHwgNTA7XG4gICAgICB2YXIgcHJvY2Vzc1Bvc2l0aW9uID0gcHJvY2Vzc1Bvc2l0aW9uIHx8IGVsZW1lbnRVdGlsaXRpZXMuY29udmVydFRvTW9kZWxQb3NpdGlvbih7eDogY3kud2lkdGgoKSAvIDIsIHk6IGN5LmhlaWdodCgpIC8gMn0pO1xuICAgICAgdmFyIGVkZ2VMZW5ndGggPSBlZGdlTGVuZ3RoIHx8IDYwO1xuXG4gICAgICBjeS5zdGFydEJhdGNoKCk7XG4gICAgICBpZiAoIWVsZW1lbnRVdGlsaXRpZXMuZ2V0TWFwVHlwZSgpKSB7XG4gICAgICAgIGVsZW1lbnRVdGlsaXRpZXMuc2V0TWFwVHlwZShcIlBEXCIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHJvY2Vzc05vZGUgPSBlbGVtZW50VXRpbGl0aWVzLmFkZE5vZGUocHJvY2Vzc1Bvc2l0aW9uLngsIHByb2Nlc3NQb3NpdGlvbi55LCB7Y2xhc3M6IFwicHJvY2Vzc1wiLCBsYW5ndWFnZTogXCJQRFwifSk7XG4gICAgICBlbGVtZW50VXRpbGl0aWVzLnNldFBvcnRzT3JkZXJpbmcocHJvY2Vzc05vZGUsIFwiTC10by1SXCIpO1xuICAgICAgcHJvY2Vzc05vZGUuZGF0YSgnanVzdEFkZGVkJywgdHJ1ZSk7XG5cbiAgICAgIGNvbnN0IHhQb3NPZlNvdXJjZUFuZFNpbmtOb2RlID0gcHJvY2Vzc1Bvc2l0aW9uLnggLSBlZGdlTGVuZ3RoIC0gcHJvY2Vzc1dpZHRoIC8gMiAtIHNvdXJjZUFuZFNpbmtXaWR0aCAvIDI7XG4gICAgICBjb25zdCB5UG9zT2ZTb3VyY2VBbmRTaW5rTm9kZSA9IHByb2Nlc3NQb3NpdGlvbi55O1xuICAgICAgdmFyIHNvdXJjZUFuZFNpbmtOb2RlID0gZWxlbWVudFV0aWxpdGllcy5hZGROb2RlKHhQb3NPZlNvdXJjZUFuZFNpbmtOb2RlLCB5UG9zT2ZTb3VyY2VBbmRTaW5rTm9kZSwge2NsYXNzOiAnZW1wdHkgc2V0JywgbGFuZ3VhZ2U6ICdQRCd9KTtcbiAgICAgIHNvdXJjZUFuZFNpbmtOb2RlLmRhdGEoJ2p1c3RBZGRlZCcsIHRydWUpO1xuXG4gICAgICB2YXIgY29uc3VtcHRpb25FZGdlID0gZWxlbWVudFV0aWxpdGllcy5hZGRFZGdlKHNvdXJjZUFuZFNpbmtOb2RlLmlkKCksIHByb2Nlc3NOb2RlLmlkKCksIHtjbGFzczogJ2NvbnN1bXB0aW9uJywgbGFuZ3VhZ2U6ICdQRCd9KTtcbiAgICAgIGNvbnN1bXB0aW9uRWRnZS5kYXRhKCdqdXN0QWRkZWQnLCB0cnVlKTtcblxuICAgICAgY29uc3QgeFBvc09mR2VuZU5vZGUgPSBwcm9jZXNzUG9zaXRpb24ueDtcbiAgICAgIGNvbnN0IHlQb3NPZkdlbmVOb2RlID0gcHJvY2Vzc1Bvc2l0aW9uLnkgLSBlZGdlTGVuZ3RoIC0gcHJvY2Vzc0hlaWdodCAvIDIgLSBudWNsZWljQWNpZEZlYXR1cmVIZWlnaHQgLyAyO1xuICAgICAgdmFyIGdlbmVOb2RlID0gZWxlbWVudFV0aWxpdGllcy5hZGROb2RlKHhQb3NPZkdlbmVOb2RlLCB5UG9zT2ZHZW5lTm9kZSwge2NsYXNzOiAnbnVjbGVpYyBhY2lkIGZlYXR1cmUnLCBsYW5ndWFnZTogJ1BEJ30pO1xuICAgICAgZ2VuZU5vZGUuZGF0YSgnanVzdEFkZGVkJywgdHJ1ZSk7XG4gICAgICBnZW5lTm9kZS5kYXRhKCdsYWJlbCcsIGdlbmVOYW1lKTtcbiAgICAgIGNvbnN0IGluZm9ib3hPYmplY3RPZkdlbmUgPSB7XG4gICAgICAgIGNsYXp6OiBcInVuaXQgb2YgaW5mb3JtYXRpb25cIixcbiAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICB0ZXh0OiAnY3Q6Z2VuZSdcbiAgICAgICAgfSxcbiAgICAgICAgYmJveDoge1xuICAgICAgICAgIHc6IDM2LFxuICAgICAgICAgIGg6IDE1XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBlbGVtZW50VXRpbGl0aWVzLmFkZFN0YXRlT3JJbmZvQm94KGdlbmVOb2RlLCBpbmZvYm94T2JqZWN0T2ZHZW5lKTtcblxuICAgICAgdmFyIG5lY2Vzc2FyeVN0aW11bGF0aW9uRWRnZSA9IGVsZW1lbnRVdGlsaXRpZXMuYWRkRWRnZShnZW5lTm9kZS5pZCgpLCBwcm9jZXNzTm9kZS5pZCgpLCB7Y2xhc3M6ICduZWNlc3Nhcnkgc3RpbXVsYXRpb24nLCBsYW5ndWFnZTogJ1BEJ30pO1xuICAgICAgbmVjZXNzYXJ5U3RpbXVsYXRpb25FZGdlLmRhdGEoJ2p1c3RBZGRlZCcsIHRydWUpO1xuXG4gICAgICBjb25zdCB4UG9zT2ZtUm5hTm9kZSA9IHByb2Nlc3NQb3NpdGlvbi54ICsgZWRnZUxlbmd0aCArIHByb2Nlc3NXaWR0aCAvIDIgKyBudWNsZWljQWNpZEZlYXR1cmVXaWR0aCAvIDI7XG4gICAgICBjb25zdCB5UG9zdE9mbVJuYU5vZGUgPSBwcm9jZXNzUG9zaXRpb24ueTtcbiAgICAgIHZhciBtUm5hTm9kZSA9IGVsZW1lbnRVdGlsaXRpZXMuYWRkTm9kZSh4UG9zT2ZtUm5hTm9kZSwgeVBvc3RPZm1SbmFOb2RlLCB7Y2xhc3M6ICdudWNsZWljIGFjaWQgZmVhdHVyZScsIGxhbmd1YWdlOiAnUEQnfSk7XG4gICAgICBtUm5hTm9kZS5kYXRhKCdqdXN0QWRkZWQnLCB0cnVlKTtcbiAgICAgIG1SbmFOb2RlLmRhdGEoJ2xhYmVsJywgbVJuYU5hbWUpO1xuICAgICAgY29uc3QgaW5mb2JveE9iamVjdE9mbVJuYSA9IHtcbiAgICAgICAgY2xheno6IFwidW5pdCBvZiBpbmZvcm1hdGlvblwiLFxuICAgICAgICBsYWJlbDoge1xuICAgICAgICAgIHRleHQ6ICdjdDptUk5BJ1xuICAgICAgICB9LFxuICAgICAgICBiYm94OiB7XG4gICAgICAgICAgdzogNDUsXG4gICAgICAgICAgaDogMTVcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGVsZW1lbnRVdGlsaXRpZXMuYWRkU3RhdGVPckluZm9Cb3gobVJuYU5vZGUsIGluZm9ib3hPYmplY3RPZm1SbmEpO1xuXG4gICAgICB2YXIgcHJvZHVjdGlvbkVkZ2UgPSBlbGVtZW50VXRpbGl0aWVzLmFkZEVkZ2UocHJvY2Vzc05vZGUuaWQoKSwgbVJuYU5vZGUuaWQoKSwge2NsYXNzOiAncHJvZHVjdGlvbicsIGxhbmd1YWdlOiAnUEQnfSk7XG4gICAgICBwcm9kdWN0aW9uRWRnZS5kYXRhKCdqdXN0QWRkZWQnLCB0cnVlKTtcblxuICAgICAgY3kuZW5kQmF0Y2goKTtcblxuICAgICAgLy9maWx0ZXIgdGhlIGp1c3QgYWRkZWQgZWxlbWVtdHMgdG8gcmV0dXJuIHRoZW0gYW5kIHJlbW92ZSBqdXN0IGFkZGVkIG1hcmtcbiAgICAgIHZhciBlbGVzID0gY3kuZWxlbWVudHMoJ1tqdXN0QWRkZWRdJyk7XG4gICAgICBlbGVzLnJlbW92ZURhdGEoJ2p1c3RBZGRlZCcpO1xuXG4gICAgICBjeS5lbGVtZW50cygpLnVuc2VsZWN0KCk7XG4gICAgICBlbGVzLnNlbGVjdCgpO1xuXG4gICAgICByZXR1cm4gZWxlczsgLy8gUmV0dXJuIHRoZSBqdXN0IGFkZGVkIGVsZW1lbnRzXG4gICAgfTtcblxuICAgIGVsZW1lbnRVdGlsaXRpZXMucm90YXRlOTAgPSBmdW5jdGlvbihwb2ludCwgY2VudGVyKSB7XG4gICAgICBjb25zdCByZWxhdGl2ZVggPSBjZW50ZXIueCAtIHBvaW50Lng7XG4gICAgICBjb25zdCByZWxhdGl2ZVkgPSBjZW50ZXIueSAtIHBvaW50Lnk7XG5cbiAgICAgIGNvbnN0IHJlbGF0aXZlUm90YXRlZFggPSByZWxhdGl2ZVk7XG4gICAgICBjb25zdCByZWxhdGl2ZVJvdGF0ZWRZID0gLTEgKiByZWxhdGl2ZVg7XG5cbiAgICAgIGNvbnN0IHJlc3VsdFggPSByZWxhdGl2ZVJvdGF0ZWRYICsgY2VudGVyLng7XG4gICAgICBjb25zdCByZXN1bHRZID0gcmVsYXRpdmVSb3RhdGVkWSArIGNlbnRlci55O1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiByZXN1bHRYLFxuICAgICAgICB5OiByZXN1bHRZXG4gICAgICB9XG4gICAgfVxuXG4gICAgZWxlbWVudFV0aWxpdGllcy5jcmVhdGVUcmFuc2xhdGlvbiA9IGZ1bmN0aW9uKHJlZ3VsYXRvckxhYmVsLCBvdXRwdXRMYWJlbCwgb3JpZW50YXRpb24pIHtcbiAgICAgIGNvbnN0IGRlZmF1bHRTb3VyY2VBbmRTaW5rUHJvcGVydGllcyA9IGVsZW1lbnRVdGlsaXRpZXMuZ2V0RGVmYXVsdFByb3BlcnRpZXMoXCJlbXB0eSBzZXRcIik7XG4gICAgICBjb25zdCBkZWZhdWx0TnVjbGVpY0FjaWRGZWF0dXJlUHJvcGVydGllcyA9IGVsZW1lbnRVdGlsaXRpZXMuZ2V0RGVmYXVsdFByb3BlcnRpZXMoXCJudWNsZWljIGFjaWQgZmVhdHVyZVwiKTtcbiAgICAgIGNvbnN0IGRlZmF1bHRNYWNyb21vbGVjdWxlUHJvcGV0aWVzID0gZWxlbWVudFV0aWxpdGllcy5nZXREZWZhdWx0UHJvcGVydGllcyhcIm1hY3JvbW9sZWN1bGVcIilcbiAgICAgIGNvbnN0IGRlZmF1bHRQcm9jZXNzUHJvcGVydGllcyA9IGVsZW1lbnRVdGlsaXRpZXMuZ2V0RGVmYXVsdFByb3BlcnRpZXMoXCJwcm9jZXNzXCIpO1xuICAgICAgY29uc3Qgc291cmNlQW5kU2lua1dpZHRoID0gZGVmYXVsdFNvdXJjZUFuZFNpbmtQcm9wZXJ0aWVzLndpZHRoIHx8IDUwO1xuICAgICAgY29uc3QgbnVjbGVpY0FjaWRGZWF0dXJlV2lkdGggPSBkZWZhdWx0TnVjbGVpY0FjaWRGZWF0dXJlUHJvcGVydGllcy53aWR0aCB8fCA1MDtcbiAgICAgIGNvbnN0IG51Y2xlaWNBY2lkRmVhdHVyZUhlaWdodCA9IGRlZmF1bHROdWNsZWljQWNpZEZlYXR1cmVQcm9wZXJ0aWVzLmhlaWdodCB8fCA1MDtcbiAgICAgIGNvbnN0IG1hY3JvbW9sZWN1bGVXaWR0aCA9IGRlZmF1bHRNYWNyb21vbGVjdWxlUHJvcGV0aWVzLndpZHRoIHx8IDUwO1xuICAgICAgY29uc3QgcHJvY2Vzc1dpZHRoID0gZGVmYXVsdFByb2Nlc3NQcm9wZXJ0aWVzLndpZHRoIHx8IDUwO1xuICAgICAgY29uc3QgcHJvY2Vzc0hlaWdodCA9IGRlZmF1bHRQcm9jZXNzUHJvcGVydGllcy5oZWlnaHQgfHwgNTA7XG4gICAgICBjb25zdCBwcm9jZXNzUG9zaXRpb24gPSBlbGVtZW50VXRpbGl0aWVzLmNvbnZlcnRUb01vZGVsUG9zaXRpb24oe3g6IGN5LndpZHRoKCkgLyAyLCB5OiBjeS5oZWlnaHQoKSAvIDJ9KTtcbiAgICAgIGNvbnN0IGVkZ2VMZW5ndGggPSAzMDtcbiAgICAgIGNvbnN0IHZlcnRpY2FsID0gb3JpZW50YXRpb24gPT09IFwidmVydGljYWxcIjtcbiAgICAgIGNvbnN0IHByb2Nlc3NQb3J0c09yZGVyaW5nID0gdmVydGljYWwgPyBcIlQtdG8tQlwiIDogXCJMLXRvLVJcIjtcbiAgICAgIGNvbnN0IG1pbkluZm9ib3hEaW1lbnNpb24gPSAxNTtcbiAgICAgIGNvbnN0IHdpZHRoUGVyQ2hhciA9IDY7XG4gICAgICBjb25zdCByZWd1bGF0b3JJbmZvYm94TGFiZWwgPSBcImN0Om1STkFcIjtcblxuICAgICAgY3kuc3RhcnRCYXRjaCgpO1xuXG4gICAgICBpZiAoIWVsZW1lbnRVdGlsaXRpZXMuZ2V0TWFwVHlwZSgpKSB7XG4gICAgICAgIGVsZW1lbnRVdGlsaXRpZXMuc2V0TWFwVHlwZShcIlBEXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgcHJvY2Vzc05vZGUgPSBlbGVtZW50VXRpbGl0aWVzLmFkZE5vZGUocHJvY2Vzc1Bvc2l0aW9uLngsIHByb2Nlc3NQb3NpdGlvbi55LCB7Y2xhc3M6IFwicHJvY2Vzc1wiLCBsYW5ndWFnZTogXCJQRFwifSk7XG4gICAgICBlbGVtZW50VXRpbGl0aWVzLnNldFBvcnRzT3JkZXJpbmcocHJvY2Vzc05vZGUsIHByb2Nlc3NQb3J0c09yZGVyaW5nKTtcbiAgICAgIHByb2Nlc3NOb2RlLmRhdGEoJ2p1c3RBZGRlZCcsIHRydWUpO1xuXG4gICAgICBsZXQgeFBvc09mSW5wdXQgPSBwcm9jZXNzUG9zaXRpb24ueCAtIGVkZ2VMZW5ndGggLSBwcm9jZXNzV2lkdGggLyAyIC0gc291cmNlQW5kU2lua1dpZHRoIC8gMjtcbiAgICAgIGxldCB4UG9zT2ZPdXRwdXQgPSBwcm9jZXNzUG9zaXRpb24ueCArIGVkZ2VMZW5ndGggKyBwcm9jZXNzV2lkdGggLyAyICsgbWFjcm9tb2xlY3VsZVdpZHRoIC8gMjtcbiAgICAgIGxldCB5UG9zT2ZJbnB1dCA9IHByb2Nlc3NQb3NpdGlvbi55O1xuICAgICAgbGV0IHlQb3NPZk91dHB1dCA9IHByb2Nlc3NQb3NpdGlvbi55O1xuXG4gICAgICBsZXQgbm9kZVBvc2l0aW9uID0ge1xuICAgICAgICB4OiB4UG9zT2ZJbnB1dCxcbiAgICAgICAgeTogeVBvc09mSW5wdXRcbiAgICAgIH1cbiAgICAgIGlmICh2ZXJ0aWNhbCkge1xuICAgICAgICBub2RlUG9zaXRpb24gPSBlbGVtZW50VXRpbGl0aWVzLnJvdGF0ZTkwKG5vZGVQb3NpdGlvbiwgcHJvY2Vzc1Bvc2l0aW9uKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgaW5wdXROb2RlID0gZWxlbWVudFV0aWxpdGllcy5hZGROb2RlKG5vZGVQb3NpdGlvbi54LCBub2RlUG9zaXRpb24ueSwge2NsYXNzOiAnZW1wdHkgc2V0JywgbGFuZ3VhZ2U6ICdQRCd9KTtcbiAgICAgIGlucHV0Tm9kZS5kYXRhKFwianVzdEFkZGVkXCIsIHRydWUpO1xuICAgICAgaW5wdXROb2RlLmRhdGEoXCJsYWJlbFwiLCBsYWJlbCk7XG5cbiAgICAgIGNvbnN0IGlucHV0RWRnZSA9IGVsZW1lbnRVdGlsaXRpZXMuYWRkRWRnZShpbnB1dE5vZGUuaWQoKSwgcHJvY2Vzc05vZGUuaWQoKSwge2NsYXNzOiAnY29uc3VtcHRpb24nLCBsYW5ndWFnZTogJ1BEJ30pXG4gICAgICBpbnB1dEVkZ2UuZGF0YShcImp1c3RBZGRlZFwiLCB0cnVlKTtcblxuICAgICAgbm9kZVBvc2l0aW9uID0ge1xuICAgICAgICB4OiB4UG9zT2ZPdXRwdXQsXG4gICAgICAgIHk6IHlQb3NPZk91dHB1dFxuICAgICAgfVxuXG4gICAgICBpZiAodmVydGljYWwpIHtcbiAgICAgICAgbm9kZVBvc2l0aW9uID0gZWxlbWVudFV0aWxpdGllcy5yb3RhdGU5MChub2RlUG9zaXRpb24sIHByb2Nlc3NQb3NpdGlvbik7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG91dHB1dE5vZGUgPSBlbGVtZW50VXRpbGl0aWVzLmFkZE5vZGUobm9kZVBvc2l0aW9uLngsIG5vZGVQb3NpdGlvbi55LCB7Y2xhc3M6IFwibWFjcm9tb2xlY3VsZVwiLCBsYW5ndWFnZTogJ1BEJ30pO1xuICAgICAgb3V0cHV0Tm9kZS5kYXRhKFwianVzdEFkZGVkXCIsIHRydWUpO1xuICAgICAgb3V0cHV0Tm9kZS5kYXRhKFwibGFiZWxcIiwgb3V0cHV0TGFiZWwpO1xuXG4gICAgICBjb25zdCBvdXRwdXRFZGdlID0gZWxlbWVudFV0aWxpdGllcy5hZGRFZGdlKHByb2Nlc3NOb2RlLmlkKCksIG91dHB1dE5vZGUuaWQoKSwge2NsYXNzOiAncHJvZHVjdGlvbicsIGxhbmd1YWdlOiAnUEQnfSlcbiAgICAgIG91dHB1dEVkZ2UuZGF0YShcImp1c3RBZGRlZFwiLCB0cnVlKTtcblxuICAgICAgbGV0IHhQb3NPZlJlZ3VsYXRvciA9IHByb2Nlc3NQb3NpdGlvbi54O1xuICAgICAgY29uc3QgZGltZW5zaW9uID0gdmVydGljYWwgPyBudWNsZWljQWNpZEZlYXR1cmVXaWR0aCA6IG51Y2xlaWNBY2lkRmVhdHVyZUhlaWdodDtcbiAgICAgIGxldCB5UG9zT2ZSZWd1bGF0b3IgPSBwcm9jZXNzUG9zaXRpb24ueSAtICgocHJvY2Vzc0hlaWdodCAvIDIpICsgKGRpbWVuc2lvbiAvIDIpICsgZWRnZUxlbmd0aCk7IFxuXG4gICAgICBub2RlUG9zaXRpb24gPSB7XG4gICAgICAgIHg6IHhQb3NPZlJlZ3VsYXRvcixcbiAgICAgICAgeTogeVBvc09mUmVndWxhdG9yXG4gICAgICB9XG4gICAgICBpZiAodmVydGljYWwpIHtcbiAgICAgICAgbm9kZVBvc2l0aW9uID0gZWxlbWVudFV0aWxpdGllcy5yb3RhdGU5MChub2RlUG9zaXRpb24sIHByb2Nlc3NQb3NpdGlvbik7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlZ3VsYXRvck5vZGUgPSBlbGVtZW50VXRpbGl0aWVzLmFkZE5vZGUobm9kZVBvc2l0aW9uLngsIG5vZGVQb3NpdGlvbi55LCB7Y2xhc3M6IFwibnVjbGVpYyBhY2lkIGZlYXR1cmVcIiwgbGFuZ3VhZ2U6ICdQRCd9KTtcbiAgICAgIHJlZ3VsYXRvck5vZGUuZGF0YSgnanVzdEFkZGVkJywgdHJ1ZSk7XG4gICAgICByZWd1bGF0b3JOb2RlLmRhdGEoJ2xhYmVsJywgcmVndWxhdG9yTGFiZWwpO1xuICAgICAgaW5mb2JveE9iamVjdCA9IHtcbiAgICAgICAgY2xheno6IFwidW5pdCBvZiBpbmZvcm1hdGlvblwiLFxuICAgICAgICBsYWJlbDoge1xuICAgICAgICAgIHRleHQ6IHJlZ3VsYXRvckluZm9ib3hMYWJlbFxuICAgICAgICB9LFxuICAgICAgICBiYm94OiB7XG4gICAgICAgICAgdzogTWF0aC5tYXgocmVndWxhdG9ySW5mb2JveExhYmVsLmxlbmd0aCAqIHdpZHRoUGVyQ2hhciwgbWluSW5mb2JveERpbWVuc2lvbiksXG4gICAgICAgICAgaDogbWluSW5mb2JveERpbWVuc2lvblxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgZWxlbWVudFV0aWxpdGllcy5hZGRTdGF0ZU9ySW5mb0JveChyZWd1bGF0b3JOb2RlLCBpbmZvYm94T2JqZWN0KTtcblxuICAgICAgY29uc3QgcmVndWxhdG9yRWRnZSA9IGVsZW1lbnRVdGlsaXRpZXMuYWRkRWRnZShyZWd1bGF0b3JOb2RlLmlkKCksIHByb2Nlc3NOb2RlLmlkKCksIHtjbGFzczogJ25lY2Vzc2FyeSBzdGltdWxhdGlvbicsIGxhbmd1YWdlOiAnUEQnfSk7XG4gICAgICByZWd1bGF0b3JFZGdlLmRhdGEoJ2p1c3RBZGRlZCcsIHRydWUpO1xuXG4gICAgICBjeS5lbmRCYXRjaCgpO1xuXG4gICAgICBjb25zdCBlbGVzID0gY3kuZWxlbWVudHMoJ1tqdXN0QWRkZWRdJyk7XG4gICAgICBlbGVzLnJlbW92ZURhdGEoJ2p1c3RBZGRlZCcpO1xuXG4gICAgICBjeS5lbGVtZW50cygpLnVuc2VsZWN0KCk7XG4gICAgICBlbGVzLnNlbGVjdCgpO1xuXG4gICAgICByZXR1cm4gZWxlcztcbiAgICB9XG5cbiAgICBlbGVtZW50VXRpbGl0aWVzLmNyZWF0ZVRyYW5zY3JpcHRpb24gPSBmdW5jdGlvbihsYWJlbCwgb3JpZW50YXRpb24pIHtcbiAgICAgIGNvbnN0IGRlZmF1bHRTb3VyY2VBbmRTaW5rUHJvcGVydGllcyA9IGVsZW1lbnRVdGlsaXRpZXMuZ2V0RGVmYXVsdFByb3BlcnRpZXMoXCJlbXB0eSBzZXRcIik7XG4gICAgICBjb25zdCBkZWZhdWx0TnVjbGVpY0FjaWRGZWF0dXJlUHJvcGVydGllcyA9IGVsZW1lbnRVdGlsaXRpZXMuZ2V0RGVmYXVsdFByb3BlcnRpZXMoXCJudWNsZWljIGFjaWQgZmVhdHVyZVwiKTtcbiAgICAgIGNvbnN0IGRlZmF1bHRQcm9jZXNzUHJvcGVydGllcyA9IGVsZW1lbnRVdGlsaXRpZXMuZ2V0RGVmYXVsdFByb3BlcnRpZXMoXCJwcm9jZXNzXCIpXG4gICAgICBjb25zdCBzb3VyY2VBbmRTaW5rV2lkdGggPSBkZWZhdWx0U291cmNlQW5kU2lua1Byb3BlcnRpZXMud2lkdGggfHwgNTA7XG4gICAgICBjb25zdCBudWNsZWljQWNpZEZlYXR1cmVXaWR0aCA9IGRlZmF1bHROdWNsZWljQWNpZEZlYXR1cmVQcm9wZXJ0aWVzLndpZHRoIHx8IDUwO1xuICAgICAgY29uc3QgbnVjbGVpY0FjaWRGZWF0dXJlSGVpZ2h0ID0gZGVmYXVsdE51Y2xlaWNBY2lkRmVhdHVyZVByb3BlcnRpZXMuaGVpZ2h0IHx8IDUwO1xuICAgICAgY29uc3QgcHJvY2Vzc1dpZHRoID0gZGVmYXVsdFByb2Nlc3NQcm9wZXJ0aWVzLndpZHRoIHx8IDUwO1xuICAgICAgY29uc3QgcHJvY2Vzc0hlaWdodCA9IGRlZmF1bHRQcm9jZXNzUHJvcGVydGllcy5oZWlnaHQgfHwgNTA7XG4gICAgICBjb25zdCBwcm9jZXNzUG9zaXRpb24gPSBlbGVtZW50VXRpbGl0aWVzLmNvbnZlcnRUb01vZGVsUG9zaXRpb24oe3g6IGN5LndpZHRoKCkgLyAyLCB5OiBjeS5oZWlnaHQoKSAvIDJ9KTtcbiAgICAgIGNvbnN0IGVkZ2VMZW5ndGggPSAzMDtcbiAgICAgIGNvbnN0IHZlcnRpY2FsID0gb3JpZW50YXRpb24gPT09IFwidmVydGljYWxcIjtcbiAgICAgIGNvbnN0IHByb2Nlc3NQb3J0c09yZGVyaW5nID0gdmVydGljYWwgPyBcIlQtdG8tQlwiIDogXCJMLXRvLVJcIjtcbiAgICAgIGNvbnN0IG1pbkluZm9ib3hEaW1lbnNpb24gPSAxNTtcbiAgICAgIGNvbnN0IHdpZHRoUGVyQ2hhciA9IDY7XG4gICAgICBjb25zdCBvdXRwdXRJbmZvYm94TGFiZWwgPSBcImN0Om1STkFcIjtcbiAgICAgIGNvbnN0IHJlZ3VsYXRvckluZm9ib3hMYWJlbCA9IFwiY3Q6Z2VuZVwiO1xuXG4gICAgICBjeS5zdGFydEJhdGNoKCk7XG5cbiAgICAgIGlmICghZWxlbWVudFV0aWxpdGllcy5nZXRNYXBUeXBlKCkpIHtcbiAgICAgICAgZWxlbWVudFV0aWxpdGllcy5zZXRNYXBUeXBlKFwiUERcIik7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHByb2Nlc3NOb2RlID0gZWxlbWVudFV0aWxpdGllcy5hZGROb2RlKHByb2Nlc3NQb3NpdGlvbi54LCBwcm9jZXNzUG9zaXRpb24ueSwge2NsYXNzOiBcInByb2Nlc3NcIiwgbGFuZ3VhZ2U6IFwiUERcIn0pO1xuICAgICAgZWxlbWVudFV0aWxpdGllcy5zZXRQb3J0c09yZGVyaW5nKHByb2Nlc3NOb2RlLCBwcm9jZXNzUG9ydHNPcmRlcmluZyk7XG4gICAgICBwcm9jZXNzTm9kZS5kYXRhKCdqdXN0QWRkZWQnLCB0cnVlKTtcblxuICAgICAgbGV0IHhQb3NPZklucHV0ID0gcHJvY2Vzc1Bvc2l0aW9uLnggLSBlZGdlTGVuZ3RoIC0gcHJvY2Vzc1dpZHRoIC8gMiAtIHNvdXJjZUFuZFNpbmtXaWR0aCAvIDI7XG4gICAgICBsZXQgeFBvc09mT3V0cHV0ID0gcHJvY2Vzc1Bvc2l0aW9uLnggKyBlZGdlTGVuZ3RoICsgcHJvY2Vzc1dpZHRoIC8gMiArIG51Y2xlaWNBY2lkRmVhdHVyZVdpZHRoIC8gMjtcbiAgICAgIGxldCB5UG9zT2ZJbnB1dCA9IHByb2Nlc3NQb3NpdGlvbi55O1xuICAgICAgbGV0IHlQb3NPZk91dHB1dCA9IHByb2Nlc3NQb3NpdGlvbi55O1xuXG4gICAgICBsZXQgbm9kZVBvc2l0aW9uID0ge1xuICAgICAgICB4OiB4UG9zT2ZJbnB1dCxcbiAgICAgICAgeTogeVBvc09mSW5wdXRcbiAgICAgIH1cbiAgICAgIGlmICh2ZXJ0aWNhbCkge1xuICAgICAgICBub2RlUG9zaXRpb24gPSBlbGVtZW50VXRpbGl0aWVzLnJvdGF0ZTkwKG5vZGVQb3NpdGlvbiwgcHJvY2Vzc1Bvc2l0aW9uKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgaW5wdXROb2RlID0gZWxlbWVudFV0aWxpdGllcy5hZGROb2RlKG5vZGVQb3NpdGlvbi54LCBub2RlUG9zaXRpb24ueSwge2NsYXNzOiAnZW1wdHkgc2V0JywgbGFuZ3VhZ2U6ICdQRCd9KTtcbiAgICAgIGlucHV0Tm9kZS5kYXRhKFwianVzdEFkZGVkXCIsIHRydWUpO1xuXG4gICAgICBjb25zdCBpbnB1dEVkZ2UgPSBlbGVtZW50VXRpbGl0aWVzLmFkZEVkZ2UoaW5wdXROb2RlLmlkKCksIHByb2Nlc3NOb2RlLmlkKCksIHtjbGFzczogJ2NvbnN1bXB0aW9uJywgbGFuZ3VhZ2U6ICdQRCd9KVxuICAgICAgaW5wdXRFZGdlLmRhdGEoXCJqdXN0QWRkZWRcIiwgdHJ1ZSk7XG5cbiAgICAgIG5vZGVQb3NpdGlvbiA9IHtcbiAgICAgICAgeDogeFBvc09mT3V0cHV0LFxuICAgICAgICB5OiB5UG9zT2ZPdXRwdXRcbiAgICAgIH1cblxuICAgICAgaWYgKHZlcnRpY2FsKSB7XG4gICAgICAgIG5vZGVQb3NpdGlvbiA9IGVsZW1lbnRVdGlsaXRpZXMucm90YXRlOTAobm9kZVBvc2l0aW9uLCBwcm9jZXNzUG9zaXRpb24pO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBvdXRwdXROb2RlID0gZWxlbWVudFV0aWxpdGllcy5hZGROb2RlKG5vZGVQb3NpdGlvbi54LCBub2RlUG9zaXRpb24ueSwge2NsYXNzOiAnbnVjbGVpYyBhY2lkIGZlYXR1cmUnLCBsYW5ndWFnZTogJ1BEJ30pO1xuICAgICAgb3V0cHV0Tm9kZS5kYXRhKFwianVzdEFkZGVkXCIsIHRydWUpO1xuICAgICAgb3V0cHV0Tm9kZS5kYXRhKFwibGFiZWxcIiwgbGFiZWwpO1xuICAgICAgaW5mb2JveE9iamVjdCA9IHtcbiAgICAgICAgY2xheno6IFwidW5pdCBvZiBpbmZvcm1hdGlvblwiLFxuICAgICAgICBsYWJlbDoge1xuICAgICAgICAgIHRleHQ6IG91dHB1dEluZm9ib3hMYWJlbFxuICAgICAgICB9LFxuICAgICAgICBiYm94OiB7XG4gICAgICAgICAgdzogTWF0aC5tYXgob3V0cHV0SW5mb2JveExhYmVsLmxlbmd0aCAqIHdpZHRoUGVyQ2hhciwgbWluSW5mb2JveERpbWVuc2lvbiksXG4gICAgICAgICAgaDogbWluSW5mb2JveERpbWVuc2lvblxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgZWxlbWVudFV0aWxpdGllcy5hZGRTdGF0ZU9ySW5mb0JveChvdXRwdXROb2RlLCBpbmZvYm94T2JqZWN0KTtcblxuICAgICAgY29uc3Qgb3V0cHV0RWRnZSA9IGVsZW1lbnRVdGlsaXRpZXMuYWRkRWRnZShwcm9jZXNzTm9kZS5pZCgpLCBvdXRwdXROb2RlLmlkKCksIHtjbGFzczogJ3Byb2R1Y3Rpb24nLCBsYW5ndWFnZTogJ1BEJ30pXG4gICAgICBvdXRwdXRFZGdlLmRhdGEoXCJqdXN0QWRkZWRcIiwgdHJ1ZSk7XG5cbiAgICAgIGxldCB4UG9zT2ZSZWd1bGF0b3IgPSBwcm9jZXNzUG9zaXRpb24ueDtcbiAgICAgIGNvbnN0IGRpbWVuc2lvbiA9IHZlcnRpY2FsID8gbnVjbGVpY0FjaWRGZWF0dXJlV2lkdGggOiBudWNsZWljQWNpZEZlYXR1cmVIZWlnaHQ7XG4gICAgICBsZXQgeVBvc09mUmVndWxhdG9yID0gcHJvY2Vzc1Bvc2l0aW9uLnkgLSAoKHByb2Nlc3NIZWlnaHQgLyAyKSArIChkaW1lbnNpb24gLyAyKSArIGVkZ2VMZW5ndGgpOyBcblxuICAgICAgbm9kZVBvc2l0aW9uID0ge1xuICAgICAgICB4OiB4UG9zT2ZSZWd1bGF0b3IsXG4gICAgICAgIHk6IHlQb3NPZlJlZ3VsYXRvclxuICAgICAgfVxuICAgICAgaWYgKHZlcnRpY2FsKSB7XG4gICAgICAgIG5vZGVQb3NpdGlvbiA9IGVsZW1lbnRVdGlsaXRpZXMucm90YXRlOTAobm9kZVBvc2l0aW9uLCBwcm9jZXNzUG9zaXRpb24pO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByZWd1bGF0b3JOb2RlID0gZWxlbWVudFV0aWxpdGllcy5hZGROb2RlKG5vZGVQb3NpdGlvbi54LCBub2RlUG9zaXRpb24ueSwge2NsYXNzOiBcIm51Y2xlaWMgYWNpZCBmZWF0dXJlXCIsIGxhbmd1YWdlOiAnUEQnfSk7XG4gICAgICByZWd1bGF0b3JOb2RlLmRhdGEoJ2p1c3RBZGRlZCcsIHRydWUpO1xuICAgICAgcmVndWxhdG9yTm9kZS5kYXRhKCdsYWJlbCcsIGxhYmVsKTtcbiAgICAgIGluZm9ib3hPYmplY3QgPSB7XG4gICAgICAgIGNsYXp6OiBcInVuaXQgb2YgaW5mb3JtYXRpb25cIixcbiAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICB0ZXh0OiByZWd1bGF0b3JJbmZvYm94TGFiZWxcbiAgICAgICAgfSxcbiAgICAgICAgYmJveDoge1xuICAgICAgICAgIHc6IE1hdGgubWF4KHJlZ3VsYXRvckluZm9ib3hMYWJlbC5sZW5ndGggKiB3aWR0aFBlckNoYXIsIG1pbkluZm9ib3hEaW1lbnNpb24pLFxuICAgICAgICAgIGg6IG1pbkluZm9ib3hEaW1lbnNpb25cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGVsZW1lbnRVdGlsaXRpZXMuYWRkU3RhdGVPckluZm9Cb3gocmVndWxhdG9yTm9kZSwgaW5mb2JveE9iamVjdCk7XG5cbiAgICAgIGNvbnN0IHJlZ3VsYXRvckVkZ2UgPSBlbGVtZW50VXRpbGl0aWVzLmFkZEVkZ2UocmVndWxhdG9yTm9kZS5pZCgpLCBwcm9jZXNzTm9kZS5pZCgpLCB7Y2xhc3M6ICduZWNlc3Nhcnkgc3RpbXVsYXRpb24nLCBsYW5ndWFnZTogJ1BEJ30pO1xuICAgICAgcmVndWxhdG9yRWRnZS5kYXRhKCdqdXN0QWRkZWQnLCB0cnVlKTtcblxuICAgICAgY3kuZW5kQmF0Y2goKTtcblxuICAgICAgY29uc3QgZWxlcyA9IGN5LmVsZW1lbnRzKCdbanVzdEFkZGVkXScpO1xuICAgICAgZWxlcy5yZW1vdmVEYXRhKCdqdXN0QWRkZWQnKTtcblxuICAgICAgY3kuZWxlbWVudHMoKS51bnNlbGVjdCgpO1xuICAgICAgZWxlcy5zZWxlY3QoKTtcblxuICAgICAgcmV0dXJuIGVsZXM7XG4gICAgfVxuXG4gICAgZWxlbWVudFV0aWxpdGllcy5jcmVhdGVEZWdyYWRhdGlvbiA9IGZ1bmN0aW9uKG1hY3JvbW9sZWN1bGUsIG9yaWVudGF0aW9uKSB7XG4gICAgICBjb25zdCBtYWNyb21vbGVjdWxlTmFtZSA9IG1hY3JvbW9sZWN1bGUubmFtZTtcbiAgICAgIGNvbnN0IGRlZmF1bHRNYWNyb21vbGVjdWxlUHJvcGVydGllcyA9IGVsZW1lbnRVdGlsaXRpZXMuZ2V0RGVmYXVsdFByb3BlcnRpZXMoXCJtYWNyb21vbGVjdWxlXCIpO1xuICAgICAgY29uc3QgbWFjcm9tb2xlY3VsZVdpZHRoID0gZGVmYXVsdE1hY3JvbW9sZWN1bGVQcm9wZXJ0aWVzLndpZHRoIHx8IDUwO1xuICAgICAgY29uc3QgZGVmYXVsdFByb2Nlc3NQcm9wZXJ0aWVzID0gZWxlbWVudFV0aWxpdGllcy5nZXREZWZhdWx0UHJvcGVydGllcyhcImNhdGFseXRpY1wiKTtcbiAgICAgIGNvbnN0IHByb2Nlc3NXaWR0aCA9IGRlZmF1bHRQcm9jZXNzUHJvcGVydGllcy53aWR0aCB8fCA1MDtcbiAgICAgIGNvbnN0IHByb2Nlc3NQb3NpdGlvbiA9IGVsZW1lbnRVdGlsaXRpZXMuY29udmVydFRvTW9kZWxQb3NpdGlvbih7eDogY3kud2lkdGgoKSAvIDIsIHk6IGN5LmhlaWdodCgpIC8gMn0pO1xuICAgICAgY29uc3QgZWRnZUxlbmd0aCA9IDMwO1xuICAgICAgY29uc3QgdmVydGljYWwgPSBvcmllbnRhdGlvbiA9PT0gXCJ2ZXJ0aWNhbFwiO1xuICAgICAgY29uc3QgcHJvY2Vzc1BvcnRzT3JkZXJpbmcgPSB2ZXJ0aWNhbCA/IFwiVC10by1CXCIgOiBcIkwtdG8tUlwiO1xuXG4gICAgICBjeS5zdGFydEJhdGNoKCk7XG5cbiAgICAgIGlmICghZWxlbWVudFV0aWxpdGllcy5nZXRNYXBUeXBlKCkpIHtcbiAgICAgICAgZWxlbWVudFV0aWxpdGllcy5zZXRNYXBUeXBlKFwiUERcIik7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHByb2Nlc3NOb2RlID0gZWxlbWVudFV0aWxpdGllcy5hZGROb2RlKHByb2Nlc3NQb3NpdGlvbi54LCBwcm9jZXNzUG9zaXRpb24ueSwge2NsYXNzOiBcInByb2Nlc3NcIiwgbGFuZ3VhZ2U6IFwiUERcIn0pO1xuICAgICAgZWxlbWVudFV0aWxpdGllcy5zZXRQb3J0c09yZGVyaW5nKHByb2Nlc3NOb2RlLCBwcm9jZXNzUG9ydHNPcmRlcmluZyk7XG4gICAgICBwcm9jZXNzTm9kZS5kYXRhKCdqdXN0QWRkZWQnLCB0cnVlKTtcblxuICAgICAgbGV0IHhQb3NPZklucHV0ID0gcHJvY2Vzc1Bvc2l0aW9uLnggLSBlZGdlTGVuZ3RoIC0gcHJvY2Vzc1dpZHRoIC8gMiAtIG1hY3JvbW9sZWN1bGVXaWR0aCAvIDI7XG4gICAgICBsZXQgeFBvc09mT3V0cHV0ID0gcHJvY2Vzc1Bvc2l0aW9uLnggKyBlZGdlTGVuZ3RoICsgcHJvY2Vzc1dpZHRoIC8gMiArIG1hY3JvbW9sZWN1bGVXaWR0aCAvIDI7XG4gICAgICBsZXQgeVBvc09mSW5wdXQgPSBwcm9jZXNzUG9zaXRpb24ueTtcbiAgICAgIGxldCB5UG9zT2ZPdXRwdXQgPSBwcm9jZXNzUG9zaXRpb24ueTtcblxuICAgICAgbGV0IG5vZGVQb3NpdGlvbiA9IHtcbiAgICAgICAgeDogeFBvc09mSW5wdXQsXG4gICAgICAgIHk6IHlQb3NPZklucHV0XG4gICAgICB9XG4gICAgICBpZiAodmVydGljYWwpIHtcbiAgICAgICAgbm9kZVBvc2l0aW9uID0gZWxlbWVudFV0aWxpdGllcy5yb3RhdGU5MChub2RlUG9zaXRpb24sIHByb2Nlc3NQb3NpdGlvbik7XG4gICAgICB9XG5cbiAgICAgIGxldCBpbnB1dE5vZGUgPSBlbGVtZW50VXRpbGl0aWVzLmFkZE5vZGUobm9kZVBvc2l0aW9uLngsIG5vZGVQb3NpdGlvbi55LCB7Y2xhc3M6ICdtYWNyb21vbGVjdWxlJywgbGFuZ3VhZ2U6ICdQRCd9KTtcbiAgICAgIGlucHV0Tm9kZS5kYXRhKFwianVzdEFkZGVkXCIsIHRydWUpO1xuICAgICAgaW5wdXROb2RlLmRhdGEoXCJsYWJlbFwiLCBtYWNyb21vbGVjdWxlTmFtZSk7XG5cbiAgICAgIGxldCBpbnB1dEVkZ2UgPSBlbGVtZW50VXRpbGl0aWVzLmFkZEVkZ2UoaW5wdXROb2RlLmlkKCksIHByb2Nlc3NOb2RlLmlkKCksIHtjbGFzczogJ2NvbnN1bXB0aW9uJywgbGFuZ3VhZ2U6ICdQRCd9KVxuICAgICAgaW5wdXRFZGdlLmRhdGEoXCJqdXN0QWRkZWRcIiwgdHJ1ZSk7XG5cbiAgICAgIG5vZGVQb3NpdGlvbiA9IHtcbiAgICAgICAgeDogeFBvc09mT3V0cHV0LFxuICAgICAgICB5OiB5UG9zT2ZPdXRwdXRcbiAgICAgIH1cblxuICAgICAgaWYgKHZlcnRpY2FsKSB7XG4gICAgICAgIG5vZGVQb3NpdGlvbiA9IGVsZW1lbnRVdGlsaXRpZXMucm90YXRlOTAobm9kZVBvc2l0aW9uLCBwcm9jZXNzUG9zaXRpb24pO1xuICAgICAgfVxuXG4gICAgICBsZXQgb3V0cHV0Tm9kZSA9IGVsZW1lbnRVdGlsaXRpZXMuYWRkTm9kZShub2RlUG9zaXRpb24ueCwgbm9kZVBvc2l0aW9uLnksIHtjbGFzczogJ2VtcHR5IHNldCcsIGxhbmd1YWdlOiAnUEQnfSk7XG4gICAgICBvdXRwdXROb2RlLmRhdGEoXCJqdXN0QWRkZWRcIiwgdHJ1ZSk7XG5cbiAgICAgIGxldCBvdXRwdXRFZGdlID0gZWxlbWVudFV0aWxpdGllcy5hZGRFZGdlKHByb2Nlc3NOb2RlLmlkKCksIG91dHB1dE5vZGUuaWQoKSwge2NsYXNzOiAncHJvZHVjdGlvbicsIGxhbmd1YWdlOiAnUEQnfSlcbiAgICAgIG91dHB1dEVkZ2UuZGF0YShcImp1c3RBZGRlZFwiLCB0cnVlKTtcblxuICAgICAgY3kuZW5kQmF0Y2goKTtcblxuICAgICAgY29uc3QgZWxlcyA9IGN5LmVsZW1lbnRzKCdbanVzdEFkZGVkXScpO1xuICAgICAgZWxlcy5yZW1vdmVEYXRhKCdqdXN0QWRkZWQnKTtcblxuICAgICAgY3kuZWxlbWVudHMoKS51bnNlbGVjdCgpO1xuICAgICAgZWxlcy5zZWxlY3QoKTtcblxuICAgICAgcmV0dXJuIGVsZXM7XG4gICAgfVxuXG4gICAgZWxlbWVudFV0aWxpdGllcy5jcmVhdGVDb21wbGV4UHJvdGVpbkZvcm1hdGlvbiA9IGZ1bmN0aW9uKHByb3RlaW5MYWJlbHMsIGNvbXBsZXhMYWJlbCwgcmVndWxhdG9yLCBvcmllbnRhdGlvbiwgcmV2ZXJzZSkge1xuICAgICAgY29uc3QgaGFzUmVndWxhdG9yID0gcmVndWxhdG9yLm5hbWUgIT09IHVuZGVmaW5lZDtcbiAgICAgIGNvbnN0IGRlZmF1bHRNYWNyb21vbGVjdWxlUHJvcGVydGllcyA9IGVsZW1lbnRVdGlsaXRpZXMuZ2V0RGVmYXVsdFByb3BlcnRpZXMoXCJtYWNyb21vbGVjdWxlXCIpO1xuICAgICAgY29uc3QgZGVmYXVsdFJlZ3VsYXRvclByb3BlcnRpZXMgPSBoYXNSZWd1bGF0b3IgPyBlbGVtZW50VXRpbGl0aWVzLmdldERlZmF1bHRQcm9wZXJ0aWVzKHJlZ3VsYXRvci50eXBlKSA6IHt9O1xuICAgICAgY29uc3QgZGVmYXVsdFByb2Nlc3NQcm9wZXJ0aWVzID0gZWxlbWVudFV0aWxpdGllcy5nZXREZWZhdWx0UHJvcGVydGllcyhcImNhdGFseXRpY1wiKTtcbiAgICAgIGNvbnN0IHByb2Nlc3NXaWR0aCA9IGRlZmF1bHRQcm9jZXNzUHJvcGVydGllcy53aWR0aCB8fCA1MDtcbiAgICAgIGNvbnN0IG1hY3JvbW9sZWN1bGVXaWR0aCA9IGRlZmF1bHRNYWNyb21vbGVjdWxlUHJvcGVydGllcy53aWR0aCB8fCA1MDtcbiAgICAgIGNvbnN0IG1hY3JvbW9sZWN1bGVIZWlnaHQgPSBkZWZhdWx0TWFjcm9tb2xlY3VsZVByb3BlcnRpZXMuaGVpZ2h0IHx8IDUwOyBcbiAgICAgIGNvbnN0IHByb2Nlc3NIZWlnaHQgPSBkZWZhdWx0UHJvY2Vzc1Byb3BlcnRpZXMuaGVpZ2h0IHx8IDUwO1xuICAgICAgY29uc3QgcmVndWxhdG9ySGVpZ2h0ID0gZGVmYXVsdFJlZ3VsYXRvclByb3BlcnRpZXMuaGVpZ2h0IHx8IDUwO1xuICAgICAgY29uc3QgcHJvY2Vzc1Bvc2l0aW9uID0gZWxlbWVudFV0aWxpdGllcy5jb252ZXJ0VG9Nb2RlbFBvc2l0aW9uKHt4OiBjeS53aWR0aCgpIC8gMiwgeTogY3kuaGVpZ2h0KCkgLyAyfSk7XG4gICAgICBjb25zdCBlZGdlTGVuZ3RoID0gMzA7XG4gICAgICBjb25zdCBwcm9jZXNzUG9ydHNPcmRlcmluZyA9IG9yaWVudGF0aW9uID09PSBcInZlcnRpY2FsXCIgPyBcIlQtdG8tQlwiIDogXCJMLXRvLVJcIjtcbiAgICAgIGNvbnN0IG1pbkluZm9ib3hEaW1lbnNpb24gPSAyMDtcbiAgICAgIGNvbnN0IHdpZHRoUGVyQ2hhciA9IDY7XG4gICAgICBjb25zdCB0aWxpbmdQYWRkaW5nVmVydGljYWwgPSAxNTtcbiAgICAgIGNvbnN0IHRpbGluZ1BhZGRpbmdIb3Jpem9udGFsID0gMTU7XG4gICAgICBjb25zdCBtdWx0aW1lck9mZnNldCA9IDY7XG5cbiAgICAgIGN5LnN0YXJ0QmF0Y2goKTtcblxuICAgICAgaWYgKCFlbGVtZW50VXRpbGl0aWVzLmdldE1hcFR5cGUoKSkge1xuICAgICAgICBlbGVtZW50VXRpbGl0aWVzLnNldE1hcFR5cGUoXCJQRFwiKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcHJvY2Vzc05vZGUgPSBlbGVtZW50VXRpbGl0aWVzLmFkZE5vZGUocHJvY2Vzc1Bvc2l0aW9uLngsIHByb2Nlc3NQb3NpdGlvbi55LCB7Y2xhc3M6IFwicHJvY2Vzc1wiLCBsYW5ndWFnZTogXCJQRFwifSk7XG4gICAgICBlbGVtZW50VXRpbGl0aWVzLnNldFBvcnRzT3JkZXJpbmcocHJvY2Vzc05vZGUsIHByb2Nlc3NQb3J0c09yZGVyaW5nKTtcbiAgICAgIHByb2Nlc3NOb2RlLmRhdGEoJ2p1c3RBZGRlZCcsIHRydWUpO1xuXG4gICAgICBjb25zdCBvZmZzZXRYID0gcHJvY2Vzc1dpZHRoIC8gMiArIGVkZ2VMZW5ndGggKyBtYWNyb21vbGVjdWxlV2lkdGggLyAyO1xuICAgICAgbGV0IHhQb3NPZlByb3RlaW4gPSByZXZlcnNlID8gcHJvY2Vzc1Bvc2l0aW9uLnggKyBvZmZzZXRYXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogcHJvY2Vzc1Bvc2l0aW9uLnggLSBvZmZzZXRYO1xuXG4gICAgICBjb25zdCBwcm90ZWluQ291bnQgPSBwcm90ZWluTGFiZWxzLmxlbmd0aDtcblxuICAgICAgY29uc3QgbWFjcm9tb2xlY3VsZURpbWVuc2lvbiA9IG9yaWVudGF0aW9uID09PSBcInZlcnRpY2FsXCIgPyBtYWNyb21vbGVjdWxlV2lkdGggOiBtYWNyb21vbGVjdWxlSGVpZ2h0O1xuICAgICAgY29uc3Qgc3RlcE9mZnNldCA9IG1hY3JvbW9sZWN1bGVEaW1lbnNpb24gKyB0aWxpbmdQYWRkaW5nVmVydGljYWw7XG4gICAgICBjb25zdCBvZmZzZXRZID0gKHByb3RlaW5Db3VudCAtIDEpIC8gMiAqIChtYWNyb21vbGVjdWxlRGltZW5zaW9uICsgdGlsaW5nUGFkZGluZ1ZlcnRpY2FsKTtcbiAgICAgIGNvbnN0IGhvcml6b250YWxPZmZzZXRYID0gKHByb3RlaW5Db3VudCAtIDEpIC8gMiAqIChtYWNyb21vbGVjdWxlRGltZW5zaW9uICsgdGlsaW5nUGFkZGluZ0hvcml6b250YWwpO1xuICAgICAgXG4gICAgICBsZXQgeVBvc09mUHJvdGVpbiA9IHByb2Nlc3NQb3NpdGlvbi55IC0gb2Zmc2V0WTtcblxuICAgICAgcHJvdGVpbkxhYmVscy5mb3JFYWNoKGZ1bmN0aW9uKGxhYmVsKSB7XG4gICAgICAgIGxldCBub2RlUG9zaXRpb24gPSB7XG4gICAgICAgICAgeDogeFBvc09mUHJvdGVpbixcbiAgICAgICAgICB5OiB5UG9zT2ZQcm90ZWluXG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9yaWVudGF0aW9uID09PSBcInZlcnRpY2FsXCIpIHtcbiAgICAgICAgICBub2RlUG9zaXRpb24gPSBlbGVtZW50VXRpbGl0aWVzLnJvdGF0ZTkwKG5vZGVQb3NpdGlvbiwgcHJvY2Vzc1Bvc2l0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG5vZGUgPSBlbGVtZW50VXRpbGl0aWVzLmFkZE5vZGUobm9kZVBvc2l0aW9uLngsIG5vZGVQb3NpdGlvbi55LCB7Y2xhc3M6IFwibWFjcm9tb2xlY3VsZVwiLCBsYW5ndWFnZTogXCJQRFwifSk7XG4gICAgICAgIG5vZGUuZGF0YShcImxhYmVsXCIsIGxhYmVsKTtcbiAgICAgICAgbm9kZS5kYXRhKFwianVzdEFkZGVkXCIsIHRydWUpO1xuICAgICAgICB5UG9zT2ZQcm90ZWluICs9IHN0ZXBPZmZzZXQ7XG5cbiAgICAgICAgY29uc3Qgc291cmNlID0gcmV2ZXJzZSA/IHByb2Nlc3NOb2RlLmlkKCkgOiBub2RlLmlkKCk7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IHJldmVyc2UgPyBub2RlLmlkKCkgOiBwcm9jZXNzTm9kZS5pZCgpO1xuICAgICAgICBjb25zdCBlZGdlQ2xhc3MgPSByZXZlcnNlID8gXCJwcm9kdWN0aW9uXCIgOiBcImNvbnN1bXB0aW9uXCI7XG4gICAgICAgIGNvbnN0IGVkZ2UgPSBlbGVtZW50VXRpbGl0aWVzLmFkZEVkZ2Uoc291cmNlLCB0YXJnZXQsIHtjbGFzczogZWRnZUNsYXNzLCBsYW5ndWFnZTogXCJQRFwifSk7XG4gICAgICAgIGVkZ2UuZGF0YShcImp1c3RBZGRlZFwiLCB0cnVlKTtcbiAgICAgIH0pO1xuXG4gICAgICBsZXQgY29tcGxleFBvcyA9IHtcbiAgICAgICAgeDogcHJvY2Vzc1Bvc2l0aW9uLnggKyAocmV2ZXJzZSA/IC0xIDogMSkgKiBvZmZzZXRYLFxuICAgICAgICB5OiBwcm9jZXNzUG9zaXRpb24ueVxuICAgICAgfVxuXG4gICAgICBpZiAob3JpZW50YXRpb24gPT09IFwidmVydGljYWxcIikge1xuICAgICAgICBjb21wbGV4UG9zID0gZWxlbWVudFV0aWxpdGllcy5yb3RhdGU5MChjb21wbGV4UG9zLCBwcm9jZXNzUG9zaXRpb24pOyBcbiAgICAgIH1cblxuICAgICAgY29uc3QgY29tcGxleCA9IGVsZW1lbnRVdGlsaXRpZXMuYWRkTm9kZShjb21wbGV4UG9zLngsIGNvbXBsZXhQb3MueSwge2NsYXNzOiBcImNvbXBsZXhcIiwgbGFuZ3VhZ2U6IFwiUERcIn0pO1xuICAgICAgY29tcGxleC5kYXRhKFwibGFiZWxcIiwgY29tcGxleExhYmVsKTtcbiAgICAgIGNvbXBsZXguZGF0YShcImp1c3RBZGRlZFwiLCB0cnVlKTtcblxuICAgICAgY29uc3Qgc291cmNlID0gcmV2ZXJzZSA/IGNvbXBsZXguaWQoKSA6IHByb2Nlc3NOb2RlLmlkKCk7XG4gICAgICBjb25zdCB0YXJnZXQgPSByZXZlcnNlID8gcHJvY2Vzc05vZGUuaWQoKSA6IGNvbXBsZXguaWQoKTtcbiAgICAgIGNvbnN0IGVkZ2VDbGFzcyA9IHJldmVyc2UgPyBcImNvbnN1bXB0aW9uXCIgOiBcInByb2R1Y3Rpb25cIjtcbiAgICAgIGNvbnN0IGNvbXBsZXhFZGdlID0gZWxlbWVudFV0aWxpdGllcy5hZGRFZGdlKHNvdXJjZSwgdGFyZ2V0LCB7Y2xhc3M6IGVkZ2VDbGFzcywgbGFuZ3VhZ2U6IFwiUERcIn0pO1xuICAgICAgY29tcGxleEVkZ2UuZGF0YShcImp1c3RBZGRlZFwiLCB0cnVlKTtcblxuICAgICAgXG4gICAgICBpZiAob3JpZW50YXRpb24gPT09IFwidmVydGljYWxcIikge1xuICAgICAgICB4UG9zT2ZQcm90ZWluID0gY29tcGxleC5wb3NpdGlvbihcInhcIikgLSBob3Jpem9udGFsT2Zmc2V0WDtcbiAgICAgICAgeVBvc09mUHJvdGVpbiA9IGNvbXBsZXgucG9zaXRpb24oXCJ5XCIpOyAgIFxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHhQb3NPZlByb3RlaW4gPSBjb21wbGV4LnBvc2l0aW9uKFwieFwiKTtcbiAgICAgICAgeVBvc09mUHJvdGVpbiA9IGNvbXBsZXgucG9zaXRpb24oXCJ5XCIpIC0gb2Zmc2V0WTtcbiAgICAgIH1cblxuICAgICAgcHJvdGVpbkxhYmVscy5mb3JFYWNoKGZ1bmN0aW9uKGxhYmVsKSB7XG5cbiAgICAgICAgbGV0IG5vZGVQb3NpdGlvbiA9IHtcbiAgICAgICAgICB4OiB4UG9zT2ZQcm90ZWluLFxuICAgICAgICAgIHk6IHlQb3NPZlByb3RlaW5cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY29uc3Qgbm9kZSA9IGVsZW1lbnRVdGlsaXRpZXMuYWRkTm9kZShub2RlUG9zaXRpb24ueCwgbm9kZVBvc2l0aW9uLnksIHtjbGFzczogXCJtYWNyb21vbGVjdWxlXCIsIGxhbmd1YWdlOiBcIlBEXCJ9LCB1bmRlZmluZWQsIGNvbXBsZXguaWQoKSk7XG4gICAgICAgIG5vZGUuZGF0YShcImxhYmVsXCIsIGxhYmVsKTtcbiAgICAgICAgbm9kZS5kYXRhKFwianVzdEFkZGVkXCIsIHRydWUpO1xuICAgICAgICBcbiAgICAgICAgaWYgKG9yaWVudGF0aW9uID09PSBcInZlcnRpY2FsXCIpIHtcbiAgICAgICAgICB4UG9zT2ZQcm90ZWluICs9IHN0ZXBPZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgeVBvc09mUHJvdGVpbiArPSBzdGVwT2Zmc2V0O1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKGhhc1JlZ3VsYXRvcikge1xuICAgICAgICBjb25zdCByZWd1bGF0b3JOYW1lID0gcmVndWxhdG9yLm5hbWU7XG4gICAgICAgIGNvbnN0IHJlZ3VsYXRvclR5cGUgPSByZWd1bGF0b3IudHlwZTtcbiAgICAgICAgY29uc3QgcmVndWxhdG9yRWRnZVR5cGUgPSByZWd1bGF0b3IuZWRnZVR5cGU7XG4gICAgICAgIGNvbnN0IHJlZ3VsYXRvck11bHRpbWVyID0gcmVndWxhdG9yLm11bHRpbWVyO1xuXG4gICAgICAgIGxldCB4UG9zT2ZSZWd1bGF0b3IgPSBwcm9jZXNzUG9zaXRpb24ueDtcbiAgICAgICAgaWYgKHJlZ3VsYXRvck11bHRpbWVyLmVuYWJsZWQgJiYgb3JpZW50YXRpb24gPT09IFwiaG9yaXpvbnRhbFwiKSB7XG4gICAgICAgICAgeFBvc09mUmVndWxhdG9yIC09IG11bHRpbWVyT2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIGxldCB5UG9zT2ZSZWd1bGF0b3IgPSBwcm9jZXNzUG9zaXRpb24ueSAtICgocHJvY2Vzc0hlaWdodCAvIDIpICsgKHJlZ3VsYXRvckhlaWdodCAvIDIpICsgZWRnZUxlbmd0aCk7IFxuXG4gICAgICAgIG5vZGVQb3NpdGlvbiA9IHtcbiAgICAgICAgICB4OiB4UG9zT2ZSZWd1bGF0b3IsXG4gICAgICAgICAgeTogeVBvc09mUmVndWxhdG9yXG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9yaWVudGF0aW9uID09PSBcInZlcnRpY2FsXCIpIHtcbiAgICAgICAgICBub2RlUG9zaXRpb24gPSBlbGVtZW50VXRpbGl0aWVzLnJvdGF0ZTkwKG5vZGVQb3NpdGlvbiwgcHJvY2Vzc1Bvc2l0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCByZWd1bGF0b3JOb2RlID0gZWxlbWVudFV0aWxpdGllcy5hZGROb2RlKG5vZGVQb3NpdGlvbi54LCBub2RlUG9zaXRpb24ueSwge2NsYXNzOiByZWd1bGF0b3JUeXBlLCBsYW5ndWFnZTogJ1BEJ30pO1xuICAgICAgICByZWd1bGF0b3JOb2RlLmRhdGEoJ2p1c3RBZGRlZCcsIHRydWUpO1xuICAgICAgICByZWd1bGF0b3JOb2RlLmRhdGEoJ2xhYmVsJywgcmVndWxhdG9yTmFtZSk7XG5cbiAgICAgICAgaWYgKHJlZ3VsYXRvck11bHRpbWVyLmVuYWJsZWQpIHtcbiAgICAgICAgICBlbGVtZW50VXRpbGl0aWVzLnNldE11bHRpbWVyU3RhdHVzKHJlZ3VsYXRvck5vZGUsIHRydWUpO1xuXG4gICAgICAgICAgY29uc3QgY2FyZGluYWxpdHkgPSByZWd1bGF0b3JNdWx0aW1lci5jYXJkaW5hbGl0eTtcbiAgICAgICAgICBpZiAoY2FyZGluYWxpdHkgIT0gJycpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZm9ib3hMYWJlbCA9IFwiTjpcIiArIGNhcmRpbmFsaXR5O1xuICAgICAgICAgICAgaW5mb2JveE9iamVjdCA9IHtcbiAgICAgICAgICAgICAgY2xheno6IFwidW5pdCBvZiBpbmZvcm1hdGlvblwiLFxuICAgICAgICAgICAgICBsYWJlbDoge1xuICAgICAgICAgICAgICAgIHRleHQ6IGluZm9ib3hMYWJlbFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBiYm94OiB7XG4gICAgICAgICAgICAgICAgdzogaW5mb2JveExhYmVsLmxlbmd0aCAqIHdpZHRoUGVyQ2hhcixcbiAgICAgICAgICAgICAgICBoOiBtaW5JbmZvYm94RGltZW5zaW9uXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBlbGVtZW50VXRpbGl0aWVzLmFkZFN0YXRlT3JJbmZvQm94KHJlZ3VsYXRvck5vZGUsIGluZm9ib3hPYmplY3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCByZWd1bGF0b3JFZGdlID0gZWxlbWVudFV0aWxpdGllcy5hZGRFZGdlKHJlZ3VsYXRvck5vZGUuaWQoKSwgcHJvY2Vzc05vZGUuaWQoKSwge2NsYXNzOiByZWd1bGF0b3JFZGdlVHlwZSwgbGFuZ3VhZ2U6ICdQRCd9KTtcbiAgICAgICAgcmVndWxhdG9yRWRnZS5kYXRhKCdqdXN0QWRkZWQnLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgY3kuZW5kQmF0Y2goKTtcblxuICAgICAgY29uc3QgZWxlcyA9IGN5LmVsZW1lbnRzKCdbanVzdEFkZGVkXScpO1xuICAgICAgZWxlcy5yZW1vdmVEYXRhKCdqdXN0QWRkZWQnKTtcblxuICAgICAgY3kuZWxlbWVudHMoKS51bnNlbGVjdCgpO1xuICAgICAgZWxlcy5zZWxlY3QoKTtcblxuICAgICAgcmV0dXJuIGVsZXM7XG5cbiAgICB9XG5cbiAgICBlbGVtZW50VXRpbGl0aWVzLmNyZWF0ZU11bHRpbWVyaXphdGlvbiA9IGZ1bmN0aW9uIChtYWNyb21vbGVjdWxlLCByZWd1bGF0b3IsIHJlZ3VsYXRvck11bHRpbWVyLCBvcmllbnRhdGlvbikge1xuICAgICAgY29uc3QgaGFzUmVndWxhdG9yID0gcmVndWxhdG9yLm5hbWUgIT09IHVuZGVmaW5lZDtcbiAgICAgIGNvbnN0IG1hY3JvbW9sZWN1bGVOYW1lID0gbWFjcm9tb2xlY3VsZS5uYW1lO1xuICAgICAgY29uc3QgbWFjcm9tb2xlY3VsZU11bHRpbWVyQ2FyZGluYWxpdHkgPSBtYWNyb21vbGVjdWxlLmNhcmRpbmFsaXR5O1xuICAgICAgY29uc3QgZGVmYXVsdE1hY3JvbW9sZWN1bGVQcm9wZXJ0aWVzID0gZWxlbWVudFV0aWxpdGllcy5nZXREZWZhdWx0UHJvcGVydGllcyhcIm1hY3JvbW9sZWN1bGVcIik7XG4gICAgICBjb25zdCBkZWZhdWx0UmVndWxhdG9yUHJvcGVydGllcyA9IGhhc1JlZ3VsYXRvciA/IGVsZW1lbnRVdGlsaXRpZXMuZ2V0RGVmYXVsdFByb3BlcnRpZXMocmVndWxhdG9yLnR5cGUpIDoge307XG4gICAgICBjb25zdCBkZWZhdWx0UHJvY2Vzc1Byb3BlcnRpZXMgPSBlbGVtZW50VXRpbGl0aWVzLmdldERlZmF1bHRQcm9wZXJ0aWVzKFwiY2F0YWx5dGljXCIpO1xuICAgICAgY29uc3QgcHJvY2Vzc1dpZHRoID0gZGVmYXVsdFByb2Nlc3NQcm9wZXJ0aWVzLndpZHRoIHx8IDUwO1xuICAgICAgY29uc3QgbWFjcm9tb2xlY3VsZVdpZHRoID0gZGVmYXVsdE1hY3JvbW9sZWN1bGVQcm9wZXJ0aWVzLndpZHRoIHx8IDUwO1xuICAgICAgY29uc3QgbWFjcm9tb2xlY3VsZUhlaWdodCA9IGRlZmF1bHRNYWNyb21vbGVjdWxlUHJvcGVydGllcy5oZWlnaHQgfHwgNTA7IFxuICAgICAgY29uc3QgcHJvY2Vzc0hlaWdodCA9IGRlZmF1bHRQcm9jZXNzUHJvcGVydGllcy5oZWlnaHQgfHwgNTA7XG4gICAgICBjb25zdCByZWd1bGF0b3JIZWlnaHQgPSBkZWZhdWx0UmVndWxhdG9yUHJvcGVydGllcy5oZWlnaHQgfHwgNTA7XG4gICAgICBjb25zdCBwcm9jZXNzUG9zaXRpb24gPSBlbGVtZW50VXRpbGl0aWVzLmNvbnZlcnRUb01vZGVsUG9zaXRpb24oe3g6IGN5LndpZHRoKCkgLyAyLCB5OiBjeS5oZWlnaHQoKSAvIDJ9KTtcbiAgICAgIGNvbnN0IGVkZ2VMZW5ndGggPSAzMDtcbiAgICAgIGNvbnN0IHByb2Nlc3NQb3J0c09yZGVyaW5nID0gb3JpZW50YXRpb24gPT09IFwidmVydGljYWxcIiA/IFwiVC10by1CXCIgOiBcIkwtdG8tUlwiO1xuICAgICAgY29uc3QgbWluSW5mb2JveERpbWVuc2lvbiA9IDIwO1xuICAgICAgY29uc3Qgd2lkdGhQZXJDaGFyID0gNjtcbiAgICAgIGNvbnN0IG11bHRpbWVyT2Zmc2V0ID0gNjtcblxuICAgICAgY3kuc3RhcnRCYXRjaCgpO1xuXG4gICAgICBpZiAoIWVsZW1lbnRVdGlsaXRpZXMuZ2V0TWFwVHlwZSgpKSB7XG4gICAgICAgIGVsZW1lbnRVdGlsaXRpZXMuc2V0TWFwVHlwZShcIlBEXCIpO1xuICAgICAgfVxuXG4gICAgICBsZXQgeFBvc09mSW5wdXQgPSBwcm9jZXNzUG9zaXRpb24ueCAtIGVkZ2VMZW5ndGggLSBwcm9jZXNzV2lkdGggLyAyIC0gbWFjcm9tb2xlY3VsZVdpZHRoIC8gMjtcbiAgICAgIGxldCB4UG9zT2ZPdXRwdXQgPSBwcm9jZXNzUG9zaXRpb24ueCArIGVkZ2VMZW5ndGggKyBwcm9jZXNzV2lkdGggLyAyICsgbWFjcm9tb2xlY3VsZVdpZHRoIC8gMjtcbiAgICAgIGxldCB5UG9zT2ZJbnB1dCA9IHByb2Nlc3NQb3NpdGlvbi55O1xuICAgICAgbGV0IHlQb3NPZk91dHB1dCA9IHByb2Nlc3NQb3NpdGlvbi55O1xuXG4gICAgICBsZXQgcHJvY2Vzc05vZGUgPSBlbGVtZW50VXRpbGl0aWVzLmFkZE5vZGUocHJvY2Vzc1Bvc2l0aW9uLngsIHByb2Nlc3NQb3NpdGlvbi55LCB7Y2xhc3M6IFwicHJvY2Vzc1wiLCBsYW5ndWFnZTogXCJQRFwifSk7XG4gICAgICBlbGVtZW50VXRpbGl0aWVzLnNldFBvcnRzT3JkZXJpbmcocHJvY2Vzc05vZGUsIHByb2Nlc3NQb3J0c09yZGVyaW5nKTtcbiAgICAgIHByb2Nlc3NOb2RlLmRhdGEoJ2p1c3RBZGRlZCcsIHRydWUpO1xuXG4gICAgICBsZXQgbm9kZVBvc2l0aW9uID0ge1xuICAgICAgICB4OiB4UG9zT2ZJbnB1dCxcbiAgICAgICAgeTogeVBvc09mSW5wdXRcbiAgICAgIH1cbiAgICAgIGlmIChvcmllbnRhdGlvbiA9PT0gXCJ2ZXJ0aWNhbFwiKSB7XG4gICAgICAgIG5vZGVQb3NpdGlvbiA9IGVsZW1lbnRVdGlsaXRpZXMucm90YXRlOTAobm9kZVBvc2l0aW9uLCBwcm9jZXNzUG9zaXRpb24pO1xuICAgICAgfVxuXG4gICAgICBsZXQgaW5wdXROb2RlID0gZWxlbWVudFV0aWxpdGllcy5hZGROb2RlKG5vZGVQb3NpdGlvbi54LCBub2RlUG9zaXRpb24ueSwge2NsYXNzOiAnbWFjcm9tb2xlY3VsZScsIGxhbmd1YWdlOiAnUEQnfSk7XG4gICAgICBpbnB1dE5vZGUuZGF0YShcImp1c3RBZGRlZFwiLCB0cnVlKTtcbiAgICAgIGlucHV0Tm9kZS5kYXRhKFwibGFiZWxcIiwgbWFjcm9tb2xlY3VsZU5hbWUpO1xuXG4gICAgICBsZXQgaW5wdXRFZGdlID0gZWxlbWVudFV0aWxpdGllcy5hZGRFZGdlKGlucHV0Tm9kZS5pZCgpLCBwcm9jZXNzTm9kZS5pZCgpLCB7Y2xhc3M6ICdjb25zdW1wdGlvbicsIGxhbmd1YWdlOiAnUEQnfSlcbiAgICAgIGlucHV0RWRnZS5kYXRhKFwianVzdEFkZGVkXCIsIHRydWUpO1xuXG4gICAgICBsZXQgY2FyZGluYWxpdHkgPSBtYWNyb21vbGVjdWxlTXVsdGltZXJDYXJkaW5hbGl0eTtcbiAgICAgIGlmIChjYXJkaW5hbGl0eSAhPT0gJycpIHtcbiAgICAgICAgaW5wdXRFZGdlLmRhdGEoXCJjYXJkaW5hbGl0eVwiLCBjYXJkaW5hbGl0eSk7XG4gICAgICB9XG5cbiAgICAgIG5vZGVQb3NpdGlvbiA9IHtcbiAgICAgICAgeDogeFBvc09mT3V0cHV0LFxuICAgICAgICB5OiB5UG9zT2ZPdXRwdXRcbiAgICAgIH1cblxuICAgICAgaWYgKG9yaWVudGF0aW9uID09PSBcInZlcnRpY2FsXCIpIHtcbiAgICAgICAgbm9kZVBvc2l0aW9uID0gZWxlbWVudFV0aWxpdGllcy5yb3RhdGU5MChub2RlUG9zaXRpb24sIHByb2Nlc3NQb3NpdGlvbik7XG4gICAgICB9XG5cbiAgICAgIGxldCBvdXRwdXROb2RlID0gZWxlbWVudFV0aWxpdGllcy5hZGROb2RlKG5vZGVQb3NpdGlvbi54LCBub2RlUG9zaXRpb24ueSwge2NsYXNzOiAnbWFjcm9tb2xlY3VsZScsIGxhbmd1YWdlOiAnUEQnfSk7XG4gICAgICBvdXRwdXROb2RlLmRhdGEoXCJqdXN0QWRkZWRcIiwgdHJ1ZSk7XG4gICAgICBvdXRwdXROb2RlLmRhdGEoXCJsYWJlbFwiLCBtYWNyb21vbGVjdWxlTmFtZSk7XG4gICAgICBlbGVtZW50VXRpbGl0aWVzLnNldE11bHRpbWVyU3RhdHVzKG91dHB1dE5vZGUsIHRydWUpO1xuXG4gICAgICBpZiAoY2FyZGluYWxpdHkgIT09ICcnKSB7XG4gICAgICAgIGNvbnN0IGluZm9ib3hMYWJlbCA9IFwiTjpcIiArIGNhcmRpbmFsaXR5O1xuICAgICAgICBpbmZvYm94T2JqZWN0ID0ge1xuICAgICAgICAgIGNsYXp6OiBcInVuaXQgb2YgaW5mb3JtYXRpb25cIixcbiAgICAgICAgICBsYWJlbDoge1xuICAgICAgICAgICAgdGV4dDogaW5mb2JveExhYmVsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBiYm94OiB7XG4gICAgICAgICAgICB3OiBpbmZvYm94TGFiZWwubGVuZ3RoICogd2lkdGhQZXJDaGFyLFxuICAgICAgICAgICAgaDogbWluSW5mb2JveERpbWVuc2lvblxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZWxlbWVudFV0aWxpdGllcy5hZGRTdGF0ZU9ySW5mb0JveChvdXRwdXROb2RlLCBpbmZvYm94T2JqZWN0KTtcbiAgICAgIH1cblxuICAgICAgbGV0IG91dHB1dEVkZ2UgPSBlbGVtZW50VXRpbGl0aWVzLmFkZEVkZ2UocHJvY2Vzc05vZGUuaWQoKSwgb3V0cHV0Tm9kZS5pZCgpLCB7Y2xhc3M6ICdwcm9kdWN0aW9uJywgbGFuZ3VhZ2U6ICdQRCd9KVxuICAgICAgb3V0cHV0RWRnZS5kYXRhKFwianVzdEFkZGVkXCIsIHRydWUpO1xuXG4gICAgICBpZiAoaGFzUmVndWxhdG9yKSB7XG4gICAgICAgIGNvbnN0IHJlZ3VsYXRvck5hbWUgPSByZWd1bGF0b3IubmFtZTtcbiAgICAgICAgY29uc3QgcmVndWxhdG9yVHlwZSA9IHJlZ3VsYXRvci50eXBlO1xuICAgICAgICBjb25zdCByZWd1bGF0b3JFZGdlVHlwZSA9IHJlZ3VsYXRvci5lZGdlVHlwZTtcblxuICAgICAgICBsZXQgeFBvc09mUmVndWxhdG9yID0gcHJvY2Vzc1Bvc2l0aW9uLng7XG4gICAgICAgIGlmIChyZWd1bGF0b3JNdWx0aW1lci5lbmFibGVkICYmIG9yaWVudGF0aW9uID09PSBcImhvcml6b250YWxcIikge1xuICAgICAgICAgIHhQb3NPZlJlZ3VsYXRvciAtPSBtdWx0aW1lck9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgeVBvc09mUmVndWxhdG9yID0gcHJvY2Vzc1Bvc2l0aW9uLnkgLSAoKHByb2Nlc3NIZWlnaHQgLyAyKSArIChyZWd1bGF0b3JIZWlnaHQgLyAyKSArIGVkZ2VMZW5ndGgpOyBcblxuICAgICAgICBub2RlUG9zaXRpb24gPSB7XG4gICAgICAgICAgeDogeFBvc09mUmVndWxhdG9yLFxuICAgICAgICAgIHk6IHlQb3NPZlJlZ3VsYXRvclxuICAgICAgICB9XG4gICAgICAgIGlmIChvcmllbnRhdGlvbiA9PT0gXCJ2ZXJ0aWNhbFwiKSB7XG4gICAgICAgICAgbm9kZVBvc2l0aW9uID0gZWxlbWVudFV0aWxpdGllcy5yb3RhdGU5MChub2RlUG9zaXRpb24sIHByb2Nlc3NQb3NpdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcmVndWxhdG9yTm9kZSA9IGVsZW1lbnRVdGlsaXRpZXMuYWRkTm9kZShub2RlUG9zaXRpb24ueCwgbm9kZVBvc2l0aW9uLnksIHtjbGFzczogcmVndWxhdG9yVHlwZSwgbGFuZ3VhZ2U6ICdQRCd9KTtcbiAgICAgICAgcmVndWxhdG9yTm9kZS5kYXRhKCdqdXN0QWRkZWQnLCB0cnVlKTtcbiAgICAgICAgcmVndWxhdG9yTm9kZS5kYXRhKCdsYWJlbCcsIHJlZ3VsYXRvck5hbWUpO1xuXG4gICAgICAgIGlmIChyZWd1bGF0b3JNdWx0aW1lci5lbmFibGVkKSB7XG4gICAgICAgICAgZWxlbWVudFV0aWxpdGllcy5zZXRNdWx0aW1lclN0YXR1cyhyZWd1bGF0b3JOb2RlLCB0cnVlKTtcblxuICAgICAgICAgIGNvbnN0IGNhcmRpbmFsaXR5ID0gcmVndWxhdG9yTXVsdGltZXIuY2FyZGluYWxpdHk7XG4gICAgICAgICAgaWYgKGNhcmRpbmFsaXR5ICE9ICcnKSB7XG4gICAgICAgICAgICBjb25zdCBpbmZvYm94TGFiZWwgPSBcIk46XCIgKyBjYXJkaW5hbGl0eTtcbiAgICAgICAgICAgIGluZm9ib3hPYmplY3QgPSB7XG4gICAgICAgICAgICAgIGNsYXp6OiBcInVuaXQgb2YgaW5mb3JtYXRpb25cIixcbiAgICAgICAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBpbmZvYm94TGFiZWxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgYmJveDoge1xuICAgICAgICAgICAgICAgIHc6IGluZm9ib3hMYWJlbC5sZW5ndGggKiB3aWR0aFBlckNoYXIsXG4gICAgICAgICAgICAgICAgaDogbWluSW5mb2JveERpbWVuc2lvblxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZWxlbWVudFV0aWxpdGllcy5hZGRTdGF0ZU9ySW5mb0JveChyZWd1bGF0b3JOb2RlLCBpbmZvYm94T2JqZWN0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcmVndWxhdG9yRWRnZSA9IGVsZW1lbnRVdGlsaXRpZXMuYWRkRWRnZShyZWd1bGF0b3JOb2RlLmlkKCksIHByb2Nlc3NOb2RlLmlkKCksIHtjbGFzczogcmVndWxhdG9yRWRnZVR5cGUsIGxhbmd1YWdlOiAnUEQnfSk7XG4gICAgICAgIHJlZ3VsYXRvckVkZ2UuZGF0YSgnanVzdEFkZGVkJywgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGN5LmVuZEJhdGNoKCk7XG5cbiAgICAgIGNvbnN0IGVsZXMgPSBjeS5lbGVtZW50cygnW2p1c3RBZGRlZF0nKTtcbiAgICAgIGVsZXMucmVtb3ZlRGF0YSgnanVzdEFkZGVkJyk7XG5cbiAgICAgIGN5LmVsZW1lbnRzKCkudW5zZWxlY3QoKTtcbiAgICAgIGVsZXMuc2VsZWN0KCk7XG5cbiAgICAgIHJldHVybiBlbGVzO1xuICAgIH07XG5cbiAgICBlbGVtZW50VXRpbGl0aWVzLmNyZWF0ZUNvbnZlcnNpb24gPSBmdW5jdGlvbiAobWFjcm9tb2xlY3VsZSwgcmVndWxhdG9yLCByZWd1bGF0b3JNdWx0aW1lciwgb3JpZW50YXRpb24sIGlucHV0SW5mb2JveExhYmVscywgb3V0cHV0SW5mb2JveExhYmVscykge1xuICAgICAgY29uc3QgaGFzUmVndWxhdG9yID0gcmVndWxhdG9yLm5hbWUgIT09IHVuZGVmaW5lZDtcbiAgICAgIGNvbnN0IG1hY3JvbW9sZWN1bGVOYW1lID0gbWFjcm9tb2xlY3VsZS5uYW1lO1xuICAgICAgY29uc3QgbWFjcm9tb2xlY3VsZUlzTXVsdGltZXIgPSBtYWNyb21vbGVjdWxlLm11bHRpbWVyLmVuYWJsZWQ7XG4gICAgICBjb25zdCBtYWNyb21vbGVjdWxlTXVsdGltZXJDYXJkaW5hbGl0eSA9IG1hY3JvbW9sZWN1bGUubXVsdGltZXIuY2FyZGluYWxpdHk7XG4gICAgICBjb25zdCBkZWZhdWx0TWFjcm9tb2xlY3VsZVByb3BlcnRpZXMgPSBlbGVtZW50VXRpbGl0aWVzLmdldERlZmF1bHRQcm9wZXJ0aWVzKFwibWFjcm9tb2xlY3VsZVwiKTtcbiAgICAgIGNvbnN0IGRlZmF1bHRSZWd1bGF0b3JQcm9wZXJ0aWVzID0gaGFzUmVndWxhdG9yID8gZWxlbWVudFV0aWxpdGllcy5nZXREZWZhdWx0UHJvcGVydGllcyhyZWd1bGF0b3IudHlwZSkgOiB7fTtcbiAgICAgIGNvbnN0IGRlZmF1bHRQcm9jZXNzUHJvcGVydGllcyA9IGVsZW1lbnRVdGlsaXRpZXMuZ2V0RGVmYXVsdFByb3BlcnRpZXMoXCJjYXRhbHl0aWNcIik7XG4gICAgICBjb25zdCBwcm9jZXNzV2lkdGggPSBkZWZhdWx0UHJvY2Vzc1Byb3BlcnRpZXMud2lkdGggfHwgNTA7XG4gICAgICBjb25zdCBtYWNyb21vbGVjdWxlV2lkdGggPSBkZWZhdWx0TWFjcm9tb2xlY3VsZVByb3BlcnRpZXMud2lkdGggfHwgNTA7XG4gICAgICBjb25zdCBtYWNyb21vbGVjdWxlSGVpZ2h0ID0gZGVmYXVsdE1hY3JvbW9sZWN1bGVQcm9wZXJ0aWVzLmhlaWdodCB8fCA1MDsgXG4gICAgICBjb25zdCBwcm9jZXNzSGVpZ2h0ID0gZGVmYXVsdFByb2Nlc3NQcm9wZXJ0aWVzLmhlaWdodCB8fCA1MDtcbiAgICAgIGNvbnN0IHJlZ3VsYXRvckhlaWdodCA9IGRlZmF1bHRSZWd1bGF0b3JQcm9wZXJ0aWVzLmhlaWdodCB8fCA1MDtcbiAgICAgIGNvbnN0IHByb2Nlc3NQb3NpdGlvbiA9IGVsZW1lbnRVdGlsaXRpZXMuY29udmVydFRvTW9kZWxQb3NpdGlvbih7eDogY3kud2lkdGgoKSAvIDIsIHk6IGN5LmhlaWdodCgpIC8gMn0pO1xuICAgICAgY29uc3QgZWRnZUxlbmd0aCA9IDMwO1xuICAgICAgY29uc3QgcHJvY2Vzc1BvcnRzT3JkZXJpbmcgPSBvcmllbnRhdGlvbiA9PT0gXCJ2ZXJ0aWNhbFwiID8gXCJULXRvLUJcIiA6IFwiTC10by1SXCI7XG4gICAgICBjb25zdCBtaW5JbmZvYm94RGltZW5zaW9uID0gMjA7XG4gICAgICBjb25zdCB3aWR0aFBlckNoYXIgPSA2O1xuICAgICAgY29uc3QgbXVsdGltZXJPZmZzZXQgPSA2O1xuXG4gICAgICBjeS5zdGFydEJhdGNoKCk7XG5cbiAgICAgIGlmICghZWxlbWVudFV0aWxpdGllcy5nZXRNYXBUeXBlKCkpIHtcbiAgICAgICAgZWxlbWVudFV0aWxpdGllcy5zZXRNYXBUeXBlKFwiUERcIik7XG4gICAgICB9XG5cbiAgICAgIGxldCB4UG9zT2ZJbnB1dCA9IHByb2Nlc3NQb3NpdGlvbi54IC0gZWRnZUxlbmd0aCAtIHByb2Nlc3NXaWR0aCAvIDIgLSBtYWNyb21vbGVjdWxlV2lkdGggLyAyO1xuICAgICAgbGV0IHhQb3NPZk91dHB1dCA9IHByb2Nlc3NQb3NpdGlvbi54ICsgZWRnZUxlbmd0aCArIHByb2Nlc3NXaWR0aCAvIDIgKyBtYWNyb21vbGVjdWxlV2lkdGggLyAyO1xuICAgICAgbGV0IHlQb3NPZklucHV0ID0gcHJvY2Vzc1Bvc2l0aW9uLnk7XG4gICAgICBsZXQgeVBvc09mT3V0cHV0ID0gcHJvY2Vzc1Bvc2l0aW9uLnk7XG5cbiAgICAgIGxldCBwcm9jZXNzTm9kZSA9IGVsZW1lbnRVdGlsaXRpZXMuYWRkTm9kZShwcm9jZXNzUG9zaXRpb24ueCwgcHJvY2Vzc1Bvc2l0aW9uLnksIHtjbGFzczogXCJwcm9jZXNzXCIsIGxhbmd1YWdlOiBcIlBEXCJ9KTtcbiAgICAgIGVsZW1lbnRVdGlsaXRpZXMuc2V0UG9ydHNPcmRlcmluZyhwcm9jZXNzTm9kZSwgcHJvY2Vzc1BvcnRzT3JkZXJpbmcpO1xuICAgICAgcHJvY2Vzc05vZGUuZGF0YSgnanVzdEFkZGVkJywgdHJ1ZSk7XG5cbiAgICAgIGxldCBub2RlUG9zaXRpb24gPSB7XG4gICAgICAgIHg6IHhQb3NPZklucHV0LFxuICAgICAgICB5OiB5UG9zT2ZJbnB1dFxuICAgICAgfVxuICAgICAgaWYgKG9yaWVudGF0aW9uID09PSBcInZlcnRpY2FsXCIpIHtcbiAgICAgICAgbm9kZVBvc2l0aW9uID0gZWxlbWVudFV0aWxpdGllcy5yb3RhdGU5MChub2RlUG9zaXRpb24sIHByb2Nlc3NQb3NpdGlvbik7XG4gICAgICB9XG5cbiAgICAgIGxldCBpbnB1dE5vZGUgPSBlbGVtZW50VXRpbGl0aWVzLmFkZE5vZGUobm9kZVBvc2l0aW9uLngsIG5vZGVQb3NpdGlvbi55LCB7Y2xhc3M6ICdtYWNyb21vbGVjdWxlJywgbGFuZ3VhZ2U6ICdQRCd9KTtcbiAgICAgIGlucHV0Tm9kZS5kYXRhKFwianVzdEFkZGVkXCIsIHRydWUpO1xuICAgICAgaW5wdXROb2RlLmRhdGEoXCJsYWJlbFwiLCBtYWNyb21vbGVjdWxlTmFtZSk7XG4gICAgICBpZiAobWFjcm9tb2xlY3VsZUlzTXVsdGltZXIpIHtcbiAgICAgICAgXG4gICAgICAgIGVsZW1lbnRVdGlsaXRpZXMuc2V0TXVsdGltZXJTdGF0dXMoaW5wdXROb2RlLCB0cnVlKTtcblxuICAgICAgICBjb25zdCBjYXJkaW5hbGl0eSA9IG1hY3JvbW9sZWN1bGVNdWx0aW1lckNhcmRpbmFsaXR5O1xuICAgICAgICBpZiAoY2FyZGluYWxpdHkgIT0gJycpIHtcbiAgICAgICAgICBjb25zdCBpbmZvYm94TGFiZWwgPSBcIk46XCIgKyBjYXJkaW5hbGl0eTtcbiAgICAgICAgICBpbmZvYm94T2JqZWN0ID0ge1xuICAgICAgICAgICAgY2xheno6IFwidW5pdCBvZiBpbmZvcm1hdGlvblwiLFxuICAgICAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICAgICAgdGV4dDogaW5mb2JveExhYmVsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYmJveDoge1xuICAgICAgICAgICAgICB3OiBpbmZvYm94TGFiZWwubGVuZ3RoICogd2lkdGhQZXJDaGFyLFxuICAgICAgICAgICAgICBoOiBtaW5JbmZvYm94RGltZW5zaW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICBlbGVtZW50VXRpbGl0aWVzLmFkZFN0YXRlT3JJbmZvQm94KGlucHV0Tm9kZSwgaW5mb2JveE9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaW5wdXRJbmZvYm94TGFiZWxzLmZvckVhY2goZnVuY3Rpb24obGFiZWwpIHtcbiAgICAgICAgY29uc3QgaW5wdXRJbmZvYm94V2lkdGggPSBsYWJlbC5sZW5ndGggPiAwID8gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgubWF4KHdpZHRoUGVyQ2hhciAqIGxhYmVsLmxlbmd0aCwgbWluSW5mb2JveERpbWVuc2lvbikgOiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluSW5mb2JveERpbWVuc2lvbjsgXG4gICAgICAgIGxldCBpbmZvYm94T2JqZWN0ID0ge1xuICAgICAgICAgIGNsYXp6OiBcInVuaXQgb2YgaW5mb3JtYXRpb25cIixcbiAgICAgICAgICBsYWJlbDoge1xuICAgICAgICAgICAgdGV4dDogbGFiZWxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGJib3g6IHtcbiAgICAgICAgICAgIHc6IGlucHV0SW5mb2JveFdpZHRoLFxuICAgICAgICAgICAgaDogbWluSW5mb2JveERpbWVuc2lvblxuICAgICAgICAgIH0sXG4gICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIFwic2hhcGUtbmFtZVwiOiBcImVsbGlwc2VcIlxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZWxlbWVudFV0aWxpdGllcy5hZGRTdGF0ZU9ySW5mb0JveChpbnB1dE5vZGUsIGluZm9ib3hPYmplY3QpO1xuICAgICAgfSk7XG5cbiAgICAgIGxldCBpbnB1dEVkZ2UgPSBlbGVtZW50VXRpbGl0aWVzLmFkZEVkZ2UoaW5wdXROb2RlLmlkKCksIHByb2Nlc3NOb2RlLmlkKCksIHtjbGFzczogJ2NvbnN1bXB0aW9uJywgbGFuZ3VhZ2U6ICdQRCd9KVxuICAgICAgaW5wdXRFZGdlLmRhdGEoXCJqdXN0QWRkZWRcIiwgdHJ1ZSk7XG5cbiAgICAgIG5vZGVQb3NpdGlvbiA9IHtcbiAgICAgICAgeDogeFBvc09mT3V0cHV0LFxuICAgICAgICB5OiB5UG9zT2ZPdXRwdXRcbiAgICAgIH1cblxuICAgICAgaWYgKG9yaWVudGF0aW9uID09PSBcInZlcnRpY2FsXCIpIHtcbiAgICAgICAgbm9kZVBvc2l0aW9uID0gZWxlbWVudFV0aWxpdGllcy5yb3RhdGU5MChub2RlUG9zaXRpb24sIHByb2Nlc3NQb3NpdGlvbik7XG4gICAgICB9XG5cbiAgICAgIGxldCBvdXRwdXROb2RlID0gZWxlbWVudFV0aWxpdGllcy5hZGROb2RlKG5vZGVQb3NpdGlvbi54LCBub2RlUG9zaXRpb24ueSwge2NsYXNzOiAnbWFjcm9tb2xlY3VsZScsIGxhbmd1YWdlOiAnUEQnfSk7XG4gICAgICBvdXRwdXROb2RlLmRhdGEoXCJqdXN0QWRkZWRcIiwgdHJ1ZSk7XG4gICAgICBvdXRwdXROb2RlLmRhdGEoXCJsYWJlbFwiLCBtYWNyb21vbGVjdWxlTmFtZSk7XG4gICAgICBpZiAobWFjcm9tb2xlY3VsZUlzTXVsdGltZXIpIHtcbiAgICAgICAgXG4gICAgICAgIGVsZW1lbnRVdGlsaXRpZXMuc2V0TXVsdGltZXJTdGF0dXMob3V0cHV0Tm9kZSwgdHJ1ZSk7XG5cbiAgICAgICAgY29uc3QgY2FyZGluYWxpdHkgPSBtYWNyb21vbGVjdWxlTXVsdGltZXJDYXJkaW5hbGl0eTtcbiAgICAgICAgaWYgKGNhcmRpbmFsaXR5ICE9ICcnKSB7XG4gICAgICAgICAgY29uc3QgaW5mb2JveExhYmVsID0gXCJOOlwiICsgY2FyZGluYWxpdHk7XG4gICAgICAgICAgaW5mb2JveE9iamVjdCA9IHtcbiAgICAgICAgICAgIGNsYXp6OiBcInVuaXQgb2YgaW5mb3JtYXRpb25cIixcbiAgICAgICAgICAgIGxhYmVsOiB7XG4gICAgICAgICAgICAgIHRleHQ6IGluZm9ib3hMYWJlbFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJib3g6IHtcbiAgICAgICAgICAgICAgdzogaW5mb2JveExhYmVsLmxlbmd0aCAqIHdpZHRoUGVyQ2hhcixcbiAgICAgICAgICAgICAgaDogbWluSW5mb2JveERpbWVuc2lvblxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgZWxlbWVudFV0aWxpdGllcy5hZGRTdGF0ZU9ySW5mb0JveChvdXRwdXROb2RlLCBpbmZvYm94T2JqZWN0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBvdXRwdXRJbmZvYm94TGFiZWxzLmZvckVhY2goZnVuY3Rpb24obGFiZWwpIHtcbiAgICAgICAgY29uc3Qgb3V0cHV0SW5mb2JveFdpZHRoID0gbGFiZWwubGVuZ3RoID4gMCA/IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLm1heCh3aWR0aFBlckNoYXIgKiBsYWJlbC5sZW5ndGgsIG1pbkluZm9ib3hEaW1lbnNpb24pIDogXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbkluZm9ib3hEaW1lbnNpb247XG4gICAgICAgIGluZm9ib3hPYmplY3QgPSB7XG4gICAgICAgICAgY2xheno6IFwidW5pdCBvZiBpbmZvcm1hdGlvblwiLFxuICAgICAgICAgIGxhYmVsOiB7XG4gICAgICAgICAgICB0ZXh0OiBsYWJlbFxuICAgICAgICAgIH0sXG4gICAgICAgICAgYmJveDoge1xuICAgICAgICAgICAgdzogb3V0cHV0SW5mb2JveFdpZHRoLFxuICAgICAgICAgICAgaDogbWluSW5mb2JveERpbWVuc2lvblxuICAgICAgICAgIH0sXG4gICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIFwic2hhcGUtbmFtZVwiOiBcImVsbGlwc2VcIlxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZWxlbWVudFV0aWxpdGllcy5hZGRTdGF0ZU9ySW5mb0JveChvdXRwdXROb2RlLCBpbmZvYm94T2JqZWN0KTtcbiAgICAgIH0pO1xuXG4gICAgICBcbiAgICAgIFtpbnB1dE5vZGUsIG91dHB1dE5vZGVdLmZvckVhY2goZnVuY3Rpb24obm9kZSl7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gZWxlbWVudFV0aWxpdGllcy5jYWxjdWxhdGVNaW5XaWR0aChub2RlKTtcbiAgICAgICAgXG4gICAgICAgIGVsZW1lbnRVdGlsaXRpZXMucmVzaXplTm9kZXMobm9kZSwgd2lkdGgsIG1hY3JvbW9sZWN1bGVIZWlnaHQsIGZhbHNlLCB0cnVlKTtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBpZiAob3JpZW50YXRpb24gPT09IFwiaG9yaXpvbnRhbFwiKSB7XG4gICAgICAgIGxldCBuZXdJbnB1dFhQb3MgPSBwcm9jZXNzUG9zaXRpb24ueCAtIGVkZ2VMZW5ndGggLSBwcm9jZXNzV2lkdGggLyAyIC0gaW5wdXROb2RlLmRhdGEoJ2Jib3gnKS53IC8gMjtcbiAgICAgICAgaW5wdXROb2RlLnBvc2l0aW9uKCd4JywgbmV3SW5wdXRYUG9zKTtcbiAgICAgIFxuICAgICAgICBsZXQgbmV3T3V0cHV0WFBvcyA9IHByb2Nlc3NQb3NpdGlvbi54ICsgZWRnZUxlbmd0aCArIHByb2Nlc3NXaWR0aCAvIDIgKyBvdXRwdXROb2RlLmRhdGEoJ2Jib3gnKS53IC8gMjtcbiAgICAgICAgb3V0cHV0Tm9kZS5wb3NpdGlvbigneCcsIG5ld091dHB1dFhQb3MpO1xuICAgICAgfSBcbiAgICAgIGVsc2Uge1xuICAgICAgICBsZXQgbmV3SW5wdXRZUG9zID0gcHJvY2Vzc1Bvc2l0aW9uLnkgLSBlZGdlTGVuZ3RoIC0gcHJvY2Vzc1dpZHRoIC8gMiAtIGlucHV0Tm9kZS5kYXRhKCdiYm94JykuaCAvIDI7XG4gICAgICAgIGlucHV0Tm9kZS5wb3NpdGlvbigneScsIG5ld0lucHV0WVBvcyk7XG4gICAgICBcbiAgICAgICAgbGV0IG5ld091dHB1dFlQb3MgPSBwcm9jZXNzUG9zaXRpb24ueSArIGVkZ2VMZW5ndGggKyBwcm9jZXNzV2lkdGggLyAyICsgb3V0cHV0Tm9kZS5kYXRhKCdiYm94JykuaCAvIDI7XG4gICAgICAgIG91dHB1dE5vZGUucG9zaXRpb24oJ3knLCBuZXdPdXRwdXRZUG9zKTtcbiAgICAgIH1cblxuICAgICAgbGV0IG91dHB1dEVkZ2UgPSBlbGVtZW50VXRpbGl0aWVzLmFkZEVkZ2UocHJvY2Vzc05vZGUuaWQoKSwgb3V0cHV0Tm9kZS5pZCgpLCB7Y2xhc3M6ICdwcm9kdWN0aW9uJywgbGFuZ3VhZ2U6ICdQRCd9KVxuICAgICAgb3V0cHV0RWRnZS5kYXRhKFwianVzdEFkZGVkXCIsIHRydWUpO1xuXG4gICAgICBpZiAoaGFzUmVndWxhdG9yKSB7XG4gICAgICAgIGNvbnN0IHJlZ3VsYXRvck5hbWUgPSByZWd1bGF0b3IubmFtZTtcbiAgICAgICAgY29uc3QgcmVndWxhdG9yVHlwZSA9IHJlZ3VsYXRvci50eXBlO1xuICAgICAgICBsZXQgeFBvc09mUmVndWxhdG9yID0gcHJvY2Vzc1Bvc2l0aW9uLng7XG4gICAgICAgIGlmIChyZWd1bGF0b3JNdWx0aW1lci5lbmFibGVkICYmIG9yaWVudGF0aW9uID09PSBcImhvcml6b250YWxcIikge1xuICAgICAgICAgIHhQb3NPZlJlZ3VsYXRvciAtPSBtdWx0aW1lck9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgeVBvc09mUmVndWxhdG9yID0gcHJvY2Vzc1Bvc2l0aW9uLnkgLSAoKHByb2Nlc3NIZWlnaHQgLyAyKSArIChyZWd1bGF0b3JIZWlnaHQgLyAyKSArIGVkZ2VMZW5ndGgpOyBcblxuICAgICAgICBub2RlUG9zaXRpb24gPSB7XG4gICAgICAgICAgeDogeFBvc09mUmVndWxhdG9yLFxuICAgICAgICAgIHk6IHlQb3NPZlJlZ3VsYXRvclxuICAgICAgICB9XG4gICAgICAgIGlmIChvcmllbnRhdGlvbiA9PT0gXCJ2ZXJ0aWNhbFwiKSB7XG4gICAgICAgICAgbm9kZVBvc2l0aW9uID0gZWxlbWVudFV0aWxpdGllcy5yb3RhdGU5MChub2RlUG9zaXRpb24sIHByb2Nlc3NQb3NpdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcmVndWxhdG9yTm9kZSA9IGVsZW1lbnRVdGlsaXRpZXMuYWRkTm9kZShub2RlUG9zaXRpb24ueCwgbm9kZVBvc2l0aW9uLnksIHtjbGFzczogcmVndWxhdG9yVHlwZSwgbGFuZ3VhZ2U6ICdQRCd9KTtcbiAgICAgICAgcmVndWxhdG9yTm9kZS5kYXRhKCdqdXN0QWRkZWQnLCB0cnVlKTtcbiAgICAgICAgcmVndWxhdG9yTm9kZS5kYXRhKCdsYWJlbCcsIHJlZ3VsYXRvck5hbWUpO1xuXG4gICAgICAgIGlmIChyZWd1bGF0b3JNdWx0aW1lci5lbmFibGVkKSB7XG4gICAgICAgICAgZWxlbWVudFV0aWxpdGllcy5zZXRNdWx0aW1lclN0YXR1cyhyZWd1bGF0b3JOb2RlLCB0cnVlKTtcblxuICAgICAgICAgIGNvbnN0IGNhcmRpbmFsaXR5ID0gcmVndWxhdG9yTXVsdGltZXIuY2FyZGluYWxpdHk7XG4gICAgICAgICAgaWYgKGNhcmRpbmFsaXR5ICE9ICcnKSB7XG4gICAgICAgICAgICBjb25zdCBpbmZvYm94TGFiZWwgPSBcIk46XCIgKyBjYXJkaW5hbGl0eTtcbiAgICAgICAgICAgIGluZm9ib3hPYmplY3QgPSB7XG4gICAgICAgICAgICAgIGNsYXp6OiBcInVuaXQgb2YgaW5mb3JtYXRpb25cIixcbiAgICAgICAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBpbmZvYm94TGFiZWxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgYmJveDoge1xuICAgICAgICAgICAgICAgIHc6IGluZm9ib3hMYWJlbC5sZW5ndGggKiB3aWR0aFBlckNoYXIsXG4gICAgICAgICAgICAgICAgaDogbWluSW5mb2JveERpbWVuc2lvblxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZWxlbWVudFV0aWxpdGllcy5hZGRTdGF0ZU9ySW5mb0JveChyZWd1bGF0b3JOb2RlLCBpbmZvYm94T2JqZWN0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcmVndWxhdG9yRWRnZSA9IGVsZW1lbnRVdGlsaXRpZXMuYWRkRWRnZShyZWd1bGF0b3JOb2RlLmlkKCksIHByb2Nlc3NOb2RlLmlkKCksIHtjbGFzczogJ2NhdGFseXNpcycsIGxhbmd1YWdlOiAnUEQnfSk7XG4gICAgICAgIHJlZ3VsYXRvckVkZ2UuZGF0YSgnanVzdEFkZGVkJywgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGN5LmVuZEJhdGNoKCk7XG5cbiAgICAgIGNvbnN0IGVsZXMgPSBjeS5lbGVtZW50cygnW2p1c3RBZGRlZF0nKTtcbiAgICAgIGVsZXMucmVtb3ZlRGF0YSgnanVzdEFkZGVkJyk7XG5cbiAgICAgIGN5LmVsZW1lbnRzKCkudW5zZWxlY3QoKTtcbiAgICAgIGVsZXMuc2VsZWN0KCk7XG5cbiAgICAgIHJldHVybiBlbGVzO1xuICAgIH07XG5cbiAgICBlbGVtZW50VXRpbGl0aWVzLmNyZWF0ZU1ldGFib2xpY1JlYWN0aW9uID0gZnVuY3Rpb24gKGlucHV0cywgb3V0cHV0cywgcmV2ZXJzaWJsZSwgcmVndWxhdG9yLCByZWd1bGF0b3JNdWx0aW1lciwgb3JpZW50YXRpb24pIHtcbiAgICAgIGxldCByb3RhdGU5MCA9IGZ1bmN0aW9uKHBvaW50LCBjZW50ZXIpIHtcbiAgICAgICAgY29uc3QgcmVsYXRpdmVYID0gY2VudGVyLnggLSBwb2ludC54O1xuICAgICAgICBjb25zdCByZWxhdGl2ZVkgPSBjZW50ZXIueSAtIHBvaW50Lnk7XG5cbiAgICAgICAgY29uc3QgcmVsYXRpdmVSb3RhdGVkWCA9IHJlbGF0aXZlWTtcbiAgICAgICAgY29uc3QgcmVsYXRpdmVSb3RhdGVkWSA9IC0xICogcmVsYXRpdmVYO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdFggPSByZWxhdGl2ZVJvdGF0ZWRYICsgY2VudGVyLng7XG4gICAgICAgIGNvbnN0IHJlc3VsdFkgPSByZWxhdGl2ZVJvdGF0ZWRZICsgY2VudGVyLnk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiByZXN1bHRYLFxuICAgICAgICAgIHk6IHJlc3VsdFlcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGhhc1JlZ3VsYXRvciA9IHJlZ3VsYXRvci5uYW1lICE9PSB1bmRlZmluZWQ7XG4gICAgICBjb25zdCBkZWZhdWx0U2ltcGxlQ2hlbWljYWxQcm9wZXJ0aWVzID0gZWxlbWVudFV0aWxpdGllcy5nZXREZWZhdWx0UHJvcGVydGllcyggXCJzaW1wbGUgY2hlbWljYWxcIiApO1xuICAgICAgY29uc3QgZGVmYXVsdFJlZ3VsYXRvclByb3BlcnRpZXMgPSBoYXNSZWd1bGF0b3IgPyBlbGVtZW50VXRpbGl0aWVzLmdldERlZmF1bHRQcm9wZXJ0aWVzKHJlZ3VsYXRvci50eXBlKSA6IHt9O1xuICAgICAgY29uc3QgZGVmYXVsdFByb2Nlc3NQcm9wZXJ0aWVzID0gZWxlbWVudFV0aWxpdGllcy5nZXREZWZhdWx0UHJvcGVydGllcyhcImNhdGFseXRpY1wiKTtcbiAgICAgIGNvbnN0IHByb2Nlc3NXaWR0aCA9IGRlZmF1bHRQcm9jZXNzUHJvcGVydGllcy53aWR0aCB8fCA1MDtcbiAgICAgIGNvbnN0IHByb2Nlc3NIZWlnaHQgPSBkZWZhdWx0UHJvY2Vzc1Byb3BlcnRpZXMuaGVpZ2h0IHx8IDUwO1xuICAgICAgY29uc3Qgc2ltcGxlQ2hlbWljYWxIZWlnaHQgPSBkZWZhdWx0U2ltcGxlQ2hlbWljYWxQcm9wZXJ0aWVzLmhlaWdodCB8fCAzNTtcbiAgICAgIGNvbnN0IHNpbXBsZUNoZW1pY2FsV2lkdGggPSBkZWZhdWx0U2ltcGxlQ2hlbWljYWxQcm9wZXJ0aWVzLndpZHRoIHx8IDM1O1xuICAgICAgY29uc3QgcmVndWxhdG9ySGVpZ2h0ID0gZGVmYXVsdFJlZ3VsYXRvclByb3BlcnRpZXMuaGVpZ2h0IHx8IDUwO1xuICAgICAgY29uc3QgcHJvY2Vzc1Bvc2l0aW9uID0gZWxlbWVudFV0aWxpdGllcy5jb252ZXJ0VG9Nb2RlbFBvc2l0aW9uKHt4OiBjeS53aWR0aCgpIC8gMiwgeTogY3kuaGVpZ2h0KCkgLyAyfSk7XG4gICAgICBjb25zdCB0aWxpbmdQYWRkaW5nVmVydGljYWwgPSAxNTtcbiAgICAgIGNvbnN0IGVkZ2VMZW5ndGggPSAzMDtcbiAgICAgIGNvbnN0IHByb2Nlc3NMZWZ0U2lkZUVkZ2VUeXBlID0gcmV2ZXJzaWJsZSA/IFwicHJvZHVjdGlvblwiIDogXCJjb25zdW1wdGlvblwiO1xuICAgICAgY29uc3QgcHJvY2Vzc1JpZ2h0U2lkZUVkZ2VUeXBlID0gXCJwcm9kdWN0aW9uXCI7XG4gICAgICBjb25zdCBwcm9jZXNzUG9ydHNPcmRlcmluZyA9IG9yaWVudGF0aW9uID09PSBcInZlcnRpY2FsXCIgPyBcIlQtdG8tQlwiIDogXCJMLXRvLVJcIjtcbiAgICAgIGNvbnN0IG11bHRpbWVyT2Zmc2V0ID0gNjtcblxuICAgICAgY3kuc3RhcnRCYXRjaCgpO1xuICAgICAgaWYgKCFlbGVtZW50VXRpbGl0aWVzLmdldE1hcFR5cGUoKSkge1xuICAgICAgICBlbGVtZW50VXRpbGl0aWVzLnNldE1hcFR5cGUoXCJQRFwiKTtcbiAgICAgIH1cblxuICAgICAgbGV0IHhQb3NPZklucHV0ID0gcHJvY2Vzc1Bvc2l0aW9uLnggLSBlZGdlTGVuZ3RoIC0gcHJvY2Vzc1dpZHRoIC8gMiAtIHNpbXBsZUNoZW1pY2FsV2lkdGggLyAyO1xuICAgICAgbGV0IHhQb3NPZk91dHB1dCA9IHByb2Nlc3NQb3NpdGlvbi54ICsgZWRnZUxlbmd0aCArIHByb2Nlc3NXaWR0aCAvIDIgKyBzaW1wbGVDaGVtaWNhbFdpZHRoIC8gMjtcblxuXG4gICAgICBsZXQgcHJvY2Vzc05vZGUgPSBlbGVtZW50VXRpbGl0aWVzLmFkZE5vZGUocHJvY2Vzc1Bvc2l0aW9uLngsIHByb2Nlc3NQb3NpdGlvbi55LCB7Y2xhc3M6IFwicHJvY2Vzc1wiLCBsYW5ndWFnZTogXCJQRFwifSk7XG4gICAgICBlbGVtZW50VXRpbGl0aWVzLnNldFBvcnRzT3JkZXJpbmcocHJvY2Vzc05vZGUsIHByb2Nlc3NQb3J0c09yZGVyaW5nKTtcbiAgICAgIHByb2Nlc3NOb2RlLmRhdGEoJ2p1c3RBZGRlZCcsIHRydWUpO1xuXG4gICAgICBjb25zdCBudW1PZklucHV0Tm9kZXMgPSBpbnB1dHMubGVuZ3RoO1xuICAgICAgY29uc3QgbnVtT2ZPdXRwdXROb2RlcyA9IG91dHB1dHMubGVuZ3RoO1xuXG4gICAgICBsZXQgeVBvc09mSW5wdXQgPSBwcm9jZXNzUG9zaXRpb24ueSAtICgobnVtT2ZJbnB1dE5vZGVzIC0gMSkgLyAyKSAqIChzaW1wbGVDaGVtaWNhbEhlaWdodCArIHRpbGluZ1BhZGRpbmdWZXJ0aWNhbCk7XG5cbiAgICAgIGlucHV0cy5mb3JFYWNoKGZ1bmN0aW9uKGRhdGEsIGluZGV4KSB7XG4gICAgICAgIGNvbnN0IG5vZGVOYW1lID0gZGF0YS5uYW1lO1xuICAgICAgICBjb25zdCBub2RlVHlwZSA9IGRhdGEudHlwZTtcblxuICAgICAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgICB5UG9zT2ZJbnB1dCA9IHByb2Nlc3NQb3NpdGlvbi55O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGluZGV4ICUgMiA9PT0gMSkge1xuICAgICAgICAgIHlQb3NPZklucHV0ID0gcHJvY2Vzc1Bvc2l0aW9uLnkgLSAoKHNpbXBsZUNoZW1pY2FsSGVpZ2h0ICsgdGlsaW5nUGFkZGluZ1ZlcnRpY2FsKSAqIE1hdGguY2VpbChpbmRleCAvIDIpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB5UG9zT2ZJbnB1dCA9IHByb2Nlc3NQb3NpdGlvbi55ICsgKChzaW1wbGVDaGVtaWNhbEhlaWdodCArIHRpbGluZ1BhZGRpbmdWZXJ0aWNhbCkgKiAoaW5kZXggLyAyKSk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbm9kZVBvc2l0aW9uID0ge1xuICAgICAgICAgIHg6IHhQb3NPZklucHV0LFxuICAgICAgICAgIHk6IHlQb3NPZklucHV0XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9yaWVudGF0aW9uID09PSBcInZlcnRpY2FsXCIpIHtcbiAgICAgICAgICBub2RlUG9zaXRpb24gPSByb3RhdGU5MChub2RlUG9zaXRpb24sIHByb2Nlc3NQb3NpdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbmV3Tm9kZSA9IGVsZW1lbnRVdGlsaXRpZXMuYWRkTm9kZShub2RlUG9zaXRpb24ueCwgbm9kZVBvc2l0aW9uLnksIHtjbGFzczogbm9kZVR5cGUudG9Mb3dlckNhc2UoKSwgbGFuZ3VhZ2U6IFwiUERcIn0pO1xuICAgICAgICBuZXdOb2RlLmRhdGEoXCJqdXN0QWRkZWRcIiwgdHJ1ZSk7XG4gICAgICAgIG5ld05vZGUuZGF0YShcImxhYmVsXCIsIG5vZGVOYW1lKTtcblxuICAgICAgICBsZXQgbmV3RWRnZTtcbiAgICAgICAgaWYgKHJldmVyc2libGUpIHtcbiAgICAgICAgICBuZXdFZGdlID0gZWxlbWVudFV0aWxpdGllcy5hZGRFZGdlKHByb2Nlc3NOb2RlLmlkKCksIG5ld05vZGUuaWQoKSwge2NsYXNzOiBwcm9jZXNzTGVmdFNpZGVFZGdlVHlwZSwgbGFuZ3VhZ2U6IFwiUERcIn0sIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCAxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBuZXdFZGdlID0gZWxlbWVudFV0aWxpdGllcy5hZGRFZGdlKG5ld05vZGUuaWQoKSwgcHJvY2Vzc05vZGUuaWQoKSwge2NsYXNzOiBwcm9jZXNzTGVmdFNpZGVFZGdlVHlwZSwgbGFuZ3VhZ2U6IFwiUERcIn0pO1xuICAgICAgICB9XG4gICAgICAgIG5ld0VkZ2UuZGF0YShcImp1c3RBZGRlZFwiLCB0cnVlKTtcbiAgICAgIH0pO1xuXG4gICAgICBsZXQgeVBvc09mT3V0cHV0ID0gcHJvY2Vzc1Bvc2l0aW9uLnkgLSAoKG51bU9mT3V0cHV0Tm9kZXMgLSAxKSAvIDIpICogKHNpbXBsZUNoZW1pY2FsSGVpZ2h0ICsgdGlsaW5nUGFkZGluZ1ZlcnRpY2FsKTtcblxuICAgICAgb3V0cHV0cy5mb3JFYWNoKGZ1bmN0aW9uKGRhdGEsIGluZGV4KSB7XG4gICAgICAgIGNvbnN0IG5vZGVOYW1lID0gZGF0YS5uYW1lO1xuICAgICAgICBjb25zdCBub2RlVHlwZSA9IGRhdGEudHlwZTtcblxuICAgICAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgICB5UG9zT2ZPdXRwdXQgPSBwcm9jZXNzUG9zaXRpb24ueTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbmRleCAlIDIgPT09IDEpIHtcbiAgICAgICAgICB5UG9zT2ZPdXRwdXQgPSBwcm9jZXNzUG9zaXRpb24ueSAtICgoc2ltcGxlQ2hlbWljYWxIZWlnaHQgKyB0aWxpbmdQYWRkaW5nVmVydGljYWwpICogTWF0aC5jZWlsKGluZGV4IC8gMikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHlQb3NPZk91dHB1dCA9IHByb2Nlc3NQb3NpdGlvbi55ICsgKChzaW1wbGVDaGVtaWNhbEhlaWdodCArIHRpbGluZ1BhZGRpbmdWZXJ0aWNhbCkgKiAoaW5kZXggLyAyKSk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbm9kZVBvc2l0aW9uID0ge1xuICAgICAgICAgIHg6IHhQb3NPZk91dHB1dCxcbiAgICAgICAgICB5OiB5UG9zT2ZPdXRwdXRcbiAgICAgICAgfVxuICAgICAgICBpZiAob3JpZW50YXRpb24gPT09IFwidmVydGljYWxcIikge1xuICAgICAgICAgIG5vZGVQb3NpdGlvbiA9IHJvdGF0ZTkwKG5vZGVQb3NpdGlvbiwgcHJvY2Vzc1Bvc2l0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBuZXdOb2RlID0gZWxlbWVudFV0aWxpdGllcy5hZGROb2RlKG5vZGVQb3NpdGlvbi54LCBub2RlUG9zaXRpb24ueSwge2NsYXNzOiBub2RlVHlwZS50b0xvd2VyQ2FzZSgpLCBsYW5ndWFnZTogXCJQRFwifSk7XG4gICAgICAgIG5ld05vZGUuZGF0YShcImp1c3RBZGRlZFwiLCB0cnVlKTtcbiAgICAgICAgbmV3Tm9kZS5kYXRhKFwibGFiZWxcIiwgbm9kZU5hbWUpO1xuXG4gICAgICAgIGxldCBuZXdFZGdlID0gZWxlbWVudFV0aWxpdGllcy5hZGRFZGdlKHByb2Nlc3NOb2RlLmlkKCksIG5ld05vZGUuaWQoKSwge2NsYXNzOiBwcm9jZXNzUmlnaHRTaWRlRWRnZVR5cGUsIGxhbmd1YWdlOiBcIlBEXCJ9LCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgMCk7XG4gICAgICAgIG5ld0VkZ2UuZGF0YShcImp1c3RBZGRlZFwiLCB0cnVlKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBhZGQgcmVndWxhdG9yIG5vZGVcbiAgICAgIGlmIChoYXNSZWd1bGF0b3IpIHtcbiAgICAgICAgY29uc3QgcmVndWxhdG9yTmFtZSA9IHJlZ3VsYXRvci5uYW1lO1xuICAgICAgICBjb25zdCByZWd1bGF0b3JUeXBlID0gcmVndWxhdG9yLnR5cGU7XG4gICAgICAgIGxldCB4UG9zT2ZSZWd1bGF0b3IgPSBwcm9jZXNzUG9zaXRpb24ueDtcbiAgICAgICAgaWYgKHJlZ3VsYXRvck11bHRpbWVyLmVuYWJsZWQgJiYgb3JpZW50YXRpb24gPT09IFwiaG9yaXpvbnRhbFwiKSB7XG4gICAgICAgICAgeFBvc09mUmVndWxhdG9yIC09IG11bHRpbWVyT2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIGxldCB5UG9zT2ZSZWd1bGF0b3IgPSBwcm9jZXNzUG9zaXRpb24ueSAtICgocHJvY2Vzc0hlaWdodCAvIDIpICsgKHJlZ3VsYXRvckhlaWdodCAvIDIpICsgZWRnZUxlbmd0aCk7IFxuXG4gICAgICAgIGxldCBub2RlUG9zaXRpb24gPSB7XG4gICAgICAgICAgeDogeFBvc09mUmVndWxhdG9yLFxuICAgICAgICAgIHk6IHlQb3NPZlJlZ3VsYXRvclxuICAgICAgICB9XG4gICAgICAgIGlmIChvcmllbnRhdGlvbiA9PT0gXCJ2ZXJ0aWNhbFwiKSB7XG4gICAgICAgICAgbm9kZVBvc2l0aW9uID0gcm90YXRlOTAobm9kZVBvc2l0aW9uLCBwcm9jZXNzUG9zaXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHJlZ3VsYXRvck5vZGUgPSBlbGVtZW50VXRpbGl0aWVzLmFkZE5vZGUobm9kZVBvc2l0aW9uLngsIG5vZGVQb3NpdGlvbi55LCB7Y2xhc3M6IHJlZ3VsYXRvclR5cGUsIGxhbmd1YWdlOiAnUEQnfSk7XG4gICAgICAgIHJlZ3VsYXRvck5vZGUuZGF0YSgnanVzdEFkZGVkJywgdHJ1ZSk7XG4gICAgICAgIHJlZ3VsYXRvck5vZGUuZGF0YSgnbGFiZWwnLCByZWd1bGF0b3JOYW1lKTtcblxuICAgICAgICBpZiAocmVndWxhdG9yTXVsdGltZXIuZW5hYmxlZCkge1xuICAgICAgICAgIGVsZW1lbnRVdGlsaXRpZXMuc2V0TXVsdGltZXJTdGF0dXMocmVndWxhdG9yTm9kZSwgdHJ1ZSk7XG5cbiAgICAgICAgICBjb25zdCBjYXJkaW5hbGl0eSA9IHJlZ3VsYXRvck11bHRpbWVyLmNhcmRpbmFsaXR5O1xuICAgICAgICAgIGlmIChjYXJkaW5hbGl0eSAhPSAnJykge1xuICAgICAgICAgICAgY29uc3QgaW5mb2JveExhYmVsID0gXCJOOlwiICsgY2FyZGluYWxpdHk7XG4gICAgICAgICAgICBpbmZvYm94T2JqZWN0ID0ge1xuICAgICAgICAgICAgICBjbGF6ejogXCJ1bml0IG9mIGluZm9ybWF0aW9uXCIsXG4gICAgICAgICAgICAgIGxhYmVsOiB7XG4gICAgICAgICAgICAgICAgdGV4dDogaW5mb2JveExhYmVsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGJib3g6IHtcbiAgICAgICAgICAgICAgICB3OiBpbmZvYm94TGFiZWwubGVuZ3RoICogNixcbiAgICAgICAgICAgICAgICBoOiAxNVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBlbGVtZW50VXRpbGl0aWVzLmFkZFN0YXRlT3JJbmZvQm94KHJlZ3VsYXRvck5vZGUsIGluZm9ib3hPYmplY3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCByZWd1bGF0b3JFZGdlID0gZWxlbWVudFV0aWxpdGllcy5hZGRFZGdlKHJlZ3VsYXRvck5vZGUuaWQoKSwgcHJvY2Vzc05vZGUuaWQoKSwge2NsYXNzOiAnY2F0YWx5c2lzJywgbGFuZ3VhZ2U6ICdQRCd9KTtcbiAgICAgICAgcmVndWxhdG9yRWRnZS5kYXRhKCdqdXN0QWRkZWQnLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgY3kuZW5kQmF0Y2goKTtcblxuICAgICAgY29uc3QgZWxlcyA9IGN5LmVsZW1lbnRzKCdbanVzdEFkZGVkXScpO1xuICAgICAgZWxlcy5yZW1vdmVEYXRhKCdqdXN0QWRkZWQnKTtcblxuICAgICAgY3kuZWxlbWVudHMoKS51bnNlbGVjdCgpO1xuICAgICAgZWxlcy5zZWxlY3QoKTtcblxuICAgICAgcmV0dXJuIGVsZXM7XG4gICAgfTtcblxuICAgIGVsZW1lbnRVdGlsaXRpZXMuY3JlYXRlTWV0YWJvbGljQ2F0YWx5dGljQWN0aXZpdHkgPSBmdW5jdGlvbihpbnB1dE5vZGVMaXN0LCBvdXRwdXROb2RlTGlzdCwgY2F0YWx5c3ROYW1lLCBjYXRhbHlzdFR5cGUsIHByb2Nlc3NQb3NpdGlvbiwgdGlsaW5nUGFkZGluZ1ZlcnRpY2FsLCB0aWxpbmdQYWRkaW5nSG9yaXpvbnRhbCwgZWRnZUxlbmd0aCkge1xuICAgICAgdmFyIGRlZmF1bHRNYWNyb21vbGVjdWxQcm9wZXJ0aWVzID0gZWxlbWVudFV0aWxpdGllcy5nZXREZWZhdWx0UHJvcGVydGllcyggXCJtYWNyb21vbGVjdWxlXCIgKTtcbiAgICAgIHZhciBkZWZhdWx0U2ltcGxlQ2hlbWljYWxQcm9wZXJ0aWVzID0gZWxlbWVudFV0aWxpdGllcy5nZXREZWZhdWx0UHJvcGVydGllcyggXCJzaW1wbGUgY2hlbWljYWxcIiApO1xuICAgICAgdmFyIGRlZmF1bHRDYXRhbHlzdFR5cGVQcm9wZXJ0aWVzID0gZWxlbWVudFV0aWxpdGllcy5nZXREZWZhdWx0UHJvcGVydGllcyhjYXRhbHlzdFR5cGUpO1xuICAgICAgdmFyIGRlZmF1bHRQcm9jZXNzUHJvcGVydGllcyA9IGVsZW1lbnRVdGlsaXRpZXMuZ2V0RGVmYXVsdFByb3BlcnRpZXMoXCJjYXRhbHl0aWNcIik7XG4gICAgICB2YXIgcHJvY2Vzc1dpZHRoID0gZGVmYXVsdFByb2Nlc3NQcm9wZXJ0aWVzLndpZHRoIHx8IDUwO1xuICAgICAgdmFyIHByb2Nlc3NIZWlnaHQgPSBkZWZhdWx0UHJvY2Vzc1Byb3BlcnRpZXMuaGVpZ2h0IHx8IDUwO1xuICAgICAgdmFyIHNpbXBsZUNoZW1pY2FsSGVpZ2h0ID0gZGVmYXVsdFNpbXBsZUNoZW1pY2FsUHJvcGVydGllcy5oZWlnaHQgfHwgMzU7XG4gICAgICB2YXIgbWFjcm9tb2xlY3VsZVdpZHRoID0gZGVmYXVsdE1hY3JvbW9sZWN1bFByb3BlcnRpZXMud2lkdGggfHwgNTA7XG4gICAgICB2YXIgbWFjcm9tb2xlY3VsZUhlaWdodCA9IGRlZmF1bHRNYWNyb21vbGVjdWxQcm9wZXJ0aWVzLmhlaWdodCB8fCA1MDtcbiAgICAgIHZhciBjYXRhbHlzdEhlaWdodCA9IGRlZmF1bHRDYXRhbHlzdFR5cGVQcm9wZXJ0aWVzLmhlaWdodCB8fCA1MDtcbiAgICAgIHZhciBwcm9jZXNzUG9zaXRpb24gPSBwcm9jZXNzUG9zaXRpb24gfHwgZWxlbWVudFV0aWxpdGllcy5jb252ZXJ0VG9Nb2RlbFBvc2l0aW9uKHt4OiBjeS53aWR0aCgpIC8gMiwgeTogY3kuaGVpZ2h0KCkgLyAyfSk7XG4gICAgICB2YXIgdGlsaW5nUGFkZGluZ1ZlcnRpY2FsID0gdGlsaW5nUGFkZGluZ1ZlcnRpY2FsIHx8IDE1O1xuICAgICAgdmFyIHRpbGluZ1BhZGRpbmdIb3Jpem9udGFsID0gdGlsaW5nUGFkZGluZ0hvcml6b250YWwgfHwgMTU7XG4gICAgICB2YXIgZWRnZUxlbmd0aCA9IGVkZ2VMZW5ndGggfHwgNjA7XG5cbiAgICAgIGN5LnN0YXJ0QmF0Y2goKTtcbiAgICAgIGlmICghZWxlbWVudFV0aWxpdGllcy5nZXRNYXBUeXBlKCkpIHtcbiAgICAgICAgZWxlbWVudFV0aWxpdGllcy5zZXRNYXBUeXBlKFwiUERcIik7XG4gICAgICB9XG5cbiAgICAgIHZhciB4UG9zT2ZJbnB1dCA9IHByb2Nlc3NQb3NpdGlvbi54IC0gZWRnZUxlbmd0aCAtIHByb2Nlc3NXaWR0aCAvIDIgLSBtYWNyb21vbGVjdWxlV2lkdGggLyAyO1xuICAgICAgdmFyIHhQb3NPZk91dHB1dCA9IHByb2Nlc3NQb3NpdGlvbi54ICsgZWRnZUxlbmd0aCArIHByb2Nlc3NXaWR0aCAvIDIgKyBtYWNyb21vbGVjdWxlV2lkdGggLyAyO1xuXG4gICAgICB2YXIgcHJvY2Vzc05vZGUgPSBlbGVtZW50VXRpbGl0aWVzLmFkZE5vZGUocHJvY2Vzc1Bvc2l0aW9uLngsIHByb2Nlc3NQb3NpdGlvbi55LCB7Y2xhc3M6IFwicHJvY2Vzc1wiLCBsYW5ndWFnZTogXCJQRFwifSk7XG4gICAgICBlbGVtZW50VXRpbGl0aWVzLnNldFBvcnRzT3JkZXJpbmcocHJvY2Vzc05vZGUsIFwiTC10by1SXCIpO1xuICAgICAgcHJvY2Vzc05vZGUuZGF0YSgnanVzdEFkZGVkJywgdHJ1ZSk7XG5cbiAgICAgIGNvbnN0IG51bU9mSW5wdXROb2RlcyA9IGlucHV0Tm9kZUxpc3QubGVuZ3RoO1xuICAgICAgY29uc3QgbnVtT2ZPdXRwdXROb2RlcyA9IG91dHB1dE5vZGVMaXN0Lmxlbmd0aDtcbiAgICAgIHZhciB5UG9zT2ZJbnB1dCA9IHByb2Nlc3NQb3NpdGlvbi55IC0gKChudW1PZklucHV0Tm9kZXMgLSAxKSAvIDIpICogKG1hY3JvbW9sZWN1bGVIZWlnaHQgKyB0aWxpbmdQYWRkaW5nVmVydGljYWwpO1xuXG4gICAgICAvLyBhZGQgaW5wdXQgc2lkZSBub2Rlc1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1PZklucHV0Tm9kZXM7IGkrKykge1xuICAgICAgICBpZihpbnB1dE5vZGVMaXN0W2ldLnR5cGUgPT0gXCJTaW1wbGUgQ2hlbWljYWxcIil7XG4gICAgICAgICAgdmFyIG5ld05vZGUgPSBlbGVtZW50VXRpbGl0aWVzLmFkZE5vZGUoeFBvc09mSW5wdXQsIHlQb3NPZklucHV0LCB7Y2xhc3MgOiAnc2ltcGxlIGNoZW1pY2FsJywgbGFuZ3VhZ2UgOiAnUEQnfSk7XG4gICAgICAgICAgeVBvc09mSW5wdXQgKz0gc2ltcGxlQ2hlbWljYWxIZWlnaHQgKyB0aWxpbmdQYWRkaW5nVmVydGljYWw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZXtcbiAgICAgICAgICB2YXIgbmV3Tm9kZSA9IGVsZW1lbnRVdGlsaXRpZXMuYWRkTm9kZSh4UG9zT2ZJbnB1dCwgeVBvc09mSW5wdXQsIHtjbGFzcyA6ICdtYWNyb21vbGVjdWxlJywgbGFuZ3VhZ2UgOiAnUEQnfSk7XG4gICAgICAgICAgLy91cGRhdGUgdGhlIHkgcG9zaXRpb25cbiAgICAgICAgICB5UG9zT2ZJbnB1dCArPSBtYWNyb21vbGVjdWxlSGVpZ2h0ICsgdGlsaW5nUGFkZGluZ1ZlcnRpY2FsO1xuICAgICAgICB9XG4gICAgICAgIG5ld05vZGUuZGF0YSgnanVzdEFkZGVkJywgdHJ1ZSk7XG4gICAgICAgIG5ld05vZGUuZGF0YSgnbGFiZWwnLCBpbnB1dE5vZGVMaXN0W2ldLm5hbWUpO1xuXG4gICAgICAgIHZhciBuZXdFZGdlID0gZWxlbWVudFV0aWxpdGllcy5hZGRFZGdlKG5ld05vZGUuaWQoKSwgcHJvY2Vzc05vZGUuaWQoKSwge2NsYXNzIDogJ2NvbnN1bXB0aW9uJywgbGFuZ3VhZ2UgOiAnUEQnfSk7XG4gICAgICAgIG5ld0VkZ2UuZGF0YSgnanVzdEFkZGVkJywgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHZhciB5UG9zT2ZPdXRwdXQgPSBwcm9jZXNzUG9zaXRpb24ueSAtICgobnVtT2ZPdXRwdXROb2RlcyAtIDEpIC8gMikgKiAobWFjcm9tb2xlY3VsZUhlaWdodCArIHRpbGluZ1BhZGRpbmdWZXJ0aWNhbCk7XG5cbiAgICAgIC8vIGFkZCBvdXRwdXQgc2lkZSBub2Rlc1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1PZk91dHB1dE5vZGVzOyBpKyspIHtcbiAgICAgICAgaWYob3V0cHV0Tm9kZUxpc3RbaV0udHlwZSA9PSBcIlNpbXBsZSBDaGVtaWNhbFwiKXtcbiAgICAgICAgICB2YXIgbmV3Tm9kZSA9IGVsZW1lbnRVdGlsaXRpZXMuYWRkTm9kZSh4UG9zT2ZPdXRwdXQsIHlQb3NPZk91dHB1dCwge2NsYXNzIDogJ3NpbXBsZSBjaGVtaWNhbCcsIGxhbmd1YWdlIDogJ1BEJ30pO1xuICAgICAgICAgIHlQb3NPZk91dHB1dCArPSBzaW1wbGVDaGVtaWNhbEhlaWdodCArIHRpbGluZ1BhZGRpbmdWZXJ0aWNhbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNle1xuICAgICAgICAgIHZhciBuZXdOb2RlID0gZWxlbWVudFV0aWxpdGllcy5hZGROb2RlKHhQb3NPZk91dHB1dCwgeVBvc09mT3V0cHV0LCB7Y2xhc3MgOiAnbWFjcm9tb2xlY3VsZScsIGxhbmd1YWdlIDogJ1BEJ30pO1xuICAgICAgICAgIC8vdXBkYXRlIHRoZSB5IHBvc2l0aW9uXG4gICAgICAgICAgeVBvc09mT3V0cHV0ICs9IG1hY3JvbW9sZWN1bGVIZWlnaHQgKyB0aWxpbmdQYWRkaW5nVmVydGljYWw7XG4gICAgICAgIH1cbiAgICAgICAgbmV3Tm9kZS5kYXRhKCdqdXN0QWRkZWQnLCB0cnVlKTtcbiAgICAgICAgbmV3Tm9kZS5kYXRhKCdsYWJlbCcsIG91dHB1dE5vZGVMaXN0W2ldLm5hbWUpO1xuXG4gICAgICAgIHZhciBuZXdFZGdlID0gZWxlbWVudFV0aWxpdGllcy5hZGRFZGdlKHByb2Nlc3NOb2RlLmlkKCksIG5ld05vZGUuaWQoKSwge2NsYXNzIDogJ3Byb2R1Y3Rpb24nLCBsYW5ndWFnZSA6ICdQRCd9KTtcbiAgICAgICAgbmV3RWRnZS5kYXRhKCdqdXN0QWRkZWQnLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgLy8gYWRkIGNhdGFseXN0IG5vZGVcbiAgICAgIHZhciB4UG9zT2ZDYXRhbHlzdCA9IHByb2Nlc3NQb3NpdGlvbi54O1xuICAgICAgdmFyIHlQb3NPZkNhdGFseXN0ID0gcHJvY2Vzc1Bvc2l0aW9uLnkgLSAocHJvY2Vzc0hlaWdodCArIGNhdGFseXN0SGVpZ2h0ICsgdGlsaW5nUGFkZGluZ1ZlcnRpY2FsKTsgXG4gICAgICB2YXIgY2F0YWx5c3ROb2RlID0gZWxlbWVudFV0aWxpdGllcy5hZGROb2RlKHhQb3NPZkNhdGFseXN0LCB5UG9zT2ZDYXRhbHlzdCwge2NsYXNzOiBjYXRhbHlzdFR5cGUsIGxhbmd1YWdlOiAnUEQnfSk7XG4gICAgICBjYXRhbHlzdE5vZGUuZGF0YSgnanVzdEFkZGVkJywgdHJ1ZSk7XG4gICAgICBjYXRhbHlzdE5vZGUuZGF0YSgnbGFiZWwnLCBjYXRhbHlzdE5hbWUpO1xuXG4gICAgICB2YXIgY2F0YWx5c3RFZGdlID0gZWxlbWVudFV0aWxpdGllcy5hZGRFZGdlKGNhdGFseXN0Tm9kZS5pZCgpLCBwcm9jZXNzTm9kZS5pZCgpLCB7Y2xhc3M6ICdjYXRhbHlzaXMnLCBsYW5ndWFnZTogJ1BEJ30pO1xuICAgICAgY2F0YWx5c3RFZGdlLmRhdGEoJ2p1c3RBZGRlZCcsIHRydWUpO1xuXG4gICAgICBjeS5lbmRCYXRjaCgpO1xuXG4gICAgICAvL2ZpbHRlciB0aGUganVzdCBhZGRlZCBlbGVtZW10cyB0byByZXR1cm4gdGhlbSBhbmQgcmVtb3ZlIGp1c3QgYWRkZWQgbWFya1xuICAgICAgdmFyIGVsZXMgPSBjeS5lbGVtZW50cygnW2p1c3RBZGRlZF0nKTtcbiAgICAgIGVsZXMucmVtb3ZlRGF0YSgnanVzdEFkZGVkJyk7XG5cbiAgICAgIGN5LmVsZW1lbnRzKCkudW5zZWxlY3QoKTtcbiAgICAgIGVsZXMuc2VsZWN0KCk7XG5cbiAgICAgIHJldHVybiBlbGVzOyAvLyBSZXR1cm4gdGhlIGp1c3QgYWRkZWQgZWxlbWVudHNcbiAgICB9XG5cbiAgICBlbGVtZW50VXRpbGl0aWVzLmNyZWF0ZUFjdGl2YXRpb25SZWFjdGlvbiA9IGZ1bmN0aW9uIChwcm90ZWluTmFtZSwgcHJvY2Vzc1Bvc2l0aW9uLCBlZGdlTGVuZ3RoLCByZXZlcnNlKSB7XG4gICAgICB2YXIgZGVmYXVsdE1hY3JvbW9sZWN1bFByb3BlcnRpZXMgPSBlbGVtZW50VXRpbGl0aWVzLmdldERlZmF1bHRQcm9wZXJ0aWVzKCBcIm1hY3JvbW9sZWN1bGVcIiApO1xuICAgICAgdmFyIGRlZmF1bHRQcm9jZXNzUHJvcGVydGllcyA9IGVsZW1lbnRVdGlsaXRpZXMuZ2V0RGVmYXVsdFByb3BlcnRpZXMoXCJhY3RpdmF0aW9uXCIpO1xuICAgICAgdmFyIHByb2Nlc3NXaWR0aCA9IGRlZmF1bHRQcm9jZXNzUHJvcGVydGllcy53aWR0aCB8fCA1MDtcbiAgICAgIHZhciBtYWNyb21vbGVjdWxlV2lkdGggPSBkZWZhdWx0TWFjcm9tb2xlY3VsUHJvcGVydGllcy53aWR0aCB8fCA1MDtcbiAgICAgIHZhciBwcm9jZXNzUG9zaXRpb24gPSBwcm9jZXNzUG9zaXRpb24gfHwgZWxlbWVudFV0aWxpdGllcy5jb252ZXJ0VG9Nb2RlbFBvc2l0aW9uKHt4OiBjeS53aWR0aCgpIC8gMiwgeTogY3kuaGVpZ2h0KCkgLyAyfSk7XG4gICAgICB2YXIgZWRnZUxlbmd0aCA9IGVkZ2VMZW5ndGggfHwgNjA7XG5cbiAgICAgIGN5LnN0YXJ0QmF0Y2goKTtcbiAgICAgIGlmICghZWxlbWVudFV0aWxpdGllcy5nZXRNYXBUeXBlKCkpIHtcbiAgICAgICAgZWxlbWVudFV0aWxpdGllcy5zZXRNYXBUeXBlKFwiUERcIik7XG4gICAgICB9XG5cbiAgICAgIHZhciB4UG9zT2ZJbnB1dCA9IHByb2Nlc3NQb3NpdGlvbi54IC0gZWRnZUxlbmd0aCAtIHByb2Nlc3NXaWR0aCAvIDIgLSBtYWNyb21vbGVjdWxlV2lkdGggLyAyO1xuICAgICAgdmFyIHhQb3NPZk91dHB1dCA9IHByb2Nlc3NQb3NpdGlvbi54ICsgZWRnZUxlbmd0aCArIHByb2Nlc3NXaWR0aCAvIDIgKyBtYWNyb21vbGVjdWxlV2lkdGggLyAyO1xuXG4gICAgICB2YXIgcHJvY2Vzc05vZGUgPSBlbGVtZW50VXRpbGl0aWVzLmFkZE5vZGUocHJvY2Vzc1Bvc2l0aW9uLngsIHByb2Nlc3NQb3NpdGlvbi55LCB7Y2xhc3M6IFwicHJvY2Vzc1wiLCBsYW5ndWFnZTogXCJQRFwifSk7XG4gICAgICBlbGVtZW50VXRpbGl0aWVzLnNldFBvcnRzT3JkZXJpbmcocHJvY2Vzc05vZGUsIFwiTC10by1SXCIpO1xuICAgICAgcHJvY2Vzc05vZGUuZGF0YSgnanVzdEFkZGVkJywgdHJ1ZSk7XG5cbiAgICAgIHZhciB5UG9zaXRpb24gPSBwcm9jZXNzUG9zaXRpb24ueTtcblxuICAgICAgdmFyIGlucHV0Tm9kZSA9IGVsZW1lbnRVdGlsaXRpZXMuYWRkTm9kZSh4UG9zT2ZJbnB1dCwgeVBvc2l0aW9uLCB7Y2xhc3M6IFwibWFjcm9tb2xlY3VsZVwiLCBsYW5ndWFnZTogXCJQRFwifSk7XG4gICAgICBpbnB1dE5vZGUuZGF0YShcImp1c3RBZGRlZFwiLCB0cnVlKTtcbiAgICAgIGlucHV0Tm9kZS5kYXRhKFwibGFiZWxcIiwgcHJvdGVpbk5hbWUpO1xuICAgICAgdmFyIGluZm9ib3hPYmplY3QgPSB7XG4gICAgICAgIGNsYXp6OiBcInVuaXQgb2YgaW5mb3JtYXRpb25cIixcbiAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICB0ZXh0OiByZXZlcnNlID8gXCJhY3RpdmVcIiA6IFwiaW5hY3RpdmVcIlxuICAgICAgICB9LFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIFwic2hhcGUtbmFtZVwiOiBcImVsbGlwc2VcIlxuICAgICAgICB9LFxuICAgICAgICBiYm94OiB7XG4gICAgICAgICAgdzogMzYsXG4gICAgICAgICAgaDogMTVcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGVsZW1lbnRVdGlsaXRpZXMuYWRkU3RhdGVPckluZm9Cb3goaW5wdXROb2RlLCBpbmZvYm94T2JqZWN0KTtcblxuICAgICAgdmFyIG91dHB1dE5vZGUgPSBlbGVtZW50VXRpbGl0aWVzLmFkZE5vZGUoeFBvc09mT3V0cHV0LCB5UG9zaXRpb24sIHtjbGFzczogXCJtYWNyb21vbGVjdWxlXCIsIGxhbmd1YWdlOiBcIlBEXCJ9KTtcbiAgICAgIG91dHB1dE5vZGUuZGF0YShcImp1c3RBZGRlZFwiLCB0cnVlKTtcbiAgICAgIG91dHB1dE5vZGUuZGF0YShcImxhYmVsXCIsIHByb3RlaW5OYW1lKTtcbiAgICAgIGluZm9ib3hPYmplY3QgPSB7XG4gICAgICAgIGNsYXp6OiBcInVuaXQgb2YgaW5mb3JtYXRpb25cIixcbiAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICB0ZXh0OiByZXZlcnNlID8gXCJpbmFjdGl2ZVwiIDogXCJhY3RpdmVcIlxuICAgICAgICB9LFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIFwic2hhcGUtbmFtZVwiOiBcImVsbGlwc2VcIlxuICAgICAgICB9LFxuICAgICAgICBiYm94OiB7XG4gICAgICAgICAgdzogMzYsXG4gICAgICAgICAgaDogMTVcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxlbWVudFV0aWxpdGllcy5hZGRTdGF0ZU9ySW5mb0JveChvdXRwdXROb2RlLCBpbmZvYm94T2JqZWN0KTtcblxuICAgICAgdmFyIGlucHV0U2lkZUVkZ2UgPSBlbGVtZW50VXRpbGl0aWVzLmFkZEVkZ2UoaW5wdXROb2RlLmlkKCksIHByb2Nlc3NOb2RlLmlkKCksIHtjbGFzczogXCJjb25zdW1wdGlvblwiLCBsYW5ndWFnZTogXCJQRFwifSk7XG4gICAgICBpbnB1dFNpZGVFZGdlLmRhdGEoXCJqdXN0QWRkZWRcIiwgdHJ1ZSk7XG4gICAgICB2YXIgb3V0cHV0U2lkZUVkZ2UgPSBlbGVtZW50VXRpbGl0aWVzLmFkZEVkZ2UocHJvY2Vzc05vZGUuaWQoKSwgb3V0cHV0Tm9kZS5pZCgpLCB7Y2xhc3M6IFwicHJvZHVjdGlvblwiLCBsYW5ndWFnZTogXCJQRFwifSk7XG4gICAgICBvdXRwdXRTaWRlRWRnZS5kYXRhKFwianVzdEFkZGVkXCIsIHRydWUpO1xuICAgICAgY3kuZW5kQmF0Y2goKTtcblxuICAgICAgLy9maWx0ZXIgdGhlIGp1c3QgYWRkZWQgZWxlbWVtdHMgdG8gcmV0dXJuIHRoZW0gYW5kIHJlbW92ZSBqdXN0IGFkZGVkIG1hcmtcbiAgICAgIHZhciBlbGVzID0gY3kuZWxlbWVudHMoJ1tqdXN0QWRkZWRdJyk7XG4gICAgICBlbGVzLnJlbW92ZURhdGEoJ2p1c3RBZGRlZCcpO1xuXG4gICAgICBjeS5lbGVtZW50cygpLnVuc2VsZWN0KCk7XG4gICAgICBlbGVzLnNlbGVjdCgpO1xuXG4gICAgICByZXR1cm4gZWxlczsgLy8gUmV0dXJuIHRoZSBqdXN0IGFkZGVkIGVsZW1lbnRzXG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBDcmVhdGVzIGEgdGVtcGxhdGUgcmVhY3Rpb24gd2l0aCBnaXZlbiBwYXJhbWV0ZXJzLiBSZXF1aXJlcyBjb3NlLWJpbGtlbnQgbGF5b3V0IHRvIHRpbGUgdGhlIGZyZWUgbWFjcm9tb2xlY3VsZXMgaW5jbHVkZWRcbiAgICAgKiBpbiB0aGUgY29tcGxleC4gUGFyYW1ldGVycyBhcmUgZXhwbGFpbmVkIGJlbG93LlxuICAgICAqIHRlbXBsYXRlVHlwZTogVGhlIHR5cGUgb2YgdGhlIHRlbXBsYXRlIHJlYWN0aW9uLiBJdCBtYXkgYmUgJ2Fzc29jaWF0aW9uJywgJ2Rpc3NvY2lhdGlvbicsICdyZXZlcnNpYmxlJyBvciAnaXJyZXZlcnNpYmxlJy5cbiAgICAgKiBub2RlTGlzdDogVGhlIGxpc3Qgb2YgdGhlIG5hbWVzIGFuZCB0eXBlcyBvZiBtb2xlY3VsZXMgd2hpY2ggd2lsbCBpbnZvbHZlIGluIHRoZSByZWFjdGlvbi5cbiAgICAgKiBjb21wbGV4TmFtZTogVGhlIG5hbWUgb2YgdGhlIGNvbXBsZXggaW4gdGhlIHJlYWN0aW9uLlxuICAgICAqIHByb2Nlc3NQb3NpdGlvbjogVGhlIG1vZGFsIHBvc2l0aW9uIG9mIHRoZSBwcm9jZXNzIGluIHRoZSByZWFjdGlvbi4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgdGhlIGNlbnRlciBvZiB0aGUgY2FudmFzLlxuICAgICAqIHRpbGluZ1BhZGRpbmdWZXJ0aWNhbDogVGhpcyBvcHRpb24gd2lsbCBiZSBwYXNzZWQgdG8gdGhlIGNvc2UtYmlsa2VudCBsYXlvdXQgd2l0aCB0aGUgc2FtZSBuYW1lLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyAxNS5cbiAgICAgKiB0aWxpbmdQYWRkaW5nSG9yaXpvbnRhbDogVGhpcyBvcHRpb24gd2lsbCBiZSBwYXNzZWQgdG8gdGhlIGNvc2UtYmlsa2VudCBsYXlvdXQgd2l0aCB0aGUgc2FtZSBuYW1lLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyAxNS5cbiAgICAgKiBlZGdlTGVuZ3RoOiBUaGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgcHJvY2VzcyBhbmQgdGhlIG1hY3JvbW9sZWN1bGVzIGF0IHRoZSBib3RoIHNpZGVzLlxuICAgICAqL1xuICAgIGVsZW1lbnRVdGlsaXRpZXMuY3JlYXRlVGVtcGxhdGVSZWFjdGlvbiA9IGZ1bmN0aW9uICh0ZW1wbGF0ZVR5cGUsIG5vZGVMaXN0LCBjb21wbGV4TmFtZSwgcHJvY2Vzc1Bvc2l0aW9uLCB0aWxpbmdQYWRkaW5nVmVydGljYWwsIHRpbGluZ1BhZGRpbmdIb3Jpem9udGFsLCBlZGdlTGVuZ3RoLCBsYXlvdXRQYXJhbSkge1xuXG4gICAgICB2YXIgZGVmYXVsdE1hY3JvbW9sZWN1bFByb3BlcnRpZXMgPSBlbGVtZW50VXRpbGl0aWVzLmdldERlZmF1bHRQcm9wZXJ0aWVzKCBcIm1hY3JvbW9sZWN1bGVcIiApO1xuICAgICAgdmFyIGRlZmF1bHRTaW1wbGVDaGVtaWNhbFByb3BlcnRpZXMgPSBlbGVtZW50VXRpbGl0aWVzLmdldERlZmF1bHRQcm9wZXJ0aWVzKCBcInNpbXBsZSBjaGVtaWNhbFwiICk7XG4gICAgICB2YXIgZGVmYXVsdFByb2Nlc3NQcm9wZXJ0aWVzID0gZWxlbWVudFV0aWxpdGllcy5nZXREZWZhdWx0UHJvcGVydGllcyggdGVtcGxhdGVUeXBlICk7XG4gICAgICB2YXIgcHJvY2Vzc1dpZHRoID0gZGVmYXVsdFByb2Nlc3NQcm9wZXJ0aWVzLndpZHRoIHx8IDUwO1xuICAgICAgdmFyIG1hY3JvbW9sZWN1bGVXaWR0aCA9IGRlZmF1bHRNYWNyb21vbGVjdWxQcm9wZXJ0aWVzLndpZHRoIHx8IDUwO1xuICAgICAgdmFyIG1hY3JvbW9sZWN1bGVIZWlnaHQgPSBkZWZhdWx0TWFjcm9tb2xlY3VsUHJvcGVydGllcy5oZWlnaHQgfHwgNTA7XG4gICAgICB2YXIgc2ltcGxlQ2hlbWljYWxXaWR0aCA9IGRlZmF1bHRTaW1wbGVDaGVtaWNhbFByb3BlcnRpZXMud2lkdGggfHwgMzU7XG4gICAgICB2YXIgc2ltcGxlQ2hlbWljYWxIZWlnaHQgPSBkZWZhdWx0U2ltcGxlQ2hlbWljYWxQcm9wZXJ0aWVzLmhlaWdodCB8fCAzNTtcbiAgICAgIHZhciBwcm9jZXNzUG9zaXRpb24gPSBwcm9jZXNzUG9zaXRpb24gfHwgZWxlbWVudFV0aWxpdGllcy5jb252ZXJ0VG9Nb2RlbFBvc2l0aW9uKHt4OiBjeS53aWR0aCgpIC8gMiwgeTogY3kuaGVpZ2h0KCkgLyAyfSk7XG4gICAgICB2YXIgbm9kZUxpc3QgPSBub2RlTGlzdDtcbiAgICAgIHZhciBjb21wbGV4TmFtZSA9IGNvbXBsZXhOYW1lO1xuICAgICAgdmFyIG51bU9mTW9sZWN1bGVzID0gbm9kZUxpc3QubGVuZ3RoO1xuICAgICAgdmFyIHRpbGluZ1BhZGRpbmdWZXJ0aWNhbCA9IHRpbGluZ1BhZGRpbmdWZXJ0aWNhbCB8fCAxNTtcbiAgICAgIHZhciB0aWxpbmdQYWRkaW5nSG9yaXpvbnRhbCA9IHRpbGluZ1BhZGRpbmdIb3Jpem9udGFsIHx8IDE1O1xuICAgICAgdmFyIGVkZ2VMZW5ndGggPSBlZGdlTGVuZ3RoIHx8IDYwO1xuXG4gICAgICBjeS5zdGFydEJhdGNoKCk7XG5cbiAgICAgIFxuICAgICAgaWYgKCFlbGVtZW50VXRpbGl0aWVzLmdldE1hcFR5cGUoKSkge1xuICAgICAgICBlbGVtZW50VXRpbGl0aWVzLnNldE1hcFR5cGUoXCJQRFwiKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHhQb3NpdGlvbk9mRnJlZU1hY3JvbW9sZWN1bGVzO1xuICAgICAgdmFyIHhQb3NpdGlvbk9mSW5wdXRNYWNyb21vbGVjdWxlcztcbiAgICAgIGlmICh0ZW1wbGF0ZVR5cGUgPT09ICdhc3NvY2lhdGlvbicpIHtcbiAgICAgICAgeFBvc2l0aW9uT2ZGcmVlTWFjcm9tb2xlY3VsZXMgPSBwcm9jZXNzUG9zaXRpb24ueCAtIGVkZ2VMZW5ndGggLSBwcm9jZXNzV2lkdGggLyAyIC0gbWFjcm9tb2xlY3VsZVdpZHRoIC8gMjtcbiAgICAgICBcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYodGVtcGxhdGVUeXBlID09PSAnZGlzc29jaWF0aW9uJyl7XG4gICAgICAgIHhQb3NpdGlvbk9mRnJlZU1hY3JvbW9sZWN1bGVzID0gcHJvY2Vzc1Bvc2l0aW9uLnggKyBlZGdlTGVuZ3RoICsgcHJvY2Vzc1dpZHRoIC8gMiArIG1hY3JvbW9sZWN1bGVXaWR0aCAvIDI7XG4gICAgICAgXG4gICAgICB9XG4gICAgICBlbHNle1xuICAgICAgICBcbiAgICAgICAgeFBvc2l0aW9uT2ZGcmVlTWFjcm9tb2xlY3VsZXMgPSBwcm9jZXNzUG9zaXRpb24ueCAtIGVkZ2VMZW5ndGggLSBwcm9jZXNzV2lkdGggLyAyIC0gbWFjcm9tb2xlY3VsZVdpZHRoIC8gMjtcbiAgICAgICAgeFBvc2l0aW9uT2ZJbnB1dE1hY3JvbW9sZWN1bGVzID0gcHJvY2Vzc1Bvc2l0aW9uLnggKyBlZGdlTGVuZ3RoICsgcHJvY2Vzc1dpZHRoIC8gMiArIG1hY3JvbW9sZWN1bGVXaWR0aCAvIDI7XG4gICAgICB9XG5cbiAgICAgIC8vQ3JlYXRlIHRoZSBwcm9jZXNzIGluIHRlbXBsYXRlIHR5cGVcbiAgICAgIHZhciBwcm9jZXNzO1xuICAgICAgaWYgKHRlbXBsYXRlVHlwZSA9PT0gJ3JldmVyc2libGUnIHx8IHRlbXBsYXRlVHlwZSA9PT0gJ2lycmV2ZXJzaWJsZScpIHtcbiAgICAgICAgcHJvY2VzcyA9IGVsZW1lbnRVdGlsaXRpZXMuYWRkTm9kZShwcm9jZXNzUG9zaXRpb24ueCwgcHJvY2Vzc1Bvc2l0aW9uLnksIHtjbGFzcyA6ICdwcm9jZXNzJywgbGFuZ3VhZ2UgOiAnUEQnfSk7XG4gICAgICAgIGVsZW1lbnRVdGlsaXRpZXMuc2V0UG9ydHNPcmRlcmluZyhwcm9jZXNzLCAnTC10by1SJyk7XG4gICAgICB9XG4gICAgICBlbHNle1xuICAgICAgICBwcm9jZXNzID0gZWxlbWVudFV0aWxpdGllcy5hZGROb2RlKHByb2Nlc3NQb3NpdGlvbi54LCBwcm9jZXNzUG9zaXRpb24ueSwge2NsYXNzIDogdGVtcGxhdGVUeXBlLCBsYW5ndWFnZSA6ICdQRCd9KTtcbiAgICAgICAgZWxlbWVudFV0aWxpdGllcy5zZXRQb3J0c09yZGVyaW5nKHByb2Nlc3MsICdMLXRvLVInKTtcbiAgICAgIH1cbiAgICAgIHByb2Nlc3MuZGF0YSgnanVzdEFkZGVkJywgdHJ1ZSk7XG5cbiAgICAgIC8vRGVmaW5lIHRoZSBzdGFydGluZyB5IHBvc2l0aW9uXG4gICAgICB2YXIgeVBvc2l0aW9uID0gcHJvY2Vzc1Bvc2l0aW9uLnkgLSAoKG51bU9mTW9sZWN1bGVzIC0gMSkgLyAyKSAqIChtYWNyb21vbGVjdWxlSGVpZ2h0ICsgdGlsaW5nUGFkZGluZ1ZlcnRpY2FsKTtcblxuICAgICAgLy9DcmVhdGUgdGhlIGZyZWUgbW9sZWN1bGVzXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bU9mTW9sZWN1bGVzOyBpKyspIHtcbiAgICAgICAgLy8gbm9kZSBhZGRpdGlvbiBvcGVyYXRpb24gaXMgZGV0ZXJtaW5lZCBieSBtb2xlY3VsZSB0eXBlXG4gICAgICAgIGlmKG5vZGVMaXN0W2ldLnR5cGUgPT0gXCJTaW1wbGUgQ2hlbWljYWxcIil7XG4gICAgICAgICAgdmFyIG5ld05vZGUgPSBlbGVtZW50VXRpbGl0aWVzLmFkZE5vZGUoeFBvc2l0aW9uT2ZGcmVlTWFjcm9tb2xlY3VsZXMsIHlQb3NpdGlvbiwge2NsYXNzIDogJ3NpbXBsZSBjaGVtaWNhbCcsIGxhbmd1YWdlIDogJ1BEJ30pO1xuICAgICAgICAgIC8vdXBkYXRlIHRoZSB5IHBvc2l0aW9uXG4gICAgICAgICAgeVBvc2l0aW9uICs9IHNpbXBsZUNoZW1pY2FsSGVpZ2h0ICsgdGlsaW5nUGFkZGluZ1ZlcnRpY2FsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2V7XG4gICAgICAgICAgdmFyIG5ld05vZGUgPSBlbGVtZW50VXRpbGl0aWVzLmFkZE5vZGUoeFBvc2l0aW9uT2ZGcmVlTWFjcm9tb2xlY3VsZXMsIHlQb3NpdGlvbiwge2NsYXNzIDogJ21hY3JvbW9sZWN1bGUnLCBsYW5ndWFnZSA6ICdQRCd9KTtcbiAgICAgICAgICAvL3VwZGF0ZSB0aGUgeSBwb3NpdGlvblxuICAgICAgICAgIHlQb3NpdGlvbiArPSBtYWNyb21vbGVjdWxlSGVpZ2h0ICsgdGlsaW5nUGFkZGluZ1ZlcnRpY2FsO1xuICAgICAgICB9XG4gICAgICAgIG5ld05vZGUuZGF0YSgnanVzdEFkZGVkJywgdHJ1ZSk7XG4gICAgICAgIG5ld05vZGUuZGF0YSgnbGFiZWwnLCBub2RlTGlzdFtpXS5uYW1lKTtcblxuICAgICAgICAvL2NyZWF0ZSB0aGUgZWRnZSBjb25uZWN0ZWQgdG8gdGhlIG5ldyBtb2xlY3VsZVxuICAgICAgICB2YXIgbmV3RWRnZTtcbiAgICAgICAgaWYgKHRlbXBsYXRlVHlwZSA9PT0gJ2Fzc29jaWF0aW9uJykge1xuICAgICAgICAgIG5ld0VkZ2UgPSBlbGVtZW50VXRpbGl0aWVzLmFkZEVkZ2UobmV3Tm9kZS5pZCgpLCBwcm9jZXNzLmlkKCksIHtjbGFzcyA6ICdjb25zdW1wdGlvbicsIGxhbmd1YWdlIDogJ1BEJ30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYodGVtcGxhdGVUeXBlID09PSAnZGlzc29jaWF0aW9uJyl7XG4gICAgICAgICAgbmV3RWRnZSA9IGVsZW1lbnRVdGlsaXRpZXMuYWRkRWRnZShwcm9jZXNzLmlkKCksIG5ld05vZGUuaWQoKSwge2NsYXNzIDogJ3Byb2R1Y3Rpb24nLCBsYW5ndWFnZSA6ICdQRCd9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNle1xuICAgICAgICAgIC8vR3JvdXAgcmlnaHQgb3IgdG9wIGVsZW1lbnRzIGluIGdyb3VwIGlkIDFcbiAgICAgICAgICBpZiAodGVtcGxhdGVUeXBlID09PSBcImlycmV2ZXJzaWJsZVwiKSB7XG4gICAgICAgICAgICBuZXdFZGdlID0gZWxlbWVudFV0aWxpdGllcy5hZGRFZGdlKG5ld05vZGUuaWQoKSwgcHJvY2Vzcy5pZCgpLCB7Y2xhc3M6IFwiY29uc3VtcHRpb25cIiwgbGFuZ3VhZ2U6ICdQRCd9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuZXdFZGdlID0gZWxlbWVudFV0aWxpdGllcy5hZGRFZGdlKHByb2Nlc3MuaWQoKSwgbmV3Tm9kZS5pZCgpLCB7Y2xhc3MgOiBcInByb2R1Y3Rpb25cIiwgbGFuZ3VhZ2UgOiAnUEQnfSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG5ld0VkZ2UuZGF0YSgnanVzdEFkZGVkJywgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmKHRlbXBsYXRlVHlwZSA9PT0gJ2Fzc29jaWF0aW9uJyB8fCB0ZW1wbGF0ZVR5cGUgPT0gJ2Rpc3NvY2lhdGlvbicpe1xuICAgICAgICAvL0NyZWF0ZSB0aGUgY29tcGxleCBpbmNsdWRpbmcgbWFjcm9tb2xlY3VsZXMgaW5zaWRlIG9mIGl0XG4gICAgICAgIC8vVGVtcHJvcmFyaWx5IGFkZCBpdCB0byB0aGUgcHJvY2VzcyBwb3NpdGlvbiB3ZSB3aWxsIG1vdmUgaXQgYWNjb3JkaW5nIHRvIHRoZSBsYXN0IHNpemUgb2YgaXRcbiAgICAgICAgdmFyIGNvbXBsZXggPSBlbGVtZW50VXRpbGl0aWVzLmFkZE5vZGUocHJvY2Vzc1Bvc2l0aW9uLngsIHByb2Nlc3NQb3NpdGlvbi55LCB7Y2xhc3MgOiAnY29tcGxleCcsIGxhbmd1YWdlIDogJ1BEJ30pO1xuICAgICAgICBjb21wbGV4LmRhdGEoJ2p1c3RBZGRlZCcsIHRydWUpO1xuICAgICAgICBjb21wbGV4LmRhdGEoJ2p1c3RBZGRlZExheW91dE5vZGUnLCB0cnVlKTtcblxuICAgICAgICAvL0lmIGEgbmFtZSBpcyBzcGVjaWZpZWQgZm9yIHRoZSBjb21wbGV4IHNldCBpdHMgbGFiZWwgYWNjb3JkaW5nbHlcbiAgICAgICAgaWYgKGNvbXBsZXhOYW1lKSB7XG4gICAgICAgICAgY29tcGxleC5kYXRhKCdsYWJlbCcsIGNvbXBsZXhOYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vY3JlYXRlIHRoZSBlZGdlIGNvbm5uZWN0ZWQgdG8gdGhlIGNvbXBsZXhcbiAgICAgICAgdmFyIGVkZ2VPZkNvbXBsZXg7XG5cbiAgICAgICAgaWYgKHRlbXBsYXRlVHlwZSA9PT0gJ2Fzc29jaWF0aW9uJykge1xuICAgICAgICAgIGVkZ2VPZkNvbXBsZXggPSBlbGVtZW50VXRpbGl0aWVzLmFkZEVkZ2UocHJvY2Vzcy5pZCgpLCBjb21wbGV4LmlkKCksIHtjbGFzcyA6ICdwcm9kdWN0aW9uJywgbGFuZ3VhZ2UgOiAnUEQnfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZWRnZU9mQ29tcGxleCA9IGVsZW1lbnRVdGlsaXRpZXMuYWRkRWRnZShjb21wbGV4LmlkKCksIHByb2Nlc3MuaWQoKSwge2NsYXNzIDogJ2NvbnN1bXB0aW9uJywgbGFuZ3VhZ2UgOiAnUEQnfSk7XG4gICAgICAgIH1cblxuICAgICAgICBlZGdlT2ZDb21wbGV4LmRhdGEoJ2p1c3RBZGRlZCcsIHRydWUpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtT2ZNb2xlY3VsZXM7IGkrKykge1xuXG4gICAgICAgICAgLy8gQWRkIGEgbW9sZWN1bGUoZGVwZW5kZW50IG9uIGl0J3MgdHlwZSkgbm90IGhhdmluZyBhIHByZXZpb3VzbHkgZGVmaW5lZCBpZCBhbmQgaGF2aW5nIHRoZSBjb21wbGV4IGNyZWF0ZWQgaW4gdGhpcyByZWFjdGlvbiBhcyBwYXJlbnRcbiAgICAgICAgICBpZihub2RlTGlzdFtpXS50eXBlID09ICdTaW1wbGUgQ2hlbWljYWwnKXtcbiAgICAgICAgICAgIHZhciBuZXdOb2RlID0gZWxlbWVudFV0aWxpdGllcy5hZGROb2RlKGNvbXBsZXgucG9zaXRpb24oJ3gnKSwgY29tcGxleC5wb3NpdGlvbigneScpLCB7Y2xhc3MgOiAnc2ltcGxlIGNoZW1pY2FsJywgbGFuZ3VhZ2UgOiAnUEQnfSwgdW5kZWZpbmVkLCBjb21wbGV4LmlkKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgdmFyIG5ld05vZGUgPSBlbGVtZW50VXRpbGl0aWVzLmFkZE5vZGUoY29tcGxleC5wb3NpdGlvbigneCcpLCBjb21wbGV4LnBvc2l0aW9uKCd5JyksIHtjbGFzcyA6ICdtYWNyb21vbGVjdWxlJywgbGFuZ3VhZ2UgOiAnUEQnfSwgdW5kZWZpbmVkLCBjb21wbGV4LmlkKCkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG5ld05vZGUuZGF0YSgnanVzdEFkZGVkJywgdHJ1ZSk7XG4gICAgICAgICAgbmV3Tm9kZS5kYXRhKCdsYWJlbCcsIG5vZGVMaXN0W2ldLm5hbWUpO1xuICAgICAgICAgIG5ld05vZGUuZGF0YSgnanVzdEFkZGVkTGF5b3V0Tm9kZScsIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNle1xuXG4gICAgICAgIC8vQ3JlYXRlIHRoZSBpbnB1dCBtYWNyb21vbGVjdWxlc1xuICAgICAgICB2YXIgbnVtT2ZJbnB1dE1hY3JvbW9sZWN1bGVzID0gY29tcGxleE5hbWUubGVuZ3RoO1xuICAgICAgICB5UG9zaXRpb24gPSBwcm9jZXNzUG9zaXRpb24ueSAtICgobnVtT2ZJbnB1dE1hY3JvbW9sZWN1bGVzIC0gMSkgLyAyKSAqIChtYWNyb21vbGVjdWxlSGVpZ2h0ICsgdGlsaW5nUGFkZGluZ1ZlcnRpY2FsKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bU9mSW5wdXRNYWNyb21vbGVjdWxlczsgaSsrKSB7XG5cbiAgICAgICAgICBpZihjb21wbGV4TmFtZVtpXS50eXBlID09ICdTaW1wbGUgQ2hlbWljYWwnKXtcbiAgICAgICAgICAgIHZhciBuZXdOb2RlID0gZWxlbWVudFV0aWxpdGllcy5hZGROb2RlKHhQb3NpdGlvbk9mSW5wdXRNYWNyb21vbGVjdWxlcywgeVBvc2l0aW9uLCB7Y2xhc3MgOiAnc2ltcGxlIGNoZW1pY2FsJywgbGFuZ3VhZ2UgOiAnUEQnfSk7XG4gICAgICAgICAgICB5UG9zaXRpb24gKz0gc2ltcGxlQ2hlbWljYWxIZWlnaHQgKyB0aWxpbmdQYWRkaW5nVmVydGljYWw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICB2YXIgbmV3Tm9kZSA9IGVsZW1lbnRVdGlsaXRpZXMuYWRkTm9kZSh4UG9zaXRpb25PZklucHV0TWFjcm9tb2xlY3VsZXMsIHlQb3NpdGlvbiwge2NsYXNzIDogJ21hY3JvbW9sZWN1bGUnLCBsYW5ndWFnZSA6ICdQRCd9KTtcbiAgICAgICAgICAgIHlQb3NpdGlvbiArPSBtYWNyb21vbGVjdWxlSGVpZ2h0ICsgdGlsaW5nUGFkZGluZ1ZlcnRpY2FsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG5ld05vZGUuZGF0YSgnanVzdEFkZGVkJywgdHJ1ZSk7XG4gICAgICAgICAgbmV3Tm9kZS5kYXRhKCdsYWJlbCcsIGNvbXBsZXhOYW1lW2ldLm5hbWUpO1xuXG4gICAgICAgICAgLy9jcmVhdGUgdGhlIGVkZ2UgY29ubmVjdGVkIHRvIHRoZSBuZXcgbWFjcm9tb2xlY3VsZVxuICAgICAgICAgIHZhciBuZXdFZGdlO1xuXG4gICAgICAgICAgLy9Hcm91cCB0aGUgbGVmdCBvciBib3R0b20gZWxlbWVudHMgaW4gZ3JvdXAgaWQgMCBpZiByZXZlcnNpYmxlXG4gICAgICAgICAgaWYgKHRlbXBsYXRlVHlwZSA9PT0gXCJpcnJldmVyc2libGVcIikge1xuICAgICAgICAgICAgbmV3RWRnZSA9IGVsZW1lbnRVdGlsaXRpZXMuYWRkRWRnZShwcm9jZXNzLmlkKCksIG5ld05vZGUuaWQoKSwge2NsYXNzOiBcInByb2R1Y3Rpb25cIiwgbGFuZ3VhZ2U6ICdQRCd9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuZXdFZGdlID0gZWxlbWVudFV0aWxpdGllcy5hZGRFZGdlKHByb2Nlc3MuaWQoKSwgbmV3Tm9kZS5pZCgpLCB7Y2xhc3MgOiBcInByb2R1Y3Rpb25cIiwgbGFuZ3VhZ2UgOiAnUEQnfSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuZXdFZGdlLmRhdGEoJ2p1c3RBZGRlZCcsIHRydWUpO1xuXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY3kuZW5kQmF0Y2goKTtcblxuICAgICAgdmFyIGxheW91dE5vZGVzID0gY3kubm9kZXMoJ1tqdXN0QWRkZWRMYXlvdXROb2RlXScpO1xuICAgICAgbGF5b3V0Tm9kZXMucmVtb3ZlRGF0YSgnanVzdEFkZGVkTGF5b3V0Tm9kZScpO1xuICAgICAgdmFyIGxheW91dCA9IGxheW91dE5vZGVzLmxheW91dCh7XG4gICAgICAgIG5hbWU6IGxheW91dFBhcmFtLm5hbWUsXG4gICAgICAgIHJhbmRvbWl6ZTogZmFsc2UsXG4gICAgICAgIGZpdDogZmFsc2UsXG4gICAgICAgIGFuaW1hdGU6IGZhbHNlLFxuICAgICAgICB0aWxpbmdQYWRkaW5nVmVydGljYWw6IHRpbGluZ1BhZGRpbmdWZXJ0aWNhbCxcbiAgICAgICAgdGlsaW5nUGFkZGluZ0hvcml6b250YWw6IHRpbGluZ1BhZGRpbmdIb3Jpem9udGFsLFxuICAgICAgICBzdG9wOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy9JZiBpdCBpcyBhIHJldmVyc2libGUgcmVhY3Rpb24gbm8gbmVlZCB0byByZS1wb3NpdGlvbiBjb21wbGV4ZXNcbiAgICAgICAgICBpZih0ZW1wbGF0ZVR5cGUgPT09ICdyZXZlcnNpYmxlJylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAvL3JlLXBvc2l0aW9uIHRoZSBub2RlcyBpbnNpZGUgdGhlIGNvbXBsZXhcbiAgICAgICAgICB2YXIgc3VwcG9zZWRYUG9zaXRpb247XG4gICAgICAgICAgdmFyIHN1cHBvc2VkWVBvc2l0aW9uID0gcHJvY2Vzc1Bvc2l0aW9uLnk7XG5cbiAgICAgICAgICBpZiAodGVtcGxhdGVUeXBlID09PSAnYXNzb2NpYXRpb24nKSB7XG4gICAgICAgICAgICBzdXBwb3NlZFhQb3NpdGlvbiA9IHByb2Nlc3NQb3NpdGlvbi54ICsgZWRnZUxlbmd0aCArIHByb2Nlc3NXaWR0aCAvIDIgKyBjb21wbGV4Lm91dGVyV2lkdGgoKSAvIDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3VwcG9zZWRYUG9zaXRpb24gPSBwcm9jZXNzUG9zaXRpb24ueCAtIGVkZ2VMZW5ndGggLSBwcm9jZXNzV2lkdGggLyAyIC0gY29tcGxleC5vdXRlcldpZHRoKCkgLyAyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBwb3NpdGlvbkRpZmZYID0gKHN1cHBvc2VkWFBvc2l0aW9uIC0gY29tcGxleC5wb3NpdGlvbigneCcpKSAvIDI7XG4gICAgICAgICAgdmFyIHBvc2l0aW9uRGlmZlkgPSAoc3VwcG9zZWRZUG9zaXRpb24gLSBjb21wbGV4LnBvc2l0aW9uKCd5JykpIC8gMjtcbiAgICAgICAgICBlbGVtZW50VXRpbGl0aWVzLm1vdmVOb2Rlcyh7eDogcG9zaXRpb25EaWZmWCwgeTogcG9zaXRpb25EaWZmWX0sIGNvbXBsZXgpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gRG8gdGhpcyBjaGVjayBmb3IgY3l0b3NjYXBlLmpzIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAgICAgIGlmIChsYXlvdXQgJiYgbGF5b3V0LnJ1biAmJiB0ZW1wbGF0ZVR5cGUgIT09ICdyZXZlcnNpYmxlJyAmJiB0ZW1wbGF0ZVR5cGUgIT09ICdpcnJldmVyc2libGUnKSB7XG4gICAgICAgIGxheW91dC5ydW4oKTtcbiAgICAgIH1cblxuICAgICAgLy9maWx0ZXIgdGhlIGp1c3QgYWRkZWQgZWxlbWVtdHMgdG8gcmV0dXJuIHRoZW0gYW5kIHJlbW92ZSBqdXN0IGFkZGVkIG1hcmtcbiAgICAgIHZhciBlbGVzID0gY3kuZWxlbWVudHMoJ1tqdXN0QWRkZWRdJyk7XG4gICAgICBlbGVzLnJlbW92ZURhdGEoJ2p1c3RBZGRlZCcpO1xuXG4gICAgICBjeS5lbGVtZW50cygpLnVuc2VsZWN0KCk7XG4gICAgICBlbGVzLnNlbGVjdCgpO1xuXG4gICAgICByZXR1cm4gZWxlczsgLy8gUmV0dXJuIHRoZSBqdXN0IGFkZGVkIGVsZW1lbnRzXG4gICAgfTtcblxuICAgIC8qXG4gICAgICogTW92ZSB0aGUgbm9kZXMgdG8gYSBuZXcgcGFyZW50IGFuZCBjaGFuZ2UgdGhlaXIgcG9zaXRpb24gaWYgcG9zc0RpZmYgcGFyYW1zIGFyZSBzZXQuXG4gICAgICovXG4gICAgZWxlbWVudFV0aWxpdGllcy5jaGFuZ2VQYXJlbnQgPSBmdW5jdGlvbihub2RlcywgbmV3UGFyZW50LCBwb3NEaWZmWCwgcG9zRGlmZlkpIHtcbiAgICAgIHZhciBuZXdQYXJlbnRJZCA9IG5ld1BhcmVudCA9PSB1bmRlZmluZWQgfHwgdHlwZW9mIG5ld1BhcmVudCA9PT0gJ3N0cmluZycgPyBuZXdQYXJlbnQgOiBuZXdQYXJlbnQuaWQoKTtcbiAgICAgIHZhciBtb3ZlZEVsZXMgPSBub2Rlcy5tb3ZlKHtcInBhcmVudFwiOiBuZXdQYXJlbnRJZH0pO1xuICAgICAgaWYodHlwZW9mIHBvc0RpZmZYICE9ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBwb3NEaWZmWSAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICBlbGVtZW50VXRpbGl0aWVzLm1vdmVOb2Rlcyh7eDogcG9zRGlmZlgsIHk6IHBvc0RpZmZZfSwgbm9kZXMpO1xuICAgICAgfVxuICAgICAgZWxlbWVudFV0aWxpdGllcy5tYWludGFpblBvaW50ZXIobW92ZWRFbGVzKTtcbiAgICAgIHJldHVybiBtb3ZlZEVsZXM7XG4gICAgfTtcblxuICAgIGVsZW1lbnRVdGlsaXRpZXMudXBkYXRlSW5mb2JveFN0eWxlID0gZnVuY3Rpb24oIG5vZGUsIGluZGV4LCBuZXdQcm9wcyApIHtcbiAgICAgIHZhciBpbmZvYm94T2JqID0gbm9kZS5kYXRhKCdzdGF0ZXNhbmRpbmZvcycpW2luZGV4XTtcbiAgICAgICQuZXh0ZW5kKCBpbmZvYm94T2JqLnN0eWxlLCBuZXdQcm9wcyApO1xuICAgICAgY3kuc3R5bGUoKS51cGRhdGUoKTtcbiAgICB9O1xuXG4gICAgZWxlbWVudFV0aWxpdGllcy51cGRhdGVJbmZvYm94T2JqID0gZnVuY3Rpb24oIG5vZGUsIGluZGV4LCBuZXdQcm9wcyApIHtcbiAgICAgIHZhciBpbmZvYm94T2JqID0gbm9kZS5kYXRhKCdzdGF0ZXNhbmRpbmZvcycpW2luZGV4XTtcbiAgICAgICQuZXh0ZW5kKCBpbmZvYm94T2JqLCBuZXdQcm9wcyApO1xuICAgIH07XG5cbiAgICAvLyBSZXNpemUgZ2l2ZW4gbm9kZXMgaWYgdXNlQXNwZWN0UmF0aW8gaXMgdHJ1dGh5IG9uZSBvZiB3aWR0aCBvciBoZWlnaHQgc2hvdWxkIG5vdCBiZSBzZXQuXG4gICAgZWxlbWVudFV0aWxpdGllcy5yZXNpemVOb2RlcyA9IGZ1bmN0aW9uIChub2Rlcywgd2lkdGgsIGhlaWdodCwgdXNlQXNwZWN0UmF0aW8sIHByZXNlcnZlUmVsYXRpdmVQb3MpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcblxuICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICB2YXIgcmF0aW8gPSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBlbGVNdXN0QmVTcXVhcmUgPSBlbGVtZW50VXRpbGl0aWVzLm11c3RCZVNxdWFyZShub2RlLmRhdGEoJ2NsYXNzJykpO1xuXG4gICAgICAgIGlmIChwcmVzZXJ2ZVJlbGF0aXZlUG9zID09PSB0cnVlKSB7XG4gICAgICAgICAgdmFyIG9sZFdpZHRoID0gbm9kZS5kYXRhKFwiYmJveFwiKS53O1xuICAgICAgICAgIHZhciBvbGRIZWlnaHQgPSBub2RlLmRhdGEoXCJiYm94XCIpLmg7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBOb3RlIHRoYXQgYm90aCB3aWR0aCBhbmQgaGVpZ2h0IHNob3VsZCBub3QgYmUgc2V0IGlmIHVzZUFzcGVjdFJhdGlvIGlzIHRydXRoeVxuICAgICAgICBpZighbm9kZS5pc1BhcmVudCgpKXtcbiAgICAgICAgICBpZiAod2lkdGgpIHtcbiAgICAgICAgICAgIGlmICh1c2VBc3BlY3RSYXRpbyB8fCBlbGVNdXN0QmVTcXVhcmUpIHtcbiAgICAgICAgICAgICAgcmF0aW8gPSB3aWR0aCAvIG5vZGUud2lkdGgoKTtcbiAgICAgICAgICAgIH1cbiAgXG4gICAgICAgICAgICBub2RlLmRhdGEoXCJiYm94XCIpLncgPSB3aWR0aDtcbiAgICAgICAgICB9XG4gIFxuICAgICAgICAgIGlmIChoZWlnaHQpIHtcbiAgICAgICAgICAgIGlmICh1c2VBc3BlY3RSYXRpbyB8fCBlbGVNdXN0QmVTcXVhcmUpIHtcbiAgICAgICAgICAgICAgcmF0aW8gPSBoZWlnaHQgLyBub2RlLmhlaWdodCgpO1xuICAgICAgICAgICAgfVxuICBcbiAgICAgICAgICAgIG5vZGUuZGF0YShcImJib3hcIikuaCA9IGhlaWdodDtcbiAgICAgICAgICB9XG4gIFxuICAgICAgICAgIGlmIChyYXRpbyAmJiAhaGVpZ2h0KSB7XG4gICAgICAgICAgICBub2RlLmRhdGEoXCJiYm94XCIpLmggPSBub2RlLmhlaWdodCgpICogcmF0aW87XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKHJhdGlvICYmICF3aWR0aCkge1xuICAgICAgICAgICAgbm9kZS5kYXRhKFwiYmJveFwiKS53ID0gbm9kZS53aWR0aCgpICogcmF0aW87XG4gICAgICAgICAgfVxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICBub2RlLmRhdGEoXCJtaW5IZWlnaHRcIiAsIFwiXCIrIGhlaWdodCk7XG4gICAgICAgICAgbm9kZS5kYXRhKFwibWluV2lkdGhcIiAsIFwiXCIrIHdpZHRoKTtcbiAgICAgICAgICBub2RlLmRhdGEoXCJtaW5XaWR0aEJpYXNMZWZ0XCIsIFwiNTAlXCIpO1xuICAgICAgICAgIG5vZGUuZGF0YShcIm1pbldpZHRoQmlhc1JpZ2h0XCIsIFwiNTAlXCIpO1xuICAgICAgICAgIG5vZGUuZGF0YShcIm1pbkhlaWdodEJpYXNUb3BcIiwgXCI1MCVcIiApO1xuICAgICAgICAgIG5vZGUuZGF0YShcIm1pbkhlaWdodEJpYXNCb3R0b21cIiwgXCI1MCVcIik7XG4gICAgICAgIH1cbiAgICAgICAgXG5cbiAgICAgLyogICAgaWYgKHByZXNlcnZlUmVsYXRpdmVQb3MgPT09IHRydWUpIHtcbiAgICAgICAgICB2YXIgc3RhdGVzYW5kaW5mb3MgPSBub2RlLmRhdGEoJ3N0YXRlc2FuZGluZm9zJyk7XG4gICAgICAgICAgdmFyIHRvcEJvdHRvbSA9IHN0YXRlc2FuZGluZm9zLmZpbHRlcihib3ggPT4gKGJveC5hbmNob3JTaWRlID09PSBcInRvcFwiIHx8IGJveC5hbmNob3JTaWRlID09PSBcImJvdHRvbVwiKSk7XG4gICAgICAgICAgdmFyIHJpZ2h0TGVmdCA9IHN0YXRlc2FuZGluZm9zLmZpbHRlcihib3ggPT4gKGJveC5hbmNob3JTaWRlID09PSBcInJpZ2h0XCIgfHwgYm94LmFuY2hvclNpZGUgPT09IFwibGVmdFwiKSk7XG5cbiAgICAgICAgICB0b3BCb3R0b20uZm9yRWFjaChmdW5jdGlvbihib3gpe1xuICAgICAgICAgICAgaWYgKGJveC5iYm94LnggPCAwKSB7XG4gICAgICAgICAgICAgIGJveC5iYm94LnggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYm94LmJib3gueCA+IG9sZFdpZHRoKSB7XG4gICAgICAgICAgICAgIGJveC5iYm94LnggPSBvbGRXaWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJveC5iYm94LnggPSBub2RlLmRhdGEoXCJiYm94XCIpLncgKiBib3guYmJveC54IC8gb2xkV2lkdGg7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICByaWdodExlZnQuZm9yRWFjaChmdW5jdGlvbihib3gpe1xuICAgICAgICAgICAgaWYgKGJveC5iYm94LnkgPCAwKSB7XG4gICAgICAgICAgICAgIGJveC5iYm94LnkgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYm94LmJib3gueSA+IG9sZEhlaWdodCkge1xuICAgICAgICAgICAgICBib3guYmJveC55ID0gb2xkSGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYm94LmJib3gueSA9IG5vZGUuZGF0YShcImJib3hcIikuaCAqIGJveC5iYm94LnkgLyBvbGRIZWlnaHQ7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gKi9cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZWxlbWVudFV0aWxpdGllcy5jYWxjdWxhdGVNaW5XaWR0aCA9IGZ1bmN0aW9uKG5vZGUpIHtcblxuICAgICAgICB2YXIgZGVmYXVsdFdpZHRoID0gdGhpcy5nZXREZWZhdWx0UHJvcGVydGllcyhub2RlLmRhdGEoJ2NsYXNzJykpLndpZHRoO1xuXG4gICAgICAgIC8vIExhYmVsIHdpZHRoIGNhbGN1bGF0aW9uXG4gICAgICAgIHZhciBzdHlsZSA9IG5vZGUuc3R5bGUoKTtcblxuICAgICAgICB2YXIgZm9udEZhbWlsaXkgPSBzdHlsZVsnZm9udC1mYW1pbHknXTtcbiAgICAgICAgdmFyIGZvbnRTaXplID0gc3R5bGVbJ2ZvbnQtc2l6ZSddO1xuICAgICAgICB2YXIgbGFiZWxUZXh0ID0gc3R5bGVbJ2xhYmVsJ107XG5cbiAgICAgICAgaWYgKGxhYmVsVGV4dCA9PT0gXCJcIiAmJiBub2RlLmRhdGEoJ2xhYmVsJykgJiYgbm9kZS5kYXRhKCdsYWJlbCcpICE9PSBcIlwiKSB7XG4gICAgICAgICAgbGFiZWxUZXh0ID0gbm9kZS5kYXRhKCdsYWJlbCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxhYmVsV2lkdGggPSBlbGVtZW50VXRpbGl0aWVzLmdldFdpZHRoQnlDb250ZW50KCBsYWJlbFRleHQsIGZvbnRGYW1pbGl5LCBmb250U2l6ZSApO1xuXG4gICAgICAgIHZhciBzdGF0ZXNhbmRpbmZvcyA9IG5vZGUuZGF0YSgnc3RhdGVzYW5kaW5mb3MnKTtcbiAgICAgICAgLy9Ub3AgYW5kIGJvdHRvbSBpbmZvQm94ZXNcbiAgICAgICAgLy92YXIgdG9wSW5mb0JveGVzID0gc3RhdGVzYW5kaW5mb3MuZmlsdGVyKGJveCA9PiAoYm94LmFuY2hvclNpZGUgPT09IFwidG9wXCIgfHwgKChib3guYW5jaG9yU2lkZSA9PT0gXCJyaWdodFwiIHx8IGJveC5hbmNob3JTaWRlID09PSBcImxlZnRcIikgJiYgKGJveC5iYm94LnkgPD0gMTIpKSkpO1xuICAgICAgICAvL3ZhciBib3R0b21JbmZvQm94ZXMgPSBzdGF0ZXNhbmRpbmZvcy5maWx0ZXIoYm94ID0+IChib3guYW5jaG9yU2lkZSA9PT0gXCJib3R0b21cIiB8fCAoKGJveC5hbmNob3JTaWRlID09PSBcInJpZ2h0XCIgfHwgYm94LmFuY2hvclNpZGUgPT09IFwibGVmdFwiKSAmJiAoYm94LmJib3gueSA+PSBub2RlLmRhdGEoJ2Jib3gnKS5oIC0gMTIpKSkpO1xuICAgICAgICB2YXIgdW5pdEdhcCA9IDU7XG4gICAgICAgIHZhciB0b3BJZGVhbFdpZHRoID0gdW5pdEdhcDtcbiAgICAgICAgdmFyIGJvdHRvbUlkZWFsV2lkdGggPSB1bml0R2FwOyAgICAgICAgXG4gICAgICAgIHZhciByaWdodE1heFdpZHRoID0gMDtcbiAgICAgICAgdmFyIGxlZnRNYXhXaWR0aCA9MDtcbiAgICAgICAgc3RhdGVzYW5kaW5mb3MuZm9yRWFjaChmdW5jdGlvbihib3gpe1xuICAgICAgICAgIGlmKGJveC5hbmNob3JTaWRlID09PSBcInRvcFwiKXtcbiAgICAgICAgICAgIHRvcElkZWFsV2lkdGggKz0gYm94LmJib3gudyArIHVuaXRHYXA7XG5cbiAgICAgICAgICB9ZWxzZSBpZihib3guYW5jaG9yU2lkZSA9PT0gXCJib3R0b21cIil7XG4gICAgICAgICAgICBib3R0b21JZGVhbFdpZHRoICs9IGJveC5iYm94LncgKyB1bml0R2FwO1xuXG4gICAgICAgICAgfWVsc2UgaWYoYm94LmFuY2hvclNpZGUgPT09IFwicmlnaHRcIilcbiAgICAgICAgICB7ICAgICAgICAgICBcbiAgICAgICAgICAgIHJpZ2h0TWF4V2lkdGggPSAoYm94LmJib3gudyA+IHJpZ2h0TWF4V2lkdGgpID8gYm94LmJib3gudyA6IHJpZ2h0TWF4V2lkdGg7XG4gICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGxlZnRNYXhXaWR0aCA9IChib3guYmJveC53ID4gbGVmdE1heFdpZHRoKSA/IGJveC5iYm94LncgOiBsZWZ0TWF4V2lkdGg7XG4gICAgICAgICAgfVxuICAgICAgICB9KTsgICAgICBcblxuICAgICAgICB2YXIgbWlkZGxlV2lkdGggPSBsYWJlbFdpZHRoICsgMiAqIE1hdGgubWF4KHJpZ2h0TWF4V2lkdGgvMiwgbGVmdE1heFdpZHRoLzIpO1xuXG4gICAgICAgIHZhciBjb21wb3VuZFdpZHRoID0gMDtcbiAgICAgICAgaWYobm9kZS5pc1BhcmVudCgpKXtcbiAgICAgICAgICBjb21wb3VuZFdpZHRoID0gbm9kZS5jaGlsZHJlbigpLmJvdW5kaW5nQm94KCkudztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTWF0aC5tYXgobWlkZGxlV2lkdGgsIGRlZmF1bHRXaWR0aC8yLCB0b3BJZGVhbFdpZHRoLCBib3R0b21JZGVhbFdpZHRoLCBjb21wb3VuZFdpZHRoKTtcbiAgICB9XG5cbiAgICBlbGVtZW50VXRpbGl0aWVzLmNhbGN1bGF0ZU1pbkhlaWdodCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgdmFyIHN0YXRlc2FuZGluZm9zID0gbm9kZS5kYXRhKCdzdGF0ZXNhbmRpbmZvcycpO1xuICAgICAgICB2YXIgbWFyZ2luID0gNztcbiAgICAgICAgdmFyIHVuaXRHYXAgPSA1O1xuICAgICAgICB2YXIgZGVmYXVsdEhlaWdodCA9IHRoaXMuZ2V0RGVmYXVsdFByb3BlcnRpZXMobm9kZS5kYXRhKCdjbGFzcycpKS5oZWlnaHQ7XG4gICAgICAgIHZhciBsZWZ0SW5mb0JveGVzID0gc3RhdGVzYW5kaW5mb3MuZmlsdGVyKGJveCA9PiBib3guYW5jaG9yU2lkZSA9PT0gXCJsZWZ0XCIpOyAgICAgICAgXG4gICAgICAgIHZhciBsZWZ0SGVpZ2h0ID0gdW5pdEdhcDsgXG4gICAgICAgIGxlZnRJbmZvQm94ZXMuZm9yRWFjaChmdW5jdGlvbihib3gpe1xuICAgICAgICAgICAgbGVmdEhlaWdodCArPSBib3guYmJveC5oICsgdW5pdEdhcDtcbiAgICAgICAgICAgXG4gICAgICAgIH0pOyAgICAgIFxuICAgICAgICB2YXIgcmlnaHRJbmZvQm94ZXMgPSBzdGF0ZXNhbmRpbmZvcy5maWx0ZXIoYm94ID0+IGJveC5hbmNob3JTaWRlID09PSBcInJpZ2h0XCIpO1xuICAgICAgICB2YXIgcmlnaHRIZWlnaHQgPSB1bml0R2FwOyAgICAgICAgXG4gICAgICAgIHJpZ2h0SW5mb0JveGVzLmZvckVhY2goZnVuY3Rpb24oYm94KXtcbiAgICAgICAgICAgIHJpZ2h0SGVpZ2h0ICs9IGJveC5iYm94LmggKyB1bml0R2FwOyAgICAgICAgICAgXG4gICAgICAgIH0pOyAgICAgICBcbiAgICAgICAgdmFyIHN0eWxlID0gbm9kZS5zdHlsZSgpO1xuICAgICAgICB2YXIgbGFiZWxUZXh0ID0gKChzdHlsZVsnbGFiZWwnXSkuc3BsaXQoXCJcXG5cIikpLmZpbHRlciggdGV4dCA9PiB0ZXh0ICE9PSAnJyk7XG4gICAgICAgIHZhciBmb250U2l6ZSA9IHBhcnNlRmxvYXQoc3R5bGVbJ2ZvbnQtc2l6ZSddLnN1YnN0cmluZygwLCBzdHlsZVsnZm9udC1zaXplJ10ubGVuZ3RoIC0gMikpO1xuICAgICAgICB2YXIgdG90YWxIZWlnaHQgPSBsYWJlbFRleHQubGVuZ3RoICogZm9udFNpemUgKyAyICogbWFyZ2luO1xuXG4gICAgICAgIFxuXG4gICAgICAgIHZhciBjb21wb3VuZEhlaWdodCA9IDA7XG4gICAgICAgIGlmKG5vZGUuaXNQYXJlbnQoKSl7XG4gICAgICAgICAgY29tcG91bmRIZWlnaHQgPSBub2RlLmNoaWxkcmVuKCkuYm91bmRpbmdCb3goKS5oO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBNYXRoLm1heCh0b3RhbEhlaWdodCwgZGVmYXVsdEhlaWdodC8yLCBsZWZ0SGVpZ2h0LCByaWdodEhlaWdodCwgY29tcG91bmRIZWlnaHQpO1xuICAgIH1cblxuICAgIGVsZW1lbnRVdGlsaXRpZXMuaXNSZXNpemVkVG9Db250ZW50ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIGlmKCFub2RlIHx8ICFub2RlLmlzTm9kZSgpIHx8ICFub2RlLmRhdGEoJ2Jib3gnKSl7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy92YXIgdyA9IG5vZGUuZGF0YSgnYmJveCcpLnc7XG4gICAgICAvL3ZhciBoID0gbm9kZS5kYXRhKCdiYm94JykuaDtcbiAgICAgIHZhciB3ID0gbm9kZS53aWR0aCgpO1xuICAgICAgdmFyIGggPSBub2RlLmhlaWdodCgpO1xuXG4gICAgICB2YXIgbWluVyA9IGVsZW1lbnRVdGlsaXRpZXMuY2FsY3VsYXRlTWluV2lkdGgobm9kZSk7XG4gICAgICB2YXIgbWluSCA9IGVsZW1lbnRVdGlsaXRpZXMuY2FsY3VsYXRlTWluSGVpZ2h0KG5vZGUpO1xuXG4gICAgICBpZih3ID09PSBtaW5XICYmIGggPT09IG1pbkgpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gU2VjdGlvbiBFbmRcbiAgICAvLyBBZGQgcmVtb3ZlIHV0aWxpdGllc1xuXG4gICAgLy8gUmVsb2NhdGVzIHN0YXRlIGFuZCBpbmZvIGJveGVzLiBUaGlzIGZ1bmN0aW9uIGlzIGV4cGVjdGVkIHRvIGJlIGNhbGxlZCBhZnRlciBhZGQvcmVtb3ZlIHN0YXRlIGFuZCBpbmZvIGJveGVzXG4gICAgZWxlbWVudFV0aWxpdGllcy5yZWxvY2F0ZVN0YXRlQW5kSW5mb3MgPSBmdW5jdGlvbiAoZWxlKSB7XG4gICAgICB2YXIgc3RhdGVBbmRJbmZvcyA9IChlbGUuaXNOb2RlICYmIGVsZS5pc05vZGUoKSkgPyBlbGUuZGF0YSgnc3RhdGVzYW5kaW5mb3MnKSA6IGVsZTtcbiAgICAgIHZhciBsZW5ndGggPSBzdGF0ZUFuZEluZm9zLmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGggPT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChsZW5ndGggPT0gMSkge1xuICAgICAgICBzdGF0ZUFuZEluZm9zWzBdLmJib3gueCA9IDA7XG4gICAgICAgIHN0YXRlQW5kSW5mb3NbMF0uYmJveC55ID0gLTUwO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAobGVuZ3RoID09IDIpIHtcbiAgICAgICAgc3RhdGVBbmRJbmZvc1swXS5iYm94LnggPSAwO1xuICAgICAgICBzdGF0ZUFuZEluZm9zWzBdLmJib3gueSA9IC01MDtcblxuICAgICAgICBzdGF0ZUFuZEluZm9zWzFdLmJib3gueCA9IDA7XG4gICAgICAgIHN0YXRlQW5kSW5mb3NbMV0uYmJveC55ID0gNTA7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChsZW5ndGggPT0gMykge1xuICAgICAgICBzdGF0ZUFuZEluZm9zWzBdLmJib3gueCA9IC0yNTtcbiAgICAgICAgc3RhdGVBbmRJbmZvc1swXS5iYm94LnkgPSAtNTA7XG5cbiAgICAgICAgc3RhdGVBbmRJbmZvc1sxXS5iYm94LnggPSAyNTtcbiAgICAgICAgc3RhdGVBbmRJbmZvc1sxXS5iYm94LnkgPSAtNTA7XG5cbiAgICAgICAgc3RhdGVBbmRJbmZvc1syXS5iYm94LnggPSAwO1xuICAgICAgICBzdGF0ZUFuZEluZm9zWzJdLmJib3gueSA9IDUwO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHN0YXRlQW5kSW5mb3NbMF0uYmJveC54ID0gLTI1O1xuICAgICAgICBzdGF0ZUFuZEluZm9zWzBdLmJib3gueSA9IC01MDtcblxuICAgICAgICBzdGF0ZUFuZEluZm9zWzFdLmJib3gueCA9IDI1O1xuICAgICAgICBzdGF0ZUFuZEluZm9zWzFdLmJib3gueSA9IC01MDtcblxuICAgICAgICBzdGF0ZUFuZEluZm9zWzJdLmJib3gueCA9IC0yNTtcbiAgICAgICAgc3RhdGVBbmRJbmZvc1syXS5iYm94LnkgPSA1MDtcblxuICAgICAgICBzdGF0ZUFuZEluZm9zWzNdLmJib3gueCA9IDI1O1xuICAgICAgICBzdGF0ZUFuZEluZm9zWzNdLmJib3gueSA9IDUwO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBDaGFuZ2Ugc3RhdGUgdmFsdWUgb3IgdW5pdCBvZiBpbmZvcm1hdGlvbiBib3ggb2YgZ2l2ZW4gbm9kZXMgd2l0aCBnaXZlbiBpbmRleC5cbiAgICAvLyBUeXBlIHBhcmFtZXRlciBpbmRpY2F0ZXMgd2hldGhlciB0byBjaGFuZ2UgdmFsdWUgb3IgdmFyaWFibGUsIGl0IGlzIHZhbGlkIGlmIHRoZSBib3ggYXQgdGhlIGdpdmVuIGluZGV4IGlzIGEgc3RhdGUgdmFyaWFibGUuXG4gICAgLy8gVmFsdWUgcGFyYW1ldGVyIGlzIHRoZSBuZXcgdmFsdWUgdG8gc2V0LlxuICAgIC8vIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIG9sZCB2YWx1ZSBvZiB0aGUgY2hhbmdlZCBkYXRhIChXZSBhc3N1bWUgdGhhdCB0aGUgb2xkIHZhbHVlIG9mIHRoZSBjaGFuZ2VkIGRhdGEgd2FzIHRoZSBzYW1lIGZvciBhbGwgbm9kZXMpLlxuICAgIC8vIEVhY2ggY2hhcmFjdGVyIGFzc3VtZWQgdG8gb2NjdXB5IDggdW5pdFxuICAgIC8vIEVhY2ggaW5mb2JveCBjYW4gaGF2ZSBhdCBtb3N0IDMyIHVuaXRzIG9mIHdpZHRoXG4gICAgZWxlbWVudFV0aWxpdGllcy5jaGFuZ2VTdGF0ZU9ySW5mb0JveCA9IGZ1bmN0aW9uIChub2RlcywgaW5kZXgsIHZhbHVlLCB0eXBlKSB7XG4gICAgICB2YXIgcmVzdWx0O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICB2YXIgc2JnbmNsYXNzID0gbm9kZS5kYXRhKCdjbGFzcycpO1xuICAgICAgICB2YXIgc3RhdGVBbmRJbmZvcyA9IG5vZGUuZGF0YSgnc3RhdGVzYW5kaW5mb3MnKTtcbiAgICAgICAgdmFyIGJveCA9IHN0YXRlQW5kSW5mb3NbaW5kZXhdO1xuICAgICAgICB2YXIgb2xkTGVuZ3RoID0gYm94LmJib3gudztcbiAgICAgICAgdmFyIG5ld0xlbmd0aCA9IDA7XG5cbiAgICAgICAgdmFyIGNvbnRlbnQgPSAnJztcbiAgICAgICAgaWYgKGJveC5jbGF6eiA9PSBcInN0YXRlIHZhcmlhYmxlXCIpIHtcbiAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gYm94LnN0YXRlW3R5cGVdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJveC5zdGF0ZVt0eXBlXSA9IHZhbHVlO1xuICAgICAgICAgIGlmIChib3guc3RhdGVbXCJ2YWx1ZVwiXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb250ZW50ICs9IGJveC5zdGF0ZVtcInZhbHVlXCJdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYm94LnN0YXRlW1widmFyaWFibGVcIl0gIT09IHVuZGVmaW5lZCAmJiBib3guc3RhdGVbXCJ2YXJpYWJsZVwiXS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb250ZW50ICs9IGJveC5zdGF0ZVtcInZhcmlhYmxlXCJdICsgXCJAXCI7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYm94LmNsYXp6ID09IFwidW5pdCBvZiBpbmZvcm1hdGlvblwiKSB7XG4gICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGJveC5sYWJlbC50ZXh0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250ZW50ICs9IHZhbHVlO1xuICAgICAgICAgIGJveC5sYWJlbC50ZXh0ID0gdmFsdWU7XG4gICAgICAgIH1lbHNlICBpZiAoYm94LmNsYXp6ID09IFwicmVzaWR1ZSB2YXJpYWJsZVwiKSB7XG4gICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGJveC5yZXNpZHVlW3R5cGVdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJveC5yZXNpZHVlW3R5cGVdID0gdmFsdWU7XG4gICAgICAgICAgaWYgKGJveC5yZXNpZHVlW1widmFyaWFibGVcIl0gIT09IHVuZGVmaW5lZCAmJiBib3gucmVzaWR1ZVtcInZhcmlhYmxlXCJdLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnRlbnQgKz0gYm94LnJlc2lkdWVbXCJ2YXJpYWJsZVwiXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlICBpZiAoYm94LmNsYXp6ID09IFwiYmluZGluZyByZWdpb25cIikge1xuICAgICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICByZXN1bHQgPSBib3gucmVnaW9uW3R5cGVdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJveC5yZWdpb25bdHlwZV0gPSB2YWx1ZTtcbiAgICAgICAgICBpZiAoYm94LnJlZ2lvbltcInZhcmlhYmxlXCJdICE9PSB1bmRlZmluZWQgJiYgYm94LnJlZ2lvbltcInZhcmlhYmxlXCJdLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnRlbnQgKz0gYm94LnJlZ2lvbltcInZhcmlhYmxlXCJdO1xuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1pbiA9ICggc2JnbmNsYXNzID09PSAnU0lGIG1hY3JvbW9sZWN1bGUnIHx8IHNiZ25jbGFzcyA9PT0gJ1NJRiBzaW1wbGUgY2hlbWljYWwnICkgPyAxNSA6IDEyO1xuICAgICAgICB2YXIgZm9udEZhbWlseSA9IGJveC5zdHlsZVsgJ2ZvbnQtZmFtaWx5JyBdO1xuICAgICAgICB2YXIgZm9udFNpemUgPSBib3guc3R5bGVbICdmb250LXNpemUnIF07XG4gICAgICAgIHZhciBib3JkZXJXaWR0aCA9IGJveC5zdHlsZVsgJ2JvcmRlci13aWR0aCcgXTtcbiAgICAgICAgdmFyIG9wdHMgPSB7XG4gICAgICAgICAgbWluLFxuICAgICAgICAgIG1heDogNDgsXG4gICAgICAgICAgbWFyZ2luOiBib3JkZXJXaWR0aCAvIDIgKyAwLjVcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHByZXZpb3VzV2lkdGggPSBib3guYmJveC53O1xuICAgICAgICBib3guYmJveC53ID0gZWxlbWVudFV0aWxpdGllcy5nZXRXaWR0aEJ5Q29udGVudCggY29udGVudCwgZm9udEZhbWlseSwgZm9udFNpemUsIG9wdHMgKTtcblxuICAgICAgICBpZihib3guYW5jaG9yU2lkZSA9PSBcInRvcFwiIHx8IGJveC5hbmNob3JTaWRlID09IFwiYm90dG9tXCIpe1xuICAgICAgICAgIHZhciB1bml0TGF5b3V0ID0gbm9kZS5kYXRhKClbXCJhdXh1bml0bGF5b3V0c1wiXVtib3guYW5jaG9yU2lkZV07XG4gICAgICAgICAgaWYodW5pdExheW91dC51bml0c1t1bml0TGF5b3V0LnVuaXRzLmxlbmd0aC0xXS5pZCA9PSBib3guaWQpe1xuICAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIGJvcmRlcldpZHRoID0gbm9kZS5kYXRhKClbJ2JvcmRlci13aWR0aCddO1xuICAgICAgICAgICAgdmFyIHNoaWZ0QW1vdW50ID0gKCgoYm94LmJib3gudyAtIHByZXZpb3VzV2lkdGgpIC8gMikgKiAxMDAgKS8gKG5vZGUub3V0ZXJXaWR0aCgpIC0gYm9yZGVyV2lkdGgpO1xuICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKHNoaWZ0QW1vdW50ID49IDApe1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgIGlmKGJveC5iYm94LnggKyBzaGlmdEFtb3VudCA8PSAxMDApe1xuICAgICAgICAgICAgICAgIGJveC5iYm94LnggPSBib3guYmJveC54ICsgc2hpZnRBbW91bnQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgLyogIGVsc2V7XG4gICAgICAgICAgICAgIHZhciBwcmV2aW91c0luZm9CYm94ID0ge3ggOiAwLCB3OjB9O1xuICAgICAgICAgICAgICBpZih1bml0TGF5b3V0LnVuaXRzLmxlbmd0aCA+IDEpe1xuICAgICAgICAgICAgICAgIHByZXZpb3VzSW5mb0Jib3g9IHVuaXRMYXlvdXQudW5pdHNbdW5pdExheW91dC51bml0cy5sZW5ndGgtMl0uYmJveDsgICAgICBcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgc2JnbnZpekluc3RhbmNlLmNsYXNzZXMuQXV4VW5pdExheW91dC5zZXRJZGVhbEdhcChub2RlLCBib3guYW5jaG9yU2lkZSk7XG4gICAgICAgICAgICAgIHZhciBpZGVhbEdhcCA9IHNiZ252aXpJbnN0YW5jZS5jbGFzc2VzLkF1eFVuaXRMYXlvdXQuZ2V0Q3VycmVudEdhcChib3guYW5jaG9yU2lkZSk7XG4gICAgICAgICAgICAgIHZhciBuZXdQb3NpdGlvbiA9IHByZXZpb3VzSW5mb0Jib3gueCArIChwcmV2aW91c0luZm9CYm94LncvMiArIGlkZWFsR2FwICsgYm94LmJib3gudy8yKSoxMDAgLyAobm9kZS5vdXRlcldpZHRoKCkgLSBib3JkZXJXaWR0aCk7XG4gICAgICAgICAgICAgIGJveC5iYm94LnggPSBuZXdQb3NpdGlvbjtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9ICovXG4gICAgICAgICAgIFxuICAgICAgICAgICBcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICAvKiBpZiAoYm94LmFuY2hvclNpZGUgPT09IFwidG9wXCIgfHwgYm94LmFuY2hvclNpZGUgPT09IFwiYm90dG9tXCIpIHtcbiAgICAgICAgICBib3guYmJveC54ICs9IChib3guYmJveC53IC0gb2xkTGVuZ3RoKSAvIDI7XG4gICAgICAgICAgdmFyIHVuaXRzID0gKG5vZGUuZGF0YSgnYXV4dW5pdGxheW91dHMnKVtib3guYW5jaG9yU2lkZV0pLnVuaXRzO1xuICAgICAgICAgIHZhciBzaGlmdEluZGV4ID0gMDtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHVuaXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZih1bml0c1tpXSA9PT0gYm94KXtcbiAgICAgICAgICAgICAgc2hpZnRJbmRleCA9IGk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKHZhciBqID0gc2hpZnRJbmRleCsxOyBqIDwgdW5pdHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgdW5pdHNbal0uYmJveC54ICs9IChib3guYmJveC53IC0gb2xkTGVuZ3RoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gKi9cblxuICAgICAgfVxuXG4gICAgICAvL1RPRE8gZmluZCBhIHdheSB0byBlbGltYXRlIHRoaXMgcmVkdW5kYW5jeSB0byB1cGRhdGUgaW5mby1ib3ggcG9zaXRpb25zXG4gICAgICBub2RlLmRhdGEoJ2JvcmRlci13aWR0aCcsIG5vZGUuZGF0YSgnYm9yZGVyLXdpZHRoJykpO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICAvLyBBZGQgYSBuZXcgc3RhdGUgb3IgaW5mbyBib3ggdG8gZ2l2ZW4gbm9kZXMuXG4gICAgLy8gVGhlIGJveCBpcyByZXByZXNlbnRlZCBieSB0aGUgcGFyYW1ldGVyIG9iai5cbiAgICAvLyBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUganVzdCBhZGRlZCBib3guXG4gICAgZWxlbWVudFV0aWxpdGllcy5hZGRTdGF0ZU9ySW5mb0JveCA9IGZ1bmN0aW9uIChub2Rlcywgb2JqKSB7XG4gICAgICBjb25zb2xlLmxvZyhcImFkZFN0YXRlT3JJbmZvQm94XCIpXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIHZhciBsb2NhdGlvbk9iajtcblxuICAgICAgICB2YXIgZGVmYXVsdFByb3BzID0gZWxlbWVudFV0aWxpdGllcy5nZXREZWZhdWx0UHJvcGVydGllcyggbm9kZS5kYXRhKCdjbGFzcycpICk7XG4gICAgICAgIHZhciBpbmZvYm94UHJvcHMgPSBkZWZhdWx0UHJvcHNbIG9iai5jbGF6eiBdO1xuICAgICAgICB2YXIgYmJveCA9IG9iai5iYm94IHx8IHsgdzogaW5mb2JveFByb3BzLndpZHRoLCBoOiBpbmZvYm94UHJvcHMuaGVpZ2h0IH07ICAgICAgICBcbiAgICAgICAgdmFyIHN0eWxlID0gZWxlbWVudFV0aWxpdGllcy5nZXREZWZhdWx0SW5mb2JveFN0eWxlKCBub2RlLmRhdGEoJ2NsYXNzJyksIG9iai5jbGF6eiApO1xuICAgICAgICBpZihvYmouc3R5bGUpe1xuICAgICAgICAgICQuZXh0ZW5kKCBzdHlsZSwgb2JqLnN0eWxlICk7XG4gICAgICAgIH1cbiAgICAgXG4gICAgICAgIGlmKG9iai5jbGF6eiA9PSBcInVuaXQgb2YgaW5mb3JtYXRpb25cIikge1xuICAgICAgICAgIGxvY2F0aW9uT2JqID0gc2JnbnZpekluc3RhbmNlLmNsYXNzZXMuVW5pdE9mSW5mb3JtYXRpb24uY3JlYXRlKG5vZGUsIGN5LCBvYmoubGFiZWwudGV4dCwgYmJveCwgb2JqLmxvY2F0aW9uLCBvYmoucG9zaXRpb24sIHN0eWxlLCBvYmouaW5kZXgsIG9iai5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob2JqLmNsYXp6ID09IFwic3RhdGUgdmFyaWFibGVcIikge1xuICAgICAgICAgIGxvY2F0aW9uT2JqID0gc2JnbnZpekluc3RhbmNlLmNsYXNzZXMuU3RhdGVWYXJpYWJsZS5jcmVhdGUobm9kZSwgY3ksIG9iai5zdGF0ZS52YWx1ZSwgb2JqLnN0YXRlLnZhcmlhYmxlLCBiYm94LCBvYmoubG9jYXRpb24sIG9iai5wb3NpdGlvbiwgc3R5bGUsIG9iai5pbmRleCwgb2JqLmlkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvYmouY2xhenogPT0gXCJyZXNpZHVlIHZhcmlhYmxlXCIpIHtcbiAgICAgICAgICBsb2NhdGlvbk9iaiA9IHNiZ252aXpJbnN0YW5jZS5jbGFzc2VzLlJlc2lkdWVWYXJpYWJsZS5jcmVhdGUobm9kZSwgY3ksIG9iai5yZXNpZHVlLnZhbHVlLCBvYmoucmVzaWR1ZS52YXJpYWJsZSwgYmJveCwgb2JqLmxvY2F0aW9uLCBvYmoucG9zaXRpb24sIHN0eWxlLCBvYmouaW5kZXgsIG9iai5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob2JqLmNsYXp6ID09IFwiYmluZGluZyByZWdpb25cIikge1xuICAgICAgICAgIGxvY2F0aW9uT2JqID0gc2JnbnZpekluc3RhbmNlLmNsYXNzZXMuQmluZGluZ1JlZ2lvbi5jcmVhdGUobm9kZSwgY3ksIG9iai5yZWdpb24udmFsdWUsIG9iai5yZWdpb24udmFyaWFibGUsIGJib3gsIG9iai5sb2NhdGlvbiwgb2JqLnBvc2l0aW9uLCBzdHlsZSwgb2JqLmluZGV4LCBvYmouaWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbG9jYXRpb25PYmo7XG4gICAgfTtcblxuICAgIC8vIFJlbW92ZSB0aGUgc3RhdGUgb3IgaW5mbyBib3hlcyBvZiB0aGUgZ2l2ZW4gbm9kZXMgYXQgZ2l2ZW4gaW5kZXguXG4gICAgLy8gUmV0dXJucyB0aGUgcmVtb3ZlZCBib3guXG4gICAgZWxlbWVudFV0aWxpdGllcy5yZW1vdmVTdGF0ZU9ySW5mb0JveCA9IGZ1bmN0aW9uIChub2RlcywgbG9jYXRpb25PYmopIHtcbiAgICAgIHZhciBvYmo7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIHZhciBzdGF0ZUFuZEluZm9zID0gbm9kZS5kYXRhKCdzdGF0ZXNhbmRpbmZvcycpO1xuICAgICAgICB2YXIgdW5pdCA9IHN0YXRlQW5kSW5mb3NbbG9jYXRpb25PYmouaW5kZXhdO1xuXG4gICAgICAgIHZhciB1bml0Q2xhc3MgPSBzYmdudml6SW5zdGFuY2UuY2xhc3Nlcy5nZXRBdXhVbml0Q2xhc3ModW5pdCk7XG5cbiAgICAgICAgb2JqID0gdW5pdENsYXNzLnJlbW92ZSh1bml0LCBjeSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvYmo7XG4gICAgfTtcblxuXG4gICAgLy9UaWxlcyBpbmZvcm1hdGlvbnMgYm94ZXMgZm9yIGdpdmVuIGFuY2hvclNpZGVzXG4gICAgZWxlbWVudFV0aWxpdGllcy5maXRVbml0cyA9IGZ1bmN0aW9uIChub2RlLCBsb2NhdGlvbnMpIHtcbiAgICAgIHZhciBvYmogPSBbXTtcbiAgICAgIG5vZGUuZGF0YSgnc3RhdGVzYW5kaW5mb3MnKS5mb3JFYWNoKCBmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgIG9iai5wdXNoKHtcbiAgICAgICAgICB4OiBlbGUuYmJveC54LFxuICAgICAgICAgIHk6IGVsZS5iYm94LnksXG4gICAgICAgICAgYW5jaG9yU2lkZTogZWxlLmFuY2hvclNpZGVcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHNiZ252aXpJbnN0YW5jZS5jbGFzc2VzLkF1eFVuaXRMYXlvdXQuZml0VW5pdHMobm9kZSwgY3ksIGxvY2F0aW9ucyk7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH07XG5cbiAgICAvL0NoZWNrIHdoaWNoIGFuY2hvcnNpZGVzIGZpdHNcbiAgICBlbGVtZW50VXRpbGl0aWVzLmNoZWNrRml0ID0gZnVuY3Rpb24gKG5vZGUsIGxvY2F0aW9uKSB7IC8vaWYgbm8gbG9jYXRpb24gZ2l2ZW4sIGl0IGNoZWNrcyBhbGwgcG9zc2libGUgbG9jYXRpb25zXG4gICAgICBjb25zb2xlLmxvZyhcImVsZW1lbnRVdGlsaXRpZXMuY2hlY2tGaXRcIiwgbm9kZSlcbiAgICAgIHJldHVybiBzYmdudml6SW5zdGFuY2UuY2xhc3Nlcy5BdXhVbml0TGF5b3V0LmNoZWNrRml0KG5vZGUsIGN5LCBsb2NhdGlvbik7XG4gICAgfTtcblxuICAgIC8vTW9kaWZ5IGFycmF5IG9mIGF1eCBsYXlvdXQgdW5pdHNcbiAgICBlbGVtZW50VXRpbGl0aWVzLm1vZGlmeVVuaXRzID0gZnVuY3Rpb24gKG5vZGUsIHVuaXQsIGFuY2hvclNpZGUpIHtcbiAgICAgIHNiZ252aXpJbnN0YW5jZS5jbGFzc2VzLkF1eFVuaXRMYXlvdXQubW9kaWZ5VW5pdHMobm9kZSwgdW5pdCwgYW5jaG9yU2lkZSwgY3kpO1xuICAgIH07XG5cbiAgICAvLyBTZXQgbXVsdGltZXIgc3RhdHVzIG9mIHRoZSBnaXZlbiBub2RlcyB0byB0aGUgZ2l2ZW4gc3RhdHVzLlxuICAgIGVsZW1lbnRVdGlsaXRpZXMuc2V0TXVsdGltZXJTdGF0dXMgPSBmdW5jdGlvbiAobm9kZXMsIHN0YXR1cykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICB2YXIgc2JnbmNsYXNzID0gbm9kZS5kYXRhKCdjbGFzcycpO1xuICAgICAgICB2YXIgaXNNdWx0aW1lciA9IG5vZGUuZGF0YSgnY2xhc3MnKS5lbmRzV2l0aCgnIG11bHRpbWVyJyk7XG5cbiAgICAgICAgaWYgKHN0YXR1cykgeyAvLyBNYWtlIG11bHRpbWVyIHN0YXR1cyB0cnVlXG4gICAgICAgICAgaWYgKCFpc011bHRpbWVyKSB7XG4gICAgICAgICAgICBub2RlLmRhdGEoJ2NsYXNzJywgc2JnbmNsYXNzICsgJyBtdWx0aW1lcicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gTWFrZSBtdWx0aW1lciBzdGF0dXMgZmFsc2VcbiAgICAgICAgICBpZiAoaXNNdWx0aW1lcikge1xuICAgICAgICAgICAgbm9kZS5kYXRhKCdjbGFzcycsIHNiZ25jbGFzcy5yZXBsYWNlKCcgbXVsdGltZXInLCAnJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICAvL05lZWQgdG8gYWRkIHRoaXMgdG8gZG9jIDogVE8tRE9cbiAgICBlbGVtZW50VXRpbGl0aWVzLnNldEFjdGl2ZVN0YXR1cyA9IGZ1bmN0aW9uIChub2Rlcywgc3RhdHVzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIHZhciBzYmduY2xhc3MgPSBub2RlLmRhdGEoJ2NsYXNzJyk7XG4gICAgICAgIHZhciBpc0FjdGl2ZSA9IG5vZGUuZGF0YSgnY2xhc3MnKS5zdGFydHNXaXRoKCdhY3RpdmUgJyk7XG5cbiAgICAgICAgaWYgKHN0YXR1cykgeyAvLyBNYWtlIG11bHRpbWVyIHN0YXR1cyB0cnVlXG4gICAgICAgICAgaWYgKCFpc0FjdGl2ZSkge1xuICAgICAgICAgICAgbm9kZS5kYXRhKCdjbGFzcycsICdhY3RpdmUgJyArIHNiZ25jbGFzcyk7XG4gICAgICAgICAgICAvL25vZGUuZGF0YSgnY2xhc3MnLCBzYmduY2xhc3MgKyAnIG11bHRpbWVyJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvLyBNYWtlIG11bHRpbWVyIHN0YXR1cyBmYWxzZVxuICAgICAgICAgIGlmIChpc0FjdGl2ZSkge1xuICAgICAgICAgICAgbm9kZS5kYXRhKCdjbGFzcycsIHNiZ25jbGFzcy5yZXBsYWNlKCdhY3RpdmUgJywgJycpKTtcbiAgICAgICAgICAgIC8vbm9kZS5kYXRhKCdjbGFzcycsIHNiZ25jbGFzcy5yZXBsYWNlKCcgbXVsdGltZXInLCAnJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgfTtcblxuICAgIC8vTmVlZCB0byBhZGQgdGhpcyB0byBkb2MgOiBUTy1ET1xuICAgIGVsZW1lbnRVdGlsaXRpZXMuc2V0SHlwb3RoZXRpY2FsU3RhdHVzID0gZnVuY3Rpb24gKG5vZGVzLCBzdGF0dXMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgdmFyIHNiZ25jbGFzcyA9IG5vZGUuZGF0YSgnY2xhc3MnKTtcbiAgICAgICAgdmFyIGlzSHlwb3RoZXRpY2FsID0gbm9kZS5kYXRhKCdjbGFzcycpLmluY2x1ZGVzKCdoeXBvdGhldGljYWwnKTtcbiAgICAgICAgdmFyIGlzQWN0aXZlID0gbm9kZS5kYXRhKCdjbGFzcycpLnN0YXJ0c1dpdGgoJ2FjdGl2ZSAnKTtcblxuICAgICAgICBpZiAoc3RhdHVzKSB7IC8vIE1ha2UgbXVsdGltZXIgc3RhdHVzIHRydWVcbiAgICAgICAgICBpZiAoIWlzSHlwb3RoZXRpY2FsKSB7XG4gICAgICAgICAgICBpZiAoaXNBY3RpdmUpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciB0bXAgPSBzYmduY2xhc3Muc3Vic3RyaW5nKDcpXG4gICAgICAgICAgICAgIG5vZGUuZGF0YSgnY2xhc3MnLCAnYWN0aXZlIGh5cG90aGV0aWNhbCAnICsgdG1wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgIG5vZGUuZGF0YSgnY2xhc3MnLCAnaHlwb3RoZXRpY2FsICcgKyBzYmduY2xhc3MpO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL25vZGUuZGF0YSgnY2xhc3MnLCBzYmduY2xhc3MgKyAnIG11bHRpbWVyJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvLyBNYWtlIG11bHRpbWVyIHN0YXR1cyBmYWxzZVxuICAgICAgICAgIGlmIChpc0h5cG90aGV0aWNhbCkge1xuICAgICAgICAgICAgbm9kZS5kYXRhKCdjbGFzcycsIHNiZ25jbGFzcy5yZXBsYWNlKCdoeXBvdGhldGljYWwgJywgJycpKTtcbiAgICAgICAgICAgIC8vbm9kZS5kYXRhKCdjbGFzcycsIHNiZ25jbGFzcy5yZXBsYWNlKCcgbXVsdGltZXInLCAnJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgfTtcblxuICAgIC8vIENoYW5nZSBmb250IHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIGVsZW1lbnRzIHdpdGggZ2l2ZW4gZm9udCBkYXRhXG4gICAgZWxlbWVudFV0aWxpdGllcy5jaGFuZ2VGb250UHJvcGVydGllcyA9IGZ1bmN0aW9uIChlbGVzLCBkYXRhKSB7XG4gICAgICBmb3IgKHZhciBwcm9wIGluIGRhdGEpIHtcbiAgICAgICAgZWxlcy5kYXRhKHByb3AsIGRhdGFbcHJvcF0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGdldHMgYW4gZWRnZSwgYW5kIGVuZHMgb2YgdGhhdCBlZGdlIChPcHRpb25hbGx5IGl0IG1heSB0YWtlIGp1c3QgdGhlIGNsYXNzZXMgb2YgdGhlIGVkZ2UgYXMgd2VsbCkgYXMgcGFyYW1ldGVycy5cbiAgICAvLyBJdCBtYXkgcmV0dXJuICd2YWxpZCcgKHRoYXQgZW5kcyBpcyB2YWxpZCBmb3IgdGhhdCBlZGdlKSwgJ3JldmVyc2UnICh0aGF0IGVuZHMgaXMgbm90IHZhbGlkIGZvciB0aGF0IGVkZ2UgYnV0IHRoZXkgd291bGQgYmUgdmFsaWRcbiAgICAvLyBpZiB5b3UgcmV2ZXJzZSB0aGUgc291cmNlIGFuZCB0YXJnZXQpLCAnaW52YWxpZCcgKHRoYXQgZW5kcyBhcmUgdG90YWxseSBpbnZhbGlkIGZvciB0aGF0IGVkZ2UpLlxuICAgIGVsZW1lbnRVdGlsaXRpZXMudmFsaWRhdGVBcnJvd0VuZHMgPSBmdW5jdGlvbiAoZWRnZSwgc291cmNlLCB0YXJnZXQsIGlzUmVwbGFjZW1lbnQpIHtcblxuICAgICAgLy8gaWYgbWFwIHR5cGUgaXMgVW5rbm93biAtLSBubyBydWxlcyBhcHBsaWVkXG4gICAgICBpZiAoZWxlbWVudFV0aWxpdGllcy5nZXRNYXBUeXBlKCkgPT0gXCJIeWJyaWRBbnlcIiB8fCBlbGVtZW50VXRpbGl0aWVzLmdldE1hcFR5cGUoKSA9PSBcIkh5YnJpZFNiZ25cIiB8fCAhZWxlbWVudFV0aWxpdGllcy5nZXRNYXBUeXBlKCkpXG4gICAgICAgIHJldHVybiBcInZhbGlkXCI7XG5cbiAgICAgIHZhciBlZGdlY2xhc3MgPSB0eXBlb2YgZWRnZSA9PT0gJ3N0cmluZycgPyBlZGdlIDogZWRnZS5kYXRhKCdjbGFzcycpO1xuICAgICAgdmFyIHNvdXJjZWNsYXNzID0gc291cmNlLmRhdGEoJ2NsYXNzJyk7XG4gICAgICB2YXIgdGFyZ2V0Y2xhc3MgPSB0YXJnZXQuZGF0YSgnY2xhc3MnKTtcbiAgICAgIHZhciBtYXBUeXBlID0gZWxlbWVudFV0aWxpdGllcy5nZXRNYXBUeXBlKCk7XG4gICAgICB2YXIgZWRnZUNvbnN0cmFpbnRzID0gZWxlbWVudFV0aWxpdGllc1ttYXBUeXBlXS5jb25uZWN0aXZpdHlDb25zdHJhaW50c1tlZGdlY2xhc3NdO1xuXG4gICAgICBpZiAobWFwVHlwZSA9PSBcIkFGXCIpe1xuICAgICAgICBpZiAoc291cmNlY2xhc3Muc3RhcnRzV2l0aChcIkJBXCIpKSAvLyB3ZSBoYXZlIHNlcGFyYXRlIGNsYXNzZXMgZm9yIGVhY2ggYmlvbG9naWNhbCBhY3Rpdml0eVxuICAgICAgICAgIHNvdXJjZWNsYXNzID0gXCJiaW9sb2dpY2FsIGFjdGl2aXR5XCI7IC8vIGJ1dCBzYW1lIHJ1bGUgYXBwbGllcyB0byBhbGwgb2YgdGhlbVxuXG4gICAgICAgIGlmICh0YXJnZXRjbGFzcy5zdGFydHNXaXRoKFwiQkFcIikpIC8vIHdlIGhhdmUgc2VwYXJhdGUgY2xhc3NlcyBmb3IgZWFjaCBiaW9sb2dpY2FsIGFjdGl2aXR5XG4gICAgICAgICAgdGFyZ2V0Y2xhc3MgPSBcImJpb2xvZ2ljYWwgYWN0aXZpdHlcIjsgLy8gYnV0IHNhbWUgcnVsZSBhcHBsaWVzIHRvIGFsbCBvZiB0aGVtXG4gICAgICB9XG4gICAgICBlbHNlIGlmIChtYXBUeXBlID09IFwiUERcIil7XG4gICAgICAgIHNvdXJjZWNsYXNzID0gc291cmNlY2xhc3MucmVwbGFjZSgvXFxzKm11bHRpbWVyJC8sICcnKTtcbiAgICAgICAgdGFyZ2V0Y2xhc3MgPSB0YXJnZXRjbGFzcy5yZXBsYWNlKC9cXHMqbXVsdGltZXIkLywgJycpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAobWFwVHlwZSA9PSBcIlNCTUxcIil7XG4gICAgICAgIHNvdXJjZWNsYXNzID0gc291cmNlY2xhc3MucmVwbGFjZSgvXFxzKm11bHRpbWVyJC8sICcnKTtcbiAgICAgICAgdGFyZ2V0Y2xhc3MgPSB0YXJnZXRjbGFzcy5yZXBsYWNlKC9cXHMqbXVsdGltZXIkLywgJycpO1xuICAgICAgICBzb3VyY2VjbGFzcyA9IHNvdXJjZWNsYXNzLnJlcGxhY2UoXCJhY3RpdmUgXCIsICcnKTtcbiAgICAgICAgdGFyZ2V0Y2xhc3MgPSB0YXJnZXRjbGFzcy5yZXBsYWNlKFwiYWN0aXZlIFwiLCAnJyk7XG4gICAgICAgIHNvdXJjZWNsYXNzID0gc291cmNlY2xhc3MucmVwbGFjZShcImh5cG90aGV0aWNhbCBcIiwgJycpO1xuICAgICAgICB0YXJnZXRjbGFzcyA9IHRhcmdldGNsYXNzLnJlcGxhY2UoXCJoeXBvdGhldGljYWwgXCIsICcnKTtcbiAgICAgIH1cblxuICAgICAgLy8gZ2l2ZW4gYSBub2RlLCBhY3RpbmcgYXMgc291cmNlIG9yIHRhcmdldCwgcmV0dXJucyBib29sZWFuIHdldGhlciBvciBub3QgaXQgaGFzIHRvbyBtYW55IGVkZ2VzIGFscmVhZHlcbiAgICAgIGZ1bmN0aW9uIGhhc1Rvb01hbnlFZGdlcyhub2RlLCBzb3VyY2VPclRhcmdldCkge1xuICAgICAgICB2YXIgbm9kZWNsYXNzID0gbm9kZS5kYXRhKCdjbGFzcycpO1xuICAgICAgICBub2RlY2xhc3MgPSBub2RlY2xhc3MucmVwbGFjZSgvXFxzKm11bHRpbWVyJC8sICcnKTtcbiAgICAgICAgbm9kZWNsYXNzID0gbm9kZWNsYXNzLnJlcGxhY2UoXCJhY3RpdmUgXCIsICcnKTtcbiAgICAgICAgbm9kZWNsYXNzID0gbm9kZWNsYXNzLnJlcGxhY2UoXCJoeXBvdGhldGljYWwgXCIsICcnKTtcbiAgICAgICAgaWYgKG5vZGVjbGFzcy5zdGFydHNXaXRoKFwiQkFcIikpXG4gICAgICAgICAgbm9kZWNsYXNzID0gXCJiaW9sb2dpY2FsIGFjdGl2aXR5XCI7XG5cbiAgICAgICAgLypcbiAgICAgICAgICBPbiB0aGUgbG9naWMgYmVsb3c6XG5cbiAgICAgICAgICBDdXJyZW50IGVkZ2UgY291bnQgKGluY29taW5nIG9yIG91dGdvaW5nKSBvZiBub2RlcyBzaG91bGQgYmUgc3RyaWN0bHkgbGVzcyBcbiAgICAgICAgICB0aGFuIHRoZSBtYXhpbXVtIGFsbG93ZWQgaWYgd2UgYXJlIGFkZGluZyBhbiBlZGdlIHRvIHRoZSBub2RlLiBUaGlzIHdheVxuICAgICAgICAgIGl0IHdpbGwgbmV2ZXIgZXhjZWVkIHRoZSBtYXggY291bnQuXG4gICAgICAgICAgXG4gICAgICAgICAgRWRnZXMgY2FuIGJlIGFkZGVkIGluIHR3byBkaWZmZXJlbnQgd2F5cy4gRWl0aGVyIHRoZXkgYXJlIGFkZGVkIGRpcmVjdGx5IG9yXG4gICAgICAgICAgdGhleSBhcmUgYWRkZWQgYnkgYmVpbmcgcmVwbGFjZWQgZnJvbSBhbm90aGVyIG5vZGUsIGkuZSBkaXNjb25uZWN0ZWQgZnJvbVxuICAgICAgICAgIG9uZSBhbmQgY29ubmVjdGVkIHRvIGFub3RoZXIuXG5cbiAgICAgICAgICBXZSBjYW4gZGV0ZWN0IGlmIHRoZSBlZGdlIGJlaW5nIGFkZGVkIGlzIGFkZGVkIGZyb20gYSByZXBsYWNlbWVudCBieSBjaGVja2luZ1xuICAgICAgICAgIHdoZXRoZXIgdGhlIHNvdXJjZSBzdGF5ZWQgdGhlIHNhbWUgd2hlbiBjaGVja2luZyBlZGdlIGNvdW50cyBvZiB0aGUgc291cmNlIG5vZGUsXG4gICAgICAgICAgYW5kIHdoZXRoZXIgdGhlIHRhcmdldCBzdGF5ZWQgdGhlIHNhbWUgd2hlbiBjaGVja2luZyBlZGdlIGNvdW50cyBvZiB0aGVcbiAgICAgICAgICB0YXJnZXQgbm9kZS5cblxuICAgICAgICAgIEN1cnJlbnQgZWRnZSBjb3VudCBvZiBub2RlcyBjYW4gYmUgYWxsb3dlZCB0byBiZSBlcXVhbCB0byB0aGUgbWF4aW11bSBpbiBcbiAgICAgICAgICBjYXNlcyB3aGVyZSBhIHJlcGxhY2VtZW50IGlzIG1hZGUuIEJ1dCB3ZSBzaG91bGQgYmUgY2FyZWZ1bCB0aGF0IHRoaXNcbiAgICAgICAgICByZXBsYWNlbWVudCBvcGVyYXRpb24gaXMgbm90IGFsc28gYW4gYWRkaXRpb24gb3BlcmF0aW9uIGFzIGRlc2NyaWJlZCBhYm92ZS5cbiAgICAgICAgKi9cblxuICAgICAgICB2YXIgdG90YWxUb29NYW55ID0gdHJ1ZTtcbiAgICAgICAgdmFyIGVkZ2VUb29NYW55ID0gdHJ1ZTtcbiAgICAgICAgaWYgKHNvdXJjZU9yVGFyZ2V0ID09IFwic291cmNlXCIpIHtcbiAgICAgICAgICAgIHZhciBzYW1lRWRnZUNvdW50T3V0ID0gbm9kZS5vdXRnb2VycygnZWRnZVtjbGFzcz1cIicrZWRnZWNsYXNzKydcIl0nKS5zaXplKCk7XG4gICAgICAgICAgICB2YXIgdG90YWxFZGdlQ291bnRPdXQgPSBub2RlLm91dGdvZXJzKCdlZGdlJykuc2l6ZSgpO1xuICAgICAgICAgICAgdmFyIG1heFRvdGFsID0gZWRnZUNvbnN0cmFpbnRzW25vZGVjbGFzc10uYXNTb3VyY2UubWF4VG90YWw7IFxuICAgICAgICAgICAgdmFyIG1heEVkZ2UgPSBlZGdlQ29uc3RyYWludHNbbm9kZWNsYXNzXS5hc1NvdXJjZS5tYXhFZGdlO1xuXG4gICAgICAgICAgICB2YXIgY29tcGFyZVN0cmljdCA9ICEoaXNSZXBsYWNlbWVudCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChlZGdlLnNvdXJjZSgpID09PSBzb3VyY2UpKTtcblxuICAgICAgICAgICAgdmFyIHdpdGhpbkxpbWl0cyA9ICFtYXhUb3RhbCB8fCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjb21wYXJlU3RyaWN0ICYmICh0b3RhbEVkZ2VDb3VudE91dCA8IG1heFRvdGFsKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICghY29tcGFyZVN0cmljdCAmJiAodG90YWxFZGdlQ291bnRPdXQgPD0gbWF4VG90YWwpKTtcblxuICAgICAgICAgICAgaWYgKHdpdGhpbkxpbWl0cykge1xuICAgICAgICAgICAgICAgIHRvdGFsVG9vTWFueSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGhlbiBjaGVjayBsaW1pdHMgZm9yIHRoaXMgc3BlY2lmaWMgZWRnZSBjbGFzc1xuXG4gICAgICAgICAgICB3aXRoaW5MaW1pdHMgPSAhbWF4RWRnZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjb21wYXJlU3RyaWN0ICYmIChzYW1lRWRnZUNvdW50T3V0IDwgbWF4RWRnZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIWNvbXBhcmVTdHJpY3QgJiYgKHNhbWVFZGdlQ291bnRPdXQgPD0gbWF4RWRnZSkpKTsgXG5cbiAgICAgICAgICAgIGlmICh3aXRoaW5MaW1pdHMpIHtcbiAgICAgICAgICAgICAgICBlZGdlVG9vTWFueSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiBvbmx5IG9uZSBvZiB0aGUgbGltaXRzIGlzIHJlYWNoZWQgdGhlbiBlZGdlIGlzIGludmFsaWRcbiAgICAgICAgICAgIHJldHVybiB0b3RhbFRvb01hbnkgfHwgZWRnZVRvb01hbnk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vIG5vZGUgaXMgdXNlZCBhcyB0YXJnZXRcbiAgICAgICAgICAgIHZhciBzYW1lRWRnZUNvdW50SW4gPSBub2RlLmluY29tZXJzKCdlZGdlW2NsYXNzPVwiJytlZGdlY2xhc3MrJ1wiXScpLnNpemUoKTtcbiAgICAgICAgICAgIHZhciB0b3RhbEVkZ2VDb3VudEluID0gbm9kZS5pbmNvbWVycygnZWRnZScpLnNpemUoKTtcbiAgICAgICAgICAgIHZhciBtYXhUb3RhbCA9IGVkZ2VDb25zdHJhaW50c1tub2RlY2xhc3NdLmFzVGFyZ2V0Lm1heFRvdGFsOyBcbiAgICAgICAgICAgIHZhciBtYXhFZGdlID0gZWRnZUNvbnN0cmFpbnRzW25vZGVjbGFzc10uYXNUYXJnZXQubWF4RWRnZTtcblxuICAgICAgICAgICAgdmFyIGNvbXBhcmVTdHJpY3QgPSAhKGlzUmVwbGFjZW1lbnQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGVkZ2UudGFyZ2V0KCkgPT09IHRhcmdldCkpO1xuXG4gICAgICAgICAgICB2YXIgd2l0aGluTGltaXRzID0gIW1heFRvdGFsIHx8IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGNvbXBhcmVTdHJpY3QgJiYgKHRvdGFsRWRnZUNvdW50SW4gPCBtYXhUb3RhbCkpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIWNvbXBhcmVTdHJpY3QgJiYgKHRvdGFsRWRnZUNvdW50SW4gPD0gbWF4VG90YWwpKTtcblxuICAgICAgICAgICAgaWYgKHdpdGhpbkxpbWl0cykge1xuICAgICAgICAgICAgICAgIHRvdGFsVG9vTWFueSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3aXRoaW5MaW1pdHMgPSAhbWF4RWRnZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAoY29tcGFyZVN0cmljdCAmJiAoc2FtZUVkZ2VDb3VudEluIDwgbWF4RWRnZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKCFjb21wYXJlU3RyaWN0ICYmIChzYW1lRWRnZUNvdW50SW4gPD0gbWF4RWRnZSkpKTsgXG5cbiAgICAgICAgICAgIGlmICh3aXRoaW5MaW1pdHMpIHtcbiAgICAgICAgICAgICAgICBlZGdlVG9vTWFueSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRvdGFsVG9vTWFueSB8fCBlZGdlVG9vTWFueTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpc0luQ29tcGxleChub2RlKSB7XG4gICAgICAgIHZhciBwYXJlbnRDbGFzcyA9IG5vZGUucGFyZW50KCkuZGF0YSgnY2xhc3MnKTtcbiAgICAgICAgcmV0dXJuIHBhcmVudENsYXNzICYmIHBhcmVudENsYXNzLnN0YXJ0c1dpdGgoJ2NvbXBsZXgnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzSW5Db21wbGV4KHNvdXJjZSkgfHwgaXNJbkNvbXBsZXgodGFyZ2V0KSkgeyAvLyBzdWJ1bml0cyBvZiBhIGNvbXBsZXggYXJlIG5vIGxvbmdlciBFUE5zLCBubyBjb25uZWN0aW9uIGFsbG93ZWRcbiAgICAgICAgcmV0dXJuICdpbnZhbGlkJztcbiAgICAgIH1cblxuICAgICAgLy8gY2hlY2sgbmF0dXJlIG9mIGNvbm5lY3Rpb25cbiAgICAgIGlmIChlZGdlQ29uc3RyYWludHNbc291cmNlY2xhc3NdLmFzU291cmNlLmlzQWxsb3dlZCAmJiBlZGdlQ29uc3RyYWludHNbdGFyZ2V0Y2xhc3NdLmFzVGFyZ2V0LmlzQWxsb3dlZCkge1xuICAgICAgICAvLyBjaGVjayBhbW91bnQgb2YgY29ubmVjdGlvbnNcbiAgICAgICAgaWYgKCFoYXNUb29NYW55RWRnZXMoc291cmNlLCBcInNvdXJjZVwiKSAmJiAhaGFzVG9vTWFueUVkZ2VzKHRhcmdldCwgXCJ0YXJnZXRcIikgKSB7XG4gICAgICAgICAgcmV0dXJuICd2YWxpZCc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIHRyeSB0byByZXZlcnNlXG4gICAgICBpZiAoZWRnZUNvbnN0cmFpbnRzW3RhcmdldGNsYXNzXS5hc1NvdXJjZS5pc0FsbG93ZWQgJiYgZWRnZUNvbnN0cmFpbnRzW3NvdXJjZWNsYXNzXS5hc1RhcmdldC5pc0FsbG93ZWQpIHtcbiAgICAgICAgaWYgKCFoYXNUb29NYW55RWRnZXModGFyZ2V0LCBcInNvdXJjZVwiKSAmJiAhaGFzVG9vTWFueUVkZ2VzKHNvdXJjZSwgXCJ0YXJnZXRcIikgKSB7XG4gICAgICAgICAgcmV0dXJuICdyZXZlcnNlJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuICdpbnZhbGlkJztcbiAgICB9O1xuXG4gICAgZWxlbWVudFV0aWxpdGllcy5kZWxldGVBbmRQZXJmb3JtTGF5b3V0ID0gZnVuY3Rpb24oZWxlcywgbGF5b3V0cGFyYW0pIHtcbiAgICAgIHZhciByZXN1bHQgPSBlbGVzLnJlbW92ZSgpO1xuICAgICAgaWYgKHR5cGVvZiBsYXlvdXRwYXJhbSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBsYXlvdXRwYXJhbSgpOyAvLyBJZiBsYXlvdXRwYXJhbSBpcyBhIGZ1bmN0aW9uIGV4ZWN1dGUgaXRcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciBsYXlvdXQgPSBjeS5sYXlvdXQobGF5b3V0cGFyYW0pOyAvLyBJZiBsYXlvdXRwYXJhbSBpcyBsYXlvdXQgb3B0aW9ucyBjYWxsIGxheW91dCB3aXRoIHRoYXQgb3B0aW9ucy5cblxuICAgICAgICAgIC8vIERvIHRoaXMgY2hlY2sgZm9yIGN5dG9zY2FwZS5qcyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gICAgICAgICAgaWYgKGxheW91dCAmJiBsYXlvdXQucnVuKSB7XG4gICAgICAgICAgICAgIGxheW91dC5ydW4oKTtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIC8qXG4gICAgICogSGlkZSBnaXZlbiBlbGVzIGFuZCBwZXJmb3JtIGdpdmVuIGxheW91dCBhZnRlcndhcmQuIExheW91dCBwYXJhbWV0ZXIgbWF5IGJlIGxheW91dCBvcHRpb25zXG4gICAgICogb3IgYSBmdW5jdGlvbiB0byBjYWxsLlxuICAgICAqL1xuICAgIGVsZW1lbnRVdGlsaXRpZXMuaGlkZUFuZFBlcmZvcm1MYXlvdXQgPSBmdW5jdGlvbihlbGVzLCBsYXlvdXRwYXJhbSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gY3kudmlld1V0aWxpdGllcygpLmhpZGUoZWxlcyk7IC8vIEhpZGUgZ2l2ZW4gZWxlc1xuICAgICAgICBpZiAodHlwZW9mIGxheW91dHBhcmFtID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBsYXlvdXRwYXJhbSgpOyAvLyBJZiBsYXlvdXRwYXJhbSBpcyBhIGZ1bmN0aW9uIGV4ZWN1dGUgaXRcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBsYXlvdXQgPSBjeS5sYXlvdXQobGF5b3V0cGFyYW0pOyAvLyBJZiBsYXlvdXRwYXJhbSBpcyBsYXlvdXQgb3B0aW9ucyBjYWxsIGxheW91dCB3aXRoIHRoYXQgb3B0aW9ucy5cblxuICAgICAgICAgICAgLy8gRG8gdGhpcyBjaGVjayBmb3IgY3l0b3NjYXBlLmpzIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAgICAgICAgICAgIGlmIChsYXlvdXQgJiYgbGF5b3V0LnJ1bikge1xuICAgICAgICAgICAgICAgIGxheW91dC5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIC8qXG4gICAgICogVW5oaWRlIGdpdmVuIGVsZXMgYW5kIHBlcmZvcm0gZ2l2ZW4gbGF5b3V0IGFmdGVyd2FyZC4gTGF5b3V0IHBhcmFtZXRlciBtYXkgYmUgbGF5b3V0IG9wdGlvbnNcbiAgICAgKiBvciBhIGZ1bmN0aW9uIHRvIGNhbGwuXG4gICAgICovXG4gICAgZWxlbWVudFV0aWxpdGllcy5zaG93QW5kUGVyZm9ybUxheW91dCA9IGZ1bmN0aW9uKGVsZXMsIGxheW91dHBhcmFtKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gY3kudmlld1V0aWxpdGllcygpLnNob3coZWxlcyk7IC8vIFNob3cgZ2l2ZW4gZWxlc1xuICAgICAgaWYgKHR5cGVvZiBsYXlvdXRwYXJhbSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBsYXlvdXRwYXJhbSgpOyAvLyBJZiBsYXlvdXRwYXJhbSBpcyBhIGZ1bmN0aW9uIGV4ZWN1dGUgaXRcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB2YXIgbGF5b3V0ID0gY3kubGF5b3V0KGxheW91dHBhcmFtKTsgLy8gSWYgbGF5b3V0cGFyYW0gaXMgbGF5b3V0IG9wdGlvbnMgY2FsbCBsYXlvdXQgd2l0aCB0aGF0IG9wdGlvbnMuXG5cbiAgICAgICAgLy8gRG8gdGhpcyBjaGVjayBmb3IgY3l0b3NjYXBlLmpzIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAgICAgICAgaWYgKGxheW91dCAmJiBsYXlvdXQucnVuKSB7XG4gICAgICAgICAgbGF5b3V0LnJ1bigpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIC8qXG4gICAgICogQ2hhbmdlIHN0eWxlL2NzcyBvZiBnaXZlbiBlbGVzIGJ5IHNldHRpbmcgZ2V0dGluZyBwcm9wZXJ0eSBuYW1lIHRvIHRoZSBnaXZlbiB2YWx1ZS92YWx1ZXMgKE5vdGUgdGhhdCB2YWx1ZU1hcCBwYXJhbWV0ZXIgbWF5IGJlXG4gICAgICogYSBzaW5nbGUgc3RyaW5nIG9yIGFuIGlkIHRvIHZhbHVlIG1hcCkuXG4gICAgICovXG4gICAgZWxlbWVudFV0aWxpdGllcy5jaGFuZ2VDc3MgPSBmdW5jdGlvbihlbGVzLCBuYW1lLCB2YWx1ZU1hcCkge1xuICAgICAgaWYgKCB0eXBlb2YgdmFsdWVNYXAgPT09ICdvYmplY3QnICkge1xuICAgICAgICBjeS5zdGFydEJhdGNoKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBlbGUgPSBjeS5nZXRFbGVtZW50QnlJZChlbGVzW2ldLmlkKCkpO1xuICAgICAgICAgIGVsZS5jc3MobmFtZSwgdmFsdWVNYXBbZWxlLmlkKCldKTsgLy8gdmFsdWVNYXAgaXMgYW4gaWQgdG8gdmFsdWUgbWFwIHVzZSBpdCBpbiB0aGlzIHdheVxuICAgICAgICB9XG4gICAgICAgIGN5LmVuZEJhdGNoKCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZWxlcy5jc3MobmFtZSwgdmFsdWVNYXApOyAvLyB2YWx1ZU1hcCBpcyBqdXN0IGEgc3RyaW5nIHNldCBjc3MoJ25hbWUnKSBmb3IgYWxsIGVsZXMgdG8gdGhpcyB2YWx1ZVxuICAgICAgfVxuICAgIH07XG5cbiAgICAvKlxuICAgICAqIENoYW5nZSBkYXRhIG9mIGdpdmVuIGVsZXMgYnkgc2V0dGluZyBnZXR0aW5nIHByb3BlcnR5IG5hbWUgdG8gdGhlIGdpdmVuIHZhbHVlL3ZhbHVlcyAoTm90ZSB0aGF0IHZhbHVlTWFwIHBhcmFtZXRlciBtYXkgYmVcbiAgICAgKiBhIHNpbmdsZSBzdHJpbmcgb3IgYW4gaWQgdG8gdmFsdWUgbWFwKS5cbiAgICAgKi9cbiAgICBlbGVtZW50VXRpbGl0aWVzLmNoYW5nZURhdGEgPSBmdW5jdGlvbihlbGVzLCBuYW1lLCB2YWx1ZU1hcCkge1xuICAgICAgY29uc29sZS5sb2coXCJjaGFuZ2luZyBkYXRhIGluIGNoaXNlXCIpXG4gICAgICBpZiAoIHR5cGVvZiB2YWx1ZU1hcCA9PT0gJ29iamVjdCcgKSB7XG4gICAgICAgIGN5LnN0YXJ0QmF0Y2goKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGVsZSA9IGN5LmdldEVsZW1lbnRCeUlkKGVsZXNbaV0uaWQoKSk7XG4gICAgICAgICAgZWxlLmRhdGEobmFtZSwgdmFsdWVNYXBbZWxlLmlkKCldKTsgLy8gdmFsdWVNYXAgaXMgYW4gaWQgdG8gdmFsdWUgbWFwIHVzZSBpdCBpbiB0aGlzIHdheVxuICAgICAgICB9XG4gICAgICAgIGN5LmVuZEJhdGNoKCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZWxlcy5kYXRhKG5hbWUsIHZhbHVlTWFwKTsgLy8gdmFsdWVNYXAgaXMganVzdCBhIHN0cmluZyBzZXQgY3NzKCduYW1lJykgZm9yIGFsbCBlbGVzIHRvIHRoaXMgdmFsdWVcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZWxlbWVudFV0aWxpdGllcy51cGRhdGVTZXRGaWVsZCA9IGZ1bmN0aW9uKGVsZSwgZmllbGROYW1lLCB0b0RlbGV0ZSwgdG9BZGQsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgc2V0ID0gZWxlLmRhdGEoIGZpZWxkTmFtZSApO1xuICAgICAgaWYgKCAhc2V0ICkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgdXBkYXRlcyA9IHt9O1xuXG4gICAgICBpZiAoIHRvRGVsZXRlICE9IG51bGwgJiYgc2V0WyB0b0RlbGV0ZSBdICkge1xuICAgICAgICBkZWxldGUgc2V0WyB0b0RlbGV0ZSBdO1xuICAgICAgICB1cGRhdGVzLmRlbGV0ZWQgPSB0b0RlbGV0ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCB0b0FkZCAhPSBudWxsICkge1xuICAgICAgICBzZXRbIHRvQWRkIF0gPSB0cnVlO1xuICAgICAgICB1cGRhdGVzLmFkZGVkID0gdG9BZGQ7XG4gICAgICB9XG5cbiAgICAgIGlmICggY2FsbGJhY2sgJiYgKCB1cGRhdGVzWyAnZGVsZXRlZCcgXSAhPSBudWxsIHx8IHVwZGF0ZXNbICdhZGRlZCcgXSAhPSBudWxsICkgKSB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1cGRhdGVzO1xuICAgIH07XG5cbiAgICAvKlxuICAgICAqIFJldHVybiB0aGUgc2V0IG9mIGFsbCBub2RlcyBwcmVzZW50IHVuZGVyIHRoZSBnaXZlbiBwb3NpdGlvblxuICAgICAqIHJlbmRlcmVkUG9zIG11c3QgYmUgYSBwb2ludCBkZWZpbmVkIHJlbGF0aXZlbHkgdG8gY3l0b3NjYXBlIGNvbnRhaW5lclxuICAgICAqIChsaWtlIHJlbmRlcmVkUG9zaXRpb24gZmllbGQgb2YgYSBub2RlKVxuICAgICAqL1xuICAgIGVsZW1lbnRVdGlsaXRpZXMuZ2V0Tm9kZXNBdCA9IGZ1bmN0aW9uKHJlbmRlcmVkUG9zKSB7XG4gICAgICB2YXIgbm9kZXMgPSBjeS5ub2RlcygpO1xuICAgICAgdmFyIHggPSByZW5kZXJlZFBvcy54O1xuICAgICAgdmFyIHkgPSByZW5kZXJlZFBvcy55O1xuICAgICAgdmFyIHJlc3VsdE5vZGVzID0gW107XG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgdmFyIHJlbmRlcmVkQmJveCA9IG5vZGUucmVuZGVyZWRCb3VuZGluZ0JveCh7XG4gICAgICAgICAgaW5jbHVkZU5vZGVzOiB0cnVlLFxuICAgICAgICAgIGluY2x1ZGVFZGdlczogZmFsc2UsXG4gICAgICAgICAgaW5jbHVkZUxhYmVsczogZmFsc2UsXG4gICAgICAgICAgaW5jbHVkZVNoYWRvd3M6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoeCA+PSByZW5kZXJlZEJib3gueDEgJiYgeCA8PSByZW5kZXJlZEJib3gueDIpIHtcbiAgICAgICAgICBpZiAoeSA+PSByZW5kZXJlZEJib3gueTEgJiYgeSA8PSByZW5kZXJlZEJib3gueTIpIHtcbiAgICAgICAgICAgIHJlc3VsdE5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0Tm9kZXM7XG4gICAgfTtcblxuICAgIGVsZW1lbnRVdGlsaXRpZXMuZGVtdWx0aW1lcml6ZUNsYXNzID0gZnVuY3Rpb24oc2JnbmNsYXNzKSB7XG4gICAgICByZXR1cm4gc2JnbmNsYXNzLnJlcGxhY2UoXCIgbXVsdGltZXJcIiwgXCJcIik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBtYXBUeXBlIC0gdHlwZSBvZiB0aGUgY3VycmVudCBtYXAgKFBELCBBRiBvciBVbmtub3duKVxuICAgICAqL1xuICAgIGVsZW1lbnRVdGlsaXRpZXMuc2V0TWFwVHlwZSA9IGZ1bmN0aW9uKG1hcFR5cGUpe1xuICAgICAgZWxlbWVudFV0aWxpdGllcy5tYXBUeXBlID0gbWFwVHlwZTtcbiAgICAgIHJldHVybiBtYXBUeXBlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJldHVybiAtIG1hcCB0eXBlXG4gICAgICovXG4gICAgZWxlbWVudFV0aWxpdGllcy5nZXRNYXBUeXBlID0gZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnRVdGlsaXRpZXMubWFwVHlwZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzZXRzIG1hcCB0eXBlXG4gICAgICovXG4gICAgZWxlbWVudFV0aWxpdGllcy5yZXNldE1hcFR5cGUgPSBmdW5jdGlvbigpe1xuICAgICAgICBlbGVtZW50VXRpbGl0aWVzLm1hcFR5cGUgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogS2VlcCBjb25zaXN0ZW5jeSBvZiBsaW5rcyB0byBzZWxmIGluc2lkZSB0aGUgZGF0YSgpIHN0cnVjdHVyZS5cbiAgICAgKiBUaGlzIGlzIG5lZWRlZCB3aGVuZXZlciBhIG5vZGUgY2hhbmdlcyBwYXJlbnRzLCBmb3IgZXhhbXBsZSxcbiAgICAgKiBhcyBpdCBpcyBkZXN0cm95ZWQgYW5kIHJlY3JlYXRlZC4gQnV0IHRoZSBkYXRhKCkgc3RheXMgaWRlbnRpY2FsLlxuICAgICAqIFRoaXMgY3JlYXRlcyBpbmNvbnNpc3RlbmNpZXMgZm9yIHRoZSBwb2ludGVycyBzdG9yZWQgaW4gZGF0YSgpLFxuICAgICAqIGFzIHRoZXkgbm93IHBvaW50IHRvIGEgZGVsZXRlZCBub2RlLlxuICAgICAqL1xuICAgIGVsZW1lbnRVdGlsaXRpZXMubWFpbnRhaW5Qb2ludGVyID0gZnVuY3Rpb24gKGVsZXMpIHtcbiAgICAgIGVsZXMubm9kZXMoKS5mb3JFYWNoKGZ1bmN0aW9uKGVsZSl7XG4gICAgICAgIC8vIHJlc3RvcmUgYmFja2dyb3VuZCBpbWFnZXNcbiAgICAgICAgZWxlLmVtaXQoJ2RhdGEnKTtcblxuICAgICAgICAvLyBza2lwIG5vZGVzIHdpdGhvdXQgYW55IGF1eGlsaWFyeSB1bml0c1xuICAgICAgICBpZighZWxlLmRhdGEoJ3N0YXRlc2FuZGluZm9zJykgfHwgZWxlLmRhdGEoJ3N0YXRlc2FuZGluZm9zJykubGVuZ3RoID09IDApIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yKHZhciBzaWRlIGluIGVsZS5kYXRhKCdhdXh1bml0bGF5b3V0cycpKSB7XG4gICAgICAgICAgZWxlLmRhdGEoJ2F1eHVuaXRsYXlvdXRzJylbc2lkZV0ucGFyZW50Tm9kZSA9IGVsZS5pZCgpO1xuICAgICAgICB9XG4gICAgICAgIGZvcih2YXIgaT0wOyBpIDwgZWxlLmRhdGEoJ3N0YXRlc2FuZGluZm9zJykubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBlbGUuZGF0YSgnc3RhdGVzYW5kaW5mb3MnKVtpXS5wYXJlbnQgPSBlbGUuaWQoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZWxlbWVudFV0aWxpdGllcy5hbnlIYXNCYWNrZ3JvdW5kSW1hZ2UgPSBmdW5jdGlvbiAoZWxlcykge1xuICAgICAgdmFyIG9iaiA9IGVsZW1lbnRVdGlsaXRpZXMuZ2V0QmFja2dyb3VuZEltYWdlT2JqcyhlbGVzKTtcbiAgICAgIGlmKG9iaiA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICBlbHNle1xuICAgICAgICBmb3IodmFyIGtleSBpbiBvYmope1xuICAgICAgICAgIHZhciB2YWx1ZSA9IG9ialtrZXldO1xuICAgICAgICAgIGlmKHZhbHVlICYmICEkLmlzRW1wdHlPYmplY3QodmFsdWUpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGVsZW1lbnRVdGlsaXRpZXMuaGFzQmFja2dyb3VuZEltYWdlID0gZnVuY3Rpb24gKGVsZSkge1xuICAgICAgaWYgKCFlbGUuaXNOb2RlKCkgfHwgIWVsZS5kYXRhKCdiYWNrZ3JvdW5kLWltYWdlJykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIGJnO1xuICAgICAgXG4gICAgICBpZih0eXBlb2YgZWxlLmRhdGEoJ2JhY2tncm91bmQtaW1hZ2UnKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBiZyA9IGVsZS5kYXRhKCdiYWNrZ3JvdW5kLWltYWdlJykuc3BsaXQoXCIgXCIpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZihBcnJheS5pc0FycmF5KG9ialsnYmFja2dyb3VuZC1pbWFnZSddKSkge1xuICAgICAgICBiZyA9IGVsZS5kYXRhKCdiYWNrZ3JvdW5kLWltYWdlJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghYmcpIHJldHVybiBmYWxzZTtcblxuICAgICAgdmFyIGNsb25lSW1nID0gJ2RhdGE6aW1hZ2Uvc3ZnK3htbDt1dGY4LCUzQ3N2ZyUyMHdpZHRoJTNEJTIyMTAwJTIyJTIwaGVpZ2h0JTNEJTIyMTAwJTIyJTIwdmlld0JveCUzRCUyMjAlMjAwJTIwMTAwJTIwMTAwJTIyJTIwc3R5bGUlM0QlMjJmaWxsJTNBbm9uZSUzQnN0cm9rZSUzQWJsYWNrJTNCc3Ryb2tlLXdpZHRoJTNBMCUzQiUyMiUyMHhtbG5zJTNEJTIyaHR0cCUzQS8vd3d3LnczLm9yZy8yMDAwL3N2ZyUyMiUyMCUzRSUzQ3JlY3QlMjB4JTNEJTIyMCUyMiUyMHklM0QlMjIwJTIyJTIwd2lkdGglM0QlMjIxMDAlMjIlMjBoZWlnaHQlM0QlMjIxMDAlMjIlMjBzdHlsZSUzRCUyMmZpbGwlM0ElMjM4MzgzODMlMjIvJTNFJTIwJTNDL3N2ZyUzRSc7XG4gICAgICAvLyBJZiBjbG9uZUltZyBpcyBub3QgdGhlIG9ubHkgaW1hZ2Ugb3IgdGhlcmUgYXJlIG11bHRpcGxlIGltYWdlcyB0aGVyZSBpcyBhIGJhY2tncm91bmQgaW1hZ2VcbiAgICAgIHZhciBvbmx5SGFzQ2xvbmVNYXJrZXJBc0JnSW1hZ2UgPSAoYmcubGVuZ3RoID09PSAxKSAmJiAoYmcuaW5kZXhPZihjbG9uZUltZykgPT09IDApO1xuXG4gICAgICBpZihiZy5sZW5ndGggPiAxIHx8ICEob25seUhhc0Nsb25lTWFya2VyQXNCZ0ltYWdlKSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBlbGVtZW50VXRpbGl0aWVzLmdldEJhY2tncm91bmRJbWFnZVVSTCA9IGZ1bmN0aW9uIChlbGVzKSB7XG4gICAgICAoJ2dldHRpbmcgYmFja2dyb3VuZCBpbWFnZXMnKVxuICAgICAgaWYoIWVsZXMgfHwgZWxlcy5sZW5ndGggPCAxKVxuICAgICAgICByZXR1cm47XG5cbiAgICAgIHZhciBjb21tb25VUkwgPSBcIlwiO1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgZWxlID0gZWxlc1tpXTtcblxuICAgICAgICBpZighZWxlLmlzTm9kZSgpIHx8ICFlbGVtZW50VXRpbGl0aWVzLmhhc0JhY2tncm91bmRJbWFnZShlbGUpKVxuICAgICAgICAgIHJldHVybjtcblxuICAgICAgICB2YXIgdXJsID0gZWxlLmRhdGEoJ2JhY2tncm91bmQtaW1hZ2UnKS5zcGxpdChcIiBcIikucG9wKCk7XG4gICAgICAgIGlmKCF1cmwgfHwgdXJsLmluZGV4T2YoJ2h0dHAnKSAhPT0gMCB8fCAoY29tbW9uVVJMICE9PSBcIlwiICYmIGNvbW1vblVSTCAhPT0gdXJsKSlcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGVsc2UgaWYoY29tbW9uVVJMID09PSBcIlwiKVxuICAgICAgICAgIGNvbW1vblVSTCA9IHVybDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbW1vblVSTDtcbiAgICB9XG5cbiAgICBlbGVtZW50VXRpbGl0aWVzLmdldEJhY2tncm91bmRJbWFnZU9ianMgPSBmdW5jdGlvbiAoZWxlcykge1xuICAgICAgaWYoIWVsZXMgfHwgZWxlcy5sZW5ndGggPCAxKVxuICAgICAgICByZXR1cm47XG5cbiAgICAgIHZhciBsaXN0ID0ge307XG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgICB2YXIgb2JqID0gZ2V0QmdPYmooZWxlKTtcbiAgICAgICAgaWYoT2JqZWN0LmtleXMob2JqKS5sZW5ndGggPCAxKVxuICAgICAgICAgIHJldHVybjtcblxuICAgICAgICBsaXN0W2VsZS5kYXRhKCdpZCcpXSA9IG9iajtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsaXN0O1xuXG4gICAgICBmdW5jdGlvbiBnZXRCZ09iaiAoZWxlKSB7XG4gICAgICAgIGlmKGVsZS5pc05vZGUoKSAmJiBlbGVtZW50VXRpbGl0aWVzLmhhc0JhY2tncm91bmRJbWFnZShlbGUpKXtcbiAgICAgICAgICB2YXIga2V5cyA9IFsnYmFja2dyb3VuZC1pbWFnZScsICdiYWNrZ3JvdW5kLWZpdCcsICdiYWNrZ3JvdW5kLWltYWdlLW9wYWNpdHknLFxuICAgICAgICAgICdiYWNrZ3JvdW5kLXBvc2l0aW9uLXgnLCAnYmFja2dyb3VuZC1wb3NpdGlvbi15JywgJ2JhY2tncm91bmQtaGVpZ2h0JywgJ2JhY2tncm91bmQtd2lkdGgnXTtcblxuICAgICAgICAgIHZhciBvYmogPSB7fTtcbiAgICAgICAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgICAgICBpZiAoZWxlLmRhdGEoa2V5KSAmJiAodHlwZW9mIGVsZS5kYXRhKGtleSkgPT09IFwic3RyaW5nXCIpKSB7XG4gICAgICAgICAgICAgIHZhbHVlID0gZWxlLmRhdGEoa2V5KS5zcGxpdChcIiBcIilbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdmFsdWUgPSBlbGUuZGF0YShrZXkpO1xuICAgICAgICAgICAgfSAgICAgICAgICAgXG4gICAgICAgICAgICBvYmpba2V5XSA9IHZhbHVlO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmKGVsZS5pc05vZGUoKSlcbiAgICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG4gICAgfVxuXG4gICAgZWxlbWVudFV0aWxpdGllcy5nZXRCYWNrZ3JvdW5kRml0T3B0aW9ucyA9IGZ1bmN0aW9uIChlbGVzKSB7XG4gICAgICBpZighZWxlcyB8fCBlbGVzLmxlbmd0aCA8IDEpXG4gICAgICAgIHJldHVybjtcblxuICAgICAgdmFyIGNvbW1vbkZpdCA9IFwiXCI7XG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBub2RlID0gZWxlc1tpXTtcbiAgICAgICAgaWYoIW5vZGUuaXNOb2RlKCkpXG4gICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIHZhciBmaXQgPSBnZXRGaXRPcHRpb24obm9kZSk7XG4gICAgICAgIGlmKCFmaXQgfHwgKGNvbW1vbkZpdCAhPT0gXCJcIiAmJiBmaXQgIT09IGNvbW1vbkZpdCkpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBlbHNlIGlmKGNvbW1vbkZpdCA9PT0gXCJcIilcbiAgICAgICAgICBjb21tb25GaXQgPSBmaXQ7XG4gICAgICB9XG5cbiAgICAgIHZhciBvcHRpb25zID0gJzxvcHRpb24gdmFsdWU9XCJub25lXCI+Tm9uZTwvb3B0aW9uPidcbiAgICAgICAgICAgICAgICAgICsgJzxvcHRpb24gdmFsdWU9XCJmaXRcIj5GaXQ8L29wdGlvbj4nXG4gICAgICAgICAgICAgICAgICArICc8b3B0aW9uIHZhbHVlPVwiY292ZXJcIj5Db3Zlcjwvb3B0aW9uPidcbiAgICAgICAgICAgICAgICAgICsgJzxvcHRpb24gdmFsdWU9XCJjb250YWluXCI+Q29udGFpbjwvb3B0aW9uPic7XG4gICAgICB2YXIgc2VhcmNoS2V5ID0gJ3ZhbHVlPVwiJyArIGNvbW1vbkZpdCArICdcIic7XG4gICAgICB2YXIgaW5kZXggPSBvcHRpb25zLmluZGV4T2Yoc2VhcmNoS2V5KSArIHNlYXJjaEtleS5sZW5ndGg7XG4gICAgICByZXR1cm4gb3B0aW9ucy5zdWJzdHIoMCwgaW5kZXgpICsgJyBzZWxlY3RlZCcgKyBvcHRpb25zLnN1YnN0cihpbmRleCk7XG5cbiAgICAgIGZ1bmN0aW9uIGdldEZpdE9wdGlvbihub2RlKSB7XG4gICAgICAgIGlmKCFlbGVtZW50VXRpbGl0aWVzLmhhc0JhY2tncm91bmRJbWFnZShub2RlKSlcbiAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgdmFyIGYgPSBub2RlLmRhdGEoJ2JhY2tncm91bmQtZml0Jyk7XG4gICAgICAgIHZhciBoID0gbm9kZS5kYXRhKCdiYWNrZ3JvdW5kLWhlaWdodCcpO1xuXG4gICAgICAgIGlmKCFmIHx8ICFoKVxuICAgICAgICAgIHJldHVybjtcblxuICAgICAgICBmID0gZi5zcGxpdChcIiBcIik7XG4gICAgICAgIGggPSBoLnNwbGl0KFwiIFwiKTtcbiAgICAgICAgaWYoZltmLmxlbmd0aC0xXSA9PT0gXCJub25lXCIpXG4gICAgICAgICAgcmV0dXJuIChoW2gubGVuZ3RoLTFdID09PSBcImF1dG9cIiA/IFwibm9uZVwiIDogXCJmaXRcIik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICByZXR1cm4gZltmLmxlbmd0aC0xXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBlbGVtZW50VXRpbGl0aWVzLnVwZGF0ZUJhY2tncm91bmRJbWFnZSA9IGZ1bmN0aW9uIChub2RlcywgYmdPYmopIHtcbiAgICAgIGlmKCFub2RlcyB8fCBub2Rlcy5sZW5ndGggPT0gMCB8fCAhYmdPYmopXG4gICAgICAgIHJldHVybjtcblxuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgdmFyIG9iaiA9IGJnT2JqW25vZGUuZGF0YSgnaWQnKV07XG4gICAgICAgIGlmKCFvYmogfHwgJC5pc0VtcHR5T2JqZWN0KG9iaikpXG4gICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgdmFyIGltZ3MgPSBub2RlLmRhdGEoJ2JhY2tncm91bmQtaW1hZ2UnKSA/IG5vZGUuZGF0YSgnYmFja2dyb3VuZC1pbWFnZScpLnNwbGl0KFwiIFwiKSA6IFtdO1xuICAgICAgICB2YXIgeFBvcyA9IG5vZGUuZGF0YSgnYmFja2dyb3VuZC1wb3NpdGlvbi14JykgPyBub2RlLmRhdGEoJ2JhY2tncm91bmQtcG9zaXRpb24teCcpLnNwbGl0KFwiIFwiKSA6IFtdO1xuICAgICAgICB2YXIgeVBvcyA9IG5vZGUuZGF0YSgnYmFja2dyb3VuZC1wb3NpdGlvbi15JykgPyBub2RlLmRhdGEoJ2JhY2tncm91bmQtcG9zaXRpb24teScpLnNwbGl0KFwiIFwiKSA6IFtdO1xuICAgICAgICB2YXIgd2lkdGhzID0gbm9kZS5kYXRhKCdiYWNrZ3JvdW5kLXdpZHRoJykgPyBub2RlLmRhdGEoJ2JhY2tncm91bmQtd2lkdGgnKS5zcGxpdChcIiBcIikgOiBbXTtcbiAgICAgICAgdmFyIGhlaWdodHMgPSBub2RlLmRhdGEoJ2JhY2tncm91bmQtaGVpZ2h0JykgPyBub2RlLmRhdGEoJ2JhY2tncm91bmQtaGVpZ2h0Jykuc3BsaXQoXCIgXCIpIDogW107XG4gICAgICAgIHZhciBmaXRzID0gbm9kZS5kYXRhKCdiYWNrZ3JvdW5kLWZpdCcpID8gbm9kZS5kYXRhKCdiYWNrZ3JvdW5kLWZpdCcpLnNwbGl0KFwiIFwiKSA6IFtdO1xuICAgICAgICB2YXIgb3BhY2l0aWVzID0gbm9kZS5kYXRhKCdiYWNrZ3JvdW5kLWltYWdlLW9wYWNpdHknKSA/IChcIlwiICsgbm9kZS5kYXRhKCdiYWNrZ3JvdW5kLWltYWdlLW9wYWNpdHknKSkuc3BsaXQoXCIgXCIpIDogW107XG5cbiAgICAgICAgdmFyIGluZGV4ID0gLTE7XG4gICAgICAgIGlmKHR5cGVvZiBvYmpbJ2JhY2tncm91bmQtaW1hZ2UnXSA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICBpbmRleCA9IGltZ3MuaW5kZXhPZihvYmpbJ2JhY2tncm91bmQtaW1hZ2UnXSk7XG4gICAgICAgIGVsc2UgaWYoQXJyYXkuaXNBcnJheShvYmpbJ2JhY2tncm91bmQtaW1hZ2UnXSkpXG4gICAgICAgICAgaW5kZXggPSBpbWdzLmluZGV4T2Yob2JqWydiYWNrZ3JvdW5kLWltYWdlJ11bMF0pO1xuXG4gICAgICAgIGlmKGluZGV4IDwgMClcbiAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICBpZihvYmpbJ2JhY2tncm91bmQtaW1hZ2UnXSAmJiBpbWdzLmxlbmd0aCA+IGluZGV4KXtcbiAgICAgICAgICB2YXIgdG1wID0gaW1nc1tpbmRleF07XG4gICAgICAgICAgaW1nc1tpbmRleF0gPSBvYmpbJ2JhY2tncm91bmQtaW1hZ2UnXTtcbiAgICAgICAgICBvYmpbJ2JhY2tncm91bmQtaW1hZ2UnXSA9IHRtcDtcbiAgICAgICAgfVxuICAgICAgICBpZihvYmpbJ2JhY2tncm91bmQtZml0J10gJiYgZml0cy5sZW5ndGggPiBpbmRleCl7XG4gICAgICAgICAgdmFyIHRtcCA9IGZpdHNbaW5kZXhdO1xuICAgICAgICAgIGZpdHNbaW5kZXhdID0gb2JqWydiYWNrZ3JvdW5kLWZpdCddO1xuICAgICAgICAgIG9ialsnYmFja2dyb3VuZC1maXQnXSA9IHRtcDtcbiAgICAgICAgfVxuICAgICAgICBpZihvYmpbJ2JhY2tncm91bmQtd2lkdGgnXSAmJiB3aWR0aHMubGVuZ3RoID4gaW5kZXgpe1xuICAgICAgICAgIHZhciB0bXAgPSB3aWR0aHNbaW5kZXhdO1xuICAgICAgICAgIHdpZHRoc1tpbmRleF0gPSBvYmpbJ2JhY2tncm91bmQtd2lkdGgnXTtcbiAgICAgICAgICBvYmpbJ2JhY2tncm91bmQtd2lkdGgnXSA9IHRtcDtcbiAgICAgICAgfVxuICAgICAgICBpZihvYmpbJ2JhY2tncm91bmQtaGVpZ2h0J10gJiYgaGVpZ2h0cy5sZW5ndGggPiBpbmRleCl7XG4gICAgICAgICAgdmFyIHRtcCA9IGhlaWdodHNbaW5kZXhdO1xuICAgICAgICAgIGhlaWdodHNbaW5kZXhdID0gb2JqWydiYWNrZ3JvdW5kLWhlaWdodCddO1xuICAgICAgICAgIG9ialsnYmFja2dyb3VuZC1oZWlnaHQnXSA9IHRtcDtcbiAgICAgICAgfVxuICAgICAgICBpZihvYmpbJ2JhY2tncm91bmQtcG9zaXRpb24teCddICYmIHhQb3MubGVuZ3RoID4gaW5kZXgpe1xuICAgICAgICAgIHZhciB0bXAgPSB4UG9zW2luZGV4XTtcbiAgICAgICAgICB4UG9zW2luZGV4XSA9IG9ialsnYmFja2dyb3VuZC1wb3NpdGlvbi14J107XG4gICAgICAgICAgb2JqWydiYWNrZ3JvdW5kLXBvc2l0aW9uLXgnXSA9IHRtcDtcbiAgICAgICAgfVxuICAgICAgICBpZihvYmpbJ2JhY2tncm91bmQtcG9zaXRpb24teSddICYmIHlQb3MubGVuZ3RoID4gaW5kZXgpe1xuICAgICAgICAgIHZhciB0bXAgPSB5UG9zW2luZGV4XTtcbiAgICAgICAgICB5UG9zW2luZGV4XSA9IG9ialsnYmFja2dyb3VuZC1wb3NpdGlvbi15J107XG4gICAgICAgICAgb2JqWydiYWNrZ3JvdW5kLXBvc2l0aW9uLXknXSA9IHRtcDtcbiAgICAgICAgfVxuICAgICAgICBpZihvYmpbJ2JhY2tncm91bmQtaW1hZ2Utb3BhY2l0eSddICYmIG9wYWNpdGllcy5sZW5ndGggPiBpbmRleCl7XG4gICAgICAgICAgdmFyIHRtcCA9IG9wYWNpdGllc1tpbmRleF07XG4gICAgICAgICAgb3BhY2l0aWVzW2luZGV4XSA9IG9ialsnYmFja2dyb3VuZC1pbWFnZS1vcGFjaXR5J107XG4gICAgICAgICAgb2JqWydiYWNrZ3JvdW5kLWltYWdlLW9wYWNpdHknXSA9IHRtcDtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUuZGF0YSgnYmFja2dyb3VuZC1pbWFnZScsIGltZ3Muam9pbihcIiBcIikpO1xuICAgICAgICBub2RlLmRhdGEoJ2JhY2tncm91bmQtcG9zaXRpb24teCcsIHhQb3Muam9pbihcIiBcIikpO1xuICAgICAgICBub2RlLmRhdGEoJ2JhY2tncm91bmQtcG9zaXRpb24teScsIHlQb3Muam9pbihcIiBcIikpO1xuICAgICAgICBub2RlLmRhdGEoJ2JhY2tncm91bmQtd2lkdGgnLCB3aWR0aHMuam9pbihcIiBcIikpO1xuICAgICAgICBub2RlLmRhdGEoJ2JhY2tncm91bmQtaGVpZ2h0JywgaGVpZ2h0cy5qb2luKFwiIFwiKSk7XG4gICAgICAgIG5vZGUuZGF0YSgnYmFja2dyb3VuZC1maXQnLCBmaXRzLmpvaW4oXCIgXCIpKTtcbiAgICAgICAgbm9kZS5kYXRhKCdiYWNrZ3JvdW5kLWltYWdlLW9wYWNpdHknLCBvcGFjaXRpZXMuam9pbihcIiBcIikpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYmdPYmo7XG4gICAgfVxuXG4gICAgZWxlbWVudFV0aWxpdGllcy5jaGFuZ2VCYWNrZ3JvdW5kSW1hZ2UgPSBmdW5jdGlvbiAobm9kZXMsIG9sZEltZywgbmV3SW1nLCBmaXJzdFRpbWUsIHVwZGF0ZUluZm8sIHByb21wdEludmFsaWRJbWFnZSwgdmFsaWRhdGVVUkwpIHtcbiAgICAgIGlmKCFub2RlcyB8fCBub2Rlcy5sZW5ndGggPT0gMCB8fCAhb2xkSW1nIHx8ICFuZXdJbWcpXG4gICAgICAgIHJldHVybjtcblxuICAgICAgZWxlbWVudFV0aWxpdGllcy5yZW1vdmVCYWNrZ3JvdW5kSW1hZ2Uobm9kZXMsIG9sZEltZyk7XG4gICAgICBmb3IodmFyIGtleSBpbiBuZXdJbWcpe1xuICAgICAgICBuZXdJbWdba2V5XVsnZmlyc3RUaW1lJ10gPSBmaXJzdFRpbWU7XG4gICAgICB9XG4gICAgICBlbGVtZW50VXRpbGl0aWVzLmFkZEJhY2tncm91bmRJbWFnZShub2RlcywgbmV3SW1nLCB1cGRhdGVJbmZvLCBwcm9tcHRJbnZhbGlkSW1hZ2UsIHZhbGlkYXRlVVJMKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbm9kZXM6IG5vZGVzLFxuICAgICAgICBvbGRJbWc6IG5ld0ltZyxcbiAgICAgICAgbmV3SW1nOiBvbGRJbWcsXG4gICAgICAgIGZpcnN0VGltZTogZmFsc2UsXG4gICAgICAgIHByb21wdEludmFsaWRJbWFnZTogcHJvbXB0SW52YWxpZEltYWdlLFxuICAgICAgICB2YWxpZGF0ZVVSTDogdmFsaWRhdGVVUkxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gQWRkIGEgYmFja2dyb3VuZCBpbWFnZSB0byBnaXZlbiBub2Rlcy5cbiAgICBlbGVtZW50VXRpbGl0aWVzLmFkZEJhY2tncm91bmRJbWFnZSA9IGZ1bmN0aW9uIChub2RlcywgYmdPYmosIHVwZGF0ZUluZm8sIHByb21wdEludmFsaWRJbWFnZSwgdmFsaWRhdGVVUkwpIHtcbiAgICAgIGlmKCFub2RlcyB8fCBub2Rlcy5sZW5ndGggPT0gMCB8fCAhYmdPYmopXG4gICAgICAgIHJldHVybjtcblxuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgdmFyIG9iaiA9IGJnT2JqW25vZGUuZGF0YSgnaWQnKV07XG4gICAgICAgIGlmKCFvYmogfHwgJC5pc0VtcHR5T2JqZWN0KG9iaikpXG4gICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgLy8gTG9hZCB0aGUgaW1hZ2UgZnJvbSBsb2NhbCwgZWxzZSBqdXN0IHB1dCB0aGUgVVJMXG4gICAgICAgIGlmKG9ialsnZnJvbUZpbGUnXSlcbiAgICAgICAgbG9hZEJhY2tncm91bmRUaGVuQXBwbHkobm9kZSwgb2JqKTtcbiAgICAgICAgLy8gVmFsaWRpdHkgb2YgZ2l2ZW4gVVJMIHNob3VsZCBiZSBjaGVja2VkIGJlZm9yZSBhcHBseWluZyBpdFxuICAgICAgICBlbHNlIGlmKG9ialsnZmlyc3RUaW1lJ10pe1xuICAgICAgICAgIGlmKHR5cGVvZiB2YWxpZGF0ZVVSTCA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHZhbGlkYXRlVVJMKG5vZGUsIG9iaiwgYXBwbHlCYWNrZ3JvdW5kLCBwcm9tcHRJbnZhbGlkSW1hZ2UpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGNoZWNrR2l2ZW5VUkwobm9kZSwgb2JqKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgYXBwbHlCYWNrZ3JvdW5kKG5vZGUsIG9iaik7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGxvYWRCYWNrZ3JvdW5kVGhlbkFwcGx5KG5vZGUsIGJnT2JqKSB7XG4gICAgICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICB2YXIgaW1nRmlsZSA9IGJnT2JqWydiYWNrZ3JvdW5kLWltYWdlJ107XG5cbiAgICAgICAgLy8gQ2hlY2sgd2hldGhlciBnaXZlbiBmaWxlIGlzIGFuIGltYWdlIGZpbGVcbiAgICAgICAgaWYoaW1nRmlsZS50eXBlLmluZGV4T2YoXCJpbWFnZVwiKSAhPT0gMCl7XG4gICAgICAgICAgaWYocHJvbXB0SW52YWxpZEltYWdlKVxuICAgICAgICAgICAgcHJvbXB0SW52YWxpZEltYWdlKFwiSW52YWxpZCBpbWFnZSBmaWxlIGlzIGdpdmVuIVwiKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICByZWFkZXIucmVhZEFzRGF0YVVSTChpbWdGaWxlKTtcblxuICAgICAgICByZWFkZXIub25sb2FkID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICB2YXIgaW1nID0gcmVhZGVyLnJlc3VsdDtcbiAgICAgICAgICBpZihpbWcpe1xuICAgICAgICAgICAgYmdPYmpbJ2JhY2tncm91bmQtaW1hZ2UnXSA9IGltZztcbiAgICAgICAgICAgIGJnT2JqWydmcm9tRmlsZSddID0gZmFsc2U7XG4gICAgICAgICAgICBhcHBseUJhY2tncm91bmQobm9kZSwgYmdPYmopO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgaWYocHJvbXB0SW52YWxpZEltYWdlKVxuICAgICAgICAgICAgICBwcm9tcHRJbnZhbGlkSW1hZ2UoXCJHaXZlbiBmaWxlIGNvdWxkIG5vdCBiZSByZWFkIVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGNoZWNrR2l2ZW5VUkwobm9kZSwgYmdPYmope1xuICAgICAgICB2YXIgdXJsID0gYmdPYmpbJ2JhY2tncm91bmQtaW1hZ2UnXTtcbiAgICAgICAgdmFyIGV4dGVuc2lvbiA9ICh1cmwuc3BsaXQoL1s/I10vKVswXSkuc3BsaXQoXCIuXCIpLnBvcCgpO1xuICAgICAgICB2YXIgdmFsaWRFeHRlbnNpb25zID0gW1wicG5nXCIsIFwic3ZnXCIsIFwianBnXCIsIFwianBlZ1wiXTtcblxuICAgICAgICBpZighdmFsaWRFeHRlbnNpb25zLmluY2x1ZGVzKGV4dGVuc2lvbikpe1xuICAgICAgICAgIGlmKHR5cGVvZiBwcm9tcHRJbnZhbGlkSW1hZ2UgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICBwcm9tcHRJbnZhbGlkSW1hZ2UoXCJJbnZhbGlkIFVSTCBpcyBnaXZlbiFcIik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgJC5hamF4KHtcbiAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICB0eXBlOiAnR0VUJyxcbiAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbihyZXN1bHQsIHN0YXR1cywgeGhyKXtcbiAgICAgICAgICAgIGFwcGx5QmFja2dyb3VuZChub2RlLCBiZ09iaik7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlcnJvcjogZnVuY3Rpb24oeGhyLCBzdGF0dXMsIGVycm9yKXtcbiAgICAgICAgICAgIGlmKHByb21wdEludmFsaWRJbWFnZSlcbiAgICAgICAgICAgICAgcHJvbXB0SW52YWxpZEltYWdlKFwiSW52YWxpZCBVUkwgaXMgZ2l2ZW4hXCIpO1xuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBhcHBseUJhY2tncm91bmQobm9kZSwgYmdPYmopIHtcblxuICAgICAgICBpZihlbGVtZW50VXRpbGl0aWVzLmhhc0JhY2tncm91bmRJbWFnZShub2RlKSlcbiAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgdmFyIGltZ3MgPSBub2RlLmRhdGEoJ2JhY2tncm91bmQtaW1hZ2UnKSA/IG5vZGUuZGF0YSgnYmFja2dyb3VuZC1pbWFnZScpLnNwbGl0KFwiIFwiKSA6IFtdO1xuICAgICAgICB2YXIgeFBvcyA9IG5vZGUuZGF0YSgnYmFja2dyb3VuZC1wb3NpdGlvbi14JykgPyBub2RlLmRhdGEoJ2JhY2tncm91bmQtcG9zaXRpb24teCcpLnNwbGl0KFwiIFwiKSA6IFtdO1xuICAgICAgICB2YXIgeVBvcyA9IG5vZGUuZGF0YSgnYmFja2dyb3VuZC1wb3NpdGlvbi15JykgPyBub2RlLmRhdGEoJ2JhY2tncm91bmQtcG9zaXRpb24teScpLnNwbGl0KFwiIFwiKSA6IFtdO1xuICAgICAgICB2YXIgd2lkdGhzID0gbm9kZS5kYXRhKCdiYWNrZ3JvdW5kLXdpZHRoJykgPyBub2RlLmRhdGEoJ2JhY2tncm91bmQtd2lkdGgnKS5zcGxpdChcIiBcIikgOiBbXTtcbiAgICAgICAgdmFyIGhlaWdodHMgPSBub2RlLmRhdGEoJ2JhY2tncm91bmQtaGVpZ2h0JykgPyBub2RlLmRhdGEoJ2JhY2tncm91bmQtaGVpZ2h0Jykuc3BsaXQoXCIgXCIpIDogW107XG4gICAgICAgIHZhciBmaXRzID0gbm9kZS5kYXRhKCdiYWNrZ3JvdW5kLWZpdCcpID8gbm9kZS5kYXRhKCdiYWNrZ3JvdW5kLWZpdCcpLnNwbGl0KFwiIFwiKSA6IFtdO1xuICAgICAgICB2YXIgb3BhY2l0aWVzID0gbm9kZS5kYXRhKCdiYWNrZ3JvdW5kLWltYWdlLW9wYWNpdHknKSA/IChcIlwiICsgbm9kZS5kYXRhKCdiYWNrZ3JvdW5kLWltYWdlLW9wYWNpdHknKSkuc3BsaXQoXCIgXCIpIDogW107XG5cbiAgICAgICAgdmFyIGluZGV4VG9JbnNlcnQgPSBpbWdzLmxlbmd0aDtcblxuICAgICAgICAvLyBpbnNlcnQgdG8gbGVuZ3RoLTFcbiAgICAgICAgaWYoZWxlbWVudFV0aWxpdGllcy5oYXNDbG9uZU1hcmtlcihpbWdzKSl7XG4gICAgICAgICAgaW5kZXhUb0luc2VydC0tO1xuICAgICAgICB9XG5cbiAgICAgICAgaW1ncy5zcGxpY2UoaW5kZXhUb0luc2VydCwgMCwgYmdPYmpbJ2JhY2tncm91bmQtaW1hZ2UnXSk7XG4gICAgICAgIGZpdHMuc3BsaWNlKGluZGV4VG9JbnNlcnQsIDAsIGJnT2JqWydiYWNrZ3JvdW5kLWZpdCddKTtcbiAgICAgICAgb3BhY2l0aWVzLnNwbGljZShpbmRleFRvSW5zZXJ0LCAwLCBiZ09ialsnYmFja2dyb3VuZC1pbWFnZS1vcGFjaXR5J10pO1xuICAgICAgICB4UG9zLnNwbGljZShpbmRleFRvSW5zZXJ0LCAwLCBiZ09ialsnYmFja2dyb3VuZC1wb3NpdGlvbi14J10pO1xuICAgICAgICB5UG9zLnNwbGljZShpbmRleFRvSW5zZXJ0LCAwLCBiZ09ialsnYmFja2dyb3VuZC1wb3NpdGlvbi15J10pO1xuICAgICAgICB3aWR0aHMuc3BsaWNlKGluZGV4VG9JbnNlcnQsIDAsIGJnT2JqWydiYWNrZ3JvdW5kLXdpZHRoJ10pO1xuICAgICAgICBoZWlnaHRzLnNwbGljZShpbmRleFRvSW5zZXJ0LCAwLCBiZ09ialsnYmFja2dyb3VuZC1oZWlnaHQnXSk7XG5cbiAgICAgICAgbm9kZS5kYXRhKCdiYWNrZ3JvdW5kLWltYWdlJywgaW1ncy5qb2luKFwiIFwiKSk7XG4gICAgICAgIG5vZGUuZGF0YSgnYmFja2dyb3VuZC1wb3NpdGlvbi14JywgeFBvcy5qb2luKFwiIFwiKSk7XG4gICAgICAgIG5vZGUuZGF0YSgnYmFja2dyb3VuZC1wb3NpdGlvbi15JywgeVBvcy5qb2luKFwiIFwiKSk7XG4gICAgICAgIG5vZGUuZGF0YSgnYmFja2dyb3VuZC13aWR0aCcsIHdpZHRocy5qb2luKFwiIFwiKSk7XG4gICAgICAgIG5vZGUuZGF0YSgnYmFja2dyb3VuZC1oZWlnaHQnLCBoZWlnaHRzLmpvaW4oXCIgXCIpKTtcbiAgICAgICAgbm9kZS5kYXRhKCdiYWNrZ3JvdW5kLWZpdCcsIGZpdHMuam9pbihcIiBcIikpO1xuICAgICAgICBub2RlLmRhdGEoJ2JhY2tncm91bmQtaW1hZ2Utb3BhY2l0eScsIG9wYWNpdGllcy5qb2luKFwiIFwiKSk7XG4gICAgICAgIGJnT2JqWydmaXJzdFRpbWUnXSA9IGZhbHNlO1xuXG4gICAgICAgIGlmKHVwZGF0ZUluZm8pXG4gICAgICAgICAgdXBkYXRlSW5mbygpO1xuXG4gICAgICB9XG4gICAgfTtcblxuICAgIGVsZW1lbnRVdGlsaXRpZXMuaGFzQ2xvbmVNYXJrZXIgPSBmdW5jdGlvbiAoaW1ncykge1xuICAgICAgdmFyIGNsb25lSW1nID0gJ2RhdGE6aW1hZ2Uvc3ZnK3htbDt1dGY4LCUzQ3N2ZyUyMHdpZHRoJTNEJTIyMTAwJTIyJTIwaGVpZ2h0JTNEJTIyMTAwJTIyJTIwdmlld0JveCUzRCUyMjAlMjAwJTIwMTAwJTIwMTAwJTIyJTIwc3R5bGUlM0QlMjJmaWxsJTNBbm9uZSUzQnN0cm9rZSUzQWJsYWNrJTNCc3Ryb2tlLXdpZHRoJTNBMCUzQiUyMiUyMHhtbG5zJTNEJTIyaHR0cCUzQS8vd3d3LnczLm9yZy8yMDAwL3N2ZyUyMiUyMCUzRSUzQ3JlY3QlMjB4JTNEJTIyMCUyMiUyMHklM0QlMjIwJTIyJTIwd2lkdGglM0QlMjIxMDAlMjIlMjBoZWlnaHQlM0QlMjIxMDAlMjIlMjBzdHlsZSUzRCUyMmZpbGwlM0ElMjM4MzgzODMlMjIvJTNFJTIwJTNDL3N2ZyUzRSc7XG4gICAgICByZXR1cm4gKGltZ3MuaW5kZXhPZihjbG9uZUltZykgPiAtMSk7XG4gICAgfTtcblxuICAgIC8vIFJlbW92ZSBhIGJhY2tncm91bmQgaW1hZ2UgZnJvbSBnaXZlbiBub2Rlcy5cbiAgICBlbGVtZW50VXRpbGl0aWVzLnJlbW92ZUJhY2tncm91bmRJbWFnZSA9IGZ1bmN0aW9uIChub2RlcywgYmdPYmopIHtcbiAgICAgIGlmKCFub2RlcyB8fCBub2Rlcy5sZW5ndGggPT0gMCB8fCAhYmdPYmopXG4gICAgICAgIHJldHVybjtcblxuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgdmFyIG9iaiA9IGJnT2JqW25vZGUuZGF0YSgnaWQnKV07XG4gICAgICAgIGlmKCFvYmopXG4gICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgdmFyIGltZ3MgPSBub2RlLmRhdGEoJ2JhY2tncm91bmQtaW1hZ2UnKSA/IG5vZGUuZGF0YSgnYmFja2dyb3VuZC1pbWFnZScpLnNwbGl0KFwiIFwiKSA6IFtdO1xuICAgICAgICB2YXIgeFBvcyA9IG5vZGUuZGF0YSgnYmFja2dyb3VuZC1wb3NpdGlvbi14JykgPyBub2RlLmRhdGEoJ2JhY2tncm91bmQtcG9zaXRpb24teCcpLnNwbGl0KFwiIFwiKSA6IFtdO1xuICAgICAgICB2YXIgeVBvcyA9IG5vZGUuZGF0YSgnYmFja2dyb3VuZC1wb3NpdGlvbi15JykgPyBub2RlLmRhdGEoJ2JhY2tncm91bmQtcG9zaXRpb24teScpLnNwbGl0KFwiIFwiKSA6IFtdO1xuICAgICAgICB2YXIgd2lkdGhzID0gbm9kZS5kYXRhKCdiYWNrZ3JvdW5kLXdpZHRoJykgPyBub2RlLmRhdGEoJ2JhY2tncm91bmQtd2lkdGgnKS5zcGxpdChcIiBcIikgOiBbXTtcbiAgICAgICAgdmFyIGhlaWdodHMgPSBub2RlLmRhdGEoJ2JhY2tncm91bmQtaGVpZ2h0JykgPyBub2RlLmRhdGEoJ2JhY2tncm91bmQtaGVpZ2h0Jykuc3BsaXQoXCIgXCIpIDogW107XG4gICAgICAgIHZhciBmaXRzID0gbm9kZS5kYXRhKCdiYWNrZ3JvdW5kLWZpdCcpID8gbm9kZS5kYXRhKCdiYWNrZ3JvdW5kLWZpdCcpLnNwbGl0KFwiIFwiKSA6IFtdO1xuICAgICAgICB2YXIgb3BhY2l0aWVzID0gbm9kZS5kYXRhKCdiYWNrZ3JvdW5kLWltYWdlLW9wYWNpdHknKSA/IChcIlwiICsgbm9kZS5kYXRhKCdiYWNrZ3JvdW5kLWltYWdlLW9wYWNpdHknKSkuc3BsaXQoXCIgXCIpIDogW107XG5cbiAgICAgICAgdmFyIGluZGV4ID0gLTE7XG4gICAgICAgIGlmKHR5cGVvZiBvYmpbJ2JhY2tncm91bmQtaW1hZ2UnXSA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICBpbmRleCA9IGltZ3MuaW5kZXhPZihvYmpbJ2JhY2tncm91bmQtaW1hZ2UnXS5zcGxpdChcIiBcIilbMF0pO1xuICAgICAgICBlbHNlIGlmKEFycmF5LmlzQXJyYXkob2JqWydiYWNrZ3JvdW5kLWltYWdlJ10pKVxuICAgICAgICAgIGluZGV4ID0gaW1ncy5pbmRleE9mKG9ialsnYmFja2dyb3VuZC1pbWFnZSddWzBdKTtcblxuICAgICAgICBpZihpbmRleCA+IC0xKXtcbiAgICAgICAgICBpbWdzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgZml0cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgIG9wYWNpdGllcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgIHhQb3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICB5UG9zLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgd2lkdGhzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgaGVpZ2h0cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9kZS5kYXRhKCdiYWNrZ3JvdW5kLWltYWdlJywgaW1ncy5qb2luKFwiIFwiKSk7XG4gICAgICAgIG5vZGUuZGF0YSgnYmFja2dyb3VuZC1wb3NpdGlvbi14JywgeFBvcy5qb2luKFwiIFwiKSk7XG4gICAgICAgIG5vZGUuZGF0YSgnYmFja2dyb3VuZC1wb3NpdGlvbi15JywgeVBvcy5qb2luKFwiIFwiKSk7XG4gICAgICAgIG5vZGUuZGF0YSgnYmFja2dyb3VuZC13aWR0aCcsIHdpZHRocy5qb2luKFwiIFwiKSk7XG4gICAgICAgIG5vZGUuZGF0YSgnYmFja2dyb3VuZC1oZWlnaHQnLCBoZWlnaHRzLmpvaW4oXCIgXCIpKTtcbiAgICAgICAgbm9kZS5kYXRhKCdiYWNrZ3JvdW5kLWZpdCcsIGZpdHMuam9pbihcIiBcIikpO1xuICAgICAgICBub2RlLmRhdGEoJ2JhY2tncm91bmQtaW1hZ2Utb3BhY2l0eScsIG9wYWNpdGllcy5qb2luKFwiIFwiKSk7XG4gICAgICAgIGJnT2JqWydmaXJzdFRpbWUnXSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBlbGVtZW50VXRpbGl0aWVzLnJldmVyc2VFZGdlID0gZnVuY3Rpb24oZWRnZSl7XG4gICAgICB2YXIgb2xkU291cmNlID0gZWRnZS5zb3VyY2UoKS5pZCgpO1xuICAgICAgdmFyIG9sZFRhcmdldCA9IGVkZ2UudGFyZ2V0KCkuaWQoKTtcbiAgICAgIHZhciBvbGRQb3J0U291cmNlID0gZWRnZS5kYXRhKFwicG9ydHNvdXJjZVwiKTtcbiAgICAgIHZhciBvbGRQb3J0VGFyZ2V0ID0gZWRnZS5kYXRhKFwicG9ydHRhcmdldFwiKTtcbiAgICAgIHZhciBzZWdtZW50UG9pbnRzID0gZWRnZS5zZWdtZW50UG9pbnRzKCk7XG4gICAgICB2YXIgY29udHJvbFBvaW50cyA9IGVkZ2UuY29udHJvbFBvaW50cygpO1xuXG4gICAgICBlZGdlLmRhdGEoKS5zb3VyY2UgPSBvbGRUYXJnZXQ7XG4gICAgICBlZGdlLmRhdGEoKS50YXJnZXQgPSBvbGRTb3VyY2U7XG4gICAgICBlZGdlLmRhdGEoKS5wb3J0c291cmNlID0gb2xkUG9ydFRhcmdldDtcbiAgICAgIGVkZ2UuZGF0YSgpLnBvcnR0YXJnZXQgPSBvbGRQb3J0U291cmNlO1xuICAgICAgIGVkZ2UgPSBlZGdlLm1vdmUoe1xuICAgICAgICAgdGFyZ2V0OiBvbGRTb3VyY2UsXG4gICAgICAgICBzb3VyY2UgOiBvbGRUYXJnZXQgICAgICAgIFxuICAgICAgfSk7XG5cbiAgICAgIGlmKEFycmF5LmlzQXJyYXkoc2VnbWVudFBvaW50cykpe1xuICAgICAgICBzZWdtZW50UG9pbnRzLnJldmVyc2UoKTtcbiAgICAgICAgZWRnZS5kYXRhKCkuYmVuZFBvaW50UG9zaXRpb25zID0gc2VnbWVudFBvaW50cztcbiAgICAgICAgaWYoQXJyYXkuaXNBcnJheShjb250cm9sUG9pbnRzKSkge1xuICAgICAgICAgIGNvbnRyb2xQb2ludHMucmV2ZXJzZSgpO1xuICAgICAgICAgIGVkZ2UuZGF0YSgpLmNvbnRyb2xQb2ludFBvc2l0aW9ucyA9IGNvbnRyb2xQb2ludHM7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVkZ2VFZGl0aW5nID0gY3kuZWRnZUVkaXRpbmcoJ2dldCcpO1xuICAgICAgICBlZGdlRWRpdGluZy5pbml0QW5jaG9yUG9pbnRzKGVkZ2UpO1xuICAgICAgfVxuICAgIFxuXG4gICAgICByZXR1cm4gZWRnZTtcbiAgICB9XG5cbiAgfVxuXG4gIHJldHVybiBlbGVtZW50VXRpbGl0aWVzRXh0ZW5kZXI7XG59O1xuIl0sIm5hbWVzIjpbImxpYnMiLCJyZXF1aXJlIiwiZ2V0TGlicyIsImpRdWVyeSIsIiQiLCJtb2R1bGUiLCJleHBvcnRzIiwib3B0aW9ucyIsInNiZ252aXpJbnN0YW5jZSIsImVsZW1lbnRVdGlsaXRpZXMiLCJjeSIsImVsZW1lbnRVdGlsaXRpZXNFeHRlbmRlciIsInBhcmFtIiwic2JnbnZpekluc3RhbmNlVXRpbGl0aWVzIiwiZ2V0SW5zdGFuY2UiLCJvcHRpb25VdGlsaXRpZXMiLCJnZXRPcHRpb25zIiwiZ2V0Q3kiLCJleHRlbmQiLCJhZGROb2RlIiwieCIsInkiLCJub2RlUGFyYW1zIiwiaWQiLCJwYXJlbnQiLCJ2aXNpYmlsaXR5Iiwic2JnbmNsYXNzIiwibGFuZ3VhZ2UiLCJjc3MiLCJkZWZhdWx0V2lkdGgiLCJkZWZhdWx0SGVpZ2h0IiwiZGF0YSIsImJib3giLCJ3IiwiaCIsInN0YXRlc2FuZGluZm9zIiwicG9ydHMiLCJnZW5lcmF0ZU5vZGVJZCIsImV4dGVuZE5vZGVEYXRhV2l0aENsYXNzRGVmYXVsdHMiLCJkZWZhdWx0cyIsImdldERlZmF1bHRQcm9wZXJ0aWVzIiwiZWxlcyIsImFkZCIsImdyb3VwIiwicG9zaXRpb24iLCJuZXdOb2RlIiwibGVuZ3RoIiwib3JkZXJpbmciLCJzZXRQb3J0c09yZGVyaW5nIiwiY2FuSGF2ZU11bHRpcGxlVW5pdE9mSW5mb3JtYXRpb24iLCJ1b2lfb2JqIiwiY2xhenoiLCJsYWJlbCIsInRleHQiLCJhZGRTdGF0ZU9ySW5mb0JveCIsImJnSW1hZ2UiLCJzYXZlVW5pdHMiLCJub2RlIiwidGVtcERhdGEiLCJpbmRleCIsImZvckVhY2giLCJlbGUiLCJwdXNoIiwiYW5jaG9yU2lkZSIsInJlc3RvcmVVbml0cyIsInVuZGVmaW5lZCIsIm1vZGlmeVVuaXRzIiwiY29uc29sZSIsImxvZyIsImluc3RhbmNlIiwiY2xhc3NlcyIsIkF1eFVuaXRMYXlvdXQiLCJhZGRFZGdlIiwic291cmNlIiwidGFyZ2V0IiwiZWRnZVBhcmFtcyIsImdyb3VwSUQiLCJPYmplY3QiLCJrZXlzIiwicHJvcCIsImdlbmVyYXRlRWRnZUlkIiwiY2FuSGF2ZVNCR05DYXJkaW5hbGl0eSIsImNhcmRpbmFsaXR5Iiwic291cmNlTm9kZSIsImdldEVsZW1lbnRCeUlkIiwidGFyZ2V0Tm9kZSIsInNvdXJjZUhhc1BvcnRzIiwidGFyZ2V0SGFzUG9ydHMiLCJwb3J0c291cmNlIiwicG9ydHRhcmdldCIsImdldElPUG9ydElkcyIsIm5vZGVJbnB1dFBvcnRJZCIsIm5vZGVPdXRwdXRQb3J0SWQiLCJub2RlUG9ydHNPcmRlcmluZyIsImdldFBvcnRzT3JkZXJpbmciLCJub2RlUG9ydHMiLCJsZWZ0UG9ydElkIiwicmlnaHRQb3J0SWQiLCJ0b3BQb3J0SWQiLCJib3R0b21Qb3J0SWQiLCJpbnB1dFBvcnRJZCIsIm91dHB1dFBvcnRJZCIsInNvdXJjZU5vZGVJbnB1dFBvcnRJZCIsInNvdXJjZU5vZGVPdXRwdXRQb3J0SWQiLCJ0YXJnZXROb2RlSW5wdXRQb3J0SWQiLCJ0YXJnZXROb2RlT3V0cHV0UG9ydElkIiwiaW9Qb3J0cyIsImlzTW9kdWxhdGlvbkFyY0NsYXNzIiwiaXNBRkFyY0NsYXNzIiwic3JjQ2xhc3MiLCJ0Z3RDbGFzcyIsImlzU291cmNlTG9naWNhbE9wIiwiaXNUYXJnZXRMb2dpY2FsT3AiLCJuZXdFZGdlIiwiYWRkUHJvY2Vzc1dpdGhDb252ZW5pZW50RWRnZXMiLCJfc291cmNlIiwiX3RhcmdldCIsInByb2Nlc3NQYXJlbnQiLCJjb2xsZWN0aW9uIiwiY29tbW9uQW5jZXN0b3JzIiwiZmlyc3QiLCJwcm9jZXNzIiwieGRpZmYiLCJ5ZGlmZiIsIk1hdGgiLCJhYnMiLCJlZGdlQnR3U3JjIiwiZWRnZUJ0d1RndCIsImNyZWF0ZUNvbXBvdW5kRm9yR2l2ZW5Ob2RlcyIsIm5vZGVzVG9NYWtlQ29tcG91bmQiLCJjb21wb3VuZFR5cGUiLCJvbGRQYXJlbnRJZCIsImkiLCJuZXdDb21wb3VuZCIsIm5ld0NvbXBvdW5kSWQiLCJuZXdFbGVzIiwiY2hhbmdlUGFyZW50IiwidW5pb24iLCJjcmVhdGVUcmFuc2xhdGlvblJlYWN0aW9uIiwibVJuYU5hbWUiLCJwcm90ZWluTmFtZSIsInByb2Nlc3NQb3NpdGlvbiIsImVkZ2VMZW5ndGgiLCJkZWZhdWx0UHJvY2Vzc1Byb3BlcnRpZXMiLCJkZWZhdWx0U291cmNlQW5kU2lua1Byb3BlcnRpZXMiLCJkZWZhdWx0TnVjbGVpY0FjaWRGZWF0dXJlUHJvcGVydGllcyIsImRlZmF1bHRNYWNyb21vbGVjdWxlUHJvcGVydGllcyIsIm1hY3JvbW9sZWN1bGVXaWR0aCIsIndpZHRoIiwic291cmNlQW5kU2lua1dpZHRoIiwibnVjbGVpY0FjaWRGZWF0dXJlSGVpZ2h0IiwiaGVpZ2h0IiwicHJvY2Vzc1dpZHRoIiwicHJvY2Vzc0hlaWdodCIsImNvbnZlcnRUb01vZGVsUG9zaXRpb24iLCJzdGFydEJhdGNoIiwiZ2V0TWFwVHlwZSIsInNldE1hcFR5cGUiLCJwcm9jZXNzTm9kZSIsInhQb3NPZlNvdXJjZUFuZFNpbmtOb2RlIiwieVBvc09mU291cmNlQW5kU2lua05vZGUiLCJzb3VyY2VBbmRTaW5rTm9kZSIsImNvbnN1bXB0aW9uRWRnZSIsInhQb3NPZm1SbmFOb2RlIiwieVBvc09mbVJuYU5vZGUiLCJtUm5hTm9kZSIsImluZm9ib3hPYmplY3RPZkdlbmUiLCJuZWNlc3NhcnlTdGltdWxhdGlvbkVkZ2UiLCJ4UG9zT2ZQcm90ZWluTm9kZSIsInlQb3N0T2ZQcm90ZWluTm9kZSIsInByb3RlaW5Ob2RlIiwicHJvZHVjdGlvbkVkZ2UiLCJlbmRCYXRjaCIsImVsZW1lbnRzIiwicmVtb3ZlRGF0YSIsInVuc2VsZWN0Iiwic2VsZWN0IiwiY3JlYXRlVHJhbnNjcmlwdGlvblJlYWN0aW9uIiwiZ2VuZU5hbWUiLCJudWNsZWljQWNpZEZlYXR1cmVXaWR0aCIsInhQb3NPZkdlbmVOb2RlIiwieVBvc09mR2VuZU5vZGUiLCJnZW5lTm9kZSIsInlQb3N0T2ZtUm5hTm9kZSIsImluZm9ib3hPYmplY3RPZm1SbmEiLCJyb3RhdGU5MCIsInBvaW50IiwiY2VudGVyIiwicmVsYXRpdmVYIiwicmVsYXRpdmVZIiwicmVsYXRpdmVSb3RhdGVkWCIsInJlbGF0aXZlUm90YXRlZFkiLCJyZXN1bHRYIiwicmVzdWx0WSIsImNyZWF0ZVRyYW5zbGF0aW9uIiwicmVndWxhdG9yTGFiZWwiLCJvdXRwdXRMYWJlbCIsIm9yaWVudGF0aW9uIiwiZGVmYXVsdE1hY3JvbW9sZWN1bGVQcm9wZXRpZXMiLCJ2ZXJ0aWNhbCIsInByb2Nlc3NQb3J0c09yZGVyaW5nIiwibWluSW5mb2JveERpbWVuc2lvbiIsIndpZHRoUGVyQ2hhciIsInJlZ3VsYXRvckluZm9ib3hMYWJlbCIsInhQb3NPZklucHV0IiwieFBvc09mT3V0cHV0IiwieVBvc09mSW5wdXQiLCJ5UG9zT2ZPdXRwdXQiLCJub2RlUG9zaXRpb24iLCJpbnB1dE5vZGUiLCJpbnB1dEVkZ2UiLCJvdXRwdXROb2RlIiwib3V0cHV0RWRnZSIsInhQb3NPZlJlZ3VsYXRvciIsImRpbWVuc2lvbiIsInlQb3NPZlJlZ3VsYXRvciIsInJlZ3VsYXRvck5vZGUiLCJpbmZvYm94T2JqZWN0IiwibWF4IiwicmVndWxhdG9yRWRnZSIsImNyZWF0ZVRyYW5zY3JpcHRpb24iLCJvdXRwdXRJbmZvYm94TGFiZWwiLCJjcmVhdGVEZWdyYWRhdGlvbiIsIm1hY3JvbW9sZWN1bGUiLCJtYWNyb21vbGVjdWxlTmFtZSIsIm5hbWUiLCJjcmVhdGVDb21wbGV4UHJvdGVpbkZvcm1hdGlvbiIsInByb3RlaW5MYWJlbHMiLCJjb21wbGV4TGFiZWwiLCJyZWd1bGF0b3IiLCJyZXZlcnNlIiwiaGFzUmVndWxhdG9yIiwiZGVmYXVsdFJlZ3VsYXRvclByb3BlcnRpZXMiLCJ0eXBlIiwibWFjcm9tb2xlY3VsZUhlaWdodCIsInJlZ3VsYXRvckhlaWdodCIsInRpbGluZ1BhZGRpbmdWZXJ0aWNhbCIsInRpbGluZ1BhZGRpbmdIb3Jpem9udGFsIiwibXVsdGltZXJPZmZzZXQiLCJvZmZzZXRYIiwieFBvc09mUHJvdGVpbiIsInByb3RlaW5Db3VudCIsIm1hY3JvbW9sZWN1bGVEaW1lbnNpb24iLCJzdGVwT2Zmc2V0Iiwib2Zmc2V0WSIsImhvcml6b250YWxPZmZzZXRYIiwieVBvc09mUHJvdGVpbiIsImVkZ2VDbGFzcyIsImVkZ2UiLCJjb21wbGV4UG9zIiwiY29tcGxleCIsImNvbXBsZXhFZGdlIiwicmVndWxhdG9yTmFtZSIsInJlZ3VsYXRvclR5cGUiLCJyZWd1bGF0b3JFZGdlVHlwZSIsImVkZ2VUeXBlIiwicmVndWxhdG9yTXVsdGltZXIiLCJtdWx0aW1lciIsImVuYWJsZWQiLCJzZXRNdWx0aW1lclN0YXR1cyIsImluZm9ib3hMYWJlbCIsImNyZWF0ZU11bHRpbWVyaXphdGlvbiIsIm1hY3JvbW9sZWN1bGVNdWx0aW1lckNhcmRpbmFsaXR5IiwiY3JlYXRlQ29udmVyc2lvbiIsImlucHV0SW5mb2JveExhYmVscyIsIm91dHB1dEluZm9ib3hMYWJlbHMiLCJtYWNyb21vbGVjdWxlSXNNdWx0aW1lciIsImlucHV0SW5mb2JveFdpZHRoIiwic3R5bGUiLCJvdXRwdXRJbmZvYm94V2lkdGgiLCJjYWxjdWxhdGVNaW5XaWR0aCIsInJlc2l6ZU5vZGVzIiwibmV3SW5wdXRYUG9zIiwibmV3T3V0cHV0WFBvcyIsIm5ld0lucHV0WVBvcyIsIm5ld091dHB1dFlQb3MiLCJjcmVhdGVNZXRhYm9saWNSZWFjdGlvbiIsImlucHV0cyIsIm91dHB1dHMiLCJyZXZlcnNpYmxlIiwiZGVmYXVsdFNpbXBsZUNoZW1pY2FsUHJvcGVydGllcyIsInNpbXBsZUNoZW1pY2FsSGVpZ2h0Iiwic2ltcGxlQ2hlbWljYWxXaWR0aCIsInByb2Nlc3NMZWZ0U2lkZUVkZ2VUeXBlIiwicHJvY2Vzc1JpZ2h0U2lkZUVkZ2VUeXBlIiwibnVtT2ZJbnB1dE5vZGVzIiwibnVtT2ZPdXRwdXROb2RlcyIsIm5vZGVOYW1lIiwibm9kZVR5cGUiLCJjZWlsIiwidG9Mb3dlckNhc2UiLCJjcmVhdGVNZXRhYm9saWNDYXRhbHl0aWNBY3Rpdml0eSIsImlucHV0Tm9kZUxpc3QiLCJvdXRwdXROb2RlTGlzdCIsImNhdGFseXN0TmFtZSIsImNhdGFseXN0VHlwZSIsImRlZmF1bHRNYWNyb21vbGVjdWxQcm9wZXJ0aWVzIiwiZGVmYXVsdENhdGFseXN0VHlwZVByb3BlcnRpZXMiLCJjYXRhbHlzdEhlaWdodCIsInhQb3NPZkNhdGFseXN0IiwieVBvc09mQ2F0YWx5c3QiLCJjYXRhbHlzdE5vZGUiLCJjYXRhbHlzdEVkZ2UiLCJjcmVhdGVBY3RpdmF0aW9uUmVhY3Rpb24iLCJ5UG9zaXRpb24iLCJpbnB1dFNpZGVFZGdlIiwib3V0cHV0U2lkZUVkZ2UiLCJjcmVhdGVUZW1wbGF0ZVJlYWN0aW9uIiwidGVtcGxhdGVUeXBlIiwibm9kZUxpc3QiLCJjb21wbGV4TmFtZSIsImxheW91dFBhcmFtIiwibnVtT2ZNb2xlY3VsZXMiLCJ4UG9zaXRpb25PZkZyZWVNYWNyb21vbGVjdWxlcyIsInhQb3NpdGlvbk9mSW5wdXRNYWNyb21vbGVjdWxlcyIsImVkZ2VPZkNvbXBsZXgiLCJudW1PZklucHV0TWFjcm9tb2xlY3VsZXMiLCJsYXlvdXROb2RlcyIsIm5vZGVzIiwibGF5b3V0IiwicmFuZG9taXplIiwiZml0IiwiYW5pbWF0ZSIsInN0b3AiLCJzdXBwb3NlZFhQb3NpdGlvbiIsInN1cHBvc2VkWVBvc2l0aW9uIiwib3V0ZXJXaWR0aCIsInBvc2l0aW9uRGlmZlgiLCJwb3NpdGlvbkRpZmZZIiwibW92ZU5vZGVzIiwicnVuIiwibmV3UGFyZW50IiwicG9zRGlmZlgiLCJwb3NEaWZmWSIsIm5ld1BhcmVudElkIiwibW92ZWRFbGVzIiwibW92ZSIsIm1haW50YWluUG9pbnRlciIsInVwZGF0ZUluZm9ib3hTdHlsZSIsIm5ld1Byb3BzIiwiaW5mb2JveE9iaiIsInVwZGF0ZSIsInVwZGF0ZUluZm9ib3hPYmoiLCJ1c2VBc3BlY3RSYXRpbyIsInByZXNlcnZlUmVsYXRpdmVQb3MiLCJyYXRpbyIsImVsZU11c3RCZVNxdWFyZSIsIm11c3RCZVNxdWFyZSIsIm9sZFdpZHRoIiwib2xkSGVpZ2h0IiwiaXNQYXJlbnQiLCJmb250RmFtaWxpeSIsImZvbnRTaXplIiwibGFiZWxUZXh0IiwibGFiZWxXaWR0aCIsImdldFdpZHRoQnlDb250ZW50IiwidW5pdEdhcCIsInRvcElkZWFsV2lkdGgiLCJib3R0b21JZGVhbFdpZHRoIiwicmlnaHRNYXhXaWR0aCIsImxlZnRNYXhXaWR0aCIsImJveCIsIm1pZGRsZVdpZHRoIiwiY29tcG91bmRXaWR0aCIsImNoaWxkcmVuIiwiYm91bmRpbmdCb3giLCJjYWxjdWxhdGVNaW5IZWlnaHQiLCJtYXJnaW4iLCJsZWZ0SW5mb0JveGVzIiwiZmlsdGVyIiwibGVmdEhlaWdodCIsInJpZ2h0SW5mb0JveGVzIiwicmlnaHRIZWlnaHQiLCJzcGxpdCIsInBhcnNlRmxvYXQiLCJzdWJzdHJpbmciLCJ0b3RhbEhlaWdodCIsImNvbXBvdW5kSGVpZ2h0IiwiaXNSZXNpemVkVG9Db250ZW50IiwiaXNOb2RlIiwibWluVyIsIm1pbkgiLCJyZWxvY2F0ZVN0YXRlQW5kSW5mb3MiLCJzdGF0ZUFuZEluZm9zIiwiY2hhbmdlU3RhdGVPckluZm9Cb3giLCJ2YWx1ZSIsInJlc3VsdCIsIm9sZExlbmd0aCIsIm5ld0xlbmd0aCIsImNvbnRlbnQiLCJzdGF0ZSIsInJlc2lkdWUiLCJyZWdpb24iLCJtaW4iLCJmb250RmFtaWx5IiwiYm9yZGVyV2lkdGgiLCJvcHRzIiwicHJldmlvdXNXaWR0aCIsInVuaXRMYXlvdXQiLCJ1bml0cyIsInNoaWZ0QW1vdW50Iiwib2JqIiwibG9jYXRpb25PYmoiLCJkZWZhdWx0UHJvcHMiLCJpbmZvYm94UHJvcHMiLCJnZXREZWZhdWx0SW5mb2JveFN0eWxlIiwiVW5pdE9mSW5mb3JtYXRpb24iLCJjcmVhdGUiLCJsb2NhdGlvbiIsIlN0YXRlVmFyaWFibGUiLCJ2YXJpYWJsZSIsIlJlc2lkdWVWYXJpYWJsZSIsIkJpbmRpbmdSZWdpb24iLCJyZW1vdmVTdGF0ZU9ySW5mb0JveCIsInVuaXQiLCJ1bml0Q2xhc3MiLCJnZXRBdXhVbml0Q2xhc3MiLCJyZW1vdmUiLCJmaXRVbml0cyIsImxvY2F0aW9ucyIsImNoZWNrRml0Iiwic3RhdHVzIiwiaXNNdWx0aW1lciIsImVuZHNXaXRoIiwicmVwbGFjZSIsInNldEFjdGl2ZVN0YXR1cyIsImlzQWN0aXZlIiwic3RhcnRzV2l0aCIsInNldEh5cG90aGV0aWNhbFN0YXR1cyIsImlzSHlwb3RoZXRpY2FsIiwiaW5jbHVkZXMiLCJ0bXAiLCJjaGFuZ2VGb250UHJvcGVydGllcyIsInZhbGlkYXRlQXJyb3dFbmRzIiwiaXNSZXBsYWNlbWVudCIsImVkZ2VjbGFzcyIsInNvdXJjZWNsYXNzIiwidGFyZ2V0Y2xhc3MiLCJtYXBUeXBlIiwiZWRnZUNvbnN0cmFpbnRzIiwiY29ubmVjdGl2aXR5Q29uc3RyYWludHMiLCJoYXNUb29NYW55RWRnZXMiLCJzb3VyY2VPclRhcmdldCIsIm5vZGVjbGFzcyIsInRvdGFsVG9vTWFueSIsImVkZ2VUb29NYW55Iiwic2FtZUVkZ2VDb3VudE91dCIsIm91dGdvZXJzIiwic2l6ZSIsInRvdGFsRWRnZUNvdW50T3V0IiwibWF4VG90YWwiLCJhc1NvdXJjZSIsIm1heEVkZ2UiLCJjb21wYXJlU3RyaWN0Iiwid2l0aGluTGltaXRzIiwic2FtZUVkZ2VDb3VudEluIiwiaW5jb21lcnMiLCJ0b3RhbEVkZ2VDb3VudEluIiwiYXNUYXJnZXQiLCJpc0luQ29tcGxleCIsInBhcmVudENsYXNzIiwiaXNBbGxvd2VkIiwiZGVsZXRlQW5kUGVyZm9ybUxheW91dCIsImxheW91dHBhcmFtIiwiaGlkZUFuZFBlcmZvcm1MYXlvdXQiLCJ2aWV3VXRpbGl0aWVzIiwiaGlkZSIsInNob3dBbmRQZXJmb3JtTGF5b3V0Iiwic2hvdyIsImNoYW5nZUNzcyIsInZhbHVlTWFwIiwiY2hhbmdlRGF0YSIsInVwZGF0ZVNldEZpZWxkIiwiZmllbGROYW1lIiwidG9EZWxldGUiLCJ0b0FkZCIsImNhbGxiYWNrIiwic2V0IiwidXBkYXRlcyIsImRlbGV0ZWQiLCJhZGRlZCIsImdldE5vZGVzQXQiLCJyZW5kZXJlZFBvcyIsInJlc3VsdE5vZGVzIiwicmVuZGVyZWRCYm94IiwicmVuZGVyZWRCb3VuZGluZ0JveCIsImluY2x1ZGVOb2RlcyIsImluY2x1ZGVFZGdlcyIsImluY2x1ZGVMYWJlbHMiLCJpbmNsdWRlU2hhZG93cyIsIngxIiwieDIiLCJ5MSIsInkyIiwiZGVtdWx0aW1lcml6ZUNsYXNzIiwicmVzZXRNYXBUeXBlIiwiZW1pdCIsInNpZGUiLCJwYXJlbnROb2RlIiwiYW55SGFzQmFja2dyb3VuZEltYWdlIiwiZ2V0QmFja2dyb3VuZEltYWdlT2JqcyIsImtleSIsImlzRW1wdHlPYmplY3QiLCJoYXNCYWNrZ3JvdW5kSW1hZ2UiLCJiZyIsIkFycmF5IiwiaXNBcnJheSIsImNsb25lSW1nIiwib25seUhhc0Nsb25lTWFya2VyQXNCZ0ltYWdlIiwiaW5kZXhPZiIsImdldEJhY2tncm91bmRJbWFnZVVSTCIsImNvbW1vblVSTCIsInVybCIsInBvcCIsImxpc3QiLCJnZXRCZ09iaiIsImdldEJhY2tncm91bmRGaXRPcHRpb25zIiwiY29tbW9uRml0IiwiZ2V0Rml0T3B0aW9uIiwic2VhcmNoS2V5Iiwic3Vic3RyIiwiZiIsInVwZGF0ZUJhY2tncm91bmRJbWFnZSIsImJnT2JqIiwiaW1ncyIsInhQb3MiLCJ5UG9zIiwid2lkdGhzIiwiaGVpZ2h0cyIsImZpdHMiLCJvcGFjaXRpZXMiLCJqb2luIiwiY2hhbmdlQmFja2dyb3VuZEltYWdlIiwib2xkSW1nIiwibmV3SW1nIiwiZmlyc3RUaW1lIiwidXBkYXRlSW5mbyIsInByb21wdEludmFsaWRJbWFnZSIsInZhbGlkYXRlVVJMIiwicmVtb3ZlQmFja2dyb3VuZEltYWdlIiwiYWRkQmFja2dyb3VuZEltYWdlIiwibG9hZEJhY2tncm91bmRUaGVuQXBwbHkiLCJhcHBseUJhY2tncm91bmQiLCJjaGVja0dpdmVuVVJMIiwicmVhZGVyIiwiRmlsZVJlYWRlciIsImltZ0ZpbGUiLCJyZWFkQXNEYXRhVVJMIiwib25sb2FkIiwiZSIsImltZyIsImV4dGVuc2lvbiIsInZhbGlkRXh0ZW5zaW9ucyIsImFqYXgiLCJzdWNjZXNzIiwieGhyIiwiZXJyb3IiLCJpbmRleFRvSW5zZXJ0IiwiaGFzQ2xvbmVNYXJrZXIiLCJzcGxpY2UiLCJyZXZlcnNlRWRnZSIsIm9sZFNvdXJjZSIsIm9sZFRhcmdldCIsIm9sZFBvcnRTb3VyY2UiLCJvbGRQb3J0VGFyZ2V0Iiwic2VnbWVudFBvaW50cyIsImNvbnRyb2xQb2ludHMiLCJiZW5kUG9pbnRQb3NpdGlvbnMiLCJjb250cm9sUG9pbnRQb3NpdGlvbnMiLCJlZGdlRWRpdGluZyIsImluaXRBbmNob3JQb2ludHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/utilities/element-utilities-extender-factory.js\n");

/***/ }),

/***/ "./src/utilities/lib-utilities.js":
/*!****************************************!*\
  !*** ./src/utilities/lib-utilities.js ***!
  \****************************************/
/***/ ((module) => {

eval("/* \n * Utility file to get and set the libraries to which sbgnviz is dependent from any file.\n */\nvar libUtilities = function libUtilities() {};\n\nlibUtilities.setLibs = function (libs) {\n  this.libs = libs;\n};\n\nlibUtilities.getLibs = function () {\n  return this.libs;\n};\n\nmodule.exports = libUtilities;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdXRpbGl0aWVzL2xpYi11dGlsaXRpZXMuanMuanMiLCJuYW1lcyI6WyJsaWJVdGlsaXRpZXMiLCJzZXRMaWJzIiwibGlicyIsImdldExpYnMiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jaGlzZS8uL3NyYy91dGlsaXRpZXMvbGliLXV0aWxpdGllcy5qcz9iYWFmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIFxuICogVXRpbGl0eSBmaWxlIHRvIGdldCBhbmQgc2V0IHRoZSBsaWJyYXJpZXMgdG8gd2hpY2ggc2JnbnZpeiBpcyBkZXBlbmRlbnQgZnJvbSBhbnkgZmlsZS5cbiAqL1xuXG52YXIgbGliVXRpbGl0aWVzID0gZnVuY3Rpb24oKXtcbn07XG5cbmxpYlV0aWxpdGllcy5zZXRMaWJzID0gZnVuY3Rpb24obGlicykge1xuICB0aGlzLmxpYnMgPSBsaWJzO1xufTtcblxubGliVXRpbGl0aWVzLmdldExpYnMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMubGlicztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gbGliVXRpbGl0aWVzOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBRUEsSUFBSUEsWUFBWSxHQUFHLFNBQWZBLFlBQWUsR0FBVSxDQUM1QixDQUREOztBQUdBQSxZQUFZLENBQUNDLE9BQWIsR0FBdUIsVUFBU0MsSUFBVCxFQUFlO0VBQ3BDLEtBQUtBLElBQUwsR0FBWUEsSUFBWjtBQUNELENBRkQ7O0FBSUFGLFlBQVksQ0FBQ0csT0FBYixHQUF1QixZQUFXO0VBQ2hDLE9BQU8sS0FBS0QsSUFBWjtBQUNELENBRkQ7O0FBSUFFLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQkwsWUFBakIifQ==\n//# sourceURL=webpack-internal:///./src/utilities/lib-utilities.js\n");

/***/ }),

/***/ "./src/utilities/main-utilities-factory.js":
/*!*************************************************!*\
  !*** ./src/utilities/main-utilities-factory.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\nvar libs = (__webpack_require__(/*! ./lib-utilities */ \"./src/utilities/lib-utilities.js\").getLibs)();\n/*\n * The main utilities to be exposed directly.\n */\n\n\nmodule.exports = function () {\n  var elementUtilities, options, cy, sbgnvizInstance;\n\n  function mainUtilities(param) {\n    elementUtilities = param.elementUtilities;\n    options = param.optionUtilities.getOptions();\n    cy = param.sbgnvizInstanceUtilities.getCy();\n    sbgnvizInstance = param.sbgnvizInstanceUtilities.getInstance();\n  }\n\n  ;\n  /*\n   * Adds a new node with the given class and at the given coordinates. Considers undoable option.\n   */\n\n  mainUtilities.addNode = function (x, y, nodeParams, id, parent, visibility) {\n    if (elementUtilities.isGraphTopologyLocked()) {\n      return;\n    } // update map type\n\n\n    if (_typeof(nodeParams) == 'object') {\n      /* \n            if (!elementUtilities.getMapType())\n              elementUtilities.setMapType(nodeParams.language);\n            else if (elementUtilities.getMapType() != nodeParams.language)\n              elementUtilities.setMapType(\"Unknown\"); */\n    }\n\n    if (!options.undoable) {\n      return elementUtilities.addNode(x, y, nodeParams, id, parent, visibility);\n    } else {\n      var param = {\n        newNode: {\n          x: x,\n          y: y,\n          \"class\": nodeParams,\n          id: id,\n          parent: parent,\n          visibility: visibility\n        }\n      };\n      var result = cy.undoRedo()[\"do\"](\"addNode\", param);\n      return result.eles;\n    }\n  };\n  /*\n   * Adds a new edge with the given class and having the given source and target ids. Considers undoable option.\n   */\n\n\n  mainUtilities.addEdge = function (source, target, edgeParams, invalidEdgeCallback, id, visibility) {\n    if (elementUtilities.isGraphTopologyLocked()) {\n      return;\n    } // update map type\n\n\n    if (_typeof(edgeParams) == 'object') {\n      /*  if (!elementUtilities.getMapType())\n         elementUtilities.setMapType(edgeParams.language);\n       else if (elementUtilities.getMapType() != edgeParams.language)\n         elementUtilities.setMapType(\"HybridAny\"); */\n    } // Get the validation result\n\n\n    var edgeclass = edgeParams[\"class\"] ? edgeParams[\"class\"] : edgeParams;\n    var validation = elementUtilities.validateArrowEnds(edgeclass, cy.getElementById(source), cy.getElementById(target)); // If validation result is 'invalid' cancel the operation\n\n    if (validation === 'invalid') {\n      if (typeof invalidEdgeCallback === \"function\") {\n        invalidEdgeCallback();\n      }\n\n      return;\n    } // If validation result is 'reverse' reverse the source-target pair before creating the edge\n\n\n    if (validation === 'reverse') {\n      var temp = source;\n      source = target;\n      target = temp;\n    }\n\n    if (!options.undoable) {\n      return elementUtilities.addEdge(source, target, edgeParams, id, visibility);\n    } else {\n      var param = {\n        newEdge: {\n          source: source,\n          target: target,\n          \"class\": edgeParams,\n          id: id,\n          visibility: visibility\n        }\n      };\n      var result = cy.undoRedo()[\"do\"](\"addEdge\", param);\n      return result.eles;\n    }\n  };\n  /*\n   * Adds a process with convenient edges. For more information please see 'https://github.com/iVis-at-Bilkent/newt/issues/9'.\n   * Considers undoable option.\n   */\n\n\n  mainUtilities.addProcessWithConvenientEdges = function (_source, _target, processType) {\n    if (elementUtilities.isGraphTopologyLocked()) {\n      return;\n    } // If source and target IDs are given get the elements by IDs\n\n\n    var source = typeof _source === 'string' ? cy.getElementById(_source) : _source;\n    var target = typeof _target === 'string' ? cy.getElementById(_target) : _target; // If source or target does not have an EPN class the operation is not valid\n\n    if (!elementUtilities.isEPNClass(source) || !elementUtilities.isEPNClass(target)) {\n      return;\n    }\n\n    if (!options.undoable) {\n      return elementUtilities.addProcessWithConvenientEdges(_source, _target, processType);\n    } else {\n      var param = {\n        source: _source,\n        target: _target,\n        processType: processType\n      };\n      cy.undoRedo()[\"do\"](\"addProcessWithConvenientEdges\", param);\n    }\n  }; // convert collapsed compound nodes to simple nodes\n  // and update port values of pasted nodes and edges\n\n\n  var cloneCollapsedNodesAndPorts = function cloneCollapsedNodesAndPorts(elesBefore) {\n    if (elementUtilities.isGraphTopologyLocked()) {\n      return;\n    }\n\n    cy.elements().unselect();\n    var elesAfter = cy.elements();\n    var elesDiff = elesAfter.diff(elesBefore).left; // shallow copy collapsed nodes - collapsed compounds become simple nodes\n    // data related to collapsed nodes are removed from generated clones\n    // related issue: https://github.com/iVis-at-Bilkent/newt/issues/145\n\n    var collapsedNodes = elesDiff.filter('node.cy-expand-collapse-collapsed-node');\n    collapsedNodes.connectedEdges().remove();\n    collapsedNodes.removeClass('cy-expand-collapse-collapsed-node');\n    collapsedNodes.removeData('collapsedChildren');\n    collapsedNodes.removeData('position-before-collapse size-before-collapse');\n    collapsedNodes.removeData('expandcollapseRenderedCueSize expandcollapseRenderedStartX expandcollapseRenderedStartY'); // cloning ports\n\n    elesDiff.nodes().forEach(function (_node) {\n      if (_node.data(\"ports\").length == 2) {\n        var oldPortName0 = _node.data(\"ports\")[0].id;\n\n        var oldPortName1 = _node.data(\"ports\")[1].id;\n\n        _node.data(\"ports\")[0].id = _node.id() + \".1\";\n        _node.data(\"ports\")[1].id = _node.id() + \".2\";\n\n        _node.outgoers().edges().forEach(function (_edge) {\n          if (_edge.data(\"portsource\") == oldPortName0) {\n            _edge.data(\"portsource\", _node.data(\"ports\")[0].id);\n          } else if (_edge.data(\"portsource\") == oldPortName1) {\n            _edge.data(\"portsource\", _node.data(\"ports\")[1].id);\n          } else {\n            _edge.data(\"portsource\", _node.id());\n          }\n        });\n\n        _node.incomers().edges().forEach(function (_edge) {\n          if (_edge.data(\"porttarget\") == oldPortName0) {\n            _edge.data(\"porttarget\", _node.data(\"ports\")[0].id);\n          } else if (_edge.data(\"porttarget\") == oldPortName1) {\n            _edge.data(\"porttarget\", _node.data(\"ports\")[1].id);\n          } else {\n            _edge.data(\"porttarget\", _node.id());\n          }\n        });\n      } else {\n        _node.outgoers().edges().forEach(function (_edge) {\n          _edge.data(\"portsource\", _node.id());\n        });\n\n        _node.incomers().edges().forEach(function (_edge) {\n          _edge.data(\"porttarget\", _node.id());\n        });\n      }\n    });\n    elesDiff.select();\n  };\n  /*\n   * Clone given elements. Considers undoable option. Requires cytoscape-clipboard extension.\n   */\n\n\n  mainUtilities.cloneElements = function (eles, pasteAtMouseLoc) {\n    if (elementUtilities.isGraphTopologyLocked()) {\n      return;\n    }\n\n    if (eles.length === 0) {\n      return;\n    }\n\n    this.copyElements(eles);\n    this.pasteElements(pasteAtMouseLoc);\n  };\n  /*\n   * Copy given elements to clipboard. Requires cytoscape-clipboard extension.\n   */\n\n\n  mainUtilities.copyElements = function (eles) {\n    cy.clipboard().copy(eles);\n  };\n  /*\n   * Paste the elements copied to clipboard. Considers undoable option. Requires cytoscape-clipboard extension.\n   */\n\n\n  mainUtilities.pasteElements = function (pasteAtMouseLoc) {\n    if (elementUtilities.isGraphTopologyLocked()) {\n      return;\n    }\n\n    var elesBefore = cy.elements();\n\n    if (options.undoable) {\n      cy.undoRedo()[\"do\"](\"paste\", {\n        pasteAtMouseLoc: pasteAtMouseLoc\n      });\n    } else {\n      cy.clipboard().paste();\n    }\n\n    cloneCollapsedNodesAndPorts(elesBefore);\n    cy.nodes(\":selected\").emit('data');\n  };\n  /*\n   * Aligns given nodes in given horizontal and vertical order.\n   * Horizontal and vertical parameters may be 'none' or undefined.\n   * alignTo parameter indicates the leading node.\n   * Requrires cytoscape-grid-guide extension and considers undoable option.\n   */\n\n\n  mainUtilities.align = function (nodes, horizontal, vertical, alignTo) {\n    if (nodes.length === 0) {\n      return;\n    }\n\n    if (options.undoable) {\n      cy.undoRedo()[\"do\"](\"align\", {\n        nodes: nodes,\n        horizontal: horizontal,\n        vertical: vertical,\n        alignTo: alignTo\n      });\n    } else {\n      nodes.align(horizontal, vertical, alignTo);\n    }\n\n    if (cy.edges(\":selected\").length == 1) {\n      cy.edges().unselect();\n    }\n  };\n  /*\n   * Create compound for given nodes. compoundType may be 'complex' or 'compartment'.\n   * This method considers undoable option.\n   */\n\n\n  mainUtilities.createCompoundForGivenNodes = function (_nodes, compoundType) {\n    if (elementUtilities.isGraphTopologyLocked()) {\n      return;\n    }\n\n    var nodes = _nodes;\n    /*\n     * Eleminate the nodes which cannot have a parent with given compound type\n     */\n\n    nodes = _nodes.filter(function (element, i) {\n      if (typeof element === \"number\") {\n        element = i;\n      }\n\n      var sbgnclass = element.data(\"class\");\n      return elementUtilities.isValidParent(sbgnclass, compoundType, element);\n    });\n    nodes = elementUtilities.getTopMostNodes(nodes); // All elements should have the same parent and the common parent should not be a 'complex'\n    // if compoundType is 'compartent'\n    // because the old common parent will be the parent of the new compartment after this operation and\n    // 'complexes' cannot include 'compartments'\n\n    if (nodes.length == 0 || !elementUtilities.allHaveTheSameParent(nodes) || (compoundType === 'compartment' || compoundType == 'submap') && nodes.parent().data('class') && nodes.parent().data('class').startsWith('complex')) {\n      return;\n    }\n\n    if (cy.undoRedo()) {\n      var param = {\n        compoundType: compoundType,\n        nodesToMakeCompound: nodes\n      };\n      cy.undoRedo()[\"do\"](\"createCompoundForGivenNodes\", param);\n    } else {\n      elementUtilities.createCompoundForGivenNodes(nodes, compoundType);\n    }\n  };\n  /*\n   * Move the nodes to a new parent and change their position if possDiff params are set.\n   * Considers undoable option and checks if the operation is valid.\n   */\n\n\n  mainUtilities.changeParent = function (nodes, _newParent, posDiffX, posDiffY) {\n    if (elementUtilities.isGraphTopologyLocked()) {\n      return;\n    }\n\n    var newParent = typeof _newParent === 'string' ? cy.getElementById(_newParent) : _newParent; // New parent is supposed to be one of the root, a complex or a compartment\n\n    if (newParent && !newParent.data(\"class\").startsWith(\"complex\") && newParent.data(\"class\") != \"compartment\" && newParent.data(\"class\") != \"submap\") {\n      return;\n    }\n    /*\n     * Eleminate the nodes which cannot have the newParent as their parent\n     */\n\n\n    nodes = nodes.filter(function (element, i) {\n      if (typeof element === \"number\") {\n        element = i;\n      }\n\n      var sbgnclass = element.data(\"class\");\n      return elementUtilities.isValidParent(sbgnclass, newParent, element);\n    }); // Discard the nodes whose parent is already newParent.\n    // Discard the newParent itself if it is among the nodes\n\n    nodes = nodes.filter(function (ele, i) {\n      if (typeof ele === \"number\") {\n        ele = i;\n      } // Discard the newParent if it is among the nodes\n\n\n      if (newParent && ele.id() === newParent.id()) {\n        return false;\n      } // Discard the nodes whose parent is already newParent\n\n\n      if (!newParent) {\n        return ele.data('parent') != null;\n      }\n\n      return ele.data('parent') !== newParent.id();\n    }); // If some nodes are ancestor of new parent eleminate them\n\n    if (newParent) {\n      nodes = nodes.difference(newParent.ancestors());\n    } // If all nodes are eleminated return directly\n\n\n    if (nodes.length === 0) {\n      return;\n    } // Just move the top most nodes\n\n\n    nodes = elementUtilities.getTopMostNodes(nodes);\n    var parentId = newParent ? newParent.id() : null;\n\n    if (options.undoable) {\n      var param = {\n        firstTime: true,\n        parentData: parentId,\n        // It keeps the newParentId (Just an id for each nodes for the first time)\n        nodes: nodes,\n        posDiffX: posDiffX,\n        posDiffY: posDiffY,\n        // This is needed because the changeParent function called is not from elementUtilities\n        // but from the undoRedo extension directly, so maintaining pointer is not automatically done.\n        callback: elementUtilities.maintainPointer\n      };\n      cy.undoRedo()[\"do\"](\"changeParent\", param); // This action is registered by undoRedo extension\n    } else {\n      elementUtilities.changeParent(nodes, parentId, posDiffX, posDiffY);\n    }\n  };\n  /*\n   * Creates an activation reaction with given parameters. Requires cose-bilkent layout to tile the free macromolecules included\n   * in the complex. Considers undoable option. For more information see the same function in elementUtilities\n   */\n\n\n  mainUtilities.createTranslationReaction = function (mRnaName, proteinName, processPosition, edgeLength) {\n    if (elementUtilities.isGraphTopologyLocked()) {\n      return;\n    }\n\n    if (!options.undoable) {\n      elementUtilities.createTranslationReaction(mRnaName, proteinName, processPosition, edgeLength);\n    } else {\n      var param = {\n        mRnaName: mRnaName,\n        proteinName: proteinName,\n        processPosition: processPosition,\n        edgeLength: edgeLength\n      };\n      cy.undoRedo()[\"do\"](\"createTranslationReaction\", param);\n    }\n  };\n  /*\n   * Creates an activation reaction with given parameters. Requires cose-bilkent layout to tile the free macromolecules included\n   * in the complex. Considers undoable option. For more information see the same function in elementUtilities\n   */\n\n\n  mainUtilities.createTranscriptionReaction = function (geneName, mRnaName, processPosition, edgeLength) {\n    if (elementUtilities.isGraphTopologyLocked()) {\n      return;\n    }\n\n    if (!options.undoable) {\n      elementUtilities.createTranscriptionReaction(geneName, mRnaName, processPosition, edgeLength);\n    } else {\n      var param = {\n        geneName: geneName,\n        mRnaName: mRnaName,\n        processPosition: processPosition,\n        edgeLength: edgeLength\n      };\n      cy.undoRedo()[\"do\"](\"createTranscriptionReaction\", param);\n    }\n  };\n\n  mainUtilities.createTranslation = function (regulatorLabel, outputLabel, orientation) {\n    if (elementUtilities.isGraphTopologyLocked()) {\n      return;\n    }\n\n    if (!options.undoable) {\n      elementUtilities.createTranslation(regulatorLabel, outputLabel, orientation);\n    } else {\n      var param = {\n        regulatorLabel: regulatorLabel,\n        outputLabel: outputLabel,\n        orientation: orientation\n      };\n      cy.undoRedo()[\"do\"](\"createTranslation\", param);\n    }\n  };\n\n  mainUtilities.createTranscription = function (label, orientation) {\n    if (elementUtilities.isGraphTopologyLocked()) {\n      return;\n    }\n\n    if (!options.undoable) {\n      elementUtilities.createTranscription(label, orientation);\n    } else {\n      var param = {\n        label: label,\n        orientation: orientation\n      };\n      cy.undoRedo()[\"do\"](\"createTranscription\", param);\n    }\n  };\n\n  mainUtilities.createDegradation = function (macromolecule, orientation) {\n    if (elementUtilities.isGraphTopologyLocked()) {\n      return;\n    }\n\n    if (!options.undoable) {\n      elementUtilities.createDegradation(macromolecule, orientation);\n    } else {\n      var param = {\n        macromolecule: macromolecule,\n        orientation: orientation\n      };\n      cy.undoRedo()[\"do\"](\"createDegradation\", param);\n    }\n  };\n\n  mainUtilities.createComplexProteinFormation = function (proteinLabels, complexLabel, regulator, orientation, reverse) {\n    if (elementUtilities.isGraphTopologyLocked()) {\n      return;\n    }\n\n    if (!options.undoable) {\n      elementUtilities.createComplexProteinFormation(proteinLabels, complexLabel, regulator, orientation, reverse);\n    } else {\n      var param = {\n        proteinLabels: proteinLabels,\n        complexLabel: complexLabel,\n        regulator: regulator,\n        orientation: orientation,\n        reverse: reverse\n      };\n      cy.undoRedo()[\"do\"](\"createComplexProteinFormation\", param);\n    }\n  };\n\n  mainUtilities.createMultimerization = function (macromolecule, regulator, regulatorMultimer, orientation) {\n    if (elementUtilities.isGraphTopologyLocked()) {\n      return;\n    }\n\n    if (!options.undoable) {\n      elementUtilities.createMultimerization(macromolecule, regulator, regulatorMultimer, orientation);\n    } else {\n      var param = {\n        macromolecule: macromolecule,\n        regulator: regulator,\n        regulatorMultimer: regulatorMultimer,\n        orientation: orientation\n      };\n      cy.undoRedo()[\"do\"](\"createMultimerization\", param);\n    }\n  };\n\n  mainUtilities.createConversion = function (macromolecule, regulator, regulatorMultimer, orientation, inputInfoboxLabels, outputInfoboxLabels) {\n    if (elementUtilities.isGraphTopologyLocked()) {\n      return;\n    }\n\n    if (!options.undoable) {\n      elementUtilities.createConversion(macromolecule, regulator, regulatorMultimer, orientation, inputInfoboxLabels, outputInfoboxLabels);\n    } else {\n      var param = {\n        macromolecule: macromolecule,\n        regulator: regulator,\n        regulatorMultimer: regulatorMultimer,\n        orientation: orientation,\n        inputInfoboxLabels: inputInfoboxLabels,\n        outputInfoboxLabels: outputInfoboxLabels\n      };\n      cy.undoRedo()[\"do\"](\"createConversion\", param);\n    }\n  };\n\n  mainUtilities.createMetabolicReaction = function (inputs, outputs, reversible, regulator, regulatorMultimer, orientation) {\n    if (elementUtilities.isGraphTopologyLocked()) {\n      return;\n    }\n\n    if (!options.undoable) {\n      elementUtilities.createMetabolicReaction(inputs, outputs, reversible, regulator, regulatorMultimer, orientation);\n    } else {\n      var param = {\n        inputs: inputs,\n        outputs: outputs,\n        reversible: reversible,\n        regulator: regulator,\n        regulatorMultimer: regulatorMultimer,\n        orientation: orientation\n      };\n      cy.undoRedo()[\"do\"](\"createMetabolicReaction\", param);\n    }\n  };\n  /*\n   * Creates an activation reaction with given parameters. Requires cose-bilkent layout to tile the free macromolecules included\n   * in the complex. Considers undoable option. For more information see the same function in elementUtilities\n   */\n\n\n  mainUtilities.createMetabolicCatalyticActivity = function (inputNodeList, outputNodeList, catalystName, catalystType, processPosition, tilingPaddingVertical, tilingPaddingHorizontal, edgeLength) {\n    if (elementUtilities.isGraphTopologyLocked()) {\n      return;\n    }\n\n    if (!options.undoable) {\n      elementUtilities.createMetabolicCatalyticActivity(inputNodeList, outputNodeList, catalystName, catalystType, processPosition, tilingPaddingVertical, tilingPaddingHorizontal, edgeLength);\n    } else {\n      var param = {\n        inputNodeList: inputNodeList,\n        outputNodeList: outputNodeList,\n        catalystName: catalystName,\n        catalystType: catalystType,\n        processPosition: processPosition,\n        tilingPaddingVertical: tilingPaddingVertical,\n        tilingPaddingHorizontal: tilingPaddingHorizontal,\n        edgeLength: edgeLength\n      };\n      cy.undoRedo()[\"do\"](\"createMetabolicCatalyticActivity\", param);\n    }\n  };\n  /*\n   * Creates an activation reaction with given parameters. Requires cose-bilkent layout to tile the free macromolecules included\n   * in the complex. Considers undoable option. For more information see the same function in elementUtilities\n   */\n\n\n  mainUtilities.createActivationReaction = function (proteinName, processPosition, edgeLength, reverse) {\n    if (elementUtilities.isGraphTopologyLocked()) {\n      return;\n    }\n\n    if (!options.undoable) {\n      elementUtilities.createActivationReaction(proteinName, processPosition, edgeLength, reverse);\n    } else {\n      var param = {\n        proteinName: proteinName,\n        processPosition: processPosition,\n        edgeLength: edgeLength,\n        reverse: reverse\n      };\n      cy.undoRedo()[\"do\"](\"createActivationReaction\", param);\n    }\n  };\n  /*\n   * Creates a template reaction with given parameters. Requires cose-bilkent layout to tile the free macromolecules included\n   * in the complex. Considers undoable option. For more information see the same function in elementUtilities\n   */\n\n\n  mainUtilities.createTemplateReaction = function (templateType, macromoleculeList, complexName, processPosition, tilingPaddingVertical, tilingPaddingHorizontal, edgeLength, layoutParam) {\n    if (elementUtilities.isGraphTopologyLocked()) {\n      return;\n    }\n\n    if (!options.undoable) {\n      if (templateType === \"reversible\") {\n        elementUtilities.setMapType(\"HybridAny\");\n      }\n\n      elementUtilities.createTemplateReaction(templateType, macromoleculeList, complexName, processPosition, tilingPaddingVertical, tilingPaddingHorizontal, edgeLength, layoutParam);\n    } else {\n      var param = {\n        templateType: templateType,\n        macromoleculeList: macromoleculeList,\n        complexName: complexName,\n        processPosition: processPosition,\n        tilingPaddingVertical: tilingPaddingVertical,\n        tilingPaddingHorizontal: tilingPaddingHorizontal,\n        edgeLength: edgeLength,\n        layoutParam: layoutParam\n      };\n\n      if (templateType === \"reversible\") {\n        var actions = [];\n        actions.push({\n          name: \"changeMapType\",\n          param: {\n            mapType: \"HybridAny\",\n            callback: function callback() {}\n          }\n        });\n        actions.push({\n          name: \"createTemplateReaction\",\n          param: param\n        });\n        cy.undoRedo()[\"do\"](\"batch\", actions);\n      } else {\n        cy.undoRedo()[\"do\"](\"createTemplateReaction\", param);\n      }\n    }\n  };\n  /*\n   * Resize given nodes if useAspectRatio is truthy one of width or height should not be set.\n   * Considers undoable option.\n   */\n\n\n  mainUtilities.resizeNodes = function (nodes, width, height, useAspectRatio, preserveRelativePos) {\n    if (nodes.length === 0) {\n      return;\n    }\n\n    if (options.undoable) {\n      var param = {\n        nodes: nodes,\n        width: width,\n        height: height,\n        useAspectRatio: useAspectRatio,\n        performOperation: true,\n        preserveRelativePos: preserveRelativePos\n      };\n      cy.undoRedo()[\"do\"](\"resizeNodes\", param);\n    } else {\n      elementUtilities.resizeNodes(nodes, width, height, useAspectRatio);\n      cy.style().update();\n    }\n  };\n  /*\n   * Resize given nodes if useAspectRatio is truthy one of width or height should not be set.\n   * Considers undoable option.\n   */\n\n\n  mainUtilities.resizeNodesToContent = function (nodes, useAspectRatio) {\n    if (nodes.length === 0) {\n      return;\n    }\n\n    if (options.undoable) {\n      var actions = [];\n      nodes.forEach(function (node) {\n        var width = elementUtilities.calculateMinWidth(node);\n        var height = elementUtilities.calculateMinHeight(node);\n        actions.push({\n          name: \"resizeNodes\",\n          param: {\n            nodes: node,\n            width: width,\n            height: height,\n            useAspectRatio: useAspectRatio,\n            performOperation: true,\n            preserveRelativePos: true\n          }\n        });\n        var stateAndInfos = node.data('statesandinfos');\n        var length = stateAndInfos.length;\n\n        if (length != 0) {\n          var param = {\n            node: node,\n            locations: [\"top\", \"right\", \"bottom\", \"left\"]\n          };\n          actions.push({\n            name: \"fitUnits\",\n            param: param\n          });\n        }\n      });\n      cy.undoRedo()[\"do\"](\"batch\", actions);\n      cy.style().update();\n      return actions;\n    } else {\n      nodes.forEach(function (node) {\n        var width = elementUtilities.calculateMinWidth(node);\n        var height = elementUtilities.calculateMinHeight(node);\n        elementUtilities.resizeNodes(node, width, height, useAspectRatio, true);\n      });\n    }\n\n    cy.style().update();\n  };\n  /*\n   * Changes the label of the given nodes to the given label. Considers undoable option.\n   */\n\n\n  mainUtilities.changeNodeLabel = function (nodes, label) {\n    if (nodes.length === 0) {\n      return;\n    }\n\n    if (!options.undoable) {\n      nodes.data('label', label);\n    } else {\n      var param = {\n        nodes: nodes,\n        label: label,\n        firstTime: true\n      };\n      cy.undoRedo()[\"do\"](\"changeNodeLabel\", param);\n    }\n\n    cy.style().update();\n  };\n  /*\n   * Change font properties for given nodes use the given font data.\n   * Considers undoable option.\n   */\n\n\n  mainUtilities.changeFontProperties = function (eles, data) {\n    if (eles.length === 0) {\n      return;\n    }\n\n    if (options.undoable) {\n      var param = {\n        eles: eles,\n        data: data,\n        firstTime: true\n      };\n      cy.undoRedo()[\"do\"](\"changeFontProperties\", param);\n    } else {\n      elementUtilities.changeFontProperties(eles, data);\n    }\n\n    cy.style().update();\n  };\n  /*\n   * Change state value or unit of information box of given nodes with given index.\n   * Considers undoable option.\n   * For more information about the parameters see elementUtilities.changeStateOrInfoBox\n   */\n\n\n  mainUtilities.changeStateOrInfoBox = function (nodes, index, value, type) {\n    if (nodes.length === 0) {\n      return;\n    }\n\n    if (options.undoable) {\n      var param = {\n        index: index,\n        value: value,\n        type: type,\n        nodes: nodes\n      };\n      cy.undoRedo()[\"do\"](\"changeStateOrInfoBox\", param);\n    } else {\n      return elementUtilities.changeStateOrInfoBox(nodes, index, value, type);\n    }\n\n    cy.style().update();\n  }; // Add a new state or info box to given nodes.\n  // The box is represented by the parameter obj.\n  // Considers undoable option.\n\n\n  mainUtilities.addStateOrInfoBox = function (nodes, obj) {\n    if (nodes.length === 0) {\n      return;\n    }\n\n    if (!options.undoable) {\n      elementUtilities.addStateOrInfoBox(nodes, obj);\n    } else {\n      var param = {\n        obj: obj,\n        nodes: nodes\n      };\n      cy.undoRedo()[\"do\"](\"addStateOrInfoBox\", param);\n    }\n\n    cy.style().update();\n  }; // Remove the state or info boxes of the given nodes at given index.\n  // Considers undoable option.\n\n\n  mainUtilities.removeStateOrInfoBox = function (nodes, index) {\n    if (nodes.length === 0) {\n      return;\n    }\n\n    if (!options.undoable) {\n      elementUtilities.removeStateOrInfoBox(nodes, {\n        index: index\n      });\n    } else {\n      var param = {\n        locationObj: {\n          index: index\n        },\n        nodes: nodes\n      };\n      cy.undoRedo()[\"do\"](\"removeStateOrInfoBox\", param);\n    }\n\n    cy.style().update();\n  }; //Arrange information boxes\n  //If force check is true, it rearranges all information boxes\n\n\n  mainUtilities.fitUnits = function (node, locations) {\n    if (node.data('auxunitlayouts') === undefined || node.data('statesandinfos').length <= 0) {\n      return;\n    }\n\n    if (locations === undefined || locations.length <= 0) {\n      return;\n    }\n\n    if (!options.undoable) {\n      elementUtilities.fitUnits(node, locations);\n    } else {\n      var param = {\n        node: node,\n        locations: locations\n      };\n      cy.undoRedo()[\"do\"](\"fitUnits\", param);\n    }\n\n    cy.style().update();\n  };\n  /*\n   * Set multimer status of the given nodes to the given status.\n   * Considers undoable option.\n   */\n\n\n  mainUtilities.setMultimerStatus = function (nodes, status) {\n    if (nodes.length === 0) {\n      return;\n    }\n\n    if (options.undoable) {\n      var param = {\n        status: status,\n        nodes: nodes,\n        firstTime: true\n      };\n      cy.undoRedo()[\"do\"](\"setMultimerStatus\", param);\n    } else {\n      elementUtilities.setMultimerStatus(nodes, status);\n    }\n\n    cy.style().update();\n  };\n\n  mainUtilities.setActiveStatus = function (nodes, status) {\n    if (nodes.length === 0) {\n      return;\n    }\n\n    if (options.undoable) {\n      var param = {\n        status: status,\n        nodes: nodes,\n        firstTime: true\n      };\n      cy.undoRedo()[\"do\"](\"setActiveStatus\", param);\n    } else {\n      elementUtilities.setActiveStatus(nodes, status);\n    }\n\n    cy.style().update();\n  };\n\n  mainUtilities.setHypotheticalStatus = function (nodes, status) {\n    if (nodes.length === 0) {\n      return;\n    }\n\n    if (options.undoable) {\n      var param = {\n        status: status,\n        nodes: nodes,\n        firstTime: true\n      };\n      cy.undoRedo()[\"do\"](\"setHypotheticalStatus\", param);\n    } else {\n      elementUtilities.setHypotheticalStatus(nodes, status);\n    }\n\n    cy.style().update();\n  };\n  /**\n   * Redraw clone markers on given nodes without considering undo.\n   * See https://github.com/iVis-at-Bilkent/newt/issues/574 \n   */\n\n\n  mainUtilities.redrawCloneMarkers = function (nodes) {\n    elementUtilities.setCloneMarkerStatus(nodes, true);\n  };\n  /*\n   * Set clone marker status of given nodes to the given status.\n   * Considers undoable option.\n   */\n\n\n  mainUtilities.setCloneMarkerStatus = function (nodes, status) {\n    if (nodes.length === 0) {\n      return;\n    }\n\n    if (options.undoable) {\n      var param = {\n        status: status,\n        nodes: nodes,\n        firstTime: true\n      };\n      cy.undoRedo()[\"do\"](\"setCloneMarkerStatus\", param);\n    } else {\n      elementUtilities.setCloneMarkerStatus(nodes, status);\n    }\n\n    cy.style().update();\n  };\n  /*\n   * Change style/css of given eles by setting getting property name to the given given value/values (Note that valueMap parameter may be\n   * a single string or an id to value map). Considers undoable option.\n   */\n\n\n  mainUtilities.changeCss = function (eles, name, valueMap) {\n    if (eles.length === 0) {\n      return;\n    }\n\n    if (!options.undoable) {\n      elementUtilities.changeCss(eles, name, valueMap);\n    } else {\n      var param = {\n        eles: eles,\n        valueMap: valueMap,\n        name: name\n      };\n      cy.undoRedo()[\"do\"](\"changeCss\", param);\n    }\n\n    cy.style().update();\n  };\n  /*\n   * Change data of given eles by setting getting property name to the given given value/values (Note that valueMap parameter may be\n   * a single string or an id to value map). Considers undoable option.\n   */\n\n\n  mainUtilities.changeData = function (eles, name, valueMap) {\n    if (eles.length === 0) {\n      return;\n    }\n\n    if (!options.undoable) {\n      elementUtilities.changeData(eles, name, valueMap);\n    } else {\n      var param = {\n        eles: eles,\n        valueMap: valueMap,\n        name: name\n      };\n      cy.undoRedo()[\"do\"](\"changeData\", param);\n    }\n\n    cy.style().update();\n  };\n\n  mainUtilities.updateSetField = function (ele, fieldName, toDelete, toAdd, callback) {\n    if (!options.undoable) {\n      elementUtilities.changeData(ele, fieldName, toDelete, toAdd, callback);\n    } else {\n      var param = {\n        ele: ele,\n        fieldName: fieldName,\n        toDelete: toDelete,\n        toAdd: toAdd,\n        callback: callback\n      };\n      cy.undoRedo()[\"do\"](\"updateSetField\", param);\n    }\n  };\n\n  mainUtilities.setDefaultProperty = function (_class, name, value) {\n    if (!options.undoable) {\n      var propMap = {};\n      propMap[name] = value;\n      elementUtilities.setDefaultProperties(_class, propMap);\n    } else {\n      var param = {\n        \"class\": _class,\n        name: name,\n        value: value\n      };\n      cy.undoRedo()[\"do\"](\"setDefaultProperty\", param);\n    }\n  };\n\n  mainUtilities.updateInfoboxStyle = function (node, index, newProps) {\n    if (!options.undoable) {\n      elementUtilities.updateInfoboxStyle(node, index, newProps);\n    } else {\n      var param = {\n        node: node,\n        index: index,\n        newProps: newProps\n      };\n      cy.undoRedo()[\"do\"](\"updateInfoboxStyle\", param);\n    }\n\n    cy.style().update();\n  };\n\n  mainUtilities.updateInfoboxObj = function (node, index, newProps) {\n    if (!options.undoable) {\n      elementUtilities.updateInfoboxObj(node, index, newProps);\n    } else {\n      var param = {\n        node: node,\n        index: index,\n        newProps: newProps\n      };\n      cy.undoRedo()[\"do\"](\"updateInfoboxObj\", param);\n    }\n\n    cy.style().update();\n  };\n\n  mainUtilities.deleteAndPerformLayout = function (eles, layoutparam) {\n    var nodes = eles.nodes(); // Ensure that nodes list just include nodes\n\n    var allNodes = cy.nodes(\":visible\");\n    var nodesToKeep = elementUtilities.extendRemainingNodes(nodes, allNodes);\n    var nodesToRemove = allNodes.not(nodesToKeep);\n\n    if (nodesToRemove.length === 0) {\n      return;\n    }\n\n    if (!options.undoable) {\n      elementUtilities.deleteAndPerformLayout(nodesToRemove, layoutparam);\n    } else {\n      var param = {\n        eles: nodesToRemove,\n        layoutparam: layoutparam,\n        firstTime: true\n      };\n      cy.undoRedo()[\"do\"](\"deleteAndPerformLayout\", param);\n    }\n  };\n  /*\n   * Hides given eles (the ones which are selected) and perform given layout afterward. Layout parameter may be layout options\n   * or a function to call. Requires viewUtilities extension and considers undoable option.\n   */\n\n\n  mainUtilities.hideAndPerformLayout = function (eles, layoutparam) {\n    var nodes = eles.nodes(); // Ensure that nodes list just include nodes\n\n    var allNodes = cy.nodes(\":visible\");\n    var nodesToShow = elementUtilities.extendRemainingNodes(nodes, allNodes);\n    var nodesToHide = allNodes.not(nodesToShow);\n\n    if (nodesToHide.length === 0) {\n      return;\n    }\n\n    if (!options.undoable) {\n      var nodesWithHiddenNeighbor = cy.edges(\":hidden\").connectedNodes(':visible');\n      sbgnvizInstance.thinBorder(nodesWithHiddenNeighbor);\n      elementUtilities.hideAndPerformLayout(nodesToHide, layoutparam);\n      var nodesWithHiddenNeighbor = cy.edges(\":hidden\").connectedNodes(':visible');\n      sbgnvizInstance.thickenBorder(nodesWithHiddenNeighbor);\n    } else {\n      var param = {\n        eles: nodesToHide,\n        layoutparam: layoutparam,\n        firstTime: true\n      };\n      var ur = cy.undoRedo();\n      ur.action(\"thickenBorder\", sbgnvizInstance.thickenBorder, sbgnvizInstance.thinBorder);\n      ur.action(\"thinBorder\", sbgnvizInstance.thinBorder, sbgnvizInstance.thickenBorder);\n      var actions = [];\n      var nodesWithHiddenNeighbor = cy.edges(\":hidden\").connectedNodes().intersection(nodesToHide);\n      actions.push({\n        name: \"thinBorder\",\n        param: nodesWithHiddenNeighbor\n      });\n      actions.push({\n        name: \"hideAndPerformLayout\",\n        param: param\n      });\n      nodesWithHiddenNeighbor = nodesToHide.neighborhood(\":visible\").nodes().difference(nodesToHide).difference(cy.nodes(\"[thickBorder]\"));\n      actions.push({\n        name: \"thickenBorder\",\n        param: nodesWithHiddenNeighbor\n      });\n      cy.undoRedo()[\"do\"](\"batch\", actions);\n    }\n  };\n  /*\n   * Shows all elements (the ones which are hidden if any) and perform given layout afterward. Layout parameter may be layout options\n   * or a function to call. Requires viewUtilities extension and considers undoable option.\n   */\n\n\n  mainUtilities.showAllAndPerformLayout = function (layoutparam) {\n    var hiddenEles = cy.elements(':hidden');\n\n    if (hiddenEles.length === 0) {\n      return;\n    }\n\n    if (!options.undoable) {\n      var nodesWithHiddenNeighbor = cy.edges(\":hidden\").connectedNodes(':visible');\n      sbgnvizInstance.thinBorder(nodesWithHiddenNeighbor);\n      elementUtilities.showAndPerformLayout(hiddenEles, layoutparam);\n    } else {\n      var param = {\n        eles: hiddenEles,\n        layoutparam: layoutparam,\n        firstTime: true\n      };\n      var ur = cy.undoRedo();\n      ur.action(\"thickenBorder\", sbgnvizInstance.thickenBorder, sbgnvizInstance.thinBorder);\n      ur.action(\"thinBorder\", sbgnvizInstance.thinBorder, sbgnvizInstance.thickenBorder);\n      var actions = [];\n      var nodesWithHiddenNeighbor = cy.nodes(\"[thickBorder]\");\n      actions.push({\n        name: \"thinBorder\",\n        param: nodesWithHiddenNeighbor\n      });\n      actions.push({\n        name: \"showAndPerformLayout\",\n        param: param\n      });\n      cy.undoRedo()[\"do\"](\"batch\", actions);\n    }\n  };\n  /*\n   * Unhide given eles (the ones which are hidden if any) and perform given layout afterward. Layout parameter may be layout options\n   * or a function to call. Requires viewUtilities extension and considers undoable option.\n   */\n\n\n  mainUtilities.showAndPerformLayout = function (mainEle, eles, layoutparam) {\n    var hiddenEles = eles.filter(':hidden');\n\n    if (hiddenEles.length === 0) {\n      return;\n    }\n\n    mainUtilities.closeUpElements(mainEle, hiddenEles.nodes());\n\n    if (!options.undoable) {\n      var nodesWithHiddenNeighbor = cy.edges(\":hidden\").connectedNodes(':visible');\n      sbgnvizInstance.thinBorder(nodesWithHiddenNeighbor);\n      elementUtilities.showAndPerformLayout(hiddenEles, layoutparam);\n      var nodesWithHiddenNeighbor = cy.edges(\":hidden\").connectedNodes(':visible');\n      sbgnvizInstance.thickenBorder(nodesWithHiddenNeighbor);\n    } else {\n      var param = {\n        eles: hiddenEles,\n        layoutparam: layoutparam,\n        firstTime: true\n      };\n      var ur = cy.undoRedo();\n      ur.action(\"thickenBorder\", sbgnvizInstance.thickenBorder, sbgnvizInstance.thinBorder);\n      ur.action(\"thinBorder\", sbgnvizInstance.thinBorder, sbgnvizInstance.thickenBorder);\n      var actions = [];\n      var nodesToThinBorder = hiddenEles.neighborhood(\":visible\").nodes(\"[thickBorder]\").difference(cy.edges(\":hidden\").difference(hiddenEles.edges().union(hiddenEles.nodes().connectedEdges())).connectedNodes());\n      actions.push({\n        name: \"thinBorder\",\n        param: nodesToThinBorder\n      });\n      actions.push({\n        name: \"showAndPerformLayout\",\n        param: param\n      });\n      var nodesToThickenBorder = hiddenEles.nodes().edgesWith(cy.nodes(\":hidden\").difference(hiddenEles.nodes())).connectedNodes().intersection(hiddenEles.nodes());\n      actions.push({\n        name: \"thickenBorder\",\n        param: nodesToThickenBorder\n      });\n      cy.undoRedo()[\"do\"](\"batch\", actions);\n    }\n  };\n  /*\n  * Takes the hidden elements close to the nodes whose neighbors will be shown\n  * */\n\n\n  mainUtilities.closeUpElements = function (mainEle, hiddenEles) {\n    var leftX = Number.MAX_VALUE;\n    var rightX = Number.MIN_VALUE;\n    var topY = Number.MAX_VALUE;\n    var bottomY = Number.MIN_VALUE; // Check the x and y limits of all hidden elements and store them in the variables above\n\n    hiddenEles.forEach(function (ele) {\n      if (ele.data('class') != 'compartment' && ele.data('class') != 'complex') {\n        var halfWidth = ele.outerWidth() / 2;\n        var halfHeight = ele.outerHeight() / 2;\n        if (ele.position(\"x\") - halfWidth < leftX) leftX = ele.position(\"x\") - halfWidth;\n        if (ele.position(\"x\") + halfWidth > rightX) rightX = ele.position(\"x\") + halfWidth;\n        if (ele.position(\"y\") - halfHeight < topY) topY = ele.position(\"y\") - halfHeight;\n        if (ele.position(\"y\") + halfHeight > topY) bottomY = ele.position(\"y\") + halfHeight;\n      }\n    }); //The coordinates of the old center containing the hidden nodes\n\n    var oldCenterX = (leftX + rightX) / 2;\n    var oldCenterY = (topY + bottomY) / 2; //Here we calculate two parameters which define the area in which the hidden elements are placed initially\n\n    var minHorizontalParam = mainEle.outerWidth() / 2 + (rightX - leftX) / 2;\n    var maxHorizontalParam = mainEle.outerWidth() + (rightX - leftX) / 2;\n    var minVerticalParam = mainEle.outerHeight() / 2 + (bottomY - topY) / 2;\n    var maxVerticalParam = mainEle.outerHeight() + (bottomY - topY) / 2; //Quadrants is an object of the form {first:\"obtained\", second:\"free\", third:\"free\", fourth:\"obtained\"}\n    // which holds which quadrant are free (that's where hidden nodes will be brought)\n\n    var quadrants = mainUtilities.checkOccupiedQuadrants(mainEle, hiddenEles);\n    var freeQuadrants = [];\n\n    for (var property in quadrants) {\n      if (quadrants[property] === \"free\") freeQuadrants.push(property);\n    } //Can take values 1 and -1 and are used to place the hidden nodes in the random quadrant\n\n\n    var horizontalMult;\n    var verticalMult;\n\n    if (freeQuadrants.length > 0) {\n      if (freeQuadrants.length === 3) {\n        if (freeQuadrants.includes('first') && freeQuadrants.includes('second') && freeQuadrants.includes('third')) {\n          horizontalMult = -1;\n          verticalMult = -1;\n        } else if (freeQuadrants.includes('first') && freeQuadrants.includes('second') && freeQuadrants.includes('fourth')) {\n          horizontalMult = 1;\n          verticalMult = -1;\n        } else if (freeQuadrants.includes('first') && freeQuadrants.includes('third') && freeQuadrants.includes('fourth')) {\n          horizontalMult = 1;\n          verticalMult = 1;\n        } else if (freeQuadrants.includes('second') && freeQuadrants.includes('third') && freeQuadrants.includes('fourth')) {\n          horizontalMult = -1;\n          verticalMult = 1;\n        }\n      } else {\n        //Randomly picks one quadrant from the free quadrants\n        var randomQuadrant = freeQuadrants[Math.floor(Math.random() * freeQuadrants.length)];\n\n        if (randomQuadrant === \"first\") {\n          horizontalMult = 1;\n          verticalMult = -1;\n        } else if (randomQuadrant === \"second\") {\n          horizontalMult = -1;\n          verticalMult = -1;\n        } else if (randomQuadrant === \"third\") {\n          horizontalMult = -1;\n          verticalMult = 1;\n        } else if (randomQuadrant === \"fourth\") {\n          horizontalMult = 1;\n          verticalMult = 1;\n        }\n      }\n    } else {\n      horizontalMult = 0;\n      verticalMult = 0;\n    } // If the horizontalMult is 0 it means that no quadrant is free, so we randomly choose a quadrant\n\n\n    var horizontalParam = mainUtilities.generateRandom(minHorizontalParam, maxHorizontalParam, horizontalMult);\n    var verticalParam = mainUtilities.generateRandom(minVerticalParam, maxVerticalParam, verticalMult); //The coordinates of the center where the hidden nodes will be transfered\n\n    var newCenterX = mainEle.position(\"x\") + horizontalParam;\n    var newCenterY = mainEle.position(\"y\") + verticalParam;\n    var xdiff = newCenterX - oldCenterX;\n    var ydiff = newCenterY - oldCenterY; //Change the position of hidden elements\n\n    hiddenEles.forEach(function (ele) {\n      var newx = ele.position(\"x\") + xdiff;\n      var newy = ele.position(\"y\") + ydiff;\n      ele.position(\"x\", newx);\n      ele.position(\"y\", newy);\n    });\n  };\n  /*\n   * Generates a number between 2 nr and multimplies it with 1 or -1\n   * */\n\n\n  mainUtilities.generateRandom = function (min, max, mult) {\n    var val = [-1, 1];\n    if (mult === 0) mult = val[Math.floor(Math.random() * val.length)];\n    return (Math.floor(Math.random() * (max - min + 1)) + min) * mult;\n  };\n  /*\n   * This function makes sure that the random number lies in free quadrant\n   * */\n\n\n  mainUtilities.checkOccupiedQuadrants = function (mainEle, hiddenEles) {\n    if (elementUtilities.getMapType() == 'PD') {\n      var visibleNeighborEles = mainEle.neighborhood().difference(hiddenEles).nodes();\n      var visibleNeighborsOfNeighbors = visibleNeighborEles.neighborhood().difference(hiddenEles).difference(mainEle).nodes();\n      var visibleEles = visibleNeighborEles.union(visibleNeighborsOfNeighbors);\n    } else var visibleEles = mainEle.neighborhood().difference(hiddenEles).nodes();\n\n    var occupiedQuadrants = {\n      first: \"free\",\n      second: \"free\",\n      third: \"free\",\n      fourth: \"free\"\n    };\n    visibleEles.forEach(function (ele) {\n      if (ele.data('class') != 'compartment' && ele.data('class') != 'complex') {\n        if (ele.position(\"x\") < mainEle.position(\"x\") && ele.position(\"y\") < mainEle.position(\"y\")) occupiedQuadrants.second = \"occupied\";else if (ele.position(\"x\") > mainEle.position(\"x\") && ele.position(\"y\") < mainEle.position(\"y\")) occupiedQuadrants.first = \"occupied\";else if (ele.position(\"x\") < mainEle.position(\"x\") && ele.position(\"y\") > mainEle.position(\"y\")) occupiedQuadrants.third = \"occupied\";else if (ele.position(\"x\") > mainEle.position(\"x\") && ele.position(\"y\") > mainEle.position(\"y\")) occupiedQuadrants.fourth = \"occupied\";\n      }\n    });\n    return occupiedQuadrants;\n  }; // Overrides highlightProcesses from SBGNVIZ - do not highlight any nodes when the map type is AF\n\n\n  mainUtilities.highlightProcesses = function (_nodes) {\n    if (elementUtilities.getMapType() == \"AF\") return;\n    sbgnvizInstance.highlightProcesses(_nodes);\n  };\n  /**\n   * Resets map type to undefined\n   */\n\n\n  mainUtilities.resetMapType = function () {\n    elementUtilities.resetMapType();\n  };\n  /**\n   * return : map type\n   */\n\n\n  mainUtilities.getMapType = function () {\n    return elementUtilities.getMapType();\n  };\n\n  mainUtilities.addBackgroundImage = function (nodes, bgObj, updateInfo, promptInvalidImage, validateURL) {\n    if (nodes.length === 0 || !bgObj) {\n      return;\n    }\n\n    bgObj['firstTime'] = true;\n\n    if (options.undoable) {\n      var param = {\n        bgObj: bgObj,\n        nodes: nodes,\n        updateInfo: updateInfo,\n        promptInvalidImage: promptInvalidImage,\n        validateURL: validateURL\n      };\n      cy.undoRedo()[\"do\"](\"addBackgroundImage\", param);\n    } else {\n      elementUtilities.addBackgroundImage(nodes, bgObj, updateInfo, promptInvalidImage, validateURL);\n    }\n\n    cy.style().update();\n  };\n\n  mainUtilities.removeBackgroundImage = function (nodes, bgObj) {\n    if (nodes.length === 0 || !bgObj) {\n      return;\n    }\n\n    bgObj['firstTime'] = true;\n\n    if (options.undoable) {\n      var param = {\n        bgObj: bgObj,\n        nodes: nodes\n      };\n      cy.undoRedo()[\"do\"](\"removeBackgroundImage\", param);\n    } else {\n      elementUtilities.removeBackgroundImage(nodes, bgObj);\n    }\n\n    cy.style().update();\n  };\n\n  mainUtilities.updateBackgroundImage = function (nodes, bgObj) {\n    if (nodes.length === 0 || !bgObj) {\n      return;\n    }\n\n    if (options.undoable) {\n      var param = {\n        bgObj: bgObj,\n        nodes: nodes\n      };\n      cy.undoRedo()[\"do\"](\"updateBackgroundImage\", param);\n    } else {\n      elementUtilities.updateBackgroundImage(nodes, bgObj);\n    }\n\n    cy.style().update();\n  };\n\n  mainUtilities.changeBackgroundImage = function (nodes, oldImg, newImg, updateInfo, promptInvalidImage, validateURL) {\n    if (nodes.length === 0 || !oldImg || !newImg) {\n      return;\n    }\n\n    if (options.undoable) {\n      var param = {\n        oldImg: oldImg,\n        newImg: newImg,\n        nodes: nodes,\n        firstTime: true,\n        updateInfo: updateInfo,\n        promptInvalidImage: promptInvalidImage,\n        validateURL: validateURL\n      };\n      cy.undoRedo()[\"do\"](\"changeBackgroundImage\", param);\n    } else {\n      elementUtilities.changeBackgroundImage(nodes, oldImg, newImg, true, updateInfo, promptInvalidImage, validateURL);\n    }\n\n    cy.style().update();\n  };\n\n  return mainUtilities;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdXRpbGl0aWVzL21haW4tdXRpbGl0aWVzLWZhY3RvcnkuanMuanMiLCJtYXBwaW5ncyI6Ijs7QUFBQSxJQUFJQSxJQUFJLEdBQUdDLHdGQUFBLEVBQVg7QUFFQTtBQUNBO0FBQ0E7OztBQUNBRSxNQUFNLENBQUNDLE9BQVAsR0FBaUIsWUFBWTtFQUUzQixJQUFJQyxnQkFBSixFQUFzQkMsT0FBdEIsRUFBK0JDLEVBQS9CLEVBQW1DQyxlQUFuQzs7RUFFQSxTQUFTQyxhQUFULENBQXdCQyxLQUF4QixFQUErQjtJQUM3QkwsZ0JBQWdCLEdBQUdLLEtBQUssQ0FBQ0wsZ0JBQXpCO0lBQ0FDLE9BQU8sR0FBR0ksS0FBSyxDQUFDQyxlQUFOLENBQXNCQyxVQUF0QixFQUFWO0lBQ0FMLEVBQUUsR0FBR0csS0FBSyxDQUFDRyx3QkFBTixDQUErQkMsS0FBL0IsRUFBTDtJQUNBTixlQUFlLEdBQUdFLEtBQUssQ0FBQ0csd0JBQU4sQ0FBK0JFLFdBQS9CLEVBQWxCO0VBQ0Q7O0VBQUE7RUFFRDtBQUNGO0FBQ0E7O0VBQ0VOLGFBQWEsQ0FBQ08sT0FBZCxHQUF3QixVQUFTQyxDQUFULEVBQVlDLENBQVosRUFBZ0JDLFVBQWhCLEVBQTRCQyxFQUE1QixFQUFnQ0MsTUFBaEMsRUFBd0NDLFVBQXhDLEVBQW9EO0lBQzFFLElBQUtqQixnQkFBZ0IsQ0FBQ2tCLHFCQUFqQixFQUFMLEVBQWdEO01BQzlDO0lBQ0QsQ0FIeUUsQ0FLMUU7OztJQUNBLElBQUksUUFBT0osVUFBUCxLQUFxQixRQUF6QixFQUFrQztNQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0lBQ0s7O0lBRUQsSUFBSSxDQUFDYixPQUFPLENBQUNrQixRQUFiLEVBQXVCO01BQ3JCLE9BQU9uQixnQkFBZ0IsQ0FBQ1csT0FBakIsQ0FBeUJDLENBQXpCLEVBQTRCQyxDQUE1QixFQUErQkMsVUFBL0IsRUFBMkNDLEVBQTNDLEVBQStDQyxNQUEvQyxFQUF1REMsVUFBdkQsQ0FBUDtJQUNELENBRkQsTUFHSztNQUNI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Q3lKLEtBQUgsR0FBV0MsTUFBWDtFQUNELENBbEJEOztFQW9CQXhKLGFBQWEsQ0FBQ3NSLHFCQUFkLEdBQXNDLFVBQVNwTyxLQUFULEVBQWdCcU8sTUFBaEIsRUFBd0JDLE1BQXhCLEVBQWdDUCxVQUFoQyxFQUE0Q0Msa0JBQTVDLEVBQWdFQyxXQUFoRSxFQUE0RTtJQUNoSCxJQUFJak8sS0FBSyxDQUFDSSxNQUFOLEtBQWlCLENBQWpCLElBQXNCLENBQUNpTyxNQUF2QixJQUFpQyxDQUFDQyxNQUF0QyxFQUE4QztNQUM1QztJQUNEOztJQUVELElBQUkzUixPQUFPLENBQUNrQixRQUFaLEVBQXNCO01BQ3BCLElBQUlkLEtBQUssR0FBRztRQUNWc1IsTUFBTSxFQUFFQSxNQURFO1FBRVZDLE1BQU0sRUFBRUEsTUFGRTtRQUdWdE8sS0FBSyxFQUFFQSxLQUhHO1FBSVY0QyxTQUFTLEVBQUUsSUFKRDtRQUtWbUwsVUFBVSxFQUFFQSxVQUxGO1FBTVZDLGtCQUFrQixFQUFFQSxrQkFOVjtRQU9WQyxXQUFXLEVBQUVBO01BUEgsQ0FBWjtNQVVBclIsRUFBRSxDQUFDb0IsUUFBSCxTQUFpQix1QkFBakIsRUFBMENqQixLQUExQztJQUNELENBWkQsTUFhSztNQUNITCxnQkFBZ0IsQ0FBQzBSLHFCQUFqQixDQUF1Q3BPLEtBQXZDLEVBQThDcU8sTUFBOUMsRUFBc0RDLE1BQXRELEVBQThELElBQTlELEVBQW9FUCxVQUFwRSxFQUFnRkMsa0JBQWhGLEVBQW9HQyxXQUFwRztJQUNEOztJQUVEclIsRUFBRSxDQUFDeUosS0FBSCxHQUFXQyxNQUFYO0VBQ0QsQ0F2QkQ7O0VBeUJBLE9BQU94SixhQUFQO0FBQ0QsQ0E1L0NEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2hpc2UvLi9zcmMvdXRpbGl0aWVzL21haW4tdXRpbGl0aWVzLWZhY3RvcnkuanM/MDhmOCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgbGlicyA9IHJlcXVpcmUoJy4vbGliLXV0aWxpdGllcycpLmdldExpYnMoKTtcblxuLypcbiAqIFRoZSBtYWluIHV0aWxpdGllcyB0byBiZSBleHBvc2VkIGRpcmVjdGx5LlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcblxuICB2YXIgZWxlbWVudFV0aWxpdGllcywgb3B0aW9ucywgY3ksIHNiZ252aXpJbnN0YW5jZTtcblxuICBmdW5jdGlvbiBtYWluVXRpbGl0aWVzIChwYXJhbSkge1xuICAgIGVsZW1lbnRVdGlsaXRpZXMgPSBwYXJhbS5lbGVtZW50VXRpbGl0aWVzO1xuICAgIG9wdGlvbnMgPSBwYXJhbS5vcHRpb25VdGlsaXRpZXMuZ2V0T3B0aW9ucygpO1xuICAgIGN5ID0gcGFyYW0uc2JnbnZpekluc3RhbmNlVXRpbGl0aWVzLmdldEN5KCk7XG4gICAgc2JnbnZpekluc3RhbmNlID0gcGFyYW0uc2JnbnZpekluc3RhbmNlVXRpbGl0aWVzLmdldEluc3RhbmNlKCk7XG4gIH07XG5cbiAgLypcbiAgICogQWRkcyBhIG5ldyBub2RlIHdpdGggdGhlIGdpdmVuIGNsYXNzIGFuZCBhdCB0aGUgZ2l2ZW4gY29vcmRpbmF0ZXMuIENvbnNpZGVycyB1bmRvYWJsZSBvcHRpb24uXG4gICAqL1xuICBtYWluVXRpbGl0aWVzLmFkZE5vZGUgPSBmdW5jdGlvbih4LCB5ICwgbm9kZVBhcmFtcywgaWQsIHBhcmVudCwgdmlzaWJpbGl0eSkge1xuICAgIGlmICggZWxlbWVudFV0aWxpdGllcy5pc0dyYXBoVG9wb2xvZ3lMb2NrZWQoKSApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgbWFwIHR5cGVcbiAgICBpZiAodHlwZW9mIG5vZGVQYXJhbXMgPT0gJ29iamVjdCcpe1xuLyogXG4gICAgICBpZiAoIWVsZW1lbnRVdGlsaXRpZXMuZ2V0TWFwVHlwZSgpKVxuICAgICAgICBlbGVtZW50VXRpbGl0aWVzLnNldE1hcFR5cGUobm9kZVBhcmFtcy5sYW5ndWFnZSk7XG4gICAgICBlbHNlIGlmIChlbGVtZW50VXRpbGl0aWVzLmdldE1hcFR5cGUoKSAhPSBub2RlUGFyYW1zLmxhbmd1YWdlKVxuICAgICAgICBlbGVtZW50VXRpbGl0aWVzLnNldE1hcFR5cGUoXCJVbmtub3duXCIpOyAqL1xuICAgIH1cblxuICAgIGlmICghb3B0aW9ucy51bmRvYWJsZSkge1xuICAgICAgcmV0dXJuIGVsZW1lbnRVdGlsaXRpZXMuYWRkTm9kZSh4LCB5LCBub2RlUGFyYW1zLCBpZCwgcGFyZW50LCB2aXNpYmlsaXR5KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2YXIgcGFyYW0gPSB7XG4gICAgICAgIG5ld05vZGUgOiB7XG4gICAgICAgICAgeDogeCxcbiAgICAgICAgICB5OiB5LFxuICAgICAgICAgIGNsYXNzOiBub2RlUGFyYW1zLFxuICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICAgICAgICB2aXNpYmlsaXR5OiB2aXNpYmlsaXR5XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHZhciByZXN1bHQgPSBjeS51bmRvUmVkbygpLmRvKFwiYWRkTm9kZVwiLCBwYXJhbSk7XG4gICAgICByZXR1cm4gcmVzdWx0LmVsZXM7XG4gICAgfVxuICB9O1xuXG4gIC8qXG4gICAqIEFkZHMgYSBuZXcgZWRnZSB3aXRoIHRoZSBnaXZlbiBjbGFzcyBhbmQgaGF2aW5nIHRoZSBnaXZlbiBzb3VyY2UgYW5kIHRhcmdldCBpZHMuIENvbnNpZGVycyB1bmRvYWJsZSBvcHRpb24uXG4gICAqL1xuICBtYWluVXRpbGl0aWVzLmFkZEVkZ2UgPSBmdW5jdGlvbihzb3VyY2UsIHRhcmdldCwgZWRnZVBhcmFtcywgaW52YWxpZEVkZ2VDYWxsYmFjaywgaWQsIHZpc2liaWxpdHkpIHtcbiAgICBpZiAoIGVsZW1lbnRVdGlsaXRpZXMuaXNHcmFwaFRvcG9sb2d5TG9ja2VkKCkgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIG1hcCB0eXBlXG4gICAgaWYgKHR5cGVvZiBlZGdlUGFyYW1zID09ICdvYmplY3QnKXtcblxuICAgICAvKiAgaWYgKCFlbGVtZW50VXRpbGl0aWVzLmdldE1hcFR5cGUoKSlcbiAgICAgICAgZWxlbWVudFV0aWxpdGllcy5zZXRNYXBUeXBlKGVkZ2VQYXJhbXMubGFuZ3VhZ2UpO1xuICAgICAgZWxzZSBpZiAoZWxlbWVudFV0aWxpdGllcy5nZXRNYXBUeXBlKCkgIT0gZWRnZVBhcmFtcy5sYW5ndWFnZSlcbiAgICAgICAgZWxlbWVudFV0aWxpdGllcy5zZXRNYXBUeXBlKFwiSHlicmlkQW55XCIpOyAqL1xuICAgIH1cbiAgICAvLyBHZXQgdGhlIHZhbGlkYXRpb24gcmVzdWx0XG4gICAgdmFyIGVkZ2VjbGFzcyA9IGVkZ2VQYXJhbXMuY2xhc3MgPyBlZGdlUGFyYW1zLmNsYXNzIDogZWRnZVBhcmFtcztcbiAgICB2YXIgdmFsaWRhdGlvbiA9IGVsZW1lbnRVdGlsaXRpZXMudmFsaWRhdGVBcnJvd0VuZHMoZWRnZWNsYXNzLCBjeS5nZXRFbGVtZW50QnlJZChzb3VyY2UpLCBjeS5nZXRFbGVtZW50QnlJZCh0YXJnZXQpKTtcblxuICAgIC8vIElmIHZhbGlkYXRpb24gcmVzdWx0IGlzICdpbnZhbGlkJyBjYW5jZWwgdGhlIG9wZXJhdGlvblxuICAgIGlmICh2YWxpZGF0aW9uID09PSAnaW52YWxpZCcpIHtcbiAgICAgIGlmKHR5cGVvZiBpbnZhbGlkRWRnZUNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIpe1xuICAgICAgICBpbnZhbGlkRWRnZUNhbGxiYWNrKCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSWYgdmFsaWRhdGlvbiByZXN1bHQgaXMgJ3JldmVyc2UnIHJldmVyc2UgdGhlIHNvdXJjZS10YXJnZXQgcGFpciBiZWZvcmUgY3JlYXRpbmcgdGhlIGVkZ2VcbiAgICBpZiAodmFsaWRhdGlvbiA9PT0gJ3JldmVyc2UnKSB7XG4gICAgICB2YXIgdGVtcCA9IHNvdXJjZTtcbiAgICAgIHNvdXJjZSA9IHRhcmdldDtcbiAgICAgIHRhcmdldCA9IHRlbXA7XG4gICAgfVxuXG4gICAgaWYgKCFvcHRpb25zLnVuZG9hYmxlKSB7XG4gICAgICByZXR1cm4gZWxlbWVudFV0aWxpdGllcy5hZGRFZGdlKHNvdXJjZSwgdGFyZ2V0LCBlZGdlUGFyYW1zLCBpZCwgdmlzaWJpbGl0eSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIHBhcmFtID0ge1xuICAgICAgICBuZXdFZGdlIDoge1xuICAgICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgICAgIGNsYXNzOiBlZGdlUGFyYW1zLFxuICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICB2aXNpYmlsaXR5OiB2aXNpYmlsaXR5XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHZhciByZXN1bHQgPSBjeS51bmRvUmVkbygpLmRvKFwiYWRkRWRnZVwiLCBwYXJhbSk7XG4gICAgICByZXR1cm4gcmVzdWx0LmVsZXM7XG4gICAgfVxuICB9O1xuXG4gIC8qXG4gICAqIEFkZHMgYSBwcm9jZXNzIHdpdGggY29udmVuaWVudCBlZGdlcy4gRm9yIG1vcmUgaW5mb3JtYXRpb24gcGxlYXNlIHNlZSAnaHR0cHM6Ly9naXRodWIuY29tL2lWaXMtYXQtQmlsa2VudC9uZXd0L2lzc3Vlcy85Jy5cbiAgICogQ29uc2lkZXJzIHVuZG9hYmxlIG9wdGlvbi5cbiAgICovXG4gIG1haW5VdGlsaXRpZXMuYWRkUHJvY2Vzc1dpdGhDb252ZW5pZW50RWRnZXMgPSBmdW5jdGlvbihfc291cmNlLCBfdGFyZ2V0LCBwcm9jZXNzVHlwZSkge1xuICAgIGlmICggZWxlbWVudFV0aWxpdGllcy5pc0dyYXBoVG9wb2xvZ3lMb2NrZWQoKSApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJZiBzb3VyY2UgYW5kIHRhcmdldCBJRHMgYXJlIGdpdmVuIGdldCB0aGUgZWxlbWVudHMgYnkgSURzXG4gICAgdmFyIHNvdXJjZSA9IHR5cGVvZiBfc291cmNlID09PSAnc3RyaW5nJyA/IGN5LmdldEVsZW1lbnRCeUlkKF9zb3VyY2UpIDogX3NvdXJjZTtcbiAgICB2YXIgdGFyZ2V0ID0gdHlwZW9mIF90YXJnZXQgPT09ICdzdHJpbmcnID8gY3kuZ2V0RWxlbWVudEJ5SWQoX3RhcmdldCkgOiBfdGFyZ2V0O1xuXG4gICAgLy8gSWYgc291cmNlIG9yIHRhcmdldCBkb2VzIG5vdCBoYXZlIGFuIEVQTiBjbGFzcyB0aGUgb3BlcmF0aW9uIGlzIG5vdCB2YWxpZFxuICAgIGlmICghZWxlbWVudFV0aWxpdGllcy5pc0VQTkNsYXNzKHNvdXJjZSkgfHwgIWVsZW1lbnRVdGlsaXRpZXMuaXNFUE5DbGFzcyh0YXJnZXQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFvcHRpb25zLnVuZG9hYmxlKSB7XG4gICAgICByZXR1cm4gZWxlbWVudFV0aWxpdGllcy5hZGRQcm9jZXNzV2l0aENvbnZlbmllbnRFZGdlcyhfc291cmNlLCBfdGFyZ2V0LCBwcm9jZXNzVHlwZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIHBhcmFtID0ge1xuICAgICAgICBzb3VyY2U6IF9zb3VyY2UsXG4gICAgICAgIHRhcmdldDogX3RhcmdldCxcbiAgICAgICAgcHJvY2Vzc1R5cGU6IHByb2Nlc3NUeXBlXG4gICAgICB9O1xuXG4gICAgICBjeS51bmRvUmVkbygpLmRvKFwiYWRkUHJvY2Vzc1dpdGhDb252ZW5pZW50RWRnZXNcIiwgcGFyYW0pO1xuICAgIH1cbiAgfTtcblxuICAvLyBjb252ZXJ0IGNvbGxhcHNlZCBjb21wb3VuZCBub2RlcyB0byBzaW1wbGUgbm9kZXNcbiAgLy8gYW5kIHVwZGF0ZSBwb3J0IHZhbHVlcyBvZiBwYXN0ZWQgbm9kZXMgYW5kIGVkZ2VzXG4gIHZhciBjbG9uZUNvbGxhcHNlZE5vZGVzQW5kUG9ydHMgPSBmdW5jdGlvbiAoZWxlc0JlZm9yZSl7XG4gICAgaWYgKCBlbGVtZW50VXRpbGl0aWVzLmlzR3JhcGhUb3BvbG9neUxvY2tlZCgpICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGN5LmVsZW1lbnRzKCkudW5zZWxlY3QoKTtcbiAgICB2YXIgZWxlc0FmdGVyID0gY3kuZWxlbWVudHMoKTtcbiAgICB2YXIgZWxlc0RpZmYgPSBlbGVzQWZ0ZXIuZGlmZihlbGVzQmVmb3JlKS5sZWZ0O1xuXG4gICAgLy8gc2hhbGxvdyBjb3B5IGNvbGxhcHNlZCBub2RlcyAtIGNvbGxhcHNlZCBjb21wb3VuZHMgYmVjb21lIHNpbXBsZSBub2Rlc1xuICAgIC8vIGRhdGEgcmVsYXRlZCB0byBjb2xsYXBzZWQgbm9kZXMgYXJlIHJlbW92ZWQgZnJvbSBnZW5lcmF0ZWQgY2xvbmVzXG4gICAgLy8gcmVsYXRlZCBpc3N1ZTogaHR0cHM6Ly9naXRodWIuY29tL2lWaXMtYXQtQmlsa2VudC9uZXd0L2lzc3Vlcy8xNDVcbiAgICB2YXIgY29sbGFwc2VkTm9kZXMgPSBlbGVzRGlmZi5maWx0ZXIoJ25vZGUuY3ktZXhwYW5kLWNvbGxhcHNlLWNvbGxhcHNlZC1ub2RlJyk7XG5cbiAgICBjb2xsYXBzZWROb2Rlcy5jb25uZWN0ZWRFZGdlcygpLnJlbW92ZSgpO1xuICAgIGNvbGxhcHNlZE5vZGVzLnJlbW92ZUNsYXNzKCdjeS1leHBhbmQtY29sbGFwc2UtY29sbGFwc2VkLW5vZGUnKTtcbiAgICBjb2xsYXBzZWROb2Rlcy5yZW1vdmVEYXRhKCdjb2xsYXBzZWRDaGlsZHJlbicpO1xuICAgIGNvbGxhcHNlZE5vZGVzLnJlbW92ZURhdGEoJ3Bvc2l0aW9uLWJlZm9yZS1jb2xsYXBzZSBzaXplLWJlZm9yZS1jb2xsYXBzZScpO1xuICAgIGNvbGxhcHNlZE5vZGVzLnJlbW92ZURhdGEoJ2V4cGFuZGNvbGxhcHNlUmVuZGVyZWRDdWVTaXplIGV4cGFuZGNvbGxhcHNlUmVuZGVyZWRTdGFydFggZXhwYW5kY29sbGFwc2VSZW5kZXJlZFN0YXJ0WScpO1xuXG4gICAgLy8gY2xvbmluZyBwb3J0c1xuICAgIGVsZXNEaWZmLm5vZGVzKCkuZm9yRWFjaChmdW5jdGlvbihfbm9kZSl7XG4gICAgICBpZihfbm9kZS5kYXRhKFwicG9ydHNcIikubGVuZ3RoID09IDIpe1xuICAgICAgICAgIHZhciBvbGRQb3J0TmFtZTAgPSBfbm9kZS5kYXRhKFwicG9ydHNcIilbMF0uaWQ7XG4gICAgICAgICAgdmFyIG9sZFBvcnROYW1lMSA9IF9ub2RlLmRhdGEoXCJwb3J0c1wiKVsxXS5pZDtcbiAgICAgICAgICBfbm9kZS5kYXRhKFwicG9ydHNcIilbMF0uaWQgPSBfbm9kZS5pZCgpICsgXCIuMVwiO1xuICAgICAgICAgIF9ub2RlLmRhdGEoXCJwb3J0c1wiKVsxXS5pZCA9IF9ub2RlLmlkKCkgKyBcIi4yXCI7XG5cbiAgICAgICAgICBfbm9kZS5vdXRnb2VycygpLmVkZ2VzKCkuZm9yRWFjaChmdW5jdGlvbihfZWRnZSl7XG4gICAgICAgICAgICBpZihfZWRnZS5kYXRhKFwicG9ydHNvdXJjZVwiKSA9PSBvbGRQb3J0TmFtZTApe1xuICAgICAgICAgICAgICBfZWRnZS5kYXRhKFwicG9ydHNvdXJjZVwiLCBfbm9kZS5kYXRhKFwicG9ydHNcIilbMF0uaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZihfZWRnZS5kYXRhKFwicG9ydHNvdXJjZVwiKSA9PSBvbGRQb3J0TmFtZTEpe1xuICAgICAgICAgICAgICBfZWRnZS5kYXRhKFwicG9ydHNvdXJjZVwiLCBfbm9kZS5kYXRhKFwicG9ydHNcIilbMV0uaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgICAgX2VkZ2UuZGF0YShcInBvcnRzb3VyY2VcIiwgX25vZGUuaWQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgX25vZGUuaW5jb21lcnMoKS5lZGdlcygpLmZvckVhY2goZnVuY3Rpb24oX2VkZ2Upe1xuICAgICAgICAgICAgaWYoX2VkZ2UuZGF0YShcInBvcnR0YXJnZXRcIikgPT0gb2xkUG9ydE5hbWUwKXtcbiAgICAgICAgICAgICAgX2VkZ2UuZGF0YShcInBvcnR0YXJnZXRcIiwgX25vZGUuZGF0YShcInBvcnRzXCIpWzBdLmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYoX2VkZ2UuZGF0YShcInBvcnR0YXJnZXRcIikgPT0gb2xkUG9ydE5hbWUxKXtcbiAgICAgICAgICAgICAgX2VkZ2UuZGF0YShcInBvcnR0YXJnZXRcIiwgX25vZGUuZGF0YShcInBvcnRzXCIpWzFdLmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgIF9lZGdlLmRhdGEoXCJwb3J0dGFyZ2V0XCIsIF9ub2RlLmlkKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZWxzZXtcbiAgICAgICAgX25vZGUub3V0Z29lcnMoKS5lZGdlcygpLmZvckVhY2goZnVuY3Rpb24oX2VkZ2Upe1xuICAgICAgICAgIF9lZGdlLmRhdGEoXCJwb3J0c291cmNlXCIsIF9ub2RlLmlkKCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgX25vZGUuaW5jb21lcnMoKS5lZGdlcygpLmZvckVhY2goZnVuY3Rpb24oX2VkZ2Upe1xuICAgICAgICAgIF9lZGdlLmRhdGEoXCJwb3J0dGFyZ2V0XCIsIF9ub2RlLmlkKCkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBlbGVzRGlmZi5zZWxlY3QoKTtcbiAgfVxuXG4gIC8qXG4gICAqIENsb25lIGdpdmVuIGVsZW1lbnRzLiBDb25zaWRlcnMgdW5kb2FibGUgb3B0aW9uLiBSZXF1aXJlcyBjeXRvc2NhcGUtY2xpcGJvYXJkIGV4dGVuc2lvbi5cbiAgICovXG4gIG1haW5VdGlsaXRpZXMuY2xvbmVFbGVtZW50cyA9IGZ1bmN0aW9uIChlbGVzLCBwYXN0ZUF0TW91c2VMb2MpIHtcbiAgICBpZiAoIGVsZW1lbnRVdGlsaXRpZXMuaXNHcmFwaFRvcG9sb2d5TG9ja2VkKCkgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGVsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5jb3B5RWxlbWVudHMoZWxlcyk7XG5cbiAgICB0aGlzLnBhc3RlRWxlbWVudHMocGFzdGVBdE1vdXNlTG9jKTtcbiAgfTtcblxuICAvKlxuICAgKiBDb3B5IGdpdmVuIGVsZW1lbnRzIHRvIGNsaXBib2FyZC4gUmVxdWlyZXMgY3l0b3NjYXBlLWNsaXBib2FyZCBleHRlbnNpb24uXG4gICAqL1xuICBtYWluVXRpbGl0aWVzLmNvcHlFbGVtZW50cyA9IGZ1bmN0aW9uIChlbGVzKSB7XG4gICAgY3kuY2xpcGJvYXJkKCkuY29weShlbGVzKTtcbiAgfTtcblxuICAvKlxuICAgKiBQYXN0ZSB0aGUgZWxlbWVudHMgY29waWVkIHRvIGNsaXBib2FyZC4gQ29uc2lkZXJzIHVuZG9hYmxlIG9wdGlvbi4gUmVxdWlyZXMgY3l0b3NjYXBlLWNsaXBib2FyZCBleHRlbnNpb24uXG4gICAqL1xuICBtYWluVXRpbGl0aWVzLnBhc3RlRWxlbWVudHMgPSBmdW5jdGlvbihwYXN0ZUF0TW91c2VMb2MpIHtcbiAgICBpZiAoIGVsZW1lbnRVdGlsaXRpZXMuaXNHcmFwaFRvcG9sb2d5TG9ja2VkKCkgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGVsZXNCZWZvcmUgPSBjeS5lbGVtZW50cygpO1xuXG4gICAgaWYgKG9wdGlvbnMudW5kb2FibGUpIHtcbiAgICAgIGN5LnVuZG9SZWRvKCkuZG8oXCJwYXN0ZVwiLHtwYXN0ZUF0TW91c2VMb2M6IHBhc3RlQXRNb3VzZUxvY30pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGN5LmNsaXBib2FyZCgpLnBhc3RlKCk7XG4gICAgfVxuICAgIGNsb25lQ29sbGFwc2VkTm9kZXNBbmRQb3J0cyhlbGVzQmVmb3JlKTtcbiAgICBjeS5ub2RlcyhcIjpzZWxlY3RlZFwiKS5lbWl0KCdkYXRhJyk7XG4gIH07XG5cbiAgLypcbiAgICogQWxpZ25zIGdpdmVuIG5vZGVzIGluIGdpdmVuIGhvcml6b250YWwgYW5kIHZlcnRpY2FsIG9yZGVyLlxuICAgKiBIb3Jpem9udGFsIGFuZCB2ZXJ0aWNhbCBwYXJhbWV0ZXJzIG1heSBiZSAnbm9uZScgb3IgdW5kZWZpbmVkLlxuICAgKiBhbGlnblRvIHBhcmFtZXRlciBpbmRpY2F0ZXMgdGhlIGxlYWRpbmcgbm9kZS5cbiAgICogUmVxdXJpcmVzIGN5dG9zY2FwZS1ncmlkLWd1aWRlIGV4dGVuc2lvbiBhbmQgY29uc2lkZXJzIHVuZG9hYmxlIG9wdGlvbi5cbiAgICovXG4gIG1haW5VdGlsaXRpZXMuYWxpZ24gPSBmdW5jdGlvbiAobm9kZXMsIGhvcml6b250YWwsIHZlcnRpY2FsLCBhbGlnblRvKSB7XG4gICAgaWYgKG5vZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnVuZG9hYmxlKSB7XG4gICAgICBjeS51bmRvUmVkbygpLmRvKFwiYWxpZ25cIiwge1xuICAgICAgICBub2Rlczogbm9kZXMsXG4gICAgICAgIGhvcml6b250YWw6IGhvcml6b250YWwsXG4gICAgICAgIHZlcnRpY2FsOiB2ZXJ0aWNhbCxcbiAgICAgICAgYWxpZ25UbzogYWxpZ25Ub1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGVzLmFsaWduKGhvcml6b250YWwsIHZlcnRpY2FsLCBhbGlnblRvKTtcbiAgICB9XG5cbiAgICBpZihjeS5lZGdlcyhcIjpzZWxlY3RlZFwiKS5sZW5ndGggPT0gMSApIHtcbiAgICAgIGN5LmVkZ2VzKCkudW5zZWxlY3QoKTsgICAgICBcbiAgICB9XG4gICAgXG4gIH07XG5cbiAgLypcbiAgICogQ3JlYXRlIGNvbXBvdW5kIGZvciBnaXZlbiBub2Rlcy4gY29tcG91bmRUeXBlIG1heSBiZSAnY29tcGxleCcgb3IgJ2NvbXBhcnRtZW50Jy5cbiAgICogVGhpcyBtZXRob2QgY29uc2lkZXJzIHVuZG9hYmxlIG9wdGlvbi5cbiAgICovXG4gIG1haW5VdGlsaXRpZXMuY3JlYXRlQ29tcG91bmRGb3JHaXZlbk5vZGVzID0gZnVuY3Rpb24gKF9ub2RlcywgY29tcG91bmRUeXBlKSB7XG4gICAgaWYgKCBlbGVtZW50VXRpbGl0aWVzLmlzR3JhcGhUb3BvbG9neUxvY2tlZCgpICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBub2RlcyA9IF9ub2RlcztcbiAgICAvKlxuICAgICAqIEVsZW1pbmF0ZSB0aGUgbm9kZXMgd2hpY2ggY2Fubm90IGhhdmUgYSBwYXJlbnQgd2l0aCBnaXZlbiBjb21wb3VuZCB0eXBlXG4gICAgICovXG4gICAgbm9kZXMgPSBfbm9kZXMuZmlsdGVyKGZ1bmN0aW9uIChlbGVtZW50LCBpKSB7XG4gICAgICBpZih0eXBlb2YgZWxlbWVudCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBlbGVtZW50ID0gaTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNiZ25jbGFzcyA9IGVsZW1lbnQuZGF0YShcImNsYXNzXCIpO1xuICAgICAgcmV0dXJuIGVsZW1lbnRVdGlsaXRpZXMuaXNWYWxpZFBhcmVudChzYmduY2xhc3MsIGNvbXBvdW5kVHlwZSwgZWxlbWVudCk7XG4gICAgfSk7XG5cbiAgICBub2RlcyA9IGVsZW1lbnRVdGlsaXRpZXMuZ2V0VG9wTW9zdE5vZGVzKG5vZGVzKTtcblxuICAgIC8vIEFsbCBlbGVtZW50cyBzaG91bGQgaGF2ZSB0aGUgc2FtZSBwYXJlbnQgYW5kIHRoZSBjb21tb24gcGFyZW50IHNob3VsZCBub3QgYmUgYSAnY29tcGxleCdcbiAgICAvLyBpZiBjb21wb3VuZFR5cGUgaXMgJ2NvbXBhcnRlbnQnXG4gICAgLy8gYmVjYXVzZSB0aGUgb2xkIGNvbW1vbiBwYXJlbnQgd2lsbCBiZSB0aGUgcGFyZW50IG9mIHRoZSBuZXcgY29tcGFydG1lbnQgYWZ0ZXIgdGhpcyBvcGVyYXRpb24gYW5kXG4gICAgLy8gJ2NvbXBsZXhlcycgY2Fubm90IGluY2x1ZGUgJ2NvbXBhcnRtZW50cydcbiAgICBpZiAobm9kZXMubGVuZ3RoID09IDAgfHwgIWVsZW1lbnRVdGlsaXRpZXMuYWxsSGF2ZVRoZVNhbWVQYXJlbnQobm9kZXMpXG4gICAgICAgICAgICB8fCAoIChjb21wb3VuZFR5cGUgPT09ICdjb21wYXJ0bWVudCcgfHwgY29tcG91bmRUeXBlID09ICdzdWJtYXAnKSAmJiBub2Rlcy5wYXJlbnQoKS5kYXRhKCdjbGFzcycpXG4gICAgICAgICAgICAmJiBub2Rlcy5wYXJlbnQoKS5kYXRhKCdjbGFzcycpLnN0YXJ0c1dpdGgoJ2NvbXBsZXgnKSApKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGN5LnVuZG9SZWRvKCkpIHtcbiAgICAgIHZhciBwYXJhbSA9IHtcbiAgICAgICAgY29tcG91bmRUeXBlOiBjb21wb3VuZFR5cGUsXG4gICAgICAgIG5vZGVzVG9NYWtlQ29tcG91bmQ6IG5vZGVzXG4gICAgICB9O1xuXG4gICAgICBjeS51bmRvUmVkbygpLmRvKFwiY3JlYXRlQ29tcG91bmRGb3JHaXZlbk5vZGVzXCIsIHBhcmFtKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBlbGVtZW50VXRpbGl0aWVzLmNyZWF0ZUNvbXBvdW5kRm9yR2l2ZW5Ob2Rlcyhub2RlcywgY29tcG91bmRUeXBlKTtcbiAgICB9XG4gIH07XG5cbiAgLypcbiAgICogTW92ZSB0aGUgbm9kZXMgdG8gYSBuZXcgcGFyZW50IGFuZCBjaGFuZ2UgdGhlaXIgcG9zaXRpb24gaWYgcG9zc0RpZmYgcGFyYW1zIGFyZSBzZXQuXG4gICAqIENvbnNpZGVycyB1bmRvYWJsZSBvcHRpb24gYW5kIGNoZWNrcyBpZiB0aGUgb3BlcmF0aW9uIGlzIHZhbGlkLlxuICAgKi9cbiAgbWFpblV0aWxpdGllcy5jaGFuZ2VQYXJlbnQgPSBmdW5jdGlvbihub2RlcywgX25ld1BhcmVudCwgcG9zRGlmZlgsIHBvc0RpZmZZKSB7XG4gICAgaWYgKCBlbGVtZW50VXRpbGl0aWVzLmlzR3JhcGhUb3BvbG9neUxvY2tlZCgpICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuZXdQYXJlbnQgPSB0eXBlb2YgX25ld1BhcmVudCA9PT0gJ3N0cmluZycgPyBjeS5nZXRFbGVtZW50QnlJZChfbmV3UGFyZW50KSA6IF9uZXdQYXJlbnQ7XG4gICAgLy8gTmV3IHBhcmVudCBpcyBzdXBwb3NlZCB0byBiZSBvbmUgb2YgdGhlIHJvb3QsIGEgY29tcGxleCBvciBhIGNvbXBhcnRtZW50XG4gICAgaWYgKG5ld1BhcmVudCAmJiAhbmV3UGFyZW50LmRhdGEoXCJjbGFzc1wiKS5zdGFydHNXaXRoKFwiY29tcGxleFwiKSAmJiBuZXdQYXJlbnQuZGF0YShcImNsYXNzXCIpICE9IFwiY29tcGFydG1lbnRcIlxuICAgICAgICAgICAgJiYgbmV3UGFyZW50LmRhdGEoXCJjbGFzc1wiKSAhPSBcInN1Ym1hcFwiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8qXG4gICAgICogRWxlbWluYXRlIHRoZSBub2RlcyB3aGljaCBjYW5ub3QgaGF2ZSB0aGUgbmV3UGFyZW50IGFzIHRoZWlyIHBhcmVudFxuICAgICAqL1xuICAgIG5vZGVzID0gbm9kZXMuZmlsdGVyKGZ1bmN0aW9uIChlbGVtZW50LCBpKSB7XG4gICAgICBpZih0eXBlb2YgZWxlbWVudCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBlbGVtZW50ID0gaTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNiZ25jbGFzcyA9IGVsZW1lbnQuZGF0YShcImNsYXNzXCIpO1xuICAgICAgcmV0dXJuIGVsZW1lbnRVdGlsaXRpZXMuaXNWYWxpZFBhcmVudChzYmduY2xhc3MsIG5ld1BhcmVudCwgZWxlbWVudCk7XG4gICAgfSk7XG5cbiAgICAvLyBEaXNjYXJkIHRoZSBub2RlcyB3aG9zZSBwYXJlbnQgaXMgYWxyZWFkeSBuZXdQYXJlbnQuXG4gICAgLy8gRGlzY2FyZCB0aGUgbmV3UGFyZW50IGl0c2VsZiBpZiBpdCBpcyBhbW9uZyB0aGUgbm9kZXNcbiAgICBub2RlcyA9IG5vZGVzLmZpbHRlcihmdW5jdGlvbiAoZWxlLCBpKSB7XG4gICAgICBpZih0eXBlb2YgZWxlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGVsZSA9IGk7XG4gICAgICB9XG5cbiAgICAgIC8vIERpc2NhcmQgdGhlIG5ld1BhcmVudCBpZiBpdCBpcyBhbW9uZyB0aGUgbm9kZXNcbiAgICAgIGlmIChuZXdQYXJlbnQgJiYgZWxlLmlkKCkgPT09IG5ld1BhcmVudC5pZCgpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIERpc2NhcmQgdGhlIG5vZGVzIHdob3NlIHBhcmVudCBpcyBhbHJlYWR5IG5ld1BhcmVudFxuICAgICAgaWYgKCFuZXdQYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIGVsZS5kYXRhKCdwYXJlbnQnKSAhPSBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVsZS5kYXRhKCdwYXJlbnQnKSAhPT0gbmV3UGFyZW50LmlkKCk7XG4gICAgfSk7XG5cbiAgICAvLyBJZiBzb21lIG5vZGVzIGFyZSBhbmNlc3RvciBvZiBuZXcgcGFyZW50IGVsZW1pbmF0ZSB0aGVtXG4gICAgaWYgKG5ld1BhcmVudCkge1xuICAgICAgbm9kZXMgPSBub2Rlcy5kaWZmZXJlbmNlKG5ld1BhcmVudC5hbmNlc3RvcnMoKSk7XG4gICAgfVxuXG4gICAgLy8gSWYgYWxsIG5vZGVzIGFyZSBlbGVtaW5hdGVkIHJldHVybiBkaXJlY3RseVxuICAgIGlmIChub2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBKdXN0IG1vdmUgdGhlIHRvcCBtb3N0IG5vZGVzXG4gICAgbm9kZXMgPSBlbGVtZW50VXRpbGl0aWVzLmdldFRvcE1vc3ROb2Rlcyhub2Rlcyk7XG5cbiAgICB2YXIgcGFyZW50SWQgPSBuZXdQYXJlbnQgPyBuZXdQYXJlbnQuaWQoKSA6IG51bGw7XG5cbiAgICBpZiAob3B0aW9ucy51bmRvYWJsZSkge1xuICAgICAgdmFyIHBhcmFtID0ge1xuICAgICAgICBmaXJzdFRpbWU6IHRydWUsXG4gICAgICAgIHBhcmVudERhdGE6IHBhcmVudElkLCAvLyBJdCBrZWVwcyB0aGUgbmV3UGFyZW50SWQgKEp1c3QgYW4gaWQgZm9yIGVhY2ggbm9kZXMgZm9yIHRoZSBmaXJzdCB0aW1lKVxuICAgICAgICBub2Rlczogbm9kZXMsXG4gICAgICAgIHBvc0RpZmZYOiBwb3NEaWZmWCxcbiAgICAgICAgcG9zRGlmZlk6IHBvc0RpZmZZLFxuICAgICAgICAvLyBUaGlzIGlzIG5lZWRlZCBiZWNhdXNlIHRoZSBjaGFuZ2VQYXJlbnQgZnVuY3Rpb24gY2FsbGVkIGlzIG5vdCBmcm9tIGVsZW1lbnRVdGlsaXRpZXNcbiAgICAgICAgLy8gYnV0IGZyb20gdGhlIHVuZG9SZWRvIGV4dGVuc2lvbiBkaXJlY3RseSwgc28gbWFpbnRhaW5pbmcgcG9pbnRlciBpcyBub3QgYXV0b21hdGljYWxseSBkb25lLlxuICAgICAgICBjYWxsYmFjazogZWxlbWVudFV0aWxpdGllcy5tYWludGFpblBvaW50ZXJcbiAgICAgIH07XG5cbiAgICAgIGN5LnVuZG9SZWRvKCkuZG8oXCJjaGFuZ2VQYXJlbnRcIiwgcGFyYW0pOyAvLyBUaGlzIGFjdGlvbiBpcyByZWdpc3RlcmVkIGJ5IHVuZG9SZWRvIGV4dGVuc2lvblxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGVsZW1lbnRVdGlsaXRpZXMuY2hhbmdlUGFyZW50KG5vZGVzLCBwYXJlbnRJZCwgcG9zRGlmZlgsIHBvc0RpZmZZKTtcbiAgICB9XG4gIH07XG5cbiAgLypcbiAgICogQ3JlYXRlcyBhbiBhY3RpdmF0aW9uIHJlYWN0aW9uIHdpdGggZ2l2ZW4gcGFyYW1ldGVycy4gUmVxdWlyZXMgY29zZS1iaWxrZW50IGxheW91dCB0byB0aWxlIHRoZSBmcmVlIG1hY3JvbW9sZWN1bGVzIGluY2x1ZGVkXG4gICAqIGluIHRoZSBjb21wbGV4LiBDb25zaWRlcnMgdW5kb2FibGUgb3B0aW9uLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBzZWUgdGhlIHNhbWUgZnVuY3Rpb24gaW4gZWxlbWVudFV0aWxpdGllc1xuICAgKi9cbiAgbWFpblV0aWxpdGllcy5jcmVhdGVUcmFuc2xhdGlvblJlYWN0aW9uID0gZnVuY3Rpb24gKG1SbmFOYW1lLCBwcm90ZWluTmFtZSwgcHJvY2Vzc1Bvc2l0aW9uLCBlZGdlTGVuZ3RoKSB7XG4gICAgaWYgKCBlbGVtZW50VXRpbGl0aWVzLmlzR3JhcGhUb3BvbG9neUxvY2tlZCgpICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghb3B0aW9ucy51bmRvYWJsZSkge1xuICAgICAgZWxlbWVudFV0aWxpdGllcy5jcmVhdGVUcmFuc2xhdGlvblJlYWN0aW9uKG1SbmFOYW1lLCBwcm90ZWluTmFtZSwgcHJvY2Vzc1Bvc2l0aW9uLCBlZGdlTGVuZ3RoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2YXIgcGFyYW0gPSB7XG4gICAgICAgIG1SbmFOYW1lOiBtUm5hTmFtZSxcbiAgICAgICAgcHJvdGVpbk5hbWU6IHByb3RlaW5OYW1lLFxuICAgICAgICBwcm9jZXNzUG9zaXRpb246IHByb2Nlc3NQb3NpdGlvbixcbiAgICAgICAgZWRnZUxlbmd0aDogZWRnZUxlbmd0aFxuICAgICAgfTtcblxuICAgICAgY3kudW5kb1JlZG8oKS5kbyhcImNyZWF0ZVRyYW5zbGF0aW9uUmVhY3Rpb25cIiwgcGFyYW0pO1xuICB9fTtcblxuICAvKlxuICAgKiBDcmVhdGVzIGFuIGFjdGl2YXRpb24gcmVhY3Rpb24gd2l0aCBnaXZlbiBwYXJhbWV0ZXJzLiBSZXF1aXJlcyBjb3NlLWJpbGtlbnQgbGF5b3V0IHRvIHRpbGUgdGhlIGZyZWUgbWFjcm9tb2xlY3VsZXMgaW5jbHVkZWRcbiAgICogaW4gdGhlIGNvbXBsZXguIENvbnNpZGVycyB1bmRvYWJsZSBvcHRpb24uIEZvciBtb3JlIGluZm9ybWF0aW9uIHNlZSB0aGUgc2FtZSBmdW5jdGlvbiBpbiBlbGVtZW50VXRpbGl0aWVzXG4gICAqL1xuICBtYWluVXRpbGl0aWVzLmNyZWF0ZVRyYW5zY3JpcHRpb25SZWFjdGlvbiA9IGZ1bmN0aW9uIChnZW5lTmFtZSwgbVJuYU5hbWUsIHByb2Nlc3NQb3NpdGlvbiwgZWRnZUxlbmd0aCkge1xuICAgIGlmICggZWxlbWVudFV0aWxpdGllcy5pc0dyYXBoVG9wb2xvZ3lMb2NrZWQoKSApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIW9wdGlvbnMudW5kb2FibGUpIHtcbiAgICAgIGVsZW1lbnRVdGlsaXRpZXMuY3JlYXRlVHJhbnNjcmlwdGlvblJlYWN0aW9uKGdlbmVOYW1lLCBtUm5hTmFtZSwgcHJvY2Vzc1Bvc2l0aW9uLCBlZGdlTGVuZ3RoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2YXIgcGFyYW0gPSB7XG4gICAgICAgIGdlbmVOYW1lOiBnZW5lTmFtZSxcbiAgICAgICAgbVJuYU5hbWU6IG1SbmFOYW1lLFxuICAgICAgICBwcm9jZXNzUG9zaXRpb246IHByb2Nlc3NQb3NpdGlvbixcbiAgICAgICAgZWRnZUxlbmd0aDogZWRnZUxlbmd0aFxuICAgICAgfTtcblxuICAgICAgY3kudW5kb1JlZG8oKS5kbyhcImNyZWF0ZVRyYW5zY3JpcHRpb25SZWFjdGlvblwiLCBwYXJhbSk7XG4gIH19O1xuXG4gIG1haW5VdGlsaXRpZXMuY3JlYXRlVHJhbnNsYXRpb24gPSBmdW5jdGlvbihyZWd1bGF0b3JMYWJlbCwgb3V0cHV0TGFiZWwsIG9yaWVudGF0aW9uKSB7XG4gICAgaWYgKCBlbGVtZW50VXRpbGl0aWVzLmlzR3JhcGhUb3BvbG9neUxvY2tlZCgpICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghb3B0aW9ucy51bmRvYWJsZSkge1xuICAgICAgZWxlbWVudFV0aWxpdGllcy5jcmVhdGVUcmFuc2xhdGlvbihyZWd1bGF0b3JMYWJlbCwgb3V0cHV0TGFiZWwsIG9yaWVudGF0aW9uKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCBwYXJhbSA9IHtcbiAgICAgICAgcmVndWxhdG9yTGFiZWw6IHJlZ3VsYXRvckxhYmVsLFxuICAgICAgICBvdXRwdXRMYWJlbDogb3V0cHV0TGFiZWwsXG4gICAgICAgIG9yaWVudGF0aW9uOiBvcmllbnRhdGlvblxuICAgICAgfTtcblxuICAgICAgY3kudW5kb1JlZG8oKS5kbyhcImNyZWF0ZVRyYW5zbGF0aW9uXCIsIHBhcmFtKTtcbiAgICB9ICBcbiAgfTtcblxuICBtYWluVXRpbGl0aWVzLmNyZWF0ZVRyYW5zY3JpcHRpb24gPSBmdW5jdGlvbihsYWJlbCwgb3JpZW50YXRpb24pIHtcbiAgICBpZiAoIGVsZW1lbnRVdGlsaXRpZXMuaXNHcmFwaFRvcG9sb2d5TG9ja2VkKCkgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFvcHRpb25zLnVuZG9hYmxlKSB7XG4gICAgICBlbGVtZW50VXRpbGl0aWVzLmNyZWF0ZVRyYW5zY3JpcHRpb24obGFiZWwsIG9yaWVudGF0aW9uKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCBwYXJhbSA9IHtcbiAgICAgICAgbGFiZWw6IGxhYmVsLFxuICAgICAgICBvcmllbnRhdGlvbjogb3JpZW50YXRpb25cbiAgICAgIH07XG5cbiAgICAgIGN5LnVuZG9SZWRvKCkuZG8oXCJjcmVhdGVUcmFuc2NyaXB0aW9uXCIsIHBhcmFtKTtcbiAgICB9ICBcbiAgfTtcblxuICBtYWluVXRpbGl0aWVzLmNyZWF0ZURlZ3JhZGF0aW9uID0gZnVuY3Rpb24obWFjcm9tb2xlY3VsZSwgb3JpZW50YXRpb24pIHtcbiAgICBpZiAoIGVsZW1lbnRVdGlsaXRpZXMuaXNHcmFwaFRvcG9sb2d5TG9ja2VkKCkgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFvcHRpb25zLnVuZG9hYmxlKSB7XG4gICAgICBlbGVtZW50VXRpbGl0aWVzLmNyZWF0ZURlZ3JhZGF0aW9uKG1hY3JvbW9sZWN1bGUsIG9yaWVudGF0aW9uKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCBwYXJhbSA9IHtcbiAgICAgICAgbWFjcm9tb2xlY3VsZTogbWFjcm9tb2xlY3VsZSxcbiAgICAgICAgb3JpZW50YXRpb246IG9yaWVudGF0aW9uXG4gICAgICB9O1xuXG4gICAgICBjeS51bmRvUmVkbygpLmRvKFwiY3JlYXRlRGVncmFkYXRpb25cIiwgcGFyYW0pO1xuICAgIH0gIFxuICB9O1xuXG4gIG1haW5VdGlsaXRpZXMuY3JlYXRlQ29tcGxleFByb3RlaW5Gb3JtYXRpb24gPSBmdW5jdGlvbihwcm90ZWluTGFiZWxzLCBjb21wbGV4TGFiZWwsIHJlZ3VsYXRvciwgb3JpZW50YXRpb24sIHJldmVyc2UpIHtcbiAgICBpZiAoIGVsZW1lbnRVdGlsaXRpZXMuaXNHcmFwaFRvcG9sb2d5TG9ja2VkKCkgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFvcHRpb25zLnVuZG9hYmxlKSB7XG4gICAgICBlbGVtZW50VXRpbGl0aWVzLmNyZWF0ZUNvbXBsZXhQcm90ZWluRm9ybWF0aW9uKHByb3RlaW5MYWJlbHMsIGNvbXBsZXhMYWJlbCwgcmVndWxhdG9yLCBvcmllbnRhdGlvbiwgcmV2ZXJzZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY29uc3QgcGFyYW0gPSB7XG4gICAgICAgIHByb3RlaW5MYWJlbHM6IHByb3RlaW5MYWJlbHMsXG4gICAgICAgIGNvbXBsZXhMYWJlbDogY29tcGxleExhYmVsLFxuICAgICAgICByZWd1bGF0b3I6IHJlZ3VsYXRvcixcbiAgICAgICAgb3JpZW50YXRpb246IG9yaWVudGF0aW9uLFxuICAgICAgICByZXZlcnNlOiByZXZlcnNlXG4gICAgICB9O1xuXG4gICAgICBjeS51bmRvUmVkbygpLmRvKFwiY3JlYXRlQ29tcGxleFByb3RlaW5Gb3JtYXRpb25cIiwgcGFyYW0pO1xuICAgIH0gIFxuICB9O1xuXG4gIG1haW5VdGlsaXRpZXMuY3JlYXRlTXVsdGltZXJpemF0aW9uID0gZnVuY3Rpb24obWFjcm9tb2xlY3VsZSwgcmVndWxhdG9yLCByZWd1bGF0b3JNdWx0aW1lciwgb3JpZW50YXRpb24pIHtcbiAgICBpZiAoIGVsZW1lbnRVdGlsaXRpZXMuaXNHcmFwaFRvcG9sb2d5TG9ja2VkKCkgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFvcHRpb25zLnVuZG9hYmxlKSB7XG4gICAgICBlbGVtZW50VXRpbGl0aWVzLmNyZWF0ZU11bHRpbWVyaXphdGlvbihtYWNyb21vbGVjdWxlLCByZWd1bGF0b3IsIHJlZ3VsYXRvck11bHRpbWVyLCBvcmllbnRhdGlvbik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY29uc3QgcGFyYW0gPSB7XG4gICAgICAgIG1hY3JvbW9sZWN1bGU6IG1hY3JvbW9sZWN1bGUsXG4gICAgICAgIHJlZ3VsYXRvcjogcmVndWxhdG9yLFxuICAgICAgICByZWd1bGF0b3JNdWx0aW1lcjogcmVndWxhdG9yTXVsdGltZXIsXG4gICAgICAgIG9yaWVudGF0aW9uOiBvcmllbnRhdGlvblxuICAgICAgfTtcblxuICAgICAgY3kudW5kb1JlZG8oKS5kbyhcImNyZWF0ZU11bHRpbWVyaXphdGlvblwiLCBwYXJhbSk7XG4gICAgfSAgXG4gIH07XG5cbiAgbWFpblV0aWxpdGllcy5jcmVhdGVDb252ZXJzaW9uID0gZnVuY3Rpb24obWFjcm9tb2xlY3VsZSwgcmVndWxhdG9yLCByZWd1bGF0b3JNdWx0aW1lciwgb3JpZW50YXRpb24sIGlucHV0SW5mb2JveExhYmVscywgb3V0cHV0SW5mb2JveExhYmVscykge1xuICAgIGlmICggZWxlbWVudFV0aWxpdGllcy5pc0dyYXBoVG9wb2xvZ3lMb2NrZWQoKSApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIW9wdGlvbnMudW5kb2FibGUpIHtcbiAgICAgIGVsZW1lbnRVdGlsaXRpZXMuY3JlYXRlQ29udmVyc2lvbihtYWNyb21vbGVjdWxlLCByZWd1bGF0b3IsIHJlZ3VsYXRvck11bHRpbWVyLCBvcmllbnRhdGlvbiwgaW5wdXRJbmZvYm94TGFiZWxzLCBvdXRwdXRJbmZvYm94TGFiZWxzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCBwYXJhbSA9IHtcbiAgICAgICAgbWFjcm9tb2xlY3VsZTogbWFjcm9tb2xlY3VsZSxcbiAgICAgICAgcmVndWxhdG9yOiByZWd1bGF0b3IsXG4gICAgICAgIHJlZ3VsYXRvck11bHRpbWVyOiByZWd1bGF0b3JNdWx0aW1lcixcbiAgICAgICAgb3JpZW50YXRpb246IG9yaWVudGF0aW9uLFxuICAgICAgICBpbnB1dEluZm9ib3hMYWJlbHM6IGlucHV0SW5mb2JveExhYmVscyxcbiAgICAgICAgb3V0cHV0SW5mb2JveExhYmVsczogb3V0cHV0SW5mb2JveExhYmVsc1xuICAgICAgfTtcblxuICAgICAgY3kudW5kb1JlZG8oKS5kbyhcImNyZWF0ZUNvbnZlcnNpb25cIiwgcGFyYW0pO1xuICAgIH0gIFxuICB9O1xuXG4gIG1haW5VdGlsaXRpZXMuY3JlYXRlTWV0YWJvbGljUmVhY3Rpb24gPSBmdW5jdGlvbihpbnB1dHMsIG91dHB1dHMsIHJldmVyc2libGUsIHJlZ3VsYXRvciwgcmVndWxhdG9yTXVsdGltZXIsIG9yaWVudGF0aW9uKSB7XG4gICAgaWYgKCBlbGVtZW50VXRpbGl0aWVzLmlzR3JhcGhUb3BvbG9neUxvY2tlZCgpICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghb3B0aW9ucy51bmRvYWJsZSkge1xuICAgICAgZWxlbWVudFV0aWxpdGllcy5jcmVhdGVNZXRhYm9saWNSZWFjdGlvbihpbnB1dHMsIG91dHB1dHMsIHJldmVyc2libGUsIHJlZ3VsYXRvciwgcmVndWxhdG9yTXVsdGltZXIsIG9yaWVudGF0aW9uKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCBwYXJhbSA9IHtcbiAgICAgICAgaW5wdXRzOiBpbnB1dHMsXG4gICAgICAgIG91dHB1dHM6IG91dHB1dHMsXG4gICAgICAgIHJldmVyc2libGU6IHJldmVyc2libGUsXG4gICAgICAgIHJlZ3VsYXRvcjogcmVndWxhdG9yLFxuICAgICAgICByZWd1bGF0b3JNdWx0aW1lcjogcmVndWxhdG9yTXVsdGltZXIsXG4gICAgICAgIG9yaWVudGF0aW9uOiBvcmllbnRhdGlvblxuICAgICAgfTtcblxuICAgICAgY3kudW5kb1JlZG8oKS5kbyhcImNyZWF0ZU1ldGFib2xpY1JlYWN0aW9uXCIsIHBhcmFtKTtcbiAgICB9ICBcbiAgfTtcblxuICAvKlxuICAgKiBDcmVhdGVzIGFuIGFjdGl2YXRpb24gcmVhY3Rpb24gd2l0aCBnaXZlbiBwYXJhbWV0ZXJzLiBSZXF1aXJlcyBjb3NlLWJpbGtlbnQgbGF5b3V0IHRvIHRpbGUgdGhlIGZyZWUgbWFjcm9tb2xlY3VsZXMgaW5jbHVkZWRcbiAgICogaW4gdGhlIGNvbXBsZXguIENvbnNpZGVycyB1bmRvYWJsZSBvcHRpb24uIEZvciBtb3JlIGluZm9ybWF0aW9uIHNlZSB0aGUgc2FtZSBmdW5jdGlvbiBpbiBlbGVtZW50VXRpbGl0aWVzXG4gICAqL1xuICBtYWluVXRpbGl0aWVzLmNyZWF0ZU1ldGFib2xpY0NhdGFseXRpY0FjdGl2aXR5ID0gZnVuY3Rpb24gKGlucHV0Tm9kZUxpc3QsIG91dHB1dE5vZGVMaXN0LCBjYXRhbHlzdE5hbWUsIGNhdGFseXN0VHlwZSwgcHJvY2Vzc1Bvc2l0aW9uLCB0aWxpbmdQYWRkaW5nVmVydGljYWwsIHRpbGluZ1BhZGRpbmdIb3Jpem9udGFsLCBlZGdlTGVuZ3RoKSB7XG4gICAgaWYgKCBlbGVtZW50VXRpbGl0aWVzLmlzR3JhcGhUb3BvbG9neUxvY2tlZCgpICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghb3B0aW9ucy51bmRvYWJsZSkge1xuICAgICAgZWxlbWVudFV0aWxpdGllcy5jcmVhdGVNZXRhYm9saWNDYXRhbHl0aWNBY3Rpdml0eShpbnB1dE5vZGVMaXN0LCBvdXRwdXROb2RlTGlzdCwgY2F0YWx5c3ROYW1lLCBjYXRhbHlzdFR5cGUsIHByb2Nlc3NQb3NpdGlvbiwgdGlsaW5nUGFkZGluZ1ZlcnRpY2FsLCB0aWxpbmdQYWRkaW5nSG9yaXpvbnRhbCwgZWRnZUxlbmd0aCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIHBhcmFtID0ge1xuICAgICAgICBpbnB1dE5vZGVMaXN0OiBpbnB1dE5vZGVMaXN0LFxuICAgICAgICBvdXRwdXROb2RlTGlzdDogb3V0cHV0Tm9kZUxpc3QsXG4gICAgICAgIGNhdGFseXN0TmFtZTogY2F0YWx5c3ROYW1lLFxuICAgICAgICBjYXRhbHlzdFR5cGU6IGNhdGFseXN0VHlwZSxcbiAgICAgICAgcHJvY2Vzc1Bvc2l0aW9uOiBwcm9jZXNzUG9zaXRpb24sXG4gICAgICAgIHRpbGluZ1BhZGRpbmdWZXJ0aWNhbDogdGlsaW5nUGFkZGluZ1ZlcnRpY2FsLFxuICAgICAgICB0aWxpbmdQYWRkaW5nSG9yaXpvbnRhbDogdGlsaW5nUGFkZGluZ0hvcml6b250YWwsXG4gICAgICAgIGVkZ2VMZW5ndGg6IGVkZ2VMZW5ndGgsXG4gICAgICB9O1xuXG4gICAgICBjeS51bmRvUmVkbygpLmRvKFwiY3JlYXRlTWV0YWJvbGljQ2F0YWx5dGljQWN0aXZpdHlcIiwgcGFyYW0pO1xuICAgIH1cbiAgfTtcblxuICAvKlxuICAgKiBDcmVhdGVzIGFuIGFjdGl2YXRpb24gcmVhY3Rpb24gd2l0aCBnaXZlbiBwYXJhbWV0ZXJzLiBSZXF1aXJlcyBjb3NlLWJpbGtlbnQgbGF5b3V0IHRvIHRpbGUgdGhlIGZyZWUgbWFjcm9tb2xlY3VsZXMgaW5jbHVkZWRcbiAgICogaW4gdGhlIGNvbXBsZXguIENvbnNpZGVycyB1bmRvYWJsZSBvcHRpb24uIEZvciBtb3JlIGluZm9ybWF0aW9uIHNlZSB0aGUgc2FtZSBmdW5jdGlvbiBpbiBlbGVtZW50VXRpbGl0aWVzXG4gICAqL1xuICBtYWluVXRpbGl0aWVzLmNyZWF0ZUFjdGl2YXRpb25SZWFjdGlvbiA9IGZ1bmN0aW9uIChwcm90ZWluTmFtZSwgcHJvY2Vzc1Bvc2l0aW9uLCBlZGdlTGVuZ3RoLCByZXZlcnNlKSB7XG4gICAgaWYgKCBlbGVtZW50VXRpbGl0aWVzLmlzR3JhcGhUb3BvbG9neUxvY2tlZCgpICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghb3B0aW9ucy51bmRvYWJsZSkge1xuICAgICAgZWxlbWVudFV0aWxpdGllcy5jcmVhdGVBY3RpdmF0aW9uUmVhY3Rpb24ocHJvdGVpbk5hbWUsIHByb2Nlc3NQb3NpdGlvbiwgZWRnZUxlbmd0aCwgcmV2ZXJzZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIHBhcmFtID0ge1xuICAgICAgICBwcm90ZWluTmFtZTogcHJvdGVpbk5hbWUsXG4gICAgICAgIHByb2Nlc3NQb3NpdGlvbjogcHJvY2Vzc1Bvc2l0aW9uLFxuICAgICAgICBlZGdlTGVuZ3RoOiBlZGdlTGVuZ3RoLFxuICAgICAgICByZXZlcnNlOiByZXZlcnNlXG4gICAgICB9O1xuXG4gICAgICBjeS51bmRvUmVkbygpLmRvKFwiY3JlYXRlQWN0aXZhdGlvblJlYWN0aW9uXCIsIHBhcmFtKTtcbiAgfX07XG5cbiAgLypcbiAgICogQ3JlYXRlcyBhIHRlbXBsYXRlIHJlYWN0aW9uIHdpdGggZ2l2ZW4gcGFyYW1ldGVycy4gUmVxdWlyZXMgY29zZS1iaWxrZW50IGxheW91dCB0byB0aWxlIHRoZSBmcmVlIG1hY3JvbW9sZWN1bGVzIGluY2x1ZGVkXG4gICAqIGluIHRoZSBjb21wbGV4LiBDb25zaWRlcnMgdW5kb2FibGUgb3B0aW9uLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBzZWUgdGhlIHNhbWUgZnVuY3Rpb24gaW4gZWxlbWVudFV0aWxpdGllc1xuICAgKi9cbiAgbWFpblV0aWxpdGllcy5jcmVhdGVUZW1wbGF0ZVJlYWN0aW9uID0gZnVuY3Rpb24gKHRlbXBsYXRlVHlwZSwgbWFjcm9tb2xlY3VsZUxpc3QsIGNvbXBsZXhOYW1lLCBwcm9jZXNzUG9zaXRpb24sIHRpbGluZ1BhZGRpbmdWZXJ0aWNhbCwgdGlsaW5nUGFkZGluZ0hvcml6b250YWwsIGVkZ2VMZW5ndGgsIGxheW91dFBhcmFtKSB7XG4gICAgaWYgKCBlbGVtZW50VXRpbGl0aWVzLmlzR3JhcGhUb3BvbG9neUxvY2tlZCgpICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghb3B0aW9ucy51bmRvYWJsZSkge1xuICAgICAgaWYgKHRlbXBsYXRlVHlwZSA9PT0gXCJyZXZlcnNpYmxlXCIpIHtcbiAgICAgICAgZWxlbWVudFV0aWxpdGllcy5zZXRNYXBUeXBlKFwiSHlicmlkQW55XCIpO1xuICAgICAgfVxuICAgICAgZWxlbWVudFV0aWxpdGllcy5jcmVhdGVUZW1wbGF0ZVJlYWN0aW9uKHRlbXBsYXRlVHlwZSwgbWFjcm9tb2xlY3VsZUxpc3QsIGNvbXBsZXhOYW1lLCBwcm9jZXNzUG9zaXRpb24sIHRpbGluZ1BhZGRpbmdWZXJ0aWNhbCwgdGlsaW5nUGFkZGluZ0hvcml6b250YWwsIGVkZ2VMZW5ndGgsIGxheW91dFBhcmFtKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2YXIgcGFyYW0gPSB7XG4gICAgICAgIHRlbXBsYXRlVHlwZTogdGVtcGxhdGVUeXBlLFxuICAgICAgICBtYWNyb21vbGVjdWxlTGlzdDogbWFjcm9tb2xlY3VsZUxpc3QsXG4gICAgICAgIGNvbXBsZXhOYW1lOiBjb21wbGV4TmFtZSxcbiAgICAgICAgcHJvY2Vzc1Bvc2l0aW9uOiBwcm9jZXNzUG9zaXRpb24sXG4gICAgICAgIHRpbGluZ1BhZGRpbmdWZXJ0aWNhbDogdGlsaW5nUGFkZGluZ1ZlcnRpY2FsLFxuICAgICAgICB0aWxpbmdQYWRkaW5nSG9yaXpvbnRhbDogdGlsaW5nUGFkZGluZ0hvcml6b250YWwsXG4gICAgICAgIGVkZ2VMZW5ndGg6IGVkZ2VMZW5ndGgsXG4gICAgICAgIGxheW91dFBhcmFtOiBsYXlvdXRQYXJhbVxuICAgICAgfTtcbiAgICAgIGlmICh0ZW1wbGF0ZVR5cGUgPT09IFwicmV2ZXJzaWJsZVwiKSB7XG4gICAgICAgIHZhciBhY3Rpb25zID0gW107XG4gICAgICAgIGFjdGlvbnMucHVzaCh7bmFtZTpcImNoYW5nZU1hcFR5cGVcIiwgcGFyYW06IHttYXBUeXBlOiBcIkh5YnJpZEFueVwiLCBjYWxsYmFjazogZnVuY3Rpb24oKXt9IH19KTtcbiAgICAgICAgYWN0aW9ucy5wdXNoKHtuYW1lOlwiY3JlYXRlVGVtcGxhdGVSZWFjdGlvblwiLCBwYXJhbTogcGFyYW19KTtcbiAgICAgICAgY3kudW5kb1JlZG8oKS5kbyhcImJhdGNoXCIsIGFjdGlvbnMpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGN5LnVuZG9SZWRvKCkuZG8oXCJjcmVhdGVUZW1wbGF0ZVJlYWN0aW9uXCIsIHBhcmFtKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLypcbiAgICogUmVzaXplIGdpdmVuIG5vZGVzIGlmIHVzZUFzcGVjdFJhdGlvIGlzIHRydXRoeSBvbmUgb2Ygd2lkdGggb3IgaGVpZ2h0IHNob3VsZCBub3QgYmUgc2V0LlxuICAgKiBDb25zaWRlcnMgdW5kb2FibGUgb3B0aW9uLlxuICAgKi9cbiAgbWFpblV0aWxpdGllcy5yZXNpemVOb2RlcyA9IGZ1bmN0aW9uKG5vZGVzLCB3aWR0aCwgaGVpZ2h0LCB1c2VBc3BlY3RSYXRpbywgcHJlc2VydmVSZWxhdGl2ZVBvcykge1xuICAgIGlmIChub2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy51bmRvYWJsZSkge1xuICAgICAgdmFyIHBhcmFtID0ge1xuICAgICAgICBub2Rlczogbm9kZXMsXG4gICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgIHVzZUFzcGVjdFJhdGlvOiB1c2VBc3BlY3RSYXRpbyxcbiAgICAgICAgcGVyZm9ybU9wZXJhdGlvbjogdHJ1ZSxcbiAgICAgICAgcHJlc2VydmVSZWxhdGl2ZVBvczogcHJlc2VydmVSZWxhdGl2ZVBvc1xuICAgICAgfTtcblxuICAgICAgY3kudW5kb1JlZG8oKS5kbyhcInJlc2l6ZU5vZGVzXCIsIHBhcmFtKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBlbGVtZW50VXRpbGl0aWVzLnJlc2l6ZU5vZGVzKG5vZGVzLCB3aWR0aCwgaGVpZ2h0LCB1c2VBc3BlY3RSYXRpbyk7XG4gICAgICBjeS5zdHlsZSgpLnVwZGF0ZSgpO1xuICAgIH1cblxuXG4gIH07XG5cbiAgICAvKlxuICAgICAqIFJlc2l6ZSBnaXZlbiBub2RlcyBpZiB1c2VBc3BlY3RSYXRpbyBpcyB0cnV0aHkgb25lIG9mIHdpZHRoIG9yIGhlaWdodCBzaG91bGQgbm90IGJlIHNldC5cbiAgICAgKiBDb25zaWRlcnMgdW5kb2FibGUgb3B0aW9uLlxuICAgICAqL1xuICAgIG1haW5VdGlsaXRpZXMucmVzaXplTm9kZXNUb0NvbnRlbnQgPSBmdW5jdGlvbihub2RlcywgdXNlQXNwZWN0UmF0aW8pIHtcbiAgICAgICAgaWYgKG5vZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IFxuICAgICAgICBpZiAob3B0aW9ucy51bmRvYWJsZSkge1xuICAgICAgICAgIHZhciBhY3Rpb25zID0gW107XG4gICAgICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbihub2RlKXtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IGVsZW1lbnRVdGlsaXRpZXMuY2FsY3VsYXRlTWluV2lkdGgobm9kZSk7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gZWxlbWVudFV0aWxpdGllcy5jYWxjdWxhdGVNaW5IZWlnaHQobm9kZSk7XG4gICAgICAgICAgICBhY3Rpb25zLnB1c2goe25hbWU6IFwicmVzaXplTm9kZXNcIiwgcGFyYW06IHtcbiAgICAgICAgICAgICAgICBub2Rlczogbm9kZSxcbiAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgICAgICAgICAgdXNlQXNwZWN0UmF0aW86IHVzZUFzcGVjdFJhdGlvLFxuICAgICAgICAgICAgICAgIHBlcmZvcm1PcGVyYXRpb246IHRydWUsXG4gICAgICAgICAgICAgICAgcHJlc2VydmVSZWxhdGl2ZVBvczogdHJ1ZVxuICAgICAgICAgICAgfX0pO1xuXG4gICAgICAgICAgICB2YXIgc3RhdGVBbmRJbmZvcyA9IG5vZGUuZGF0YSgnc3RhdGVzYW5kaW5mb3MnKTtcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSBzdGF0ZUFuZEluZm9zLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChsZW5ndGggIT0gMCkge1xuICAgICAgICAgICAgICB2YXIgcGFyYW0gPSB7XG4gICAgICAgICAgICAgICAgbm9kZTogbm9kZSxcbiAgICAgICAgICAgICAgICBsb2NhdGlvbnM6IFtcInRvcFwiLFwicmlnaHRcIixcImJvdHRvbVwiLFwibGVmdFwiXVxuICAgICAgICAgICAgICB9OyAgICAgICAgICBcbiAgICAgICAgICAgICAgYWN0aW9ucy5wdXNoKHtuYW1lOlwiZml0VW5pdHNcIixwYXJhbSA6IHBhcmFtfSlcbiAgICAgICAgICAgICB9XG4gIFxuXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgXG4gICAgICAgICBcbiAgICAgICAgICBjeS51bmRvUmVkbygpLmRvKFwiYmF0Y2hcIiwgYWN0aW9ucyk7XG4gICAgICAgICAgY3kuc3R5bGUoKS51cGRhdGUoKTtcbiAgICAgICAgICByZXR1cm4gYWN0aW9ucztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24obm9kZSl7XG4gICAgICAgICAgICAgIHZhciB3aWR0aCA9IGVsZW1lbnRVdGlsaXRpZXMuY2FsY3VsYXRlTWluV2lkdGgobm9kZSk7XG4gICAgICAgICAgICAgIHZhciBoZWlnaHQgPSBlbGVtZW50VXRpbGl0aWVzLmNhbGN1bGF0ZU1pbkhlaWdodChub2RlKTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIGVsZW1lbnRVdGlsaXRpZXMucmVzaXplTm9kZXMobm9kZSwgd2lkdGgsIGhlaWdodCwgdXNlQXNwZWN0UmF0aW8sIHRydWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBjeS5zdHlsZSgpLnVwZGF0ZSgpO1xuICAgIH07XG5cbiAgLypcbiAgICogQ2hhbmdlcyB0aGUgbGFiZWwgb2YgdGhlIGdpdmVuIG5vZGVzIHRvIHRoZSBnaXZlbiBsYWJlbC4gQ29uc2lkZXJzIHVuZG9hYmxlIG9wdGlvbi5cbiAgICovXG4gIG1haW5VdGlsaXRpZXMuY2hhbmdlTm9kZUxhYmVsID0gZnVuY3Rpb24obm9kZXMsIGxhYmVsKSB7XG4gICAgaWYgKG5vZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghb3B0aW9ucy51bmRvYWJsZSkge1xuICAgICAgbm9kZXMuZGF0YSgnbGFiZWwnLCBsYWJlbCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIHBhcmFtID0ge1xuICAgICAgICBub2Rlczogbm9kZXMsXG4gICAgICAgIGxhYmVsOiBsYWJlbCxcbiAgICAgICAgZmlyc3RUaW1lOiB0cnVlXG4gICAgICB9O1xuXG4gICAgICBjeS51bmRvUmVkbygpLmRvKFwiY2hhbmdlTm9kZUxhYmVsXCIsIHBhcmFtKTtcbiAgICB9XG5cbiAgICBjeS5zdHlsZSgpLnVwZGF0ZSgpO1xuICB9O1xuXG4gIC8qXG4gICAqIENoYW5nZSBmb250IHByb3BlcnRpZXMgZm9yIGdpdmVuIG5vZGVzIHVzZSB0aGUgZ2l2ZW4gZm9udCBkYXRhLlxuICAgKiBDb25zaWRlcnMgdW5kb2FibGUgb3B0aW9uLlxuICAgKi9cbiAgbWFpblV0aWxpdGllcy5jaGFuZ2VGb250UHJvcGVydGllcyA9IGZ1bmN0aW9uKGVsZXMsIGRhdGEpIHtcbiAgICBpZiAoZWxlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy51bmRvYWJsZSkge1xuICAgICAgdmFyIHBhcmFtID0ge1xuICAgICAgICBlbGVzOiBlbGVzLFxuICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICBmaXJzdFRpbWU6IHRydWVcbiAgICAgIH07XG5cbiAgICAgIGN5LnVuZG9SZWRvKCkuZG8oXCJjaGFuZ2VGb250UHJvcGVydGllc1wiLCBwYXJhbSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZWxlbWVudFV0aWxpdGllcy5jaGFuZ2VGb250UHJvcGVydGllcyhlbGVzLCBkYXRhKTtcbiAgICB9XG5cbiAgICBjeS5zdHlsZSgpLnVwZGF0ZSgpO1xuICB9O1xuXG4gIC8qXG4gICAqIENoYW5nZSBzdGF0ZSB2YWx1ZSBvciB1bml0IG9mIGluZm9ybWF0aW9uIGJveCBvZiBnaXZlbiBub2RlcyB3aXRoIGdpdmVuIGluZGV4LlxuICAgKiBDb25zaWRlcnMgdW5kb2FibGUgb3B0aW9uLlxuICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcGFyYW1ldGVycyBzZWUgZWxlbWVudFV0aWxpdGllcy5jaGFuZ2VTdGF0ZU9ySW5mb0JveFxuICAgKi9cbiAgbWFpblV0aWxpdGllcy5jaGFuZ2VTdGF0ZU9ySW5mb0JveCA9IGZ1bmN0aW9uKG5vZGVzLCBpbmRleCwgdmFsdWUsIHR5cGUpIHtcbiAgICBpZiAobm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnVuZG9hYmxlKSB7XG4gICAgICB2YXIgcGFyYW0gPSB7XG4gICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICBub2Rlczogbm9kZXNcbiAgICAgIH07XG5cbiAgICAgIGN5LnVuZG9SZWRvKCkuZG8oXCJjaGFuZ2VTdGF0ZU9ySW5mb0JveFwiLCBwYXJhbSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIGVsZW1lbnRVdGlsaXRpZXMuY2hhbmdlU3RhdGVPckluZm9Cb3gobm9kZXMsIGluZGV4LCB2YWx1ZSwgdHlwZSk7XG4gICAgfVxuXG4gICAgY3kuc3R5bGUoKS51cGRhdGUoKTtcbiAgfTtcblxuICAvLyBBZGQgYSBuZXcgc3RhdGUgb3IgaW5mbyBib3ggdG8gZ2l2ZW4gbm9kZXMuXG4gIC8vIFRoZSBib3ggaXMgcmVwcmVzZW50ZWQgYnkgdGhlIHBhcmFtZXRlciBvYmouXG4gIC8vIENvbnNpZGVycyB1bmRvYWJsZSBvcHRpb24uXG4gIG1haW5VdGlsaXRpZXMuYWRkU3RhdGVPckluZm9Cb3ggPSBmdW5jdGlvbihub2Rlcywgb2JqKSB7XG4gICAgaWYgKG5vZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIW9wdGlvbnMudW5kb2FibGUpIHtcbiAgICAgIGVsZW1lbnRVdGlsaXRpZXMuYWRkU3RhdGVPckluZm9Cb3gobm9kZXMsIG9iaik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIHBhcmFtID0ge1xuICAgICAgICBvYmo6IG9iaixcbiAgICAgICAgbm9kZXM6IG5vZGVzXG4gICAgICB9O1xuXG4gICAgICBjeS51bmRvUmVkbygpLmRvKFwiYWRkU3RhdGVPckluZm9Cb3hcIiwgcGFyYW0pO1xuICAgIH1cbiAgICBjeS5zdHlsZSgpLnVwZGF0ZSgpO1xuICB9O1xuXG4gIC8vIFJlbW92ZSB0aGUgc3RhdGUgb3IgaW5mbyBib3hlcyBvZiB0aGUgZ2l2ZW4gbm9kZXMgYXQgZ2l2ZW4gaW5kZXguXG4gIC8vIENvbnNpZGVycyB1bmRvYWJsZSBvcHRpb24uXG4gIG1haW5VdGlsaXRpZXMucmVtb3ZlU3RhdGVPckluZm9Cb3ggPSBmdW5jdGlvbihub2RlcywgaW5kZXgpIHtcbiAgICBpZiAobm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFvcHRpb25zLnVuZG9hYmxlKSB7XG4gICAgICBlbGVtZW50VXRpbGl0aWVzLnJlbW92ZVN0YXRlT3JJbmZvQm94KG5vZGVzLCB7aW5kZXg6IGluZGV4fSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIHBhcmFtID0ge1xuICAgICAgICBsb2NhdGlvbk9iajoge2luZGV4OiBpbmRleH0sXG4gICAgICAgIG5vZGVzOiBub2Rlc1xuICAgICAgfTtcblxuICAgICAgY3kudW5kb1JlZG8oKS5kbyhcInJlbW92ZVN0YXRlT3JJbmZvQm94XCIsIHBhcmFtKTtcbiAgICB9XG5cbiAgICBjeS5zdHlsZSgpLnVwZGF0ZSgpO1xuICB9O1xuXG5cbiAgLy9BcnJhbmdlIGluZm9ybWF0aW9uIGJveGVzXG4gIC8vSWYgZm9yY2UgY2hlY2sgaXMgdHJ1ZSwgaXQgcmVhcnJhbmdlcyBhbGwgaW5mb3JtYXRpb24gYm94ZXNcbiAgbWFpblV0aWxpdGllcy5maXRVbml0cyA9IGZ1bmN0aW9uIChub2RlLCBsb2NhdGlvbnMpIHtcbiAgICBpZiAobm9kZS5kYXRhKCdhdXh1bml0bGF5b3V0cycpID09PSB1bmRlZmluZWQgfHwgbm9kZS5kYXRhKCdzdGF0ZXNhbmRpbmZvcycpLmxlbmd0aCA8PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChsb2NhdGlvbnMgPT09IHVuZGVmaW5lZCB8fCBsb2NhdGlvbnMubGVuZ3RoIDw9IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIW9wdGlvbnMudW5kb2FibGUpIHtcbiAgICAgIGVsZW1lbnRVdGlsaXRpZXMuZml0VW5pdHMobm9kZSwgbG9jYXRpb25zKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2YXIgcGFyYW0gPSB7XG4gICAgICAgIG5vZGU6IG5vZGUsXG4gICAgICAgIGxvY2F0aW9uczogbG9jYXRpb25zXG4gICAgICB9O1xuXG4gICAgICBjeS51bmRvUmVkbygpLmRvKFwiZml0VW5pdHNcIiwgcGFyYW0pO1xuICAgIH1cblxuICAgIGN5LnN0eWxlKCkudXBkYXRlKCk7XG4gIH07XG5cbiAgLypcbiAgICogU2V0IG11bHRpbWVyIHN0YXR1cyBvZiB0aGUgZ2l2ZW4gbm9kZXMgdG8gdGhlIGdpdmVuIHN0YXR1cy5cbiAgICogQ29uc2lkZXJzIHVuZG9hYmxlIG9wdGlvbi5cbiAgICovXG4gIG1haW5VdGlsaXRpZXMuc2V0TXVsdGltZXJTdGF0dXMgPSBmdW5jdGlvbihub2Rlcywgc3RhdHVzKSB7XG4gICAgaWYgKG5vZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnVuZG9hYmxlKSB7XG4gICAgICB2YXIgcGFyYW0gPSB7XG4gICAgICAgIHN0YXR1czogc3RhdHVzLFxuICAgICAgICBub2Rlczogbm9kZXMsXG4gICAgICAgIGZpcnN0VGltZTogdHJ1ZVxuICAgICAgfTtcblxuICAgICAgY3kudW5kb1JlZG8oKS5kbyhcInNldE11bHRpbWVyU3RhdHVzXCIsIHBhcmFtKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBlbGVtZW50VXRpbGl0aWVzLnNldE11bHRpbWVyU3RhdHVzKG5vZGVzLCBzdGF0dXMpO1xuICAgIH1cblxuICAgIGN5LnN0eWxlKCkudXBkYXRlKCk7XG4gIH07XG5cbiAgbWFpblV0aWxpdGllcy5zZXRBY3RpdmVTdGF0dXMgPSBmdW5jdGlvbihub2Rlcywgc3RhdHVzKSB7XG4gICAgaWYgKG5vZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnVuZG9hYmxlKSB7XG4gICAgICB2YXIgcGFyYW0gPSB7XG4gICAgICAgIHN0YXR1czogc3RhdHVzLFxuICAgICAgICBub2Rlczogbm9kZXMsXG4gICAgICAgIGZpcnN0VGltZTogdHJ1ZVxuICAgICAgfTtcblxuICAgICAgY3kudW5kb1JlZG8oKS5kbyhcInNldEFjdGl2ZVN0YXR1c1wiLCBwYXJhbSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZWxlbWVudFV0aWxpdGllcy5zZXRBY3RpdmVTdGF0dXMobm9kZXMsIHN0YXR1cyk7XG4gICAgfVxuXG4gICAgY3kuc3R5bGUoKS51cGRhdGUoKTtcbiAgfTtcblxuICBtYWluVXRpbGl0aWVzLnNldEh5cG90aGV0aWNhbFN0YXR1cz0gZnVuY3Rpb24obm9kZXMsIHN0YXR1cykge1xuICAgIGlmIChub2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy51bmRvYWJsZSkge1xuICAgICAgdmFyIHBhcmFtID0ge1xuICAgICAgICBzdGF0dXM6IHN0YXR1cyxcbiAgICAgICAgbm9kZXM6IG5vZGVzLFxuICAgICAgICBmaXJzdFRpbWU6IHRydWVcbiAgICAgIH07XG5cbiAgICAgIGN5LnVuZG9SZWRvKCkuZG8oXCJzZXRIeXBvdGhldGljYWxTdGF0dXNcIiwgcGFyYW0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGVsZW1lbnRVdGlsaXRpZXMuc2V0SHlwb3RoZXRpY2FsU3RhdHVzKG5vZGVzLCBzdGF0dXMpO1xuICAgIH1cblxuICAgIGN5LnN0eWxlKCkudXBkYXRlKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlZHJhdyBjbG9uZSBtYXJrZXJzIG9uIGdpdmVuIG5vZGVzIHdpdGhvdXQgY29uc2lkZXJpbmcgdW5kby5cbiAgICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9pVmlzLWF0LUJpbGtlbnQvbmV3dC9pc3N1ZXMvNTc0IFxuICAgKi9cbiAgbWFpblV0aWxpdGllcy5yZWRyYXdDbG9uZU1hcmtlcnMgPSBmdW5jdGlvbihub2Rlcykge1xuICAgIGVsZW1lbnRVdGlsaXRpZXMuc2V0Q2xvbmVNYXJrZXJTdGF0dXMobm9kZXMsIHRydWUpO1xuICB9XG5cbiAgLypcbiAgICogU2V0IGNsb25lIG1hcmtlciBzdGF0dXMgb2YgZ2l2ZW4gbm9kZXMgdG8gdGhlIGdpdmVuIHN0YXR1cy5cbiAgICogQ29uc2lkZXJzIHVuZG9hYmxlIG9wdGlvbi5cbiAgICovXG4gIG1haW5VdGlsaXRpZXMuc2V0Q2xvbmVNYXJrZXJTdGF0dXMgPSBmdW5jdGlvbihub2Rlcywgc3RhdHVzKSB7XG4gICAgaWYgKG5vZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnVuZG9hYmxlKSB7XG4gICAgICB2YXIgcGFyYW0gPSB7XG4gICAgICAgIHN0YXR1czogc3RhdHVzLFxuICAgICAgICBub2Rlczogbm9kZXMsXG4gICAgICAgIGZpcnN0VGltZTogdHJ1ZVxuICAgICAgfTtcblxuICAgICAgY3kudW5kb1JlZG8oKS5kbyhcInNldENsb25lTWFya2VyU3RhdHVzXCIsIHBhcmFtKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBlbGVtZW50VXRpbGl0aWVzLnNldENsb25lTWFya2VyU3RhdHVzKG5vZGVzLCBzdGF0dXMpO1xuICAgIH1cblxuICAgIGN5LnN0eWxlKCkudXBkYXRlKCk7XG4gIH07XG5cbiAgLypcbiAgICogQ2hhbmdlIHN0eWxlL2NzcyBvZiBnaXZlbiBlbGVzIGJ5IHNldHRpbmcgZ2V0dGluZyBwcm9wZXJ0eSBuYW1lIHRvIHRoZSBnaXZlbiBnaXZlbiB2YWx1ZS92YWx1ZXMgKE5vdGUgdGhhdCB2YWx1ZU1hcCBwYXJhbWV0ZXIgbWF5IGJlXG4gICAqIGEgc2luZ2xlIHN0cmluZyBvciBhbiBpZCB0byB2YWx1ZSBtYXApLiBDb25zaWRlcnMgdW5kb2FibGUgb3B0aW9uLlxuICAgKi9cbiAgbWFpblV0aWxpdGllcy5jaGFuZ2VDc3MgPSBmdW5jdGlvbihlbGVzLCBuYW1lLCB2YWx1ZU1hcCkge1xuICAgIGlmIChlbGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghb3B0aW9ucy51bmRvYWJsZSkge1xuICAgICAgZWxlbWVudFV0aWxpdGllcy5jaGFuZ2VDc3MoZWxlcywgbmFtZSwgdmFsdWVNYXApO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHZhciBwYXJhbSA9IHtcbiAgICAgICAgZWxlczogZWxlcyxcbiAgICAgICAgdmFsdWVNYXA6IHZhbHVlTWFwLFxuICAgICAgICBuYW1lOiBuYW1lXG4gICAgICB9O1xuXG4gICAgICBjeS51bmRvUmVkbygpLmRvKFwiY2hhbmdlQ3NzXCIsIHBhcmFtKTtcbiAgICB9XG5cbiAgICBjeS5zdHlsZSgpLnVwZGF0ZSgpO1xuICB9O1xuXG4gIC8qXG4gICAqIENoYW5nZSBkYXRhIG9mIGdpdmVuIGVsZXMgYnkgc2V0dGluZyBnZXR0aW5nIHByb3BlcnR5IG5hbWUgdG8gdGhlIGdpdmVuIGdpdmVuIHZhbHVlL3ZhbHVlcyAoTm90ZSB0aGF0IHZhbHVlTWFwIHBhcmFtZXRlciBtYXkgYmVcbiAgICogYSBzaW5nbGUgc3RyaW5nIG9yIGFuIGlkIHRvIHZhbHVlIG1hcCkuIENvbnNpZGVycyB1bmRvYWJsZSBvcHRpb24uXG4gICAqL1xuICBtYWluVXRpbGl0aWVzLmNoYW5nZURhdGEgPSBmdW5jdGlvbihlbGVzLCBuYW1lLCB2YWx1ZU1hcCkge1xuICAgIGlmIChlbGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghb3B0aW9ucy51bmRvYWJsZSkge1xuICAgICAgZWxlbWVudFV0aWxpdGllcy5jaGFuZ2VEYXRhKGVsZXMsIG5hbWUsIHZhbHVlTWFwKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2YXIgcGFyYW0gPSB7XG4gICAgICAgIGVsZXM6IGVsZXMsXG4gICAgICAgIHZhbHVlTWFwOiB2YWx1ZU1hcCxcbiAgICAgICAgbmFtZTogbmFtZVxuICAgICAgfTtcblxuICAgICAgY3kudW5kb1JlZG8oKS5kbyhcImNoYW5nZURhdGFcIiwgcGFyYW0pO1xuICAgIH1cblxuICAgIGN5LnN0eWxlKCkudXBkYXRlKCk7XG4gIH07XG5cbiAgbWFpblV0aWxpdGllcy51cGRhdGVTZXRGaWVsZCA9IGZ1bmN0aW9uKGVsZSwgZmllbGROYW1lLCB0b0RlbGV0ZSwgdG9BZGQsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCFvcHRpb25zLnVuZG9hYmxlKSB7XG4gICAgICBlbGVtZW50VXRpbGl0aWVzLmNoYW5nZURhdGEoZWxlLCBmaWVsZE5hbWUsIHRvRGVsZXRlLCB0b0FkZCwgY2FsbGJhY2spO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHZhciBwYXJhbSA9IHtcbiAgICAgICAgZWxlLFxuICAgICAgICBmaWVsZE5hbWUsXG4gICAgICAgIHRvRGVsZXRlLFxuICAgICAgICB0b0FkZCxcbiAgICAgICAgY2FsbGJhY2tcbiAgICAgIH07XG5cbiAgICAgIGN5LnVuZG9SZWRvKCkuZG8oXCJ1cGRhdGVTZXRGaWVsZFwiLCBwYXJhbSk7XG4gICAgfVxuICB9O1xuXG4gIG1haW5VdGlsaXRpZXMuc2V0RGVmYXVsdFByb3BlcnR5ID0gZnVuY3Rpb24oIF9jbGFzcywgbmFtZSwgdmFsdWUgKSB7XG4gICAgaWYgKCFvcHRpb25zLnVuZG9hYmxlKSB7XG4gICAgICB2YXIgcHJvcE1hcCA9IHt9O1xuICAgICAgcHJvcE1hcFsgbmFtZSBdID0gdmFsdWU7XG5cbiAgICAgIGVsZW1lbnRVdGlsaXRpZXMuc2V0RGVmYXVsdFByb3BlcnRpZXMoX2NsYXNzLCBwcm9wTWFwKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2YXIgcGFyYW0gPSB7XG4gICAgICAgIGNsYXNzOiBfY2xhc3MsXG4gICAgICAgIG5hbWUsXG4gICAgICAgIHZhbHVlXG4gICAgICB9O1xuXG4gICAgICBjeS51bmRvUmVkbygpLmRvKFwic2V0RGVmYXVsdFByb3BlcnR5XCIsIHBhcmFtKTtcbiAgICB9XG4gIH07XG5cbiAgbWFpblV0aWxpdGllcy51cGRhdGVJbmZvYm94U3R5bGUgPSBmdW5jdGlvbiggbm9kZSwgaW5kZXgsIG5ld1Byb3BzICkge1xuICAgIGlmICghb3B0aW9ucy51bmRvYWJsZSkge1xuICAgICAgZWxlbWVudFV0aWxpdGllcy51cGRhdGVJbmZvYm94U3R5bGUoIG5vZGUsIGluZGV4LCBuZXdQcm9wcyApO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHZhciBwYXJhbSA9IHtcbiAgICAgICAgbm9kZTogbm9kZSxcbiAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICBuZXdQcm9wczogbmV3UHJvcHNcbiAgICAgIH07XG5cbiAgICAgIGN5LnVuZG9SZWRvKCkuZG8oXCJ1cGRhdGVJbmZvYm94U3R5bGVcIiwgcGFyYW0pO1xuICAgIH1cblxuICAgIGN5LnN0eWxlKCkudXBkYXRlKCk7XG4gIH07XG5cbiAgbWFpblV0aWxpdGllcy51cGRhdGVJbmZvYm94T2JqID0gZnVuY3Rpb24oIG5vZGUsIGluZGV4LCBuZXdQcm9wcyApIHtcbiAgICBpZiAoIW9wdGlvbnMudW5kb2FibGUpIHtcbiAgICAgIGVsZW1lbnRVdGlsaXRpZXMudXBkYXRlSW5mb2JveE9iaiggbm9kZSwgaW5kZXgsIG5ld1Byb3BzICk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIHBhcmFtID0ge1xuICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgIG5ld1Byb3BzOiBuZXdQcm9wc1xuICAgICAgfTtcblxuICAgICAgY3kudW5kb1JlZG8oKS5kbyhcInVwZGF0ZUluZm9ib3hPYmpcIiwgcGFyYW0pO1xuICAgIH1cblxuICAgIGN5LnN0eWxlKCkudXBkYXRlKCk7XG4gIH07XG5cbiAgbWFpblV0aWxpdGllcy5kZWxldGVBbmRQZXJmb3JtTGF5b3V0ID0gZnVuY3Rpb24gKGVsZXMsIGxheW91dHBhcmFtKSB7XG4gICAgdmFyIG5vZGVzID0gZWxlcy5ub2RlcygpOyAvLyBFbnN1cmUgdGhhdCBub2RlcyBsaXN0IGp1c3QgaW5jbHVkZSBub2Rlc1xuXG4gICAgdmFyIGFsbE5vZGVzID0gY3kubm9kZXMoXCI6dmlzaWJsZVwiKTtcbiAgICB2YXIgbm9kZXNUb0tlZXAgPSBlbGVtZW50VXRpbGl0aWVzLmV4dGVuZFJlbWFpbmluZ05vZGVzKG5vZGVzLCBhbGxOb2Rlcyk7XG4gICAgdmFyIG5vZGVzVG9SZW1vdmUgPSBhbGxOb2Rlcy5ub3Qobm9kZXNUb0tlZXApO1xuXG4gICAgaWYgKG5vZGVzVG9SZW1vdmUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIW9wdGlvbnMudW5kb2FibGUpIHtcblxuICAgICAgICBlbGVtZW50VXRpbGl0aWVzLmRlbGV0ZUFuZFBlcmZvcm1MYXlvdXQobm9kZXNUb1JlbW92ZSwgbGF5b3V0cGFyYW0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIHBhcmFtID0ge1xuICAgICAgICAgICAgZWxlczogbm9kZXNUb1JlbW92ZSxcbiAgICAgICAgICAgIGxheW91dHBhcmFtOiBsYXlvdXRwYXJhbSxcbiAgICAgICAgICAgIGZpcnN0VGltZTogdHJ1ZVxuICAgICAgICB9O1xuXG4gICAgICAgIGN5LnVuZG9SZWRvKCkuZG8oXCJkZWxldGVBbmRQZXJmb3JtTGF5b3V0XCIsIHBhcmFtKTtcbiAgICB9XG4gIH07XG5cbiAgLypcbiAgICogSGlkZXMgZ2l2ZW4gZWxlcyAodGhlIG9uZXMgd2hpY2ggYXJlIHNlbGVjdGVkKSBhbmQgcGVyZm9ybSBnaXZlbiBsYXlvdXQgYWZ0ZXJ3YXJkLiBMYXlvdXQgcGFyYW1ldGVyIG1heSBiZSBsYXlvdXQgb3B0aW9uc1xuICAgKiBvciBhIGZ1bmN0aW9uIHRvIGNhbGwuIFJlcXVpcmVzIHZpZXdVdGlsaXRpZXMgZXh0ZW5zaW9uIGFuZCBjb25zaWRlcnMgdW5kb2FibGUgb3B0aW9uLlxuICAgKi9cbiAgbWFpblV0aWxpdGllcy5oaWRlQW5kUGVyZm9ybUxheW91dCA9IGZ1bmN0aW9uKGVsZXMsIGxheW91dHBhcmFtKSB7XG4gICAgICB2YXIgbm9kZXMgPSBlbGVzLm5vZGVzKCk7IC8vIEVuc3VyZSB0aGF0IG5vZGVzIGxpc3QganVzdCBpbmNsdWRlIG5vZGVzXG5cbiAgICAgIHZhciBhbGxOb2RlcyA9IGN5Lm5vZGVzKFwiOnZpc2libGVcIik7XG4gICAgICB2YXIgbm9kZXNUb1Nob3cgPSBlbGVtZW50VXRpbGl0aWVzLmV4dGVuZFJlbWFpbmluZ05vZGVzKG5vZGVzLCBhbGxOb2Rlcyk7XG4gICAgICB2YXIgbm9kZXNUb0hpZGUgPSBhbGxOb2Rlcy5ub3Qobm9kZXNUb1Nob3cpO1xuXG4gICAgICBpZiAobm9kZXNUb0hpZGUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIW9wdGlvbnMudW5kb2FibGUpIHtcblxuICAgICAgICAgIHZhciBub2Rlc1dpdGhIaWRkZW5OZWlnaGJvciA9IGN5LmVkZ2VzKFwiOmhpZGRlblwiKS5jb25uZWN0ZWROb2RlcygnOnZpc2libGUnKTtcbiAgICAgICAgICBzYmdudml6SW5zdGFuY2UudGhpbkJvcmRlcihub2Rlc1dpdGhIaWRkZW5OZWlnaGJvcik7XG4gICAgICAgICAgZWxlbWVudFV0aWxpdGllcy5oaWRlQW5kUGVyZm9ybUxheW91dChub2Rlc1RvSGlkZSwgbGF5b3V0cGFyYW0pO1xuICAgICAgICAgIHZhciBub2Rlc1dpdGhIaWRkZW5OZWlnaGJvciA9IGN5LmVkZ2VzKFwiOmhpZGRlblwiKS5jb25uZWN0ZWROb2RlcygnOnZpc2libGUnKTtcbiAgICAgICAgICBzYmdudml6SW5zdGFuY2UudGhpY2tlbkJvcmRlcihub2Rlc1dpdGhIaWRkZW5OZWlnaGJvcik7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgcGFyYW0gPSB7XG4gICAgICAgICAgICAgIGVsZXM6IG5vZGVzVG9IaWRlLFxuICAgICAgICAgICAgICBsYXlvdXRwYXJhbTogbGF5b3V0cGFyYW0sXG4gICAgICAgICAgICAgIGZpcnN0VGltZTogdHJ1ZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICB2YXIgdXIgPSBjeS51bmRvUmVkbygpO1xuICAgICAgICAgIHVyLmFjdGlvbihcInRoaWNrZW5Cb3JkZXJcIiwgc2JnbnZpekluc3RhbmNlLnRoaWNrZW5Cb3JkZXIsIHNiZ252aXpJbnN0YW5jZS50aGluQm9yZGVyKTtcbiAgICAgICAgICB1ci5hY3Rpb24oXCJ0aGluQm9yZGVyXCIsIHNiZ252aXpJbnN0YW5jZS50aGluQm9yZGVyLCBzYmdudml6SW5zdGFuY2UudGhpY2tlbkJvcmRlcik7XG5cbiAgICAgICAgICB2YXIgYWN0aW9ucyA9IFtdO1xuICAgICAgICAgIHZhciBub2Rlc1dpdGhIaWRkZW5OZWlnaGJvciA9IGN5LmVkZ2VzKFwiOmhpZGRlblwiKS5jb25uZWN0ZWROb2RlcygpLmludGVyc2VjdGlvbihub2Rlc1RvSGlkZSk7XG4gICAgICAgICAgYWN0aW9ucy5wdXNoKHtuYW1lOiBcInRoaW5Cb3JkZXJcIiwgcGFyYW06IG5vZGVzV2l0aEhpZGRlbk5laWdoYm9yfSk7XG4gICAgICAgICAgYWN0aW9ucy5wdXNoKHtuYW1lOiBcImhpZGVBbmRQZXJmb3JtTGF5b3V0XCIsIHBhcmFtOiBwYXJhbX0pO1xuICAgICAgICAgIG5vZGVzV2l0aEhpZGRlbk5laWdoYm9yID0gbm9kZXNUb0hpZGUubmVpZ2hib3Job29kKFwiOnZpc2libGVcIikubm9kZXMoKS5kaWZmZXJlbmNlKG5vZGVzVG9IaWRlKS5kaWZmZXJlbmNlKGN5Lm5vZGVzKFwiW3RoaWNrQm9yZGVyXVwiKSk7XG4gICAgICAgICAgYWN0aW9ucy5wdXNoKHtuYW1lOiBcInRoaWNrZW5Cb3JkZXJcIiwgcGFyYW06IG5vZGVzV2l0aEhpZGRlbk5laWdoYm9yfSk7XG4gICAgICAgICAgY3kudW5kb1JlZG8oKS5kbyhcImJhdGNoXCIsIGFjdGlvbnMpO1xuICAgICAgfVxuICB9O1xuXG4gIC8qXG4gICAqIFNob3dzIGFsbCBlbGVtZW50cyAodGhlIG9uZXMgd2hpY2ggYXJlIGhpZGRlbiBpZiBhbnkpIGFuZCBwZXJmb3JtIGdpdmVuIGxheW91dCBhZnRlcndhcmQuIExheW91dCBwYXJhbWV0ZXIgbWF5IGJlIGxheW91dCBvcHRpb25zXG4gICAqIG9yIGEgZnVuY3Rpb24gdG8gY2FsbC4gUmVxdWlyZXMgdmlld1V0aWxpdGllcyBleHRlbnNpb24gYW5kIGNvbnNpZGVycyB1bmRvYWJsZSBvcHRpb24uXG4gICAqL1xuICBtYWluVXRpbGl0aWVzLnNob3dBbGxBbmRQZXJmb3JtTGF5b3V0ID0gZnVuY3Rpb24obGF5b3V0cGFyYW0pIHtcbiAgICB2YXIgaGlkZGVuRWxlcyA9IGN5LmVsZW1lbnRzKCc6aGlkZGVuJyk7XG4gICAgaWYgKGhpZGRlbkVsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghb3B0aW9ucy51bmRvYWJsZSkge1xuICAgICAgdmFyIG5vZGVzV2l0aEhpZGRlbk5laWdoYm9yID0gY3kuZWRnZXMoXCI6aGlkZGVuXCIpLmNvbm5lY3RlZE5vZGVzKCc6dmlzaWJsZScpO1xuICAgICAgc2JnbnZpekluc3RhbmNlLnRoaW5Cb3JkZXIobm9kZXNXaXRoSGlkZGVuTmVpZ2hib3IpO1xuICAgICAgZWxlbWVudFV0aWxpdGllcy5zaG93QW5kUGVyZm9ybUxheW91dChoaWRkZW5FbGVzLCBsYXlvdXRwYXJhbSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIHBhcmFtID0ge1xuICAgICAgICBlbGVzOiBoaWRkZW5FbGVzLFxuICAgICAgICBsYXlvdXRwYXJhbTogbGF5b3V0cGFyYW0sXG4gICAgICAgIGZpcnN0VGltZTogdHJ1ZVxuICAgICAgfTtcblxuICAgICAgdmFyIHVyID0gY3kudW5kb1JlZG8oKTtcbiAgICAgIHVyLmFjdGlvbihcInRoaWNrZW5Cb3JkZXJcIiwgc2JnbnZpekluc3RhbmNlLnRoaWNrZW5Cb3JkZXIsIHNiZ252aXpJbnN0YW5jZS50aGluQm9yZGVyKTtcbiAgICAgIHVyLmFjdGlvbihcInRoaW5Cb3JkZXJcIiwgc2JnbnZpekluc3RhbmNlLnRoaW5Cb3JkZXIsIHNiZ252aXpJbnN0YW5jZS50aGlja2VuQm9yZGVyKTtcblxuICAgICAgdmFyIGFjdGlvbnMgPSBbXTtcbiAgICAgIHZhciBub2Rlc1dpdGhIaWRkZW5OZWlnaGJvciA9IGN5Lm5vZGVzKFwiW3RoaWNrQm9yZGVyXVwiKTtcbiAgICAgIGFjdGlvbnMucHVzaCh7bmFtZTogXCJ0aGluQm9yZGVyXCIsIHBhcmFtOiBub2Rlc1dpdGhIaWRkZW5OZWlnaGJvcn0pO1xuICAgICAgYWN0aW9ucy5wdXNoKHtuYW1lOiBcInNob3dBbmRQZXJmb3JtTGF5b3V0XCIsIHBhcmFtOiBwYXJhbX0pO1xuICAgICAgY3kudW5kb1JlZG8oKS5kbyhcImJhdGNoXCIsIGFjdGlvbnMpO1xuICAgIH1cbiAgfTtcblxuICAvKlxuICAgKiBVbmhpZGUgZ2l2ZW4gZWxlcyAodGhlIG9uZXMgd2hpY2ggYXJlIGhpZGRlbiBpZiBhbnkpIGFuZCBwZXJmb3JtIGdpdmVuIGxheW91dCBhZnRlcndhcmQuIExheW91dCBwYXJhbWV0ZXIgbWF5IGJlIGxheW91dCBvcHRpb25zXG4gICAqIG9yIGEgZnVuY3Rpb24gdG8gY2FsbC4gUmVxdWlyZXMgdmlld1V0aWxpdGllcyBleHRlbnNpb24gYW5kIGNvbnNpZGVycyB1bmRvYWJsZSBvcHRpb24uXG4gICAqL1xuICBtYWluVXRpbGl0aWVzLnNob3dBbmRQZXJmb3JtTGF5b3V0ID0gZnVuY3Rpb24obWFpbkVsZSwgZWxlcywgbGF5b3V0cGFyYW0pIHtcbiAgICAgIHZhciBoaWRkZW5FbGVzID0gZWxlcy5maWx0ZXIoJzpoaWRkZW4nKTtcbiAgICAgIGlmIChoaWRkZW5FbGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG1haW5VdGlsaXRpZXMuY2xvc2VVcEVsZW1lbnRzKG1haW5FbGUsIGhpZGRlbkVsZXMubm9kZXMoKSk7XG4gICAgICBpZiAoIW9wdGlvbnMudW5kb2FibGUpIHtcbiAgICAgICAgICB2YXIgbm9kZXNXaXRoSGlkZGVuTmVpZ2hib3IgPSBjeS5lZGdlcyhcIjpoaWRkZW5cIikuY29ubmVjdGVkTm9kZXMoJzp2aXNpYmxlJyk7XG4gICAgICAgICAgc2JnbnZpekluc3RhbmNlLnRoaW5Cb3JkZXIobm9kZXNXaXRoSGlkZGVuTmVpZ2hib3IpO1xuICAgICAgICAgIGVsZW1lbnRVdGlsaXRpZXMuc2hvd0FuZFBlcmZvcm1MYXlvdXQoaGlkZGVuRWxlcywgbGF5b3V0cGFyYW0pO1xuICAgICAgICAgIHZhciBub2Rlc1dpdGhIaWRkZW5OZWlnaGJvciA9IGN5LmVkZ2VzKFwiOmhpZGRlblwiKS5jb25uZWN0ZWROb2RlcygnOnZpc2libGUnKTtcbiAgICAgICAgICBzYmdudml6SW5zdGFuY2UudGhpY2tlbkJvcmRlcihub2Rlc1dpdGhIaWRkZW5OZWlnaGJvcik7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgcGFyYW0gPSB7XG4gICAgICAgICAgICAgIGVsZXM6IGhpZGRlbkVsZXMsXG4gICAgICAgICAgICAgIGxheW91dHBhcmFtOiBsYXlvdXRwYXJhbSxcbiAgICAgICAgICAgICAgZmlyc3RUaW1lOiB0cnVlXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHZhciB1ciA9IGN5LnVuZG9SZWRvKCk7XG4gICAgICAgICAgdXIuYWN0aW9uKFwidGhpY2tlbkJvcmRlclwiLCBzYmdudml6SW5zdGFuY2UudGhpY2tlbkJvcmRlciwgc2JnbnZpekluc3RhbmNlLnRoaW5Cb3JkZXIpO1xuICAgICAgICAgIHVyLmFjdGlvbihcInRoaW5Cb3JkZXJcIiwgc2JnbnZpekluc3RhbmNlLnRoaW5Cb3JkZXIsIHNiZ252aXpJbnN0YW5jZS50aGlja2VuQm9yZGVyKTtcblxuICAgICAgICAgIHZhciBhY3Rpb25zID0gW107XG4gICAgICAgICAgdmFyIG5vZGVzVG9UaGluQm9yZGVyID0gKGhpZGRlbkVsZXMubmVpZ2hib3Job29kKFwiOnZpc2libGVcIikubm9kZXMoXCJbdGhpY2tCb3JkZXJdXCIpKVxuICAgICAgICAgICAgICAgICAgLmRpZmZlcmVuY2UoY3kuZWRnZXMoXCI6aGlkZGVuXCIpLmRpZmZlcmVuY2UoaGlkZGVuRWxlcy5lZGdlcygpLnVuaW9uKGhpZGRlbkVsZXMubm9kZXMoKS5jb25uZWN0ZWRFZGdlcygpKSkuY29ubmVjdGVkTm9kZXMoKSk7XG4gICAgICAgICAgYWN0aW9ucy5wdXNoKHtuYW1lOiBcInRoaW5Cb3JkZXJcIiwgcGFyYW06IG5vZGVzVG9UaGluQm9yZGVyfSk7XG4gICAgICAgICAgYWN0aW9ucy5wdXNoKHtuYW1lOiBcInNob3dBbmRQZXJmb3JtTGF5b3V0XCIsIHBhcmFtOiBwYXJhbX0pO1xuICAgICAgICAgIHZhciBub2Rlc1RvVGhpY2tlbkJvcmRlciA9IGhpZGRlbkVsZXMubm9kZXMoKS5lZGdlc1dpdGgoY3kubm9kZXMoXCI6aGlkZGVuXCIpLmRpZmZlcmVuY2UoaGlkZGVuRWxlcy5ub2RlcygpKSlcbiAgXHQgICAgICAgICAgICAuY29ubmVjdGVkTm9kZXMoKS5pbnRlcnNlY3Rpb24oaGlkZGVuRWxlcy5ub2RlcygpKTtcbiAgICAgICAgICBhY3Rpb25zLnB1c2goe25hbWU6IFwidGhpY2tlbkJvcmRlclwiLCBwYXJhbTogbm9kZXNUb1RoaWNrZW5Cb3JkZXJ9KTtcbiAgICAgICAgICBjeS51bmRvUmVkbygpLmRvKFwiYmF0Y2hcIiwgYWN0aW9ucyk7XG4gICAgICB9XG4gIH07XG5cbiAgLypcbiAgKiBUYWtlcyB0aGUgaGlkZGVuIGVsZW1lbnRzIGNsb3NlIHRvIHRoZSBub2RlcyB3aG9zZSBuZWlnaGJvcnMgd2lsbCBiZSBzaG93blxuICAqICovXG4gIG1haW5VdGlsaXRpZXMuY2xvc2VVcEVsZW1lbnRzID0gZnVuY3Rpb24obWFpbkVsZSwgaGlkZGVuRWxlcykge1xuICAgICAgdmFyIGxlZnRYID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgIHZhciByaWdodFggPSBOdW1iZXIuTUlOX1ZBTFVFO1xuICAgICAgdmFyIHRvcFkgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgdmFyIGJvdHRvbVkgPSBOdW1iZXIuTUlOX1ZBTFVFO1xuICAgICAgLy8gQ2hlY2sgdGhlIHggYW5kIHkgbGltaXRzIG9mIGFsbCBoaWRkZW4gZWxlbWVudHMgYW5kIHN0b3JlIHRoZW0gaW4gdGhlIHZhcmlhYmxlcyBhYm92ZVxuICAgICAgaGlkZGVuRWxlcy5mb3JFYWNoKGZ1bmN0aW9uKCBlbGUgKXtcbiAgICAgICAgICBpZiAoZWxlLmRhdGEoJ2NsYXNzJykgIT0gJ2NvbXBhcnRtZW50JyAmJiAgZWxlLmRhdGEoJ2NsYXNzJykgIT0gJ2NvbXBsZXgnKVxuICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIGhhbGZXaWR0aCA9IGVsZS5vdXRlcldpZHRoKCkvMjtcbiAgICAgICAgICAgICAgdmFyIGhhbGZIZWlnaHQgPSBlbGUub3V0ZXJIZWlnaHQoKS8yO1xuICAgICAgICAgICAgICBpZiAoZWxlLnBvc2l0aW9uKFwieFwiKSAtIGhhbGZXaWR0aCA8IGxlZnRYKVxuICAgICAgICAgICAgICAgICAgbGVmdFggPSBlbGUucG9zaXRpb24oXCJ4XCIpIC0gaGFsZldpZHRoO1xuICAgICAgICAgICAgICBpZiAoZWxlLnBvc2l0aW9uKFwieFwiKSArIGhhbGZXaWR0aCA+IHJpZ2h0WClcbiAgICAgICAgICAgICAgICAgIHJpZ2h0WCA9IGVsZS5wb3NpdGlvbihcInhcIikgKyBoYWxmV2lkdGg7XG4gICAgICAgICAgICAgIGlmIChlbGUucG9zaXRpb24oXCJ5XCIpIC0gaGFsZkhlaWdodCA8IHRvcFkpXG4gICAgICAgICAgICAgICAgICB0b3BZID0gZWxlLnBvc2l0aW9uKFwieVwiKSAtIGhhbGZIZWlnaHQ7XG4gICAgICAgICAgICAgIGlmIChlbGUucG9zaXRpb24oXCJ5XCIpICsgaGFsZkhlaWdodCA+IHRvcFkpXG4gICAgICAgICAgICAgICAgICBib3R0b21ZID0gZWxlLnBvc2l0aW9uKFwieVwiKSArIGhhbGZIZWlnaHQ7XG4gICAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vVGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBvbGQgY2VudGVyIGNvbnRhaW5pbmcgdGhlIGhpZGRlbiBub2Rlc1xuICAgICAgdmFyIG9sZENlbnRlclggPSAobGVmdFggKyByaWdodFgpLzI7XG4gICAgICB2YXIgb2xkQ2VudGVyWSA9ICh0b3BZICsgYm90dG9tWSkvMjtcblxuICAgICAgLy9IZXJlIHdlIGNhbGN1bGF0ZSB0d28gcGFyYW1ldGVycyB3aGljaCBkZWZpbmUgdGhlIGFyZWEgaW4gd2hpY2ggdGhlIGhpZGRlbiBlbGVtZW50cyBhcmUgcGxhY2VkIGluaXRpYWxseVxuICAgICAgdmFyIG1pbkhvcml6b250YWxQYXJhbSA9IG1haW5FbGUub3V0ZXJXaWR0aCgpLzIgKyAocmlnaHRYIC0gbGVmdFgpLzI7XG4gICAgICB2YXIgbWF4SG9yaXpvbnRhbFBhcmFtID0gbWFpbkVsZS5vdXRlcldpZHRoKCkgKyAocmlnaHRYIC0gbGVmdFgpLzI7XG4gICAgICB2YXIgbWluVmVydGljYWxQYXJhbSA9IG1haW5FbGUub3V0ZXJIZWlnaHQoKS8yICsgKGJvdHRvbVkgLSB0b3BZKS8yO1xuICAgICAgdmFyIG1heFZlcnRpY2FsUGFyYW0gPSBtYWluRWxlLm91dGVySGVpZ2h0KCkgKyAoYm90dG9tWSAtIHRvcFkpLzI7XG5cbiAgICAgIC8vUXVhZHJhbnRzIGlzIGFuIG9iamVjdCBvZiB0aGUgZm9ybSB7Zmlyc3Q6XCJvYnRhaW5lZFwiLCBzZWNvbmQ6XCJmcmVlXCIsIHRoaXJkOlwiZnJlZVwiLCBmb3VydGg6XCJvYnRhaW5lZFwifVxuICAgICAgLy8gd2hpY2ggaG9sZHMgd2hpY2ggcXVhZHJhbnQgYXJlIGZyZWUgKHRoYXQncyB3aGVyZSBoaWRkZW4gbm9kZXMgd2lsbCBiZSBicm91Z2h0KVxuICAgICAgdmFyIHF1YWRyYW50cyA9IG1haW5VdGlsaXRpZXMuY2hlY2tPY2N1cGllZFF1YWRyYW50cyhtYWluRWxlLCBoaWRkZW5FbGVzKTtcbiAgICAgIHZhciBmcmVlUXVhZHJhbnRzID0gW107XG4gICAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBxdWFkcmFudHMpIHtcbiAgICAgICAgICBpZiAocXVhZHJhbnRzW3Byb3BlcnR5XSA9PT0gXCJmcmVlXCIpXG4gICAgICAgICAgICAgIGZyZWVRdWFkcmFudHMucHVzaChwcm9wZXJ0eSk7XG4gICAgICB9XG5cbiAgICAgIC8vQ2FuIHRha2UgdmFsdWVzIDEgYW5kIC0xIGFuZCBhcmUgdXNlZCB0byBwbGFjZSB0aGUgaGlkZGVuIG5vZGVzIGluIHRoZSByYW5kb20gcXVhZHJhbnRcbiAgICAgIHZhciBob3Jpem9udGFsTXVsdDtcbiAgICAgIHZhciB2ZXJ0aWNhbE11bHQ7XG4gICAgICBpZiAoZnJlZVF1YWRyYW50cy5sZW5ndGggPiAwKVxuICAgICAge1xuICAgICAgICBpZiAoZnJlZVF1YWRyYW50cy5sZW5ndGggPT09IDMpXG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoZnJlZVF1YWRyYW50cy5pbmNsdWRlcygnZmlyc3QnKSAmJiBmcmVlUXVhZHJhbnRzLmluY2x1ZGVzKCdzZWNvbmQnKSAmJiBmcmVlUXVhZHJhbnRzLmluY2x1ZGVzKCd0aGlyZCcpKVxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGhvcml6b250YWxNdWx0ID0gLTE7XG4gICAgICAgICAgICB2ZXJ0aWNhbE11bHQgPSAtMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoZnJlZVF1YWRyYW50cy5pbmNsdWRlcygnZmlyc3QnKSAmJiBmcmVlUXVhZHJhbnRzLmluY2x1ZGVzKCdzZWNvbmQnKSAmJiBmcmVlUXVhZHJhbnRzLmluY2x1ZGVzKCdmb3VydGgnKSlcbiAgICAgICAgICB7XG4gICAgICAgICAgICBob3Jpem9udGFsTXVsdCA9IDE7XG4gICAgICAgICAgICB2ZXJ0aWNhbE11bHQgPSAtMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoZnJlZVF1YWRyYW50cy5pbmNsdWRlcygnZmlyc3QnKSAmJiBmcmVlUXVhZHJhbnRzLmluY2x1ZGVzKCd0aGlyZCcpICYmIGZyZWVRdWFkcmFudHMuaW5jbHVkZXMoJ2ZvdXJ0aCcpKVxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGhvcml6b250YWxNdWx0ID0gMTtcbiAgICAgICAgICAgIHZlcnRpY2FsTXVsdCA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGZyZWVRdWFkcmFudHMuaW5jbHVkZXMoJ3NlY29uZCcpICYmIGZyZWVRdWFkcmFudHMuaW5jbHVkZXMoJ3RoaXJkJykgJiYgZnJlZVF1YWRyYW50cy5pbmNsdWRlcygnZm91cnRoJykpXG4gICAgICAgICAge1xuICAgICAgICAgICAgaG9yaXpvbnRhbE11bHQgPSAtMTtcbiAgICAgICAgICAgIHZlcnRpY2FsTXVsdCA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgIC8vUmFuZG9tbHkgcGlja3Mgb25lIHF1YWRyYW50IGZyb20gdGhlIGZyZWUgcXVhZHJhbnRzXG4gICAgICAgICAgdmFyIHJhbmRvbVF1YWRyYW50ID0gZnJlZVF1YWRyYW50c1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqZnJlZVF1YWRyYW50cy5sZW5ndGgpXTtcblxuICAgICAgICAgIGlmIChyYW5kb21RdWFkcmFudCA9PT0gXCJmaXJzdFwiKSB7XG4gICAgICAgICAgICAgIGhvcml6b250YWxNdWx0ID0gMTtcbiAgICAgICAgICAgICAgdmVydGljYWxNdWx0ID0gLTE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKHJhbmRvbVF1YWRyYW50ID09PSBcInNlY29uZFwiKSB7XG4gICAgICAgICAgICAgIGhvcml6b250YWxNdWx0ID0gLTE7XG4gICAgICAgICAgICAgIHZlcnRpY2FsTXVsdCA9IC0xO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChyYW5kb21RdWFkcmFudCA9PT0gXCJ0aGlyZFwiKSB7XG4gICAgICAgICAgICAgIGhvcml6b250YWxNdWx0ID0gLTE7XG4gICAgICAgICAgICAgIHZlcnRpY2FsTXVsdCA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKHJhbmRvbVF1YWRyYW50ID09PSBcImZvdXJ0aFwiKSB7XG4gICAgICAgICAgICAgIGhvcml6b250YWxNdWx0ID0gMTtcbiAgICAgICAgICAgICAgdmVydGljYWxNdWx0ID0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2VcbiAgICAgIHtcbiAgICAgICAgICBob3Jpem9udGFsTXVsdCA9IDA7XG4gICAgICAgICAgdmVydGljYWxNdWx0ID0gMDtcbiAgICAgIH1cbiAgICAgIC8vIElmIHRoZSBob3Jpem9udGFsTXVsdCBpcyAwIGl0IG1lYW5zIHRoYXQgbm8gcXVhZHJhbnQgaXMgZnJlZSwgc28gd2UgcmFuZG9tbHkgY2hvb3NlIGEgcXVhZHJhbnRcbiAgICAgIHZhciBob3Jpem9udGFsUGFyYW0gPSBtYWluVXRpbGl0aWVzLmdlbmVyYXRlUmFuZG9tKG1pbkhvcml6b250YWxQYXJhbSxtYXhIb3Jpem9udGFsUGFyYW0saG9yaXpvbnRhbE11bHQpO1xuICAgICAgdmFyIHZlcnRpY2FsUGFyYW0gPSBtYWluVXRpbGl0aWVzLmdlbmVyYXRlUmFuZG9tKG1pblZlcnRpY2FsUGFyYW0sbWF4VmVydGljYWxQYXJhbSx2ZXJ0aWNhbE11bHQpO1xuXG4gICAgICAvL1RoZSBjb29yZGluYXRlcyBvZiB0aGUgY2VudGVyIHdoZXJlIHRoZSBoaWRkZW4gbm9kZXMgd2lsbCBiZSB0cmFuc2ZlcmVkXG4gICAgICB2YXIgbmV3Q2VudGVyWCA9IG1haW5FbGUucG9zaXRpb24oXCJ4XCIpICsgaG9yaXpvbnRhbFBhcmFtO1xuICAgICAgdmFyIG5ld0NlbnRlclkgPSBtYWluRWxlLnBvc2l0aW9uKFwieVwiKSArIHZlcnRpY2FsUGFyYW07XG5cbiAgICAgIHZhciB4ZGlmZiA9IG5ld0NlbnRlclggLSBvbGRDZW50ZXJYO1xuICAgICAgdmFyIHlkaWZmID0gbmV3Q2VudGVyWSAtIG9sZENlbnRlclk7XG5cbiAgICAgIC8vQ2hhbmdlIHRoZSBwb3NpdGlvbiBvZiBoaWRkZW4gZWxlbWVudHNcbiAgICAgIGhpZGRlbkVsZXMuZm9yRWFjaChmdW5jdGlvbiggZWxlICl7XG4gICAgICAgICAgdmFyIG5ld3ggPSBlbGUucG9zaXRpb24oXCJ4XCIpICsgeGRpZmY7XG4gICAgICAgICAgdmFyIG5ld3kgPSBlbGUucG9zaXRpb24oXCJ5XCIpICsgeWRpZmY7XG4gICAgICAgICAgZWxlLnBvc2l0aW9uKFwieFwiLCBuZXd4KTtcbiAgICAgICAgICBlbGUucG9zaXRpb24oXCJ5XCIsbmV3eSk7XG4gICAgICB9KTtcbiAgfTtcblxuICAvKlxuICAgKiBHZW5lcmF0ZXMgYSBudW1iZXIgYmV0d2VlbiAyIG5yIGFuZCBtdWx0aW1wbGllcyBpdCB3aXRoIDEgb3IgLTFcbiAgICogKi9cbiAgbWFpblV0aWxpdGllcy5nZW5lcmF0ZVJhbmRvbSA9IGZ1bmN0aW9uKG1pbiwgbWF4LCBtdWx0KSB7XG4gICAgICB2YXIgdmFsID0gWy0xLDFdO1xuICAgICAgaWYgKG11bHQgPT09IDApXG4gICAgICAgICAgbXVsdCA9IHZhbFtNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqdmFsLmxlbmd0aCldO1xuICAgICAgcmV0dXJuIChNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluICsgMSkpICsgbWluKSAqIG11bHQ7XG4gIH07XG5cbiAgLypcbiAgICogVGhpcyBmdW5jdGlvbiBtYWtlcyBzdXJlIHRoYXQgdGhlIHJhbmRvbSBudW1iZXIgbGllcyBpbiBmcmVlIHF1YWRyYW50XG4gICAqICovXG4gIG1haW5VdGlsaXRpZXMuY2hlY2tPY2N1cGllZFF1YWRyYW50cyA9IGZ1bmN0aW9uKG1haW5FbGUsIGhpZGRlbkVsZXMpIHtcbiAgICAgIGlmIChlbGVtZW50VXRpbGl0aWVzLmdldE1hcFR5cGUoKSA9PSAnUEQnKVxuICAgICAge1xuICAgICAgICB2YXIgdmlzaWJsZU5laWdoYm9yRWxlcyA9IG1haW5FbGUubmVpZ2hib3Job29kKCkuZGlmZmVyZW5jZShoaWRkZW5FbGVzKS5ub2RlcygpO1xuICAgICAgICB2YXIgdmlzaWJsZU5laWdoYm9yc09mTmVpZ2hib3JzID0gdmlzaWJsZU5laWdoYm9yRWxlcy5uZWlnaGJvcmhvb2QoKS5kaWZmZXJlbmNlKGhpZGRlbkVsZXMpLmRpZmZlcmVuY2UobWFpbkVsZSkubm9kZXMoKTtcbiAgICAgICAgdmFyIHZpc2libGVFbGVzID0gdmlzaWJsZU5laWdoYm9yRWxlcy51bmlvbih2aXNpYmxlTmVpZ2hib3JzT2ZOZWlnaGJvcnMpO1xuICAgICAgfVxuICAgICAgZWxzZVxuICAgICAgICB2YXIgdmlzaWJsZUVsZXMgPSBtYWluRWxlLm5laWdoYm9yaG9vZCgpLmRpZmZlcmVuY2UoaGlkZGVuRWxlcykubm9kZXMoKTtcbiAgICAgIHZhciBvY2N1cGllZFF1YWRyYW50cyA9IHtmaXJzdDpcImZyZWVcIiwgc2Vjb25kOlwiZnJlZVwiLCB0aGlyZDpcImZyZWVcIiwgZm91cnRoOlwiZnJlZVwifTtcblxuICAgICAgdmlzaWJsZUVsZXMuZm9yRWFjaChmdW5jdGlvbiggZWxlICl7XG4gICAgICAgICAgaWYgKGVsZS5kYXRhKCdjbGFzcycpICE9ICdjb21wYXJ0bWVudCcgJiYgIGVsZS5kYXRhKCdjbGFzcycpICE9ICdjb21wbGV4JylcbiAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlmIChlbGUucG9zaXRpb24oXCJ4XCIpIDwgbWFpbkVsZS5wb3NpdGlvbihcInhcIikgJiYgZWxlLnBvc2l0aW9uKFwieVwiKSA8IG1haW5FbGUucG9zaXRpb24oXCJ5XCIpKVxuICAgICAgICAgICAgICAgICAgb2NjdXBpZWRRdWFkcmFudHMuc2Vjb25kID0gXCJvY2N1cGllZFwiO1xuICAgICAgICAgICAgICBlbHNlIGlmIChlbGUucG9zaXRpb24oXCJ4XCIpID4gbWFpbkVsZS5wb3NpdGlvbihcInhcIikgJiYgZWxlLnBvc2l0aW9uKFwieVwiKSA8IG1haW5FbGUucG9zaXRpb24oXCJ5XCIpKVxuICAgICAgICAgICAgICAgICAgb2NjdXBpZWRRdWFkcmFudHMuZmlyc3QgPSBcIm9jY3VwaWVkXCI7XG4gICAgICAgICAgICAgIGVsc2UgaWYgKGVsZS5wb3NpdGlvbihcInhcIikgPCBtYWluRWxlLnBvc2l0aW9uKFwieFwiKSAmJiBlbGUucG9zaXRpb24oXCJ5XCIpID4gbWFpbkVsZS5wb3NpdGlvbihcInlcIikpXG4gICAgICAgICAgICAgICAgICBvY2N1cGllZFF1YWRyYW50cy50aGlyZCA9IFwib2NjdXBpZWRcIjtcbiAgICAgICAgICAgICAgZWxzZSBpZiAoZWxlLnBvc2l0aW9uKFwieFwiKSA+IG1haW5FbGUucG9zaXRpb24oXCJ4XCIpICYmIGVsZS5wb3NpdGlvbihcInlcIikgPiBtYWluRWxlLnBvc2l0aW9uKFwieVwiKSlcbiAgICAgICAgICAgICAgICAgIG9jY3VwaWVkUXVhZHJhbnRzLmZvdXJ0aCA9IFwib2NjdXBpZWRcIjtcbiAgICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBvY2N1cGllZFF1YWRyYW50cztcbiAgfTtcblxuICAvLyBPdmVycmlkZXMgaGlnaGxpZ2h0UHJvY2Vzc2VzIGZyb20gU0JHTlZJWiAtIGRvIG5vdCBoaWdobGlnaHQgYW55IG5vZGVzIHdoZW4gdGhlIG1hcCB0eXBlIGlzIEFGXG4gIG1haW5VdGlsaXRpZXMuaGlnaGxpZ2h0UHJvY2Vzc2VzID0gZnVuY3Rpb24oX25vZGVzKSB7XG4gICAgaWYgKGVsZW1lbnRVdGlsaXRpZXMuZ2V0TWFwVHlwZSgpID09IFwiQUZcIilcbiAgICAgIHJldHVybjtcbiAgICBzYmdudml6SW5zdGFuY2UuaGlnaGxpZ2h0UHJvY2Vzc2VzKF9ub2Rlcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlc2V0cyBtYXAgdHlwZSB0byB1bmRlZmluZWRcbiAgICovXG4gIG1haW5VdGlsaXRpZXMucmVzZXRNYXBUeXBlID0gZnVuY3Rpb24oKXtcbiAgICBlbGVtZW50VXRpbGl0aWVzLnJlc2V0TWFwVHlwZSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiByZXR1cm4gOiBtYXAgdHlwZVxuICAgKi9cbiAgbWFpblV0aWxpdGllcy5nZXRNYXBUeXBlID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gZWxlbWVudFV0aWxpdGllcy5nZXRNYXBUeXBlKCk7XG4gIH07XG5cbiAgbWFpblV0aWxpdGllcy5hZGRCYWNrZ3JvdW5kSW1hZ2UgPSBmdW5jdGlvbihub2RlcywgYmdPYmosIHVwZGF0ZUluZm8sIHByb21wdEludmFsaWRJbWFnZSwgdmFsaWRhdGVVUkwpe1xuICAgIGlmIChub2Rlcy5sZW5ndGggPT09IDAgfHwgIWJnT2JqKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgYmdPYmpbJ2ZpcnN0VGltZSddID0gdHJ1ZTtcbiAgICBpZiAob3B0aW9ucy51bmRvYWJsZSkge1xuICAgICAgdmFyIHBhcmFtID0ge1xuICAgICAgICBiZ09iajogYmdPYmosXG4gICAgICAgIG5vZGVzOiBub2RlcyxcbiAgICAgICAgdXBkYXRlSW5mbzogdXBkYXRlSW5mbyxcbiAgICAgICAgcHJvbXB0SW52YWxpZEltYWdlOiBwcm9tcHRJbnZhbGlkSW1hZ2UsXG4gICAgICAgIHZhbGlkYXRlVVJMOiB2YWxpZGF0ZVVSTCxcbiAgICAgIH07XG5cbiAgICAgIGN5LnVuZG9SZWRvKCkuZG8oXCJhZGRCYWNrZ3JvdW5kSW1hZ2VcIiwgcGFyYW0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGVsZW1lbnRVdGlsaXRpZXMuYWRkQmFja2dyb3VuZEltYWdlKG5vZGVzLCBiZ09iaiwgdXBkYXRlSW5mbywgcHJvbXB0SW52YWxpZEltYWdlLCB2YWxpZGF0ZVVSTCk7XG4gICAgfVxuXG4gICAgY3kuc3R5bGUoKS51cGRhdGUoKTtcbiAgfVxuXG4gIG1haW5VdGlsaXRpZXMucmVtb3ZlQmFja2dyb3VuZEltYWdlID0gZnVuY3Rpb24obm9kZXMsIGJnT2JqKXtcbiAgICBpZiAobm9kZXMubGVuZ3RoID09PSAwIHx8ICFiZ09iaikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGJnT2JqWydmaXJzdFRpbWUnXSA9IHRydWU7XG4gICAgaWYgKG9wdGlvbnMudW5kb2FibGUpIHtcbiAgICAgIHZhciBwYXJhbSA9IHtcbiAgICAgICAgYmdPYmo6IGJnT2JqLFxuICAgICAgICBub2Rlczogbm9kZXNcbiAgICAgIH07XG5cbiAgICAgIGN5LnVuZG9SZWRvKCkuZG8oXCJyZW1vdmVCYWNrZ3JvdW5kSW1hZ2VcIiwgcGFyYW0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGVsZW1lbnRVdGlsaXRpZXMucmVtb3ZlQmFja2dyb3VuZEltYWdlKG5vZGVzLCBiZ09iaik7XG4gICAgfVxuXG4gICAgY3kuc3R5bGUoKS51cGRhdGUoKTtcbiAgfVxuXG4gIG1haW5VdGlsaXRpZXMudXBkYXRlQmFja2dyb3VuZEltYWdlID0gZnVuY3Rpb24obm9kZXMsIGJnT2JqKXtcbiAgICBpZiAobm9kZXMubGVuZ3RoID09PSAwIHx8ICFiZ09iaikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnVuZG9hYmxlKSB7XG4gICAgICB2YXIgcGFyYW0gPSB7XG4gICAgICAgIGJnT2JqOiBiZ09iaixcbiAgICAgICAgbm9kZXM6IG5vZGVzXG4gICAgICB9O1xuXG4gICAgICBjeS51bmRvUmVkbygpLmRvKFwidXBkYXRlQmFja2dyb3VuZEltYWdlXCIsIHBhcmFtKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBlbGVtZW50VXRpbGl0aWVzLnVwZGF0ZUJhY2tncm91bmRJbWFnZShub2RlcywgYmdPYmopO1xuICAgIH1cblxuICAgIGN5LnN0eWxlKCkudXBkYXRlKCk7XG4gIH1cblxuICBtYWluVXRpbGl0aWVzLmNoYW5nZUJhY2tncm91bmRJbWFnZSA9IGZ1bmN0aW9uKG5vZGVzLCBvbGRJbWcsIG5ld0ltZywgdXBkYXRlSW5mbywgcHJvbXB0SW52YWxpZEltYWdlLCB2YWxpZGF0ZVVSTCl7XG4gICAgaWYgKG5vZGVzLmxlbmd0aCA9PT0gMCB8fCAhb2xkSW1nIHx8ICFuZXdJbWcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy51bmRvYWJsZSkge1xuICAgICAgdmFyIHBhcmFtID0ge1xuICAgICAgICBvbGRJbWc6IG9sZEltZyxcbiAgICAgICAgbmV3SW1nOiBuZXdJbWcsXG4gICAgICAgIG5vZGVzOiBub2RlcyxcbiAgICAgICAgZmlyc3RUaW1lOiB0cnVlLFxuICAgICAgICB1cGRhdGVJbmZvOiB1cGRhdGVJbmZvLFxuICAgICAgICBwcm9tcHRJbnZhbGlkSW1hZ2U6IHByb21wdEludmFsaWRJbWFnZSxcbiAgICAgICAgdmFsaWRhdGVVUkw6IHZhbGlkYXRlVVJMXG4gICAgICB9O1xuXG4gICAgICBjeS51bmRvUmVkbygpLmRvKFwiY2hhbmdlQmFja2dyb3VuZEltYWdlXCIsIHBhcmFtKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBlbGVtZW50VXRpbGl0aWVzLmNoYW5nZUJhY2tncm91bmRJbWFnZShub2Rlcywgb2xkSW1nLCBuZXdJbWcsIHRydWUsIHVwZGF0ZUluZm8sIHByb21wdEludmFsaWRJbWFnZSwgdmFsaWRhdGVVUkwpO1xuICAgIH1cblxuICAgIGN5LnN0eWxlKCkudXBkYXRlKCk7XG4gIH1cblxuICByZXR1cm4gbWFpblV0aWxpdGllcztcbn07XG4iXSwibmFtZXMiOlsibGlicyIsInJlcXVpcmUiLCJnZXRMaWJzIiwibW9kdWxlIiwiZXhwb3J0cyIsImVsZW1lbnRVdGlsaXRpZXMiLCJvcHRpb25zIiwiY3kiLCJzYmdudml6SW5zdGFuY2UiLCJtYWluVXRpbGl0aWVzIiwicGFyYW0iLCJvcHRpb25VdGlsaXRpZXMiLCJnZXRPcHRpb25zIiwic2JnbnZpekluc3RhbmNlVXRpbGl0aWVzIiwiZ2V0Q3kiLCJnZXRJbnN0YW5jZSIsImFkZE5vZGUiLCJ4IiwieSIsIm5vZGVQYXJhbXMiLCJpZCIsInBhcmVudCIsInZpc2liaWxpdHkiLCJpc0dyYXBoVG9wb2xvZ3lMb2NrZWQiLCJ1bmRvYWJsZSIsIm5ld05vZGUiLCJyZXN1bHQiLCJ1bmRvUmVkbyIsImVsZXMiLCJhZGRFZGdlIiwic291cmNlIiwidGFyZ2V0IiwiZWRnZVBhcmFtcyIsImludmFsaWRFZGdlQ2FsbGJhY2siLCJlZGdlY2xhc3MiLCJ2YWxpZGF0aW9uIiwidmFsaWRhdGVBcnJvd0VuZHMiLCJnZXRFbGVtZW50QnlJZCIsInRlbXAiLCJuZXdFZGdlIiwiYWRkUHJvY2Vzc1dpdGhDb252ZW5pZW50RWRnZXMiLCJfc291cmNlIiwiX3RhcmdldCIsInByb2Nlc3NUeXBlIiwiaXNFUE5DbGFzcyIsImNsb25lQ29sbGFwc2VkTm9kZXNBbmRQb3J0cyIsImVsZXNCZWZvcmUiLCJlbGVtZW50cyIsInVuc2VsZWN0IiwiZWxlc0FmdGVyIiwiZWxlc0RpZmYiLCJkaWZmIiwibGVmdCIsImNvbGxhcHNlZE5vZGVzIiwiZmlsdGVyIiwiY29ubmVjdGVkRWRnZXMiLCJyZW1vdmUiLCJyZW1vdmVDbGFzcyIsInJlbW92ZURhdGEiLCJub2RlcyIsImZvckVhY2giLCJfbm9kZSIsImRhdGEiLCJsZW5ndGgiLCJvbGRQb3J0TmFtZTAiLCJvbGRQb3J0TmFtZTEiLCJvdXRnb2VycyIsImVkZ2VzIiwiX2VkZ2UiLCJpbmNvbWVycyIsInNlbGVjdCIsImNsb25lRWxlbWVudHMiLCJwYXN0ZUF0TW91c2VMb2MiLCJjb3B5RWxlbWVudHMiLCJwYXN0ZUVsZW1lbnRzIiwiY2xpcGJvYXJkIiwiY29weSIsInBhc3RlIiwiZW1pdCIsImFsaWduIiwiaG9yaXpvbnRhbCIsInZlcnRpY2FsIiwiYWxpZ25UbyIsImNyZWF0ZUNvbXBvdW5kRm9yR2l2ZW5Ob2RlcyIsIl9ub2RlcyIsImNvbXBvdW5kVHlwZSIsImVsZW1lbnQiLCJpIiwic2JnbmNsYXNzIiwiaXNWYWxpZFBhcmVudCIsImdldFRvcE1vc3ROb2RlcyIsImFsbEhhdmVUaGVTYW1lUGFyZW50Iiwic3RhcnRzV2l0aCIsIm5vZGVzVG9NYWtlQ29tcG91bmQiLCJjaGFuZ2VQYXJlbnQiLCJfbmV3UGFyZW50IiwicG9zRGlmZlgiLCJwb3NEaWZmWSIsIm5ld1BhcmVudCIsImVsZSIsImRpZmZlcmVuY2UiLCJhbmNlc3RvcnMiLCJwYXJlbnRJZCIsImZpcnN0VGltZSIsInBhcmVudERhdGEiLCJjYWxsYmFjayIsIm1haW50YWluUG9pbnRlciIsImNyZWF0ZVRyYW5zbGF0aW9uUmVhY3Rpb24iLCJtUm5hTmFtZSIsInByb3RlaW5OYW1lIiwicHJvY2Vzc1Bvc2l0aW9uIiwiZWRnZUxlbmd0aCIsImNyZWF0ZVRyYW5zY3JpcHRpb25SZWFjdGlvbiIsImdlbmVOYW1lIiwiY3JlYXRlVHJhbnNsYXRpb24iLCJyZWd1bGF0b3JMYWJlbCIsIm91dHB1dExhYmVsIiwib3JpZW50YXRpb24iLCJjcmVhdGVUcmFuc2NyaXB0aW9uIiwibGFiZWwiLCJjcmVhdGVEZWdyYWRhdGlvbiIsIm1hY3JvbW9sZWN1bGUiLCJjcmVhdGVDb21wbGV4UHJvdGVpbkZvcm1hdGlvbiIsInByb3RlaW5MYWJlbHMiLCJjb21wbGV4TGFiZWwiLCJyZWd1bGF0b3IiLCJyZXZlcnNlIiwiY3JlYXRlTXVsdGltZXJpemF0aW9uIiwicmVndWxhdG9yTXVsdGltZXIiLCJjcmVhdGVDb252ZXJzaW9uIiwiaW5wdXRJbmZvYm94TGFiZWxzIiwib3V0cHV0SW5mb2JveExhYmVscyIsImNyZWF0ZU1ldGFib2xpY1JlYWN0aW9uIiwiaW5wdXRzIiwib3V0cHV0cyIsInJldmVyc2libGUiLCJjcmVhdGVNZXRhYm9saWNDYXRhbHl0aWNBY3Rpdml0eSIsImlucHV0Tm9kZUxpc3QiLCJvdXRwdXROb2RlTGlzdCIsImNhdGFseXN0TmFtZSIsImNhdGFseXN0VHlwZSIsInRpbGluZ1BhZGRpbmdWZXJ0aWNhbCIsInRpbGluZ1BhZGRpbmdIb3Jpem9udGFsIiwiY3JlYXRlQWN0aXZhdGlvblJlYWN0aW9uIiwiY3JlYXRlVGVtcGxhdGVSZWFjdGlvbiIsInRlbXBsYXRlVHlwZSIsIm1hY3JvbW9sZWN1bGVMaXN0IiwiY29tcGxleE5hbWUiLCJsYXlvdXRQYXJhbSIsInNldE1hcFR5cGUiLCJhY3Rpb25zIiwicHVzaCIsIm5hbWUiLCJtYXBUeXBlIiwicmVzaXplTm9kZXMiLCJ3aWR0aCIsImhlaWdodCIsInVzZUFzcGVjdFJhdGlvIiwicHJlc2VydmVSZWxhdGl2ZVBvcyIsInBlcmZvcm1PcGVyYXRpb24iLCJzdHlsZSIsInVwZGF0ZSIsInJlc2l6ZU5vZGVzVG9Db250ZW50Iiwibm9kZSIsImNhbGN1bGF0ZU1pbldpZHRoIiwiY2FsY3VsYXRlTWluSGVpZ2h0Iiwic3RhdGVBbmRJbmZvcyIsImxvY2F0aW9ucyIsImNoYW5nZU5vZGVMYWJlbCIsImNoYW5nZUZvbnRQcm9wZXJ0aWVzIiwiY2hhbmdlU3RhdGVPckluZm9Cb3giLCJpbmRleCIsInZhbHVlIiwidHlwZSIsImFkZFN0YXRlT3JJbmZvQm94Iiwib2JqIiwicmVtb3ZlU3RhdGVPckluZm9Cb3giLCJsb2NhdGlvbk9iaiIsImZpdFVuaXRzIiwidW5kZWZpbmVkIiwic2V0TXVsdGltZXJTdGF0dXMiLCJzdGF0dXMiLCJzZXRBY3RpdmVTdGF0dXMiLCJzZXRIeXBvdGhldGljYWxTdGF0dXMiLCJyZWRyYXdDbG9uZU1hcmtlcnMiLCJzZXRDbG9uZU1hcmtlclN0YXR1cyIsImNoYW5nZUNzcyIsInZhbHVlTWFwIiwiY2hhbmdlRGF0YSIsInVwZGF0ZVNldEZpZWxkIiwiZmllbGROYW1lIiwidG9EZWxldGUiLCJ0b0FkZCIsInNldERlZmF1bHRQcm9wZXJ0eSIsIl9jbGFzcyIsInByb3BNYXAiLCJzZXREZWZhdWx0UHJvcGVydGllcyIsInVwZGF0ZUluZm9ib3hTdHlsZSIsIm5ld1Byb3BzIiwidXBkYXRlSW5mb2JveE9iaiIsImRlbGV0ZUFuZFBlcmZvcm1MYXlvdXQiLCJsYXlvdXRwYXJhbSIsImFsbE5vZGVzIiwibm9kZXNUb0tlZXAiLCJleHRlbmRSZW1haW5pbmdOb2RlcyIsIm5vZGVzVG9SZW1vdmUiLCJub3QiLCJoaWRlQW5kUGVyZm9ybUxheW91dCIsIm5vZGVzVG9TaG93Iiwibm9kZXNUb0hpZGUiLCJub2Rlc1dpdGhIaWRkZW5OZWlnaGJvciIsImNvbm5lY3RlZE5vZGVzIiwidGhpbkJvcmRlciIsInRoaWNrZW5Cb3JkZXIiLCJ1ciIsImFjdGlvbiIsImludGVyc2VjdGlvbiIsIm5laWdoYm9yaG9vZCIsInNob3dBbGxBbmRQZXJmb3JtTGF5b3V0IiwiaGlkZGVuRWxlcyIsInNob3dBbmRQZXJmb3JtTGF5b3V0IiwibWFpbkVsZSIsImNsb3NlVXBFbGVtZW50cyIsIm5vZGVzVG9UaGluQm9yZGVyIiwidW5pb24iLCJub2Rlc1RvVGhpY2tlbkJvcmRlciIsImVkZ2VzV2l0aCIsImxlZnRYIiwiTnVtYmVyIiwiTUFYX1ZBTFVFIiwicmlnaHRYIiwiTUlOX1ZBTFVFIiwidG9wWSIsImJvdHRvbVkiLCJoYWxmV2lkdGgiLCJvdXRlcldpZHRoIiwiaGFsZkhlaWdodCIsIm91dGVySGVpZ2h0IiwicG9zaXRpb24iLCJvbGRDZW50ZXJYIiwib2xkQ2VudGVyWSIsIm1pbkhvcml6b250YWxQYXJhbSIsIm1heEhvcml6b250YWxQYXJhbSIsIm1pblZlcnRpY2FsUGFyYW0iLCJtYXhWZXJ0aWNhbFBhcmFtIiwicXVhZHJhbnRzIiwiY2hlY2tPY2N1cGllZFF1YWRyYW50cyIsImZyZWVRdWFkcmFudHMiLCJwcm9wZXJ0eSIsImhvcml6b250YWxNdWx0IiwidmVydGljYWxNdWx0IiwiaW5jbHVkZXMiLCJyYW5kb21RdWFkcmFudCIsIk1hdGgiLCJmbG9vciIsInJhbmRvbSIsImhvcml6b250YWxQYXJhbSIsImdlbmVyYXRlUmFuZG9tIiwidmVydGljYWxQYXJhbSIsIm5ld0NlbnRlclgiLCJuZXdDZW50ZXJZIiwieGRpZmYiLCJ5ZGlmZiIsIm5ld3giLCJuZXd5IiwibWluIiwibWF4IiwibXVsdCIsInZhbCIsImdldE1hcFR5cGUiLCJ2aXNpYmxlTmVpZ2hib3JFbGVzIiwidmlzaWJsZU5laWdoYm9yc09mTmVpZ2hib3JzIiwidmlzaWJsZUVsZXMiLCJvY2N1cGllZFF1YWRyYW50cyIsImZpcnN0Iiwic2Vjb25kIiwidGhpcmQiLCJmb3VydGgiLCJoaWdobGlnaHRQcm9jZXNzZXMiLCJyZXNldE1hcFR5cGUiLCJhZGRCYWNrZ3JvdW5kSW1hZ2UiLCJiZ09iaiIsInVwZGF0ZUluZm8iLCJwcm9tcHRJbnZhbGlkSW1hZ2UiLCJ2YWxpZGF0ZVVSTCIsInJlbW92ZUJhY2tncm91bmRJbWFnZSIsInVwZGF0ZUJhY2tncm91bmRJbWFnZSIsImNoYW5nZUJhY2tncm91bmRJbWFnZSIsIm9sZEltZyIsIm5ld0ltZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/utilities/main-utilities-factory.js\n");

/***/ }),

/***/ "./src/utilities/option-utilities-factory.js":
/*!***************************************************!*\
  !*** ./src/utilities/option-utilities-factory.js ***!
  \***************************************************/
/***/ ((module) => {

eval("/*\n *  Extend default options and get current options by using this file\n */\nmodule.exports = function () {\n  // default options\n  var defaults = {\n    // The path of core library images when sbgnviz is required from npm and the index html\n    // file and node_modules are under the same folder then using the default value is fine\n    imgPath: 'node_modules/sbgnviz/src/img',\n    // Whether to fit labels to nodes\n    fitLabelsToNodes: function fitLabelsToNodes() {\n      return false;\n    },\n    fitLabelsToInfoboxes: function fitLabelsToInfoboxes() {\n      return false;\n    },\n    // dynamic label size it may be 'small', 'regular', 'large'\n    dynamicLabelSize: function dynamicLabelSize() {\n      return 'regular';\n    },\n    // Whether to infer nesting on load \n    inferNestingOnLoad: function inferNestingOnLoad() {\n      return false;\n    },\n    // percentage used to calculate compound paddings\n    compoundPadding: function compoundPadding() {\n      return 10;\n    },\n    // The selector of the component containing the sbgn network\n    networkContainerSelector: '#sbgn-network-container',\n    // Whether the actions are undoable, requires cytoscape-undo-redo extension\n    undoable: true,\n    // Whether to have undoable drag feature in undo/redo extension. This options will be passed to undo/redo extension\n    undoableDrag: true\n  };\n\n  var optionUtilities = function optionUtilities() {}; // Extend the defaults options with the user options\n\n\n  optionUtilities.extendOptions = function (options) {\n    var result = {};\n\n    for (var prop in defaults) {\n      result[prop] = defaults[prop];\n    }\n\n    for (var prop in options) {\n      result[prop] = options[prop];\n    }\n\n    optionUtilities.options = result;\n    return options;\n  };\n\n  optionUtilities.getOptions = function () {\n    return optionUtilities.options;\n  };\n\n  return optionUtilities;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdXRpbGl0aWVzL29wdGlvbi11dGlsaXRpZXMtZmFjdG9yeS5qcy5qcyIsIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJkZWZhdWx0cyIsImltZ1BhdGgiLCJmaXRMYWJlbHNUb05vZGVzIiwiZml0TGFiZWxzVG9JbmZvYm94ZXMiLCJkeW5hbWljTGFiZWxTaXplIiwiaW5mZXJOZXN0aW5nT25Mb2FkIiwiY29tcG91bmRQYWRkaW5nIiwibmV0d29ya0NvbnRhaW5lclNlbGVjdG9yIiwidW5kb2FibGUiLCJ1bmRvYWJsZURyYWciLCJvcHRpb25VdGlsaXRpZXMiLCJleHRlbmRPcHRpb25zIiwib3B0aW9ucyIsInJlc3VsdCIsInByb3AiLCJnZXRPcHRpb25zIl0sInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jaGlzZS8uL3NyYy91dGlsaXRpZXMvb3B0aW9uLXV0aWxpdGllcy1mYWN0b3J5LmpzPzllNDciXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqICBFeHRlbmQgZGVmYXVsdCBvcHRpb25zIGFuZCBnZXQgY3VycmVudCBvcHRpb25zIGJ5IHVzaW5nIHRoaXMgZmlsZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuXG4gIC8vIGRlZmF1bHQgb3B0aW9uc1xuICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgLy8gVGhlIHBhdGggb2YgY29yZSBsaWJyYXJ5IGltYWdlcyB3aGVuIHNiZ252aXogaXMgcmVxdWlyZWQgZnJvbSBucG0gYW5kIHRoZSBpbmRleCBodG1sXG4gICAgLy8gZmlsZSBhbmQgbm9kZV9tb2R1bGVzIGFyZSB1bmRlciB0aGUgc2FtZSBmb2xkZXIgdGhlbiB1c2luZyB0aGUgZGVmYXVsdCB2YWx1ZSBpcyBmaW5lXG4gICAgaW1nUGF0aDogJ25vZGVfbW9kdWxlcy9zYmdudml6L3NyYy9pbWcnLFxuICAgIC8vIFdoZXRoZXIgdG8gZml0IGxhYmVscyB0byBub2Rlc1xuICAgIGZpdExhYmVsc1RvTm9kZXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIGZpdExhYmVsc1RvSW5mb2JveGVzOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICAvLyBkeW5hbWljIGxhYmVsIHNpemUgaXQgbWF5IGJlICdzbWFsbCcsICdyZWd1bGFyJywgJ2xhcmdlJ1xuICAgIGR5bmFtaWNMYWJlbFNpemU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAncmVndWxhcic7XG4gICAgfSxcbiAgICAvLyBXaGV0aGVyIHRvIGluZmVyIG5lc3Rpbmcgb24gbG9hZCBcbiAgICBpbmZlck5lc3RpbmdPbkxvYWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIC8vIHBlcmNlbnRhZ2UgdXNlZCB0byBjYWxjdWxhdGUgY29tcG91bmQgcGFkZGluZ3NcbiAgICBjb21wb3VuZFBhZGRpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAxMDtcbiAgICB9LFxuICAgIC8vIFRoZSBzZWxlY3RvciBvZiB0aGUgY29tcG9uZW50IGNvbnRhaW5pbmcgdGhlIHNiZ24gbmV0d29ya1xuICAgIG5ldHdvcmtDb250YWluZXJTZWxlY3RvcjogJyNzYmduLW5ldHdvcmstY29udGFpbmVyJyxcbiAgICAvLyBXaGV0aGVyIHRoZSBhY3Rpb25zIGFyZSB1bmRvYWJsZSwgcmVxdWlyZXMgY3l0b3NjYXBlLXVuZG8tcmVkbyBleHRlbnNpb25cbiAgICB1bmRvYWJsZTogdHJ1ZSxcbiAgICAvLyBXaGV0aGVyIHRvIGhhdmUgdW5kb2FibGUgZHJhZyBmZWF0dXJlIGluIHVuZG8vcmVkbyBleHRlbnNpb24uIFRoaXMgb3B0aW9ucyB3aWxsIGJlIHBhc3NlZCB0byB1bmRvL3JlZG8gZXh0ZW5zaW9uXG4gICAgdW5kb2FibGVEcmFnOiB0cnVlXG4gIH07XG5cbiAgdmFyIG9wdGlvblV0aWxpdGllcyA9IGZ1bmN0aW9uICgpIHtcbiAgfTtcblxuICAvLyBFeHRlbmQgdGhlIGRlZmF1bHRzIG9wdGlvbnMgd2l0aCB0aGUgdXNlciBvcHRpb25zXG4gIG9wdGlvblV0aWxpdGllcy5leHRlbmRPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG5cbiAgICBmb3IgKHZhciBwcm9wIGluIGRlZmF1bHRzKSB7XG4gICAgICByZXN1bHRbcHJvcF0gPSBkZWZhdWx0c1twcm9wXTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBwcm9wIGluIG9wdGlvbnMpIHtcbiAgICAgIHJlc3VsdFtwcm9wXSA9IG9wdGlvbnNbcHJvcF07XG4gICAgfVxuXG4gICAgb3B0aW9uVXRpbGl0aWVzLm9wdGlvbnMgPSByZXN1bHQ7XG5cbiAgICByZXR1cm4gb3B0aW9ucztcbiAgfTtcblxuICBvcHRpb25VdGlsaXRpZXMuZ2V0T3B0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gb3B0aW9uVXRpbGl0aWVzLm9wdGlvbnM7XG4gIH07XG5cbiAgcmV0dXJuIG9wdGlvblV0aWxpdGllcztcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUVBQSxNQUFNLENBQUNDLE9BQVAsR0FBaUIsWUFBWTtFQUUzQjtFQUNBLElBQUlDLFFBQVEsR0FBRztJQUNiO0lBQ0E7SUFDQUMsT0FBTyxFQUFFLDhCQUhJO0lBSWI7SUFDQUMsZ0JBQWdCLEVBQUUsNEJBQVk7TUFDNUIsT0FBTyxLQUFQO0lBQ0QsQ0FQWTtJQVFiQyxvQkFBb0IsRUFBRSxnQ0FBWTtNQUNoQyxPQUFPLEtBQVA7SUFDRCxDQVZZO0lBV2I7SUFDQUMsZ0JBQWdCLEVBQUUsNEJBQVk7TUFDNUIsT0FBTyxTQUFQO0lBQ0QsQ0FkWTtJQWViO0lBQ0FDLGtCQUFrQixFQUFFLDhCQUFZO01BQzlCLE9BQU8sS0FBUDtJQUNELENBbEJZO0lBbUJiO0lBQ0FDLGVBQWUsRUFBRSwyQkFBWTtNQUMzQixPQUFPLEVBQVA7SUFDRCxDQXRCWTtJQXVCYjtJQUNBQyx3QkFBd0IsRUFBRSx5QkF4QmI7SUF5QmI7SUFDQUMsUUFBUSxFQUFFLElBMUJHO0lBMkJiO0lBQ0FDLFlBQVksRUFBRTtFQTVCRCxDQUFmOztFQStCQSxJQUFJQyxlQUFlLEdBQUcsU0FBbEJBLGVBQWtCLEdBQVksQ0FDakMsQ0FERCxDQWxDMkIsQ0FxQzNCOzs7RUFDQUEsZUFBZSxDQUFDQyxhQUFoQixHQUFnQyxVQUFVQyxPQUFWLEVBQW1CO0lBQ2pELElBQUlDLE1BQU0sR0FBRyxFQUFiOztJQUVBLEtBQUssSUFBSUMsSUFBVCxJQUFpQmQsUUFBakIsRUFBMkI7TUFDekJhLE1BQU0sQ0FBQ0MsSUFBRCxDQUFOLEdBQWVkLFFBQVEsQ0FBQ2MsSUFBRCxDQUF2QjtJQUNEOztJQUVELEtBQUssSUFBSUEsSUFBVCxJQUFpQkYsT0FBakIsRUFBMEI7TUFDeEJDLE1BQU0sQ0FBQ0MsSUFBRCxDQUFOLEdBQWVGLE9BQU8sQ0FBQ0UsSUFBRCxDQUF0QjtJQUNEOztJQUVESixlQUFlLENBQUNFLE9BQWhCLEdBQTBCQyxNQUExQjtJQUVBLE9BQU9ELE9BQVA7RUFDRCxDQWREOztFQWdCQUYsZUFBZSxDQUFDSyxVQUFoQixHQUE2QixZQUFZO0lBQ3ZDLE9BQU9MLGVBQWUsQ0FBQ0UsT0FBdkI7RUFDRCxDQUZEOztFQUlBLE9BQU9GLGVBQVA7QUFDRCxDQTNERCJ9\n//# sourceURL=webpack-internal:///./src/utilities/option-utilities-factory.js\n");

/***/ }),

/***/ "./src/utilities/register-undo-redo-actions-factory.js":
/*!*************************************************************!*\
  !*** ./src/utilities/register-undo-redo-actions-factory.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var libs = (__webpack_require__(/*! ./lib-utilities */ \"./src/utilities/lib-utilities.js\").getLibs)();\n\nvar $ = libs.jQuery;\n\nmodule.exports = function () {\n  var undoRedoActionFunctions, options, cy;\n\n  var registerUndoRedoActions = function registerUndoRedoActions(param) {\n    undoRedoActionFunctions = param.undoRedoActionFunctions;\n    options = param.optionUtilities.getOptions();\n    cy = param.sbgnvizInstanceUtilities.getCy();\n\n    if (!options.undoable) {\n      return;\n    } // create undo-redo instance\n\n\n    var ur = cy.undoRedo({\n      undoableDrag: options.undoableDrag\n    }); // register add remove actions\n\n    ur.action(\"addNode\", undoRedoActionFunctions.addNode, undoRedoActionFunctions.deleteElesSimple);\n    ur.action(\"deleteElesSimple\", undoRedoActionFunctions.deleteElesSimple, undoRedoActionFunctions.restoreEles);\n    ur.action(\"addEdge\", undoRedoActionFunctions.addEdge, undoRedoActionFunctions.deleteElesSimple);\n    ur.action(\"addProcessWithConvenientEdges\", undoRedoActionFunctions.addProcessWithConvenientEdges, undoRedoActionFunctions.deleteElesSimple);\n    ur.action(\"deleteElesSmart\", undoRedoActionFunctions.deleteElesSmart, undoRedoActionFunctions.restoreEles);\n    ur.action(\"createCompoundForGivenNodes\", undoRedoActionFunctions.createCompoundForGivenNodes, undoRedoActionFunctions.createCompoundForGivenNodes); // register general actions\n\n    ur.action(\"resizeNodes\", undoRedoActionFunctions.resizeNodes, undoRedoActionFunctions.resizeNodes);\n    ur.action(\"changeNodeLabel\", undoRedoActionFunctions.changeNodeLabel, undoRedoActionFunctions.changeNodeLabel);\n    ur.action(\"changeData\", undoRedoActionFunctions.changeData, undoRedoActionFunctions.changeData);\n    ur.action(\"updateSetField\", undoRedoActionFunctions.updateSetField, undoRedoActionFunctions.updateSetField);\n    ur.action(\"changeCss\", undoRedoActionFunctions.changeCss, undoRedoActionFunctions.changeCss);\n    ur.action(\"changeBendPoints\", undoRedoActionFunctions.changeBendPoints, undoRedoActionFunctions.changeBendPoints);\n    ur.action(\"changeFontProperties\", undoRedoActionFunctions.changeFontProperties, undoRedoActionFunctions.changeFontProperties);\n    ur.action(\"showAndPerformLayout\", undoRedoActionFunctions.showAndPerformLayout, undoRedoActionFunctions.undoShowAndPerformLayout);\n    ur.action(\"hideAndPerformLayout\", undoRedoActionFunctions.hideAndPerformLayout, undoRedoActionFunctions.undoHideAndPerformLayout);\n    ur.action(\"deleteAndPerformLayout\", undoRedoActionFunctions.deleteAndPerformLayout, undoRedoActionFunctions.undoDeleteAndPerformLayout);\n    ur.action(\"applySIFTopologyGrouping\", undoRedoActionFunctions.applySIFTopologyGrouping, undoRedoActionFunctions.applySIFTopologyGrouping); // register SBGN actions\n\n    ur.action(\"addStateOrInfoBox\", undoRedoActionFunctions.addStateOrInfoBox, undoRedoActionFunctions.removeStateOrInfoBox);\n    ur.action(\"changeStateOrInfoBox\", undoRedoActionFunctions.changeStateOrInfoBox, undoRedoActionFunctions.changeStateOrInfoBox);\n    ur.action(\"setMultimerStatus\", undoRedoActionFunctions.setMultimerStatus, undoRedoActionFunctions.setMultimerStatus);\n    ur.action(\"setActiveStatus\", undoRedoActionFunctions.setActiveStatus, undoRedoActionFunctions.setActiveStatus);\n    ur.action(\"setHypotheticalStatus\", undoRedoActionFunctions.setHypotheticalStatus, undoRedoActionFunctions.setHypotheticalStatus);\n    ur.action(\"setCloneMarkerStatus\", undoRedoActionFunctions.setCloneMarkerStatus, undoRedoActionFunctions.setCloneMarkerStatus);\n    ur.action(\"removeStateOrInfoBox\", undoRedoActionFunctions.removeStateOrInfoBox, undoRedoActionFunctions.addStateOrInfoBox);\n    ur.action(\"fitUnits\", undoRedoActionFunctions.fitUnits, undoRedoActionFunctions.restoreUnits);\n    ur.action(\"addBackgroundImage\", undoRedoActionFunctions.addBackgroundImage, undoRedoActionFunctions.removeBackgroundImage);\n    ur.action(\"removeBackgroundImage\", undoRedoActionFunctions.removeBackgroundImage, undoRedoActionFunctions.addBackgroundImage);\n    ur.action(\"updateBackgroundImage\", undoRedoActionFunctions.updateBackgroundImage, undoRedoActionFunctions.updateBackgroundImage);\n    ur.action(\"changeBackgroundImage\", undoRedoActionFunctions.changeBackgroundImage, undoRedoActionFunctions.changeBackgroundImage);\n    ur.action(\"updateInfoboxStyle\", undoRedoActionFunctions.updateInfoboxStyle, undoRedoActionFunctions.updateInfoboxStyle);\n    ur.action(\"updateInfoboxObj\", undoRedoActionFunctions.updateInfoboxObj, undoRedoActionFunctions.updateInfoboxObj); // register easy creation actions\n\n    ur.action(\"createTemplateReaction\", undoRedoActionFunctions.createTemplateReaction, undoRedoActionFunctions.deleteElesSimple);\n    ur.action(\"createActivationReaction\", undoRedoActionFunctions.createActivationReaction, undoRedoActionFunctions.deleteElesSimple);\n    ur.action(\"createMetabolicCatalyticActivity\", undoRedoActionFunctions.createMetabolicCatalyticActivity, undoRedoActionFunctions.deleteElesSimple);\n    ur.action(\"createMetabolicReaction\", undoRedoActionFunctions.createMetabolicReaction, undoRedoActionFunctions.deleteElesSimple);\n    ur.action(\"createConversion\", undoRedoActionFunctions.createConversion, undoRedoActionFunctions.deleteElesSimple);\n    ur.action(\"createMultimerization\", undoRedoActionFunctions.createMultimerization, undoRedoActionFunctions.deleteElesSimple);\n    ur.action(\"createComplexProteinFormation\", undoRedoActionFunctions.createComplexProteinFormation, undoRedoActionFunctions.deleteElesSimple);\n    ur.action(\"createDegradation\", undoRedoActionFunctions.createDegradation, undoRedoActionFunctions.deleteElesSimple);\n    ur.action(\"createTranscription\", undoRedoActionFunctions.createTranscription, undoRedoActionFunctions.deleteElesSimple);\n    ur.action(\"createTranslation\", undoRedoActionFunctions.createTranslation, undoRedoActionFunctions.deleteElesSimple);\n    ur.action(\"createTranscriptionReaction\", undoRedoActionFunctions.createTranscriptionReaction, undoRedoActionFunctions.deleteElesSimple);\n    ur.action(\"createTranslationReaction\", undoRedoActionFunctions.createTranslationReaction, undoRedoActionFunctions.deleteElesSimple);\n    ur.action(\"setDefaultProperty\", undoRedoActionFunctions.setDefaultProperty, undoRedoActionFunctions.setDefaultProperty);\n    ur.action(\"convertIntoReversibleReaction\", undoRedoActionFunctions.convertIntoReversibleReaction, undoRedoActionFunctions.convertIntoReversibleReaction);\n    ur.action(\"moveEdge\", undoRedoActionFunctions.moveEdge, undoRedoActionFunctions.moveEdge);\n    ur.action(\"fixError\", undoRedoActionFunctions.fixError, undoRedoActionFunctions.unfixError);\n    ur.action(\"cloneHighDegreeNode\", undoRedoActionFunctions.cloneHighDegreeNode, undoRedoActionFunctions.unCloneHighDegreeNode);\n    ur.action(\"changeMapType\", undoRedoActionFunctions.changeMapType, undoRedoActionFunctions.changeMapType);\n    ur.action(\"setCompoundPadding\", undoRedoActionFunctions.setCompoundPadding, undoRedoActionFunctions.setCompoundPadding);\n  };\n\n  return registerUndoRedoActions;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdXRpbGl0aWVzL3JlZ2lzdGVyLXVuZG8tcmVkby1hY3Rpb25zLWZhY3RvcnkuanMuanMiLCJtYXBwaW5ncyI6IkFBQUEsSUFBSUEsSUFBSSxHQUFHQyx3RkFBQSxFQUFYOztBQUNBLElBQUlFLENBQUMsR0FBR0gsSUFBSSxDQUFDSSxNQUFiOztBQUVBQyxNQUFNLENBQUNDLE9BQVAsR0FBaUIsWUFBWTtFQUUzQixJQUFJQyx1QkFBSixFQUE2QkMsT0FBN0IsRUFBc0NDLEVBQXRDOztFQUVBLElBQUlDLHVCQUF1QixHQUFHLFNBQTFCQSx1QkFBMEIsQ0FBVUMsS0FBVixFQUFpQjtJQUU3Q0osdUJBQXVCLEdBQUdJLEtBQUssQ0FBQ0osdUJBQWhDO0lBQ0FDLE9BQU8sR0FBR0csS0FBSyxDQUFDQyxlQUFOLENBQXNCQyxVQUF0QixFQUFWO0lBQ0FKLEVBQUUsR0FBR0UsS0FBSyxDQUFDRyx3QkFBTixDQUErQkMsS0FBL0IsRUFBTDs7SUFFQSxJQUFJLENBQUNQLE9BQU8sQ0FBQ1EsUUFBYixFQUF1QjtNQUNyQjtJQUNELENBUjRDLENBVTdDOzs7SUFDQSxJQUFJQyxFQUFFLEdBQUdSLEVBQUUsQ0FBQ1MsUUFBSCxDQUFZO01BQ25CQyxZQUFZLEVBQUVYLE9BQU8sQ0FBQ1c7SUFESCxDQUFaLENBQVQsQ0FYNkMsQ0FlN0M7O0lBQ0FGLEVBQUUsQ0FBQ0csTUFBSCxDQUFVLFNBQVYsRUFBcUJiLHVCQUF1QixDQUFDYyxPQUE3QyxFQUFzRGQsdUJBQXVCLENBQUNlLGdCQUE5RTtJQUNBTCxFQUFFLENBQUNHLE1BQUgsQ0FBVSxrQkFBVixFQUE4QmIsdUJBQXVCLENBQUNlLGdCQUF0RCxFQUF3RWYsdUJBQXVCLENBQUNnQixXQUFoRztJQUNBTixFQUFFLENBQUNHLE1BQUgsQ0FBVSxTQUFWLEVBQXFCYix1QkFBdUIsQ0FBQ2lCLE9BQTdDLEVBQXNEakIsdUJBQXVCLENBQUNlLGdCQUE5RTtJQUNBTCxFQUFFLENBQUNHLE1BQUgsQ0FBVSwrQkFBVixFQUEyQ2Is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QUUsQ0FBQ0csTUFBSCxDQUFVLG9CQUFWLEVBQWdDYix1QkFBdUIsQ0FBQzhELGtCQUF4RCxFQUE0RTlELHVCQUF1QixDQUFDOEQsa0JBQXBHO0lBQ0FwRCxFQUFFLENBQUNHLE1BQUgsQ0FBVSwrQkFBVixFQUEyQ2IsdUJBQXVCLENBQUMrRCw2QkFBbkUsRUFBa0cvRCx1QkFBdUIsQ0FBQytELDZCQUExSDtJQUVBckQsRUFBRSxDQUFDRyxNQUFILENBQVUsVUFBVixFQUFzQmIsdUJBQXVCLENBQUNnRSxRQUE5QyxFQUF3RGhFLHVCQUF1QixDQUFDZ0UsUUFBaEY7SUFDQXRELEVBQUUsQ0FBQ0csTUFBSCxDQUFVLFVBQVYsRUFBc0JiLHVCQUF1QixDQUFDaUUsUUFBOUMsRUFBdURqRSx1QkFBdUIsQ0FBQ2tFLFVBQS9FO0lBQ0F4RCxFQUFFLENBQUNHLE1BQUgsQ0FBVSxxQkFBVixFQUFpQ2IsdUJBQXVCLENBQUNtRSxtQkFBekQsRUFBNkVuRSx1QkFBdUIsQ0FBQ29FLHFCQUFyRztJQUVBMUQsRUFBRSxDQUFDRyxNQUFILENBQVUsZUFBVixFQUEyQmIsdUJBQXVCLENBQUNxRSxhQUFuRCxFQUFpRXJFLHVCQUF1QixDQUFDcUUsYUFBekY7SUFDQTNELEVBQUUsQ0FBQ0csTUFBSCxDQUFVLG9CQUFWLEVBQWdDYix1QkFBdUIsQ0FBQ3NFLGtCQUF4RCxFQUE0RXRFLHVCQUF1QixDQUFDc0Usa0JBQXBHO0VBRUQsQ0EzRUQ7O0VBNkVBLE9BQU9uRSx1QkFBUDtBQUNELENBbEZEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2hpc2UvLi9zcmMvdXRpbGl0aWVzL3JlZ2lzdGVyLXVuZG8tcmVkby1hY3Rpb25zLWZhY3RvcnkuanM/NWEzYSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgbGlicyA9IHJlcXVpcmUoJy4vbGliLXV0aWxpdGllcycpLmdldExpYnMoKTtcbnZhciAkID0gbGlicy5qUXVlcnk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuXG4gIHZhciB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucywgb3B0aW9ucywgY3k7XG5cbiAgdmFyIHJlZ2lzdGVyVW5kb1JlZG9BY3Rpb25zID0gZnVuY3Rpb24gKHBhcmFtKSB7XG5cbiAgICB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucyA9IHBhcmFtLnVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zO1xuICAgIG9wdGlvbnMgPSBwYXJhbS5vcHRpb25VdGlsaXRpZXMuZ2V0T3B0aW9ucygpO1xuICAgIGN5ID0gcGFyYW0uc2JnbnZpekluc3RhbmNlVXRpbGl0aWVzLmdldEN5KCk7XG5cbiAgICBpZiAoIW9wdGlvbnMudW5kb2FibGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBjcmVhdGUgdW5kby1yZWRvIGluc3RhbmNlXG4gICAgdmFyIHVyID0gY3kudW5kb1JlZG8oe1xuICAgICAgdW5kb2FibGVEcmFnOiBvcHRpb25zLnVuZG9hYmxlRHJhZ1xuICAgIH0pO1xuXG4gICAgLy8gcmVnaXN0ZXIgYWRkIHJlbW92ZSBhY3Rpb25zXG4gICAgdXIuYWN0aW9uKFwiYWRkTm9kZVwiLCB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5hZGROb2RlLCB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5kZWxldGVFbGVzU2ltcGxlKTtcbiAgICB1ci5hY3Rpb24oXCJkZWxldGVFbGVzU2ltcGxlXCIsIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLmRlbGV0ZUVsZXNTaW1wbGUsIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLnJlc3RvcmVFbGVzKTtcbiAgICB1ci5hY3Rpb24oXCJhZGRFZGdlXCIsIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLmFkZEVkZ2UsIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLmRlbGV0ZUVsZXNTaW1wbGUpO1xuICAgIHVyLmFjdGlvbihcImFkZFByb2Nlc3NXaXRoQ29udmVuaWVudEVkZ2VzXCIsIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLmFkZFByb2Nlc3NXaXRoQ29udmVuaWVudEVkZ2VzLCB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5kZWxldGVFbGVzU2ltcGxlKTtcbiAgICB1ci5hY3Rpb24oXCJkZWxldGVFbGVzU21hcnRcIiwgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMuZGVsZXRlRWxlc1NtYXJ0LCB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5yZXN0b3JlRWxlcyk7XG4gICAgdXIuYWN0aW9uKFwiY3JlYXRlQ29tcG91bmRGb3JHaXZlbk5vZGVzXCIsIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLmNyZWF0ZUNvbXBvdW5kRm9yR2l2ZW5Ob2RlcywgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMuY3JlYXRlQ29tcG91bmRGb3JHaXZlbk5vZGVzKTtcblxuICAgIC8vIHJlZ2lzdGVyIGdlbmVyYWwgYWN0aW9uc1xuICAgIHVyLmFjdGlvbihcInJlc2l6ZU5vZGVzXCIsIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLnJlc2l6ZU5vZGVzLCB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5yZXNpemVOb2Rlcyk7XG4gICAgdXIuYWN0aW9uKFwiY2hhbmdlTm9kZUxhYmVsXCIsIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLmNoYW5nZU5vZGVMYWJlbCwgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMuY2hhbmdlTm9kZUxhYmVsKTtcbiAgICB1ci5hY3Rpb24oXCJjaGFuZ2VEYXRhXCIsIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLmNoYW5nZURhdGEsIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLmNoYW5nZURhdGEpO1xuICAgIHVyLmFjdGlvbihcInVwZGF0ZVNldEZpZWxkXCIsIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLnVwZGF0ZVNldEZpZWxkLCB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy51cGRhdGVTZXRGaWVsZCk7XG4gICAgdXIuYWN0aW9uKFwiY2hhbmdlQ3NzXCIsIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLmNoYW5nZUNzcywgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMuY2hhbmdlQ3NzKTtcbiAgICB1ci5hY3Rpb24oXCJjaGFuZ2VCZW5kUG9pbnRzXCIsIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLmNoYW5nZUJlbmRQb2ludHMsIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLmNoYW5nZUJlbmRQb2ludHMpO1xuICAgIHVyLmFjdGlvbihcImNoYW5nZUZvbnRQcm9wZXJ0aWVzXCIsIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLmNoYW5nZUZvbnRQcm9wZXJ0aWVzLCB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5jaGFuZ2VGb250UHJvcGVydGllcyk7XG4gICAgdXIuYWN0aW9uKFwic2hvd0FuZFBlcmZvcm1MYXlvdXRcIiwgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMuc2hvd0FuZFBlcmZvcm1MYXlvdXQsIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLnVuZG9TaG93QW5kUGVyZm9ybUxheW91dCk7XG4gICAgdXIuYWN0aW9uKFwiaGlkZUFuZFBlcmZvcm1MYXlvdXRcIiwgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMuaGlkZUFuZFBlcmZvcm1MYXlvdXQsIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLnVuZG9IaWRlQW5kUGVyZm9ybUxheW91dCk7XG4gICAgdXIuYWN0aW9uKFwiZGVsZXRlQW5kUGVyZm9ybUxheW91dFwiLCB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5kZWxldGVBbmRQZXJmb3JtTGF5b3V0LCB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy51bmRvRGVsZXRlQW5kUGVyZm9ybUxheW91dCk7XG4gICAgdXIuYWN0aW9uKFwiYXBwbHlTSUZUb3BvbG9neUdyb3VwaW5nXCIsIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLmFwcGx5U0lGVG9wb2xvZ3lHcm91cGluZywgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMuYXBwbHlTSUZUb3BvbG9neUdyb3VwaW5nKTtcblxuICAgIC8vIHJlZ2lzdGVyIFNCR04gYWN0aW9uc1xuICAgIHVyLmFjdGlvbihcImFkZFN0YXRlT3JJbmZvQm94XCIsIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLmFkZFN0YXRlT3JJbmZvQm94LCB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5yZW1vdmVTdGF0ZU9ySW5mb0JveCk7XG4gICAgdXIuYWN0aW9uKFwiY2hhbmdlU3RhdGVPckluZm9Cb3hcIiwgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMuY2hhbmdlU3RhdGVPckluZm9Cb3gsIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLmNoYW5nZVN0YXRlT3JJbmZvQm94KTtcbiAgICB1ci5hY3Rpb24oXCJzZXRNdWx0aW1lclN0YXR1c1wiLCB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5zZXRNdWx0aW1lclN0YXR1cywgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMuc2V0TXVsdGltZXJTdGF0dXMpO1xuICAgIHVyLmFjdGlvbihcInNldEFjdGl2ZVN0YXR1c1wiLCB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5zZXRBY3RpdmVTdGF0dXMsIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLnNldEFjdGl2ZVN0YXR1cyk7XG4gICAgdXIuYWN0aW9uKFwic2V0SHlwb3RoZXRpY2FsU3RhdHVzXCIsIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLnNldEh5cG90aGV0aWNhbFN0YXR1cywgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMuc2V0SHlwb3RoZXRpY2FsU3RhdHVzKTtcbiAgICB1ci5hY3Rpb24oXCJzZXRDbG9uZU1hcmtlclN0YXR1c1wiLCB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5zZXRDbG9uZU1hcmtlclN0YXR1cywgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMuc2V0Q2xvbmVNYXJrZXJTdGF0dXMpO1xuICAgIHVyLmFjdGlvbihcInJlbW92ZVN0YXRlT3JJbmZvQm94XCIsIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLnJlbW92ZVN0YXRlT3JJbmZvQm94LCB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5hZGRTdGF0ZU9ySW5mb0JveCk7XG4gICAgdXIuYWN0aW9uKFwiZml0VW5pdHNcIiwgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMuZml0VW5pdHMsIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLnJlc3RvcmVVbml0cyk7XG4gICAgdXIuYWN0aW9uKFwiYWRkQmFja2dyb3VuZEltYWdlXCIsIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLmFkZEJhY2tncm91bmRJbWFnZSwgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMucmVtb3ZlQmFja2dyb3VuZEltYWdlKTtcbiAgICB1ci5hY3Rpb24oXCJyZW1vdmVCYWNrZ3JvdW5kSW1hZ2VcIiwgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMucmVtb3ZlQmFja2dyb3VuZEltYWdlLCB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5hZGRCYWNrZ3JvdW5kSW1hZ2UpO1xuICAgIHVyLmFjdGlvbihcInVwZGF0ZUJhY2tncm91bmRJbWFnZVwiLCB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy51cGRhdGVCYWNrZ3JvdW5kSW1hZ2UsIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLnVwZGF0ZUJhY2tncm91bmRJbWFnZSk7XG4gICAgdXIuYWN0aW9uKFwiY2hhbmdlQmFja2dyb3VuZEltYWdlXCIsIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLmNoYW5nZUJhY2tncm91bmRJbWFnZSwgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMuY2hhbmdlQmFja2dyb3VuZEltYWdlKTtcbiAgICB1ci5hY3Rpb24oXCJ1cGRhdGVJbmZvYm94U3R5bGVcIiwgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMudXBkYXRlSW5mb2JveFN0eWxlLCB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy51cGRhdGVJbmZvYm94U3R5bGUpO1xuICAgIHVyLmFjdGlvbihcInVwZGF0ZUluZm9ib3hPYmpcIiwgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMudXBkYXRlSW5mb2JveE9iaiwgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMudXBkYXRlSW5mb2JveE9iaik7XG5cbiAgICAvLyByZWdpc3RlciBlYXN5IGNyZWF0aW9uIGFjdGlvbnNcbiAgICB1ci5hY3Rpb24oXCJjcmVhdGVUZW1wbGF0ZVJlYWN0aW9uXCIsIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLmNyZWF0ZVRlbXBsYXRlUmVhY3Rpb24sIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLmRlbGV0ZUVsZXNTaW1wbGUpO1xuICAgIHVyLmFjdGlvbihcImNyZWF0ZUFjdGl2YXRpb25SZWFjdGlvblwiLCB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5jcmVhdGVBY3RpdmF0aW9uUmVhY3Rpb24sIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLmRlbGV0ZUVsZXNTaW1wbGUpO1xuICAgIHVyLmFjdGlvbihcImNyZWF0ZU1ldGFib2xpY0NhdGFseXRpY0FjdGl2aXR5XCIsIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLmNyZWF0ZU1ldGFib2xpY0NhdGFseXRpY0FjdGl2aXR5LCB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5kZWxldGVFbGVzU2ltcGxlKTtcbiAgICB1ci5hY3Rpb24oXCJjcmVhdGVNZXRhYm9saWNSZWFjdGlvblwiLCB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5jcmVhdGVNZXRhYm9saWNSZWFjdGlvbiwgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMuZGVsZXRlRWxlc1NpbXBsZSk7XG4gICAgdXIuYWN0aW9uKFwiY3JlYXRlQ29udmVyc2lvblwiLCB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5jcmVhdGVDb252ZXJzaW9uLCB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5kZWxldGVFbGVzU2ltcGxlKTtcbiAgICB1ci5hY3Rpb24oXCJjcmVhdGVNdWx0aW1lcml6YXRpb25cIiwgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMuY3JlYXRlTXVsdGltZXJpemF0aW9uLCB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5kZWxldGVFbGVzU2ltcGxlKTtcbiAgICB1ci5hY3Rpb24oXCJjcmVhdGVDb21wbGV4UHJvdGVpbkZvcm1hdGlvblwiLCB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5jcmVhdGVDb21wbGV4UHJvdGVpbkZvcm1hdGlvbiwgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMuZGVsZXRlRWxlc1NpbXBsZSk7XG4gICAgdXIuYWN0aW9uKFwiY3JlYXRlRGVncmFkYXRpb25cIiwgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMuY3JlYXRlRGVncmFkYXRpb24sIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLmRlbGV0ZUVsZXNTaW1wbGUpO1xuICAgIHVyLmFjdGlvbihcImNyZWF0ZVRyYW5zY3JpcHRpb25cIiwgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMuY3JlYXRlVHJhbnNjcmlwdGlvbiwgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMuZGVsZXRlRWxlc1NpbXBsZSk7XG4gICAgdXIuYWN0aW9uKFwiY3JlYXRlVHJhbnNsYXRpb25cIiwgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMuY3JlYXRlVHJhbnNsYXRpb24sIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLmRlbGV0ZUVsZXNTaW1wbGUpO1xuICAgIHVyLmFjdGlvbihcImNyZWF0ZVRyYW5zY3JpcHRpb25SZWFjdGlvblwiLCB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5jcmVhdGVUcmFuc2NyaXB0aW9uUmVhY3Rpb24sIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLmRlbGV0ZUVsZXNTaW1wbGUpO1xuICAgIHVyLmFjdGlvbihcImNyZWF0ZVRyYW5zbGF0aW9uUmVhY3Rpb25cIiwgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMuY3JlYXRlVHJhbnNsYXRpb25SZWFjdGlvbiwgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMuZGVsZXRlRWxlc1NpbXBsZSk7XG4gICAgdXIuYWN0aW9uKFwic2V0RGVmYXVsdFByb3BlcnR5XCIsIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLnNldERlZmF1bHRQcm9wZXJ0eSwgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMuc2V0RGVmYXVsdFByb3BlcnR5KTtcbiAgICB1ci5hY3Rpb24oXCJjb252ZXJ0SW50b1JldmVyc2libGVSZWFjdGlvblwiLCB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5jb252ZXJ0SW50b1JldmVyc2libGVSZWFjdGlvbiwgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMuY29udmVydEludG9SZXZlcnNpYmxlUmVhY3Rpb24pO1xuXG4gICAgdXIuYWN0aW9uKFwibW92ZUVkZ2VcIiwgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMubW92ZUVkZ2UsIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLm1vdmVFZGdlKTtcbiAgICB1ci5hY3Rpb24oXCJmaXhFcnJvclwiLCB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5maXhFcnJvcix1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy51bmZpeEVycm9yKTtcbiAgICB1ci5hY3Rpb24oXCJjbG9uZUhpZ2hEZWdyZWVOb2RlXCIsIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLmNsb25lSGlnaERlZ3JlZU5vZGUsdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMudW5DbG9uZUhpZ2hEZWdyZWVOb2RlKTtcblxuICAgIHVyLmFjdGlvbihcImNoYW5nZU1hcFR5cGVcIiwgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMuY2hhbmdlTWFwVHlwZSx1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5jaGFuZ2VNYXBUeXBlKTtcbiAgICB1ci5hY3Rpb24oXCJzZXRDb21wb3VuZFBhZGRpbmdcIiwgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMuc2V0Q29tcG91bmRQYWRkaW5nLCB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5zZXRDb21wb3VuZFBhZGRpbmcpO1xuXG4gIH07XG5cbiAgcmV0dXJuIHJlZ2lzdGVyVW5kb1JlZG9BY3Rpb25zO1xufTtcbiJdLCJuYW1lcyI6WyJsaWJzIiwicmVxdWlyZSIsImdldExpYnMiLCIkIiwialF1ZXJ5IiwibW9kdWxlIiwiZXhwb3J0cyIsInVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zIiwib3B0aW9ucyIsImN5IiwicmVnaXN0ZXJVbmRvUmVkb0FjdGlvbnMiLCJwYXJhbSIsIm9wdGlvblV0aWxpdGllcyIsImdldE9wdGlvbnMiLCJzYmdudml6SW5zdGFuY2VVdGlsaXRpZXMiLCJnZXRDeSIsInVuZG9hYmxlIiwidXIiLCJ1bmRvUmVkbyIsInVuZG9hYmxlRHJhZyIsImFjdGlvbiIsImFkZE5vZGUiLCJkZWxldGVFbGVzU2ltcGxlIiwicmVzdG9yZUVsZXMiLCJhZGRFZGdlIiwiYWRkUHJvY2Vzc1dpdGhDb252ZW5pZW50RWRnZXMiLCJkZWxldGVFbGVzU21hcnQiLCJjcmVhdGVDb21wb3VuZEZvckdpdmVuTm9kZXMiLCJyZXNpemVOb2RlcyIsImNoYW5nZU5vZGVMYWJlbCIsImNoYW5nZURhdGEiLCJ1cGRhdGVTZXRGaWVsZCIsImNoYW5nZUNzcyIsImNoYW5nZUJlbmRQb2ludHMiLCJjaGFuZ2VGb250UHJvcGVydGllcyIsInNob3dBbmRQZXJmb3JtTGF5b3V0IiwidW5kb1Nob3dBbmRQZXJmb3JtTGF5b3V0IiwiaGlkZUFuZFBlcmZvcm1MYXlvdXQiLCJ1bmRvSGlkZUFuZFBlcmZvcm1MYXlvdXQiLCJkZWxldGVBbmRQZXJmb3JtTGF5b3V0IiwidW5kb0RlbGV0ZUFuZFBlcmZvcm1MYXlvdXQiLCJhcHBseVNJRlRvcG9sb2d5R3JvdXBpbmciLCJhZGRTdGF0ZU9ySW5mb0JveCIsInJlbW92ZVN0YXRlT3JJbmZvQm94IiwiY2hhbmdlU3RhdGVPckluZm9Cb3giLCJzZXRNdWx0aW1lclN0YXR1cyIsInNldEFjdGl2ZVN0YXR1cyIsInNldEh5cG90aGV0aWNhbFN0YXR1cyIsInNldENsb25lTWFya2VyU3RhdHVzIiwiZml0VW5pdHMiLCJyZXN0b3JlVW5pdHMiLCJhZGRCYWNrZ3JvdW5kSW1hZ2UiLCJyZW1vdmVCYWNrZ3JvdW5kSW1hZ2UiLCJ1cGRhdGVCYWNrZ3JvdW5kSW1hZ2UiLCJjaGFuZ2VCYWNrZ3JvdW5kSW1hZ2UiLCJ1cGRhdGVJbmZvYm94U3R5bGUiLCJ1cGRhdGVJbmZvYm94T2JqIiwiY3JlYXRlVGVtcGxhdGVSZWFjdGlvbiIsImNyZWF0ZUFjdGl2YXRpb25SZWFjdGlvbiIsImNyZWF0ZU1ldGFib2xpY0NhdGFseXRpY0FjdGl2aXR5IiwiY3JlYXRlTWV0YWJvbGljUmVhY3Rpb24iLCJjcmVhdGVDb252ZXJzaW9uIiwiY3JlYXRlTXVsdGltZXJpemF0aW9uIiwiY3JlYXRlQ29tcGxleFByb3RlaW5Gb3JtYXRpb24iLCJjcmVhdGVEZWdyYWRhdGlvbiIsImNyZWF0ZVRyYW5zY3JpcHRpb24iLCJjcmVhdGVUcmFuc2xhdGlvbiIsImNyZWF0ZVRyYW5zY3JpcHRpb25SZWFjdGlvbiIsImNyZWF0ZVRyYW5zbGF0aW9uUmVhY3Rpb24iLCJzZXREZWZhdWx0UHJvcGVydHkiLCJjb252ZXJ0SW50b1JldmVyc2libGVSZWFjdGlvbiIsIm1vdmVFZGdlIiwiZml4RXJyb3IiLCJ1bmZpeEVycm9yIiwiY2xvbmVIaWdoRGVncmVlTm9kZSIsInVuQ2xvbmVIaWdoRGVncmVlTm9kZSIsImNoYW5nZU1hcFR5cGUiLCJzZXRDb21wb3VuZFBhZGRpbmciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/utilities/register-undo-redo-actions-factory.js\n");

/***/ }),

/***/ "./src/utilities/sbgnviz-instance-utilities-factory.js":
/*!*************************************************************!*\
  !*** ./src/utilities/sbgnviz-instance-utilities-factory.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var libs = (__webpack_require__(/*! ./lib-utilities */ \"./src/utilities/lib-utilities.js\").getLibs)();\n\nmodule.exports = function () {\n  var instance;\n\n  function sbgnvizInstanceUtilities(options) {\n    instance = libs.sbgnviz(options);\n    return instance;\n  }\n\n  sbgnvizInstanceUtilities.getInstance = function () {\n    return instance;\n  };\n\n  sbgnvizInstanceUtilities.getCy = function () {\n    return this.getInstance().getCy();\n  };\n\n  return sbgnvizInstanceUtilities;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdXRpbGl0aWVzL3NiZ252aXotaW5zdGFuY2UtdXRpbGl0aWVzLWZhY3RvcnkuanMuanMiLCJtYXBwaW5ncyI6IkFBQUEsSUFBSUEsSUFBSSxHQUFHQyx3RkFBQSxFQUFYOztBQUVBRSxNQUFNLENBQUNDLE9BQVAsR0FBaUIsWUFBWTtFQUUzQixJQUFJQyxRQUFKOztFQUVBLFNBQVNDLHdCQUFULENBQW1DQyxPQUFuQyxFQUE0QztJQUUxQ0YsUUFBUSxHQUFHTCxJQUFJLENBQUNRLE9BQUwsQ0FBYUQsT0FBYixDQUFYO0lBRUEsT0FBT0YsUUFBUDtFQUNEOztFQUVEQyx3QkFBd0IsQ0FBQ0csV0FBekIsR0FBdUMsWUFBWTtJQUNqRCxPQUFPSixRQUFQO0VBQ0QsQ0FGRDs7RUFJQUMsd0JBQXdCLENBQUNJLEtBQXpCLEdBQWlDLFlBQVk7SUFDM0MsT0FBTyxLQUFLRCxXQUFMLEdBQW1CQyxLQUFuQixFQUFQO0VBQ0QsQ0FGRDs7RUFJQSxPQUFPSix3QkFBUDtBQUNELENBcEJEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2hpc2UvLi9zcmMvdXRpbGl0aWVzL3NiZ252aXotaW5zdGFuY2UtdXRpbGl0aWVzLWZhY3RvcnkuanM/MzNjOCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgbGlicyA9IHJlcXVpcmUoJy4vbGliLXV0aWxpdGllcycpLmdldExpYnMoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIGluc3RhbmNlO1xuXG4gIGZ1bmN0aW9uIHNiZ252aXpJbnN0YW5jZVV0aWxpdGllcyAob3B0aW9ucykge1xuXG4gICAgaW5zdGFuY2UgPSBsaWJzLnNiZ252aXoob3B0aW9ucyk7XG5cbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH1cblxuICBzYmdudml6SW5zdGFuY2VVdGlsaXRpZXMuZ2V0SW5zdGFuY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9XG5cbiAgc2JnbnZpekluc3RhbmNlVXRpbGl0aWVzLmdldEN5ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmdldEluc3RhbmNlKCkuZ2V0Q3koKTtcbiAgfVxuXG4gIHJldHVybiBzYmdudml6SW5zdGFuY2VVdGlsaXRpZXM7XG59O1xuIl0sIm5hbWVzIjpbImxpYnMiLCJyZXF1aXJlIiwiZ2V0TGlicyIsIm1vZHVsZSIsImV4cG9ydHMiLCJpbnN0YW5jZSIsInNiZ252aXpJbnN0YW5jZVV0aWxpdGllcyIsIm9wdGlvbnMiLCJzYmdudml6IiwiZ2V0SW5zdGFuY2UiLCJnZXRDeSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/utilities/sbgnviz-instance-utilities-factory.js\n");

/***/ }),

/***/ "./src/utilities/topology-grouping-factory.js":
/*!****************************************************!*\
  !*** ./src/utilities/topology-grouping-factory.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var isEqual = __webpack_require__(/*! lodash.isequal */ \"./node_modules/lodash.isequal/index.js\");\n\nmodule.exports = function () {\n  var cy, elementUtilities;\n  var groupCompoundType, metaEdgeIdentifier, lockGraphTopology, shouldApply;\n  var DEFAULT_GROUP_COMPOUND_TYPE = 'topology group';\n  var EDGE_STYLE_NAMES = ['line-color', 'width'];\n\n  function topologyGrouping(param, props) {\n    cy = param.sbgnvizInstanceUtilities.getCy();\n    elementUtilities = param.elementUtilities;\n    groupCompoundType = props.groupCompoundType || DEFAULT_GROUP_COMPOUND_TYPE;\n    metaEdgeIdentifier = props.metaEdgeIdentifier;\n    lockGraphTopology = props.lockGraphTopology;\n    shouldApply = props.shouldApply || true;\n    topologyGrouping.applied = false;\n    initMetaStyleMap();\n  }\n\n  topologyGrouping.apply = function () {\n    if (topologyGrouping.applied || !evalOpt(shouldApply)) {\n      return;\n    }\n\n    var list = cy.nodes().map(function (node) {\n      return [node];\n    }); // determine node groups by their topology\n\n    var groups = getNodeGroups(list); // apply grouping in cy level\n\n    var metaEdges = topologyGrouping.getMetaEdges();\n    var compounds = topologyGrouping.getGroupCompounds();\n    applyGrouping(groups, metaEdges, compounds);\n    topologyGrouping.applied = true;\n\n    if (lockGraphTopology) {\n      elementUtilities.lockGraphTopology();\n    }\n\n    return groups;\n  };\n\n  topologyGrouping.unapply = function () {\n    if (!topologyGrouping.applied) {\n      return;\n    }\n\n    var metaEdges = topologyGrouping.getMetaEdges();\n    metaEdges.forEach(function (edge) {\n      var toRestore = edge.data('tg-to-restore');\n      edge.remove();\n      toRestore.restore();\n      EDGE_STYLE_NAMES.forEach(function (name) {\n        var oldVal = topologyGrouping.metaStyleMap[name][edge.id()];\n        var newVal = edge.data(name);\n\n        if (oldVal !== newVal) {\n          toRestore.data(name, newVal);\n        }\n      });\n    });\n    initMetaStyleMap();\n    var parents = topologyGrouping.getGroupCompounds();\n    elementUtilities.changeParent(parents.children(), null);\n    parents.remove();\n    topologyGrouping.applied = false;\n\n    if (lockGraphTopology) {\n      elementUtilities.unlockGraphTopology();\n    }\n  };\n\n  topologyGrouping.getMetaEdges = function () {\n    var metaEdges = cy.edges('[' + metaEdgeIdentifier + ']');\n    return metaEdges;\n  };\n\n  topologyGrouping.getGroupCompounds = function () {\n    var className = groupCompoundType;\n    return cy.nodes('[class=\"' + className + '\"]');\n  };\n\n  topologyGrouping.clearAppliedFlag = function () {\n    topologyGrouping.applied = false;\n  };\n\n  topologyGrouping.setAppliedFlag = function (applied) {\n    topologyGrouping.applied = applied;\n  };\n\n  topologyGrouping.toggleAppliedFlag = function () {\n    topologyGrouping.applied = !topologyGrouping.applied;\n  };\n\n  function initMetaStyleMap() {\n    topologyGrouping.metaStyleMap = {};\n    EDGE_STYLE_NAMES.forEach(function (name) {\n      topologyGrouping.metaStyleMap[name] = {};\n    });\n  }\n\n  function evalOpt(opt) {\n    if (typeof opt === 'function') {\n      return opt();\n    }\n\n    return opt;\n  }\n\n  function getNodeGroups(list) {\n    if (list.length <= 1) {\n      return list;\n    }\n\n    var halves = getHalves(list);\n    var firstPart = getNodeGroups(halves[0]);\n    var secondPart = getNodeGroups(halves[1]); // merge the halves\n\n    var groups = mergeGroups(firstPart, secondPart);\n    return groups;\n  }\n\n  function getParentOrSelf(node) {\n    var parent = node.parent();\n    return parent.size() > 0 ? parent : node;\n  }\n\n  function calcGroupingKey(edge) {\n    var srcId = getParentOrSelf(edge.source()).id();\n    var tgtId = getParentOrSelf(edge.target()).id();\n    var edgeType = getEdgeType(edge);\n    return [edgeType, srcId, tgtId].join('-');\n  }\n\n  function addToMapChain(map, key, val) {\n    if (!map[key]) {\n      map[key] = cy.collection();\n    }\n\n    map[key] = map[key].add(val);\n  }\n\n  function applyGrouping(groups, metaEdges, groupCompounds) {\n    var compounds;\n\n    if (groupCompounds.length > 0) {\n      compounds = groupCompounds;\n    } else {\n      groups.forEach(function (group) {\n        createGroupCompound(group);\n      });\n      compounds = topologyGrouping.getGroupCompounds();\n    }\n\n    var childrenEdges = compounds.children().connectedEdges();\n    var edgesMap = [];\n    childrenEdges.forEach(function (edge) {\n      var key = calcGroupingKey(edge);\n      addToMapChain(edgesMap, key, edge);\n      edge.remove();\n    });\n\n    if (metaEdges.length > 0) {\n      Object.keys(edgesMap).forEach(function (key) {\n        var edges = edgesMap[key];\n        var temp = edges[0];\n        var metaEdge = metaEdges.filter(function (edge) {\n          return edge.source().id() === getParentOrSelf(temp.source()).id() && edge.target().id() === getParentOrSelf(temp.target()).id();\n        })[0];\n        metaEdge.data('tg-to-restore', edges);\n        edges.remove();\n      });\n    } else {\n      Object.keys(edgesMap).forEach(function (key) {\n        createMetaEdgeFor(edgesMap[key]);\n      });\n    }\n  }\n\n  function createGroupCompound(group) {\n    if (group.length < 2) {\n      return;\n    }\n\n    var collection = cy.collection();\n    group.forEach(function (node) {\n      collection = collection.add(node);\n    });\n    elementUtilities.createCompoundForGivenNodes(collection, groupCompoundType);\n  }\n\n  function createMetaEdgeFor(edges) {\n    var srcId = getParentOrSelf(edges.source()).id();\n    var tgtId = getParentOrSelf(edges.target()).id();\n    var type = edges.data('class');\n    cy.remove(edges);\n    var metaEdge = elementUtilities.addEdge(srcId, tgtId, type);\n    metaEdge.data('tg-to-restore', edges);\n    metaEdge.data(metaEdgeIdentifier, true);\n    EDGE_STYLE_NAMES.forEach(function (styleName) {\n      edges.forEach(function (edge) {\n        topologyGrouping.metaStyleMap[styleName][edge.id()] = edge.data(styleName);\n      });\n      var commonVal = elementUtilities.getCommonProperty(edges, styleName, 'data');\n\n      if (commonVal) {\n        metaEdge.data(styleName, commonVal);\n      }\n    });\n    return metaEdge;\n  }\n\n  function mergeGroups(groups1, groups2) {\n    // notMergedGrs will include members of groups1 that are not merged\n    // mergedGrs will include the merged members from 2 groups\n    var notMergedGrs = [],\n        mergedGrs = [];\n    groups1.forEach(function (gr1) {\n      var merged = false;\n      mergedGrs.concat(groups2).forEach(function (gr2, index2) {\n        // if groups should be merged merge them, remove gr2 from where it\n        // comes from and push the merge result to mergedGrs\n        if (shouldMerge(gr1, gr2)) {\n          var mergedGr = gr1.concat(gr2);\n\n          if (index2 >= mergedGrs.length) {\n            removeAt(groups2, index2 - mergedGrs.length);\n          } else {\n            removeAt(mergedGrs, index2);\n          } // mark as merged and break the loop\n\n\n          mergedGrs.push(mergedGr);\n          merged = true;\n          return;\n        }\n      }); // if gr1 is not merged push it to notMergedGrs\n\n      if (!merged) {\n        notMergedGrs.push(gr1);\n      }\n    }); // the groups that comes from groups2 but not merged are still included\n    // in groups2 add them to the result together with mergedGrs and notMergedGrs\n\n    return notMergedGrs.concat(mergedGrs, groups2);\n  }\n\n  function shouldMerge(group1, group2) {\n    // using first elements is enough to decide whether to merge\n    var node1 = group1[0];\n    var node2 = group2[0];\n\n    if (node1.edges().length !== node2.edges().length) {\n      return false;\n    }\n\n    var getUndirectedEdges = function getUndirectedEdges(node) {\n      var edges = node.connectedEdges().filter(isUndirectedEdge);\n      return edges;\n    }; // undirected edges of node1 and node2 respectively\n\n\n    var undir1 = getUndirectedEdges(node1);\n    var undir2 = getUndirectedEdges(node2);\n    var in1 = node1.incomers().edges().not(undir1);\n    var in2 = node2.incomers().edges().not(undir2);\n    var out1 = node1.outgoers().edges().not(undir1);\n    var out2 = node2.outgoers().edges().not(undir2);\n    return compareEdgeGroup(in1, in2, node1, node2) && compareEdgeGroup(out1, out2, node1, node2) && compareEdgeGroup(undir1, undir2, node1, node2);\n  } // decide if 2 edge groups contains set of edges with similar content (type,\n  // source,target) relative to their nodes where gr1 are edges of node1 and gr2 are edges of\n  // node2\n\n\n  function compareEdgeGroup(gr1, gr2, node1, node2) {\n    var id1 = node1.id();\n    var id2 = node2.id();\n    var map1 = fillIdToTypeSetMap(gr1, node1);\n    var map2 = fillIdToTypeSetMap(gr2, node2);\n\n    if (Object.keys(map1).length !== Object.keys(map2).length) {\n      return;\n    }\n\n    var failed = false;\n    Object.keys(map1).forEach(function (key) {\n      // if already failed just return\n      if (failed) {\n        return;\n      } // if key is id2 use id1 instead because comparison is relative to nodes\n\n\n      var otherKey = key == id2 ? id1 : key; // check if the sets have the same content\n      // if check fails return false\n\n      if (!isEqual(map1[key], map2[otherKey])) {\n        failed = true;\n      }\n    }); // if check passes for each key return true\n\n    return !failed;\n  }\n\n  function fillIdToTypeSetMap(edgeGroup, node) {\n    var map = {};\n    var nodeId = node.id();\n    edgeGroup.forEach(function (edge) {\n      var srcId = edge.data('source');\n      var tgtId = edge.data('target');\n      var edgeId = edge.id();\n      var otherEnd = nodeId === tgtId ? srcId : tgtId;\n\n      function addToRelatedSet(sideStr, value) {\n        if (!map[sideStr]) {\n          map[sideStr] = new Set();\n        }\n\n        map[sideStr].add(value);\n      }\n\n      var edgeType = getEdgeType(edge);\n      addToRelatedSet(otherEnd, edgeType);\n    });\n    return map;\n  }\n\n  function getEdgeType(edge) {\n    return edge.data('class');\n  }\n\n  function isUndirectedEdge(edge) {\n    return elementUtilities.isUndirectedEdge(edge);\n  } // get halves of a list. It is assumed that list size is at least 2.\n\n\n  function getHalves(list) {\n    var s = list.length;\n    var halfIndex = Math.floor(s / 2);\n    var firstHalf = list.slice(0, halfIndex);\n    var secondHalf = list.slice(halfIndex, s);\n    return [firstHalf, secondHalf];\n  }\n\n  function removeAt(arr, index) {\n    arr.splice(index, 1);\n  }\n\n  return topologyGrouping;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdXRpbGl0aWVzL3RvcG9sb2d5LWdyb3VwaW5nLWZhY3RvcnkuanMuanMiLCJtYXBwaW5ncyI6IkFBQUEsSUFBSUEsT0FBTyxHQUFHQyxtQkFBTyxDQUFDLDhEQUFELENBQXJCOztBQUVBQyxNQUFNLENBQUNDLE9BQVAsR0FBaUIsWUFBVztFQUUxQixJQUFJQyxFQUFKLEVBQVFDLGdCQUFSO0VBQ0EsSUFBSUMsaUJBQUosRUFBdUJDLGtCQUF2QixFQUEyQ0MsaUJBQTNDLEVBQThEQyxXQUE5RDtFQUVBLElBQUlDLDJCQUEyQixHQUFHLGdCQUFsQztFQUNBLElBQUlDLGdCQUFnQixHQUFHLENBQUUsWUFBRixFQUFnQixPQUFoQixDQUF2Qjs7RUFFQSxTQUFTQyxnQkFBVCxDQUEyQkMsS0FBM0IsRUFBa0NDLEtBQWxDLEVBQTBDO0lBQ3hDVixFQUFFLEdBQUdTLEtBQUssQ0FBQ0Usd0JBQU4sQ0FBK0JDLEtBQS9CLEVBQUw7SUFDQVgsZ0JBQWdCLEdBQUdRLEtBQUssQ0FBQ1IsZ0JBQXpCO0lBRUFDLGlCQUFpQixHQUFHUSxLQUFLLENBQUNSLGlCQUFOLElBQTJCSSwyQkFBL0M7SUFDQUgsa0JBQWtCLEdBQUdPLEtBQUssQ0FBQ1Asa0JBQTNCO0lBQ0FDLGlCQUFpQixHQUFHTSxLQUFLLENBQUNOLGlCQUExQjtJQUNBQyxXQUFXLEdBQUdLLEtBQUssQ0FBQ0wsV0FBTixJQUFxQixJQUFuQztJQUVBRyxnQkFBZ0IsQ0FBQ0ssT0FBakIsR0FBMkIsS0FBM0I7SUFDQUMsZ0JBQWdCO0VBQ2pCOztFQUVETixnQkFBZ0IsQ0FBQ08sS0FBakIsR0FBeUIsWUFBVztJQUNsQyxJQUFLUCxnQkFBZ0IsQ0FBQ0ssT0FBakIsSUFBNEIsQ0FBQ0csT0FBTyxDQUFFWCxXQUFGLENBQXpDLEVBQTJEO01BQ3pEO0lBQ0Q7O0lBRUQsSUFBSVksSUFBSSxHQUFHakIsRUFBRSxDQUFDa0IsS0FBSCxHQUFXQyxHQUFYLENBQWdCLFVBQVVDLElBQVYsRUFBaUI7TUFDMUMsT0FBTyxD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b3BvbG9neS1ncm91cGluZy1mYWN0b3J5LmpzPzljMTIiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGlzRXF1YWwgPSByZXF1aXJlKCdsb2Rhc2guaXNlcXVhbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuXG4gIHZhciBjeSwgZWxlbWVudFV0aWxpdGllcztcbiAgdmFyIGdyb3VwQ29tcG91bmRUeXBlLCBtZXRhRWRnZUlkZW50aWZpZXIsIGxvY2tHcmFwaFRvcG9sb2d5LCBzaG91bGRBcHBseTtcblxuICB2YXIgREVGQVVMVF9HUk9VUF9DT01QT1VORF9UWVBFID0gJ3RvcG9sb2d5IGdyb3VwJztcbiAgdmFyIEVER0VfU1RZTEVfTkFNRVMgPSBbICdsaW5lLWNvbG9yJywgJ3dpZHRoJyBdO1xuXG4gIGZ1bmN0aW9uIHRvcG9sb2d5R3JvdXBpbmcoIHBhcmFtLCBwcm9wcyApIHtcbiAgICBjeSA9IHBhcmFtLnNiZ252aXpJbnN0YW5jZVV0aWxpdGllcy5nZXRDeSgpXG4gICAgZWxlbWVudFV0aWxpdGllcyA9IHBhcmFtLmVsZW1lbnRVdGlsaXRpZXM7XG5cbiAgICBncm91cENvbXBvdW5kVHlwZSA9IHByb3BzLmdyb3VwQ29tcG91bmRUeXBlIHx8IERFRkFVTFRfR1JPVVBfQ09NUE9VTkRfVFlQRTtcbiAgICBtZXRhRWRnZUlkZW50aWZpZXIgPSBwcm9wcy5tZXRhRWRnZUlkZW50aWZpZXI7XG4gICAgbG9ja0dyYXBoVG9wb2xvZ3kgPSBwcm9wcy5sb2NrR3JhcGhUb3BvbG9neTtcbiAgICBzaG91bGRBcHBseSA9IHByb3BzLnNob3VsZEFwcGx5IHx8IHRydWU7XG5cbiAgICB0b3BvbG9neUdyb3VwaW5nLmFwcGxpZWQgPSBmYWxzZTtcbiAgICBpbml0TWV0YVN0eWxlTWFwKCk7XG4gIH1cblxuICB0b3BvbG9neUdyb3VwaW5nLmFwcGx5ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCB0b3BvbG9neUdyb3VwaW5nLmFwcGxpZWQgfHwgIWV2YWxPcHQoIHNob3VsZEFwcGx5ICkgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGxpc3QgPSBjeS5ub2RlcygpLm1hcCggZnVuY3Rpb24oIG5vZGUgKSB7XG4gICAgICByZXR1cm4gWyBub2RlIF07XG4gICAgfSApO1xuXG4gICAgLy8gZGV0ZXJtaW5lIG5vZGUgZ3JvdXBzIGJ5IHRoZWlyIHRvcG9sb2d5XG4gICAgdmFyIGdyb3VwcyA9IGdldE5vZGVHcm91cHMoIGxpc3QgKTtcbiAgICBcbiAgICAvLyBhcHBseSBncm91cGluZyBpbiBjeSBsZXZlbFxuICAgIHZhciBtZXRhRWRnZXMgPSB0b3BvbG9neUdyb3VwaW5nLmdldE1ldGFFZGdlcygpO1xuICAgIHZhciBjb21wb3VuZHMgPSB0b3BvbG9neUdyb3VwaW5nLmdldEdyb3VwQ29tcG91bmRzKCk7XG4gIFx0YXBwbHlHcm91cGluZyhncm91cHMsIG1ldGFFZGdlcywgY29tcG91bmRzKTtcblxuICAgIHRvcG9sb2d5R3JvdXBpbmcuYXBwbGllZCA9IHRydWU7XG5cbiAgICBpZiAoIGxvY2tHcmFwaFRvcG9sb2d5ICkge1xuICAgICAgZWxlbWVudFV0aWxpdGllcy5sb2NrR3JhcGhUb3BvbG9neSgpO1xuICAgIH1cblxuICBcdHJldHVybiBncm91cHM7XG4gIH07XG5cbiAgdG9wb2xvZ3lHcm91cGluZy51bmFwcGx5ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCAhdG9wb2xvZ3lHcm91cGluZy5hcHBsaWVkICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBtZXRhRWRnZXMgPSB0b3BvbG9neUdyb3VwaW5nLmdldE1ldGFFZGdlcygpO1xuICAgIG1ldGFFZGdlcy5mb3JFYWNoKCBmdW5jdGlvbiggZWRnZSApIHtcbiAgICAgIHZhciB0b1Jlc3RvcmUgPSBlZGdlLmRhdGEoJ3RnLXRvLXJlc3RvcmUnKTtcbiAgICAgIGVkZ2UucmVtb3ZlKCk7XG4gICAgICB0b1Jlc3RvcmUucmVzdG9yZSgpO1xuXG4gICAgICBFREdFX1NUWUxFX05BTUVTLmZvckVhY2goIGZ1bmN0aW9uKCBuYW1lICkge1xuICAgICAgICB2YXIgb2xkVmFsID0gdG9wb2xvZ3lHcm91cGluZy5tZXRhU3R5bGVNYXBbIG5hbWUgXVsgZWRnZS5pZCgpIF07XG4gICAgICAgIHZhciBuZXdWYWwgPSBlZGdlLmRhdGEoIG5hbWUgKTtcblxuICAgICAgICBpZiAoIG9sZFZhbCAhPT0gbmV3VmFsICkge1xuICAgICAgICAgIHRvUmVzdG9yZS5kYXRhKCBuYW1lLCBuZXdWYWwgKTtcbiAgICAgICAgfVxuICAgICAgfSApO1xuICAgIH0gKTtcblxuICAgIGluaXRNZXRhU3R5bGVNYXAoKTtcblxuICAgIHZhciBwYXJlbnRzID0gdG9wb2xvZ3lHcm91cGluZy5nZXRHcm91cENvbXBvdW5kcygpO1xuICAgIGVsZW1lbnRVdGlsaXRpZXMuY2hhbmdlUGFyZW50KCBwYXJlbnRzLmNoaWxkcmVuKCksIG51bGwgKTtcbiAgICBwYXJlbnRzLnJlbW92ZSgpO1xuXG4gICAgdG9wb2xvZ3lHcm91cGluZy5hcHBsaWVkID0gZmFsc2U7XG5cbiAgICBpZiAoIGxvY2tHcmFwaFRvcG9sb2d5ICkge1xuICAgICAgZWxlbWVudFV0aWxpdGllcy51bmxvY2tHcmFwaFRvcG9sb2d5KCk7XG4gICAgfVxuICB9O1xuXG4gIHRvcG9sb2d5R3JvdXBpbmcuZ2V0TWV0YUVkZ2VzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG1ldGFFZGdlcyA9IGN5LmVkZ2VzKCdbJyArIG1ldGFFZGdlSWRlbnRpZmllciArICddJyk7XG4gICAgcmV0dXJuIG1ldGFFZGdlcztcbiAgfTtcblxuICB0b3BvbG9neUdyb3VwaW5nLmdldEdyb3VwQ29tcG91bmRzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNsYXNzTmFtZSA9IGdyb3VwQ29tcG91bmRUeXBlO1xuICAgIHJldHVybiBjeS5ub2RlcygnW2NsYXNzPVwiJyArIGNsYXNzTmFtZSArICdcIl0nKTtcbiAgfTtcblxuICB0b3BvbG9neUdyb3VwaW5nLmNsZWFyQXBwbGllZEZsYWcgPSBmdW5jdGlvbigpIHtcbiAgICB0b3BvbG9neUdyb3VwaW5nLmFwcGxpZWQgPSBmYWxzZTtcbiAgfTtcblxuICB0b3BvbG9neUdyb3VwaW5nLnNldEFwcGxpZWRGbGFnID0gZnVuY3Rpb24oYXBwbGllZCkge1xuICAgIHRvcG9sb2d5R3JvdXBpbmcuYXBwbGllZCA9IGFwcGxpZWQ7XG4gIH07XG5cbiAgdG9wb2xvZ3lHcm91cGluZy50b2dnbGVBcHBsaWVkRmxhZyA9IGZ1bmN0aW9uKCkge1xuICAgIHRvcG9sb2d5R3JvdXBpbmcuYXBwbGllZCA9ICF0b3BvbG9neUdyb3VwaW5nLmFwcGxpZWQ7XG4gIH07XG5cbiAgZnVuY3Rpb24gaW5pdE1ldGFTdHlsZU1hcCgpIHtcbiAgICB0b3BvbG9neUdyb3VwaW5nLm1ldGFTdHlsZU1hcCA9IHt9O1xuICAgIEVER0VfU1RZTEVfTkFNRVMuZm9yRWFjaCggZnVuY3Rpb24oIG5hbWUgKSB7XG4gICAgICB0b3BvbG9neUdyb3VwaW5nLm1ldGFTdHlsZU1hcFsgbmFtZSBdID0ge307XG4gICAgfSApO1xuICB9XG5cbiAgZnVuY3Rpb24gZXZhbE9wdCggb3B0ICkge1xuICAgIGlmICggdHlwZW9mIG9wdCA9PT0gJ2Z1bmN0aW9uJyApIHtcbiAgICAgIHJldHVybiBvcHQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3B0O1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Tm9kZUdyb3VwcyggbGlzdCApIHtcbiAgICBpZiAoIGxpc3QubGVuZ3RoIDw9IDEgKSB7XG4gICAgICByZXR1cm4gbGlzdDtcbiAgICB9XG5cbiAgICB2YXIgaGFsdmVzID0gZ2V0SGFsdmVzKCBsaXN0ICk7XG4gICAgdmFyIGZpcnN0UGFydCA9IGdldE5vZGVHcm91cHMoIGhhbHZlc1sgMCBdICk7XG4gICAgdmFyIHNlY29uZFBhcnQgPSBnZXROb2RlR3JvdXBzKCBoYWx2ZXNbIDEgXSApO1xuICAgIC8vIG1lcmdlIHRoZSBoYWx2ZXNcblx0ICB2YXIgZ3JvdXBzID0gbWVyZ2VHcm91cHMoIGZpcnN0UGFydCwgc2Vjb25kUGFydCApO1xuXG4gICAgcmV0dXJuIGdyb3VwcztcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFBhcmVudE9yU2VsZiggbm9kZSApIHtcbiAgICB2YXIgcGFyZW50ID0gbm9kZS5wYXJlbnQoKTtcbiAgICByZXR1cm4gcGFyZW50LnNpemUoKSA+IDAgPyBwYXJlbnQgOiBub2RlO1xuICB9XG5cbiAgZnVuY3Rpb24gY2FsY0dyb3VwaW5nS2V5KCBlZGdlICkge1xuICAgIHZhciBzcmNJZCA9IGdldFBhcmVudE9yU2VsZiggZWRnZS5zb3VyY2UoKSApLmlkKCk7XG4gICAgdmFyIHRndElkID0gZ2V0UGFyZW50T3JTZWxmKCBlZGdlLnRhcmdldCgpICkuaWQoKTtcbiAgICB2YXIgZWRnZVR5cGUgPSBnZXRFZGdlVHlwZSggZWRnZSApO1xuXG4gICAgcmV0dXJuIFsgZWRnZVR5cGUsIHNyY0lkLCB0Z3RJZCBdLmpvaW4oICctJyApO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkVG9NYXBDaGFpbiggbWFwLCBrZXksIHZhbCApIHtcbiAgICBpZiAoICFtYXBbIGtleSBdICkge1xuICAgICAgbWFwWyBrZXkgXSA9IGN5LmNvbGxlY3Rpb24oKTtcbiAgICB9XG5cbiAgICBtYXBbIGtleSBdID0gbWFwWyBrZXkgXS5hZGQoIHZhbCApO1xuICB9XG5cbiAgZnVuY3Rpb24gYXBwbHlHcm91cGluZyhncm91cHMsIG1ldGFFZGdlcywgZ3JvdXBDb21wb3VuZHMpIHtcbiAgICB2YXIgY29tcG91bmRzO1xuXG4gICAgaWYgKGdyb3VwQ29tcG91bmRzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbXBvdW5kcyA9IGdyb3VwQ29tcG91bmRzO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGdyb3Vwcy5mb3JFYWNoKCBmdW5jdGlvbiggZ3JvdXAgKSB7XG4gICAgICAgIGNyZWF0ZUdyb3VwQ29tcG91bmQoIGdyb3VwICk7XG4gICAgICB9ICk7XG4gIFxuICAgICAgY29tcG91bmRzID0gdG9wb2xvZ3lHcm91cGluZy5nZXRHcm91cENvbXBvdW5kcygpO1xuICAgIH1cblxuICAgIHZhciBjaGlsZHJlbkVkZ2VzID0gY29tcG91bmRzLmNoaWxkcmVuKCkuY29ubmVjdGVkRWRnZXMoKTtcbiAgICB2YXIgZWRnZXNNYXAgPSBbXTtcblxuICAgIGNoaWxkcmVuRWRnZXMuZm9yRWFjaCggZnVuY3Rpb24oIGVkZ2UgKXtcbiAgICAgIHZhciBrZXkgPSBjYWxjR3JvdXBpbmdLZXkoIGVkZ2UgKTtcbiAgICAgIGFkZFRvTWFwQ2hhaW4oIGVkZ2VzTWFwLCBrZXksIGVkZ2UgKTtcbiAgICAgIGVkZ2UucmVtb3ZlKCk7XG4gICAgfSApO1xuXG4gICAgaWYgKG1ldGFFZGdlcy5sZW5ndGggPiAwKSB7XG4gICAgICBPYmplY3Qua2V5cyggZWRnZXNNYXAgKS5mb3JFYWNoKCBmdW5jdGlvbigga2V5ICkge1xuICAgICAgICB2YXIgZWRnZXMgPSBlZGdlc01hcFtrZXldO1xuICAgICAgICB2YXIgdGVtcCA9IGVkZ2VzWzBdO1xuICAgICAgICB2YXIgbWV0YUVkZ2UgPSBtZXRhRWRnZXMuZmlsdGVyKGVkZ2UgPT4ge1xuICAgICAgICAgIHJldHVybiBlZGdlLnNvdXJjZSgpLmlkKCkgPT09IGdldFBhcmVudE9yU2VsZiggdGVtcC5zb3VyY2UoKSApLmlkKCkgJiZcbiAgICAgICAgICAgICAgICAgIGVkZ2UudGFyZ2V0KCkuaWQoKSA9PT0gZ2V0UGFyZW50T3JTZWxmKCB0ZW1wLnRhcmdldCgpICkuaWQoKTtcbiAgICAgICAgfSlbMF07XG4gICAgICAgIG1ldGFFZGdlLmRhdGEoICd0Zy10by1yZXN0b3JlJywgZWRnZXMgKTtcbiAgICAgICAgZWRnZXMucmVtb3ZlKCk7XG4gICAgICB9ICk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgT2JqZWN0LmtleXMoIGVkZ2VzTWFwICkuZm9yRWFjaCggZnVuY3Rpb24oIGtleSApIHtcbiAgICAgICAgY3JlYXRlTWV0YUVkZ2VGb3IoIGVkZ2VzTWFwWyBrZXkgXSApO1xuICAgICAgfSApO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUdyb3VwQ29tcG91bmQoIGdyb3VwICkge1xuICAgIGlmICggZ3JvdXAubGVuZ3RoIDwgMiApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgY29sbGVjdGlvbiA9IGN5LmNvbGxlY3Rpb24oKTtcblxuICAgIGdyb3VwLmZvckVhY2goIGZ1bmN0aW9uKCBub2RlICkge1xuICAgICAgY29sbGVjdGlvbiA9IGNvbGxlY3Rpb24uYWRkKCBub2RlICk7XG4gICAgfSApO1xuXG4gICAgZWxlbWVudFV0aWxpdGllcy5jcmVhdGVDb21wb3VuZEZvckdpdmVuTm9kZXMoIGNvbGxlY3Rpb24sIGdyb3VwQ29tcG91bmRUeXBlICk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVNZXRhRWRnZUZvciggZWRnZXMgKSB7XG4gICAgdmFyIHNyY0lkID0gZ2V0UGFyZW50T3JTZWxmKCBlZGdlcy5zb3VyY2UoKSApLmlkKCk7XG4gICAgdmFyIHRndElkID0gZ2V0UGFyZW50T3JTZWxmKCBlZGdlcy50YXJnZXQoKSApLmlkKCk7XG4gICAgdmFyIHR5cGUgPSBlZGdlcy5kYXRhKCAnY2xhc3MnICk7XG4gICAgY3kucmVtb3ZlKCBlZGdlcyApO1xuXG4gICAgdmFyIG1ldGFFZGdlID0gZWxlbWVudFV0aWxpdGllcy5hZGRFZGdlKCBzcmNJZCwgdGd0SWQsIHR5cGUgKTtcbiAgICBtZXRhRWRnZS5kYXRhKCAndGctdG8tcmVzdG9yZScsIGVkZ2VzICk7XG4gICAgbWV0YUVkZ2UuZGF0YSggbWV0YUVkZ2VJZGVudGlmaWVyLCB0cnVlICk7XG5cbiAgICBFREdFX1NUWUxFX05BTUVTLmZvckVhY2goIGZ1bmN0aW9uKCBzdHlsZU5hbWUgKSB7XG4gICAgICBlZGdlcy5mb3JFYWNoKCBmdW5jdGlvbiggZWRnZSApIHtcbiAgICAgICAgdG9wb2xvZ3lHcm91cGluZy5tZXRhU3R5bGVNYXBbIHN0eWxlTmFtZSBdWyBlZGdlLmlkKCkgXSA9IGVkZ2UuZGF0YSggc3R5bGVOYW1lICk7XG4gICAgICB9ICk7XG5cbiAgICAgIHZhciBjb21tb25WYWwgPSBlbGVtZW50VXRpbGl0aWVzLmdldENvbW1vblByb3BlcnR5KGVkZ2VzLCBzdHlsZU5hbWUsICdkYXRhJyk7XG4gICAgICBpZiAoIGNvbW1vblZhbCApIHtcbiAgICAgICAgbWV0YUVkZ2UuZGF0YSggc3R5bGVOYW1lLCBjb21tb25WYWwgKTtcbiAgICAgIH1cbiAgICB9ICk7XG5cbiAgICByZXR1cm4gbWV0YUVkZ2U7XG4gIH1cblxuICBmdW5jdGlvbiBtZXJnZUdyb3VwcyggZ3JvdXBzMSwgZ3JvdXBzMiApIHtcbiAgICAvLyBub3RNZXJnZWRHcnMgd2lsbCBpbmNsdWRlIG1lbWJlcnMgb2YgZ3JvdXBzMSB0aGF0IGFyZSBub3QgbWVyZ2VkXG4gIFx0Ly8gbWVyZ2VkR3JzIHdpbGwgaW5jbHVkZSB0aGUgbWVyZ2VkIG1lbWJlcnMgZnJvbSAyIGdyb3Vwc1xuICBcdHZhciBub3RNZXJnZWRHcnMgPSBbXSwgbWVyZ2VkR3JzID0gW107XG5cbiAgICBncm91cHMxLmZvckVhY2goIGZ1bmN0aW9uKCBncjEgKSB7XG4gICAgICB2YXIgbWVyZ2VkID0gZmFsc2U7XG5cbiAgICAgIG1lcmdlZEdycy5jb25jYXQoIGdyb3VwczIgKS5mb3JFYWNoKCBmdW5jdGlvbiggZ3IyLCBpbmRleDIgKSB7XG4gICAgICAgIC8vIGlmIGdyb3VwcyBzaG91bGQgYmUgbWVyZ2VkIG1lcmdlIHRoZW0sIHJlbW92ZSBncjIgZnJvbSB3aGVyZSBpdFxuICAgICAgICAvLyBjb21lcyBmcm9tIGFuZCBwdXNoIHRoZSBtZXJnZSByZXN1bHQgdG8gbWVyZ2VkR3JzXG4gICAgICAgIGlmICggc2hvdWxkTWVyZ2UoIGdyMSwgZ3IyICkgKSB7XG4gICAgICAgICAgdmFyIG1lcmdlZEdyID0gZ3IxLmNvbmNhdCggZ3IyICk7XG5cbiAgICAgICAgICBpZiAoIGluZGV4MiA+PSBtZXJnZWRHcnMubGVuZ3RoICkge1xuICAgICAgICAgICAgcmVtb3ZlQXQoIGdyb3VwczIsIGluZGV4MiAtIG1lcmdlZEdycy5sZW5ndGggKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZW1vdmVBdCggbWVyZ2VkR3JzLCBpbmRleDIgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBtYXJrIGFzIG1lcmdlZCBhbmQgYnJlYWsgdGhlIGxvb3BcbiAgICAgICAgICBtZXJnZWRHcnMucHVzaCggbWVyZ2VkR3IgKTtcbiAgICAgICAgICBtZXJnZWQgPSB0cnVlO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSApO1xuXG4gICAgICAvLyBpZiBncjEgaXMgbm90IG1lcmdlZCBwdXNoIGl0IHRvIG5vdE1lcmdlZEdyc1xuICAgICAgaWYgKCAhbWVyZ2VkICkge1xuICAgICAgICBub3RNZXJnZWRHcnMucHVzaCggZ3IxICk7XG4gICAgICB9XG4gICAgfSApO1xuXG4gICAgLy8gdGhlIGdyb3VwcyB0aGF0IGNvbWVzIGZyb20gZ3JvdXBzMiBidXQgbm90IG1lcmdlZCBhcmUgc3RpbGwgaW5jbHVkZWRcblx0ICAvLyBpbiBncm91cHMyIGFkZCB0aGVtIHRvIHRoZSByZXN1bHQgdG9nZXRoZXIgd2l0aCBtZXJnZWRHcnMgYW5kIG5vdE1lcmdlZEdyc1xuICAgIHJldHVybiBub3RNZXJnZWRHcnMuY29uY2F0KCBtZXJnZWRHcnMsIGdyb3VwczIgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNob3VsZE1lcmdlKCBncm91cDEsIGdyb3VwMiApIHtcbiAgICAvLyB1c2luZyBmaXJzdCBlbGVtZW50cyBpcyBlbm91Z2ggdG8gZGVjaWRlIHdoZXRoZXIgdG8gbWVyZ2VcbiAgXHR2YXIgbm9kZTEgPSBncm91cDFbIDAgXTtcbiAgXHR2YXIgbm9kZTIgPSBncm91cDJbIDAgXTtcblxuICAgIGlmICggbm9kZTEuZWRnZXMoKS5sZW5ndGggIT09IG5vZGUyLmVkZ2VzKCkubGVuZ3RoICkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBnZXRVbmRpcmVjdGVkRWRnZXMgPSBmdW5jdGlvbiggbm9kZSApIHtcbiAgICAgIHZhciBlZGdlcyA9IG5vZGUuY29ubmVjdGVkRWRnZXMoKS5maWx0ZXIoIGlzVW5kaXJlY3RlZEVkZ2UgKTtcbiAgICAgIHJldHVybiBlZGdlcztcbiAgICB9O1xuICAgIC8vIHVuZGlyZWN0ZWQgZWRnZXMgb2Ygbm9kZTEgYW5kIG5vZGUyIHJlc3BlY3RpdmVseVxuICAgIHZhciB1bmRpcjEgPSBnZXRVbmRpcmVjdGVkRWRnZXMoIG5vZGUxICk7XG4gICAgdmFyIHVuZGlyMiA9IGdldFVuZGlyZWN0ZWRFZGdlcyggbm9kZTIgKTtcblxuICAgIHZhciBpbjEgPSBub2RlMS5pbmNvbWVycygpLmVkZ2VzKCkubm90KCB1bmRpcjEgKTtcbiAgICB2YXIgaW4yID0gbm9kZTIuaW5jb21lcnMoKS5lZGdlcygpLm5vdCggdW5kaXIyICk7XG5cbiAgICB2YXIgb3V0MSA9IG5vZGUxLm91dGdvZXJzKCkuZWRnZXMoKS5ub3QoIHVuZGlyMSApO1xuXHQgIHZhciBvdXQyID0gbm9kZTIub3V0Z29lcnMoKS5lZGdlcygpLm5vdCggdW5kaXIyICk7XG5cbiAgICByZXR1cm4gY29tcGFyZUVkZ2VHcm91cCggaW4xLCBpbjIsIG5vZGUxLCBub2RlMiApXG4gICAgICAgICAgICAmJiBjb21wYXJlRWRnZUdyb3VwKCBvdXQxLCBvdXQyLCBub2RlMSwgbm9kZTIgKVxuICAgICAgICAgICAgJiYgY29tcGFyZUVkZ2VHcm91cCggdW5kaXIxLCB1bmRpcjIsIG5vZGUxLCBub2RlMiApO1xuICB9XG5cbiAgLy8gZGVjaWRlIGlmIDIgZWRnZSBncm91cHMgY29udGFpbnMgc2V0IG9mIGVkZ2VzIHdpdGggc2ltaWxhciBjb250ZW50ICh0eXBlLFxuICAvLyBzb3VyY2UsdGFyZ2V0KSByZWxhdGl2ZSB0byB0aGVpciBub2RlcyB3aGVyZSBncjEgYXJlIGVkZ2VzIG9mIG5vZGUxIGFuZCBncjIgYXJlIGVkZ2VzIG9mXG4gIC8vIG5vZGUyXG4gIGZ1bmN0aW9uIGNvbXBhcmVFZGdlR3JvdXAoIGdyMSwgZ3IyLCBub2RlMSwgbm9kZTIgKSB7XG4gICAgdmFyIGlkMSA9IG5vZGUxLmlkKCk7XG4gICAgdmFyIGlkMiA9IG5vZGUyLmlkKCk7XG5cbiAgICB2YXIgbWFwMSA9IGZpbGxJZFRvVHlwZVNldE1hcCggZ3IxLCBub2RlMSApO1xuICAgIHZhciBtYXAyID0gZmlsbElkVG9UeXBlU2V0TWFwKCBncjIsIG5vZGUyICk7XG5cbiAgICBpZiAoIE9iamVjdC5rZXlzKCBtYXAxICkubGVuZ3RoICE9PSBPYmplY3Qua2V5cyggbWFwMiApLmxlbmd0aCApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZmFpbGVkID0gZmFsc2U7XG5cbiAgICBPYmplY3Qua2V5cyggbWFwMSApLmZvckVhY2goIGZ1bmN0aW9uKCBrZXkgKSB7XG4gICAgICAvLyBpZiBhbHJlYWR5IGZhaWxlZCBqdXN0IHJldHVyblxuICAgICAgaWYgKCBmYWlsZWQgKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gaWYga2V5IGlzIGlkMiB1c2UgaWQxIGluc3RlYWQgYmVjYXVzZSBjb21wYXJpc29uIGlzIHJlbGF0aXZlIHRvIG5vZGVzXG4gICAgICB2YXIgb3RoZXJLZXkgPSAoIGtleSA9PSBpZDIgKSA/IGlkMSA6IGtleTtcblxuICAgICAgLy8gY2hlY2sgaWYgdGhlIHNldHMgaGF2ZSB0aGUgc2FtZSBjb250ZW50XG4gIFx0XHQvLyBpZiBjaGVjayBmYWlscyByZXR1cm4gZmFsc2VcbiAgICAgIGlmICggIWlzRXF1YWwoIG1hcDFbIGtleSBdLCBtYXAyWyBvdGhlcktleSBdICkgKSB7XG4gICAgICAgIGZhaWxlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSApO1xuXG4gICAgLy8gaWYgY2hlY2sgcGFzc2VzIGZvciBlYWNoIGtleSByZXR1cm4gdHJ1ZVxuICAgIHJldHVybiAhZmFpbGVkO1xuICB9XG5cbiAgZnVuY3Rpb24gZmlsbElkVG9UeXBlU2V0TWFwKCBlZGdlR3JvdXAsIG5vZGUgKSB7XG4gICAgdmFyIG1hcCA9IHt9O1xuICAgIHZhciBub2RlSWQgPSBub2RlLmlkKCk7XG5cbiAgICBlZGdlR3JvdXAuZm9yRWFjaCggZnVuY3Rpb24oIGVkZ2UgKSB7XG4gICAgICB2YXIgc3JjSWQgPSBlZGdlLmRhdGEoJ3NvdXJjZScpO1xuICAgICAgdmFyIHRndElkID0gZWRnZS5kYXRhKCd0YXJnZXQnKTtcbiAgICAgIHZhciBlZGdlSWQgPSBlZGdlLmlkKCk7XG5cbiAgICAgIHZhciBvdGhlckVuZCA9ICggbm9kZUlkID09PSB0Z3RJZCApID8gc3JjSWQgOiB0Z3RJZDtcblxuICAgICAgZnVuY3Rpb24gYWRkVG9SZWxhdGVkU2V0KCBzaWRlU3RyLCB2YWx1ZSApIHtcbiAgICAgICAgaWYgKCAhbWFwWyBzaWRlU3RyIF0gKSB7XG4gICAgICAgICAgbWFwWyBzaWRlU3RyIF0gPSBuZXcgU2V0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBtYXBbIHNpZGVTdHIgXS5hZGQoIHZhbHVlICk7XG4gICAgICB9XG5cbiAgICAgIHZhciBlZGdlVHlwZSA9IGdldEVkZ2VUeXBlKCBlZGdlICk7XG5cbiAgICAgIGFkZFRvUmVsYXRlZFNldCggb3RoZXJFbmQsIGVkZ2VUeXBlICk7XG4gICAgfSApO1xuXG4gICAgcmV0dXJuIG1hcDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEVkZ2VUeXBlKCBlZGdlICkge1xuICAgIHJldHVybiBlZGdlLmRhdGEoICdjbGFzcycgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzVW5kaXJlY3RlZEVkZ2UoIGVkZ2UgKSB7XG4gICAgcmV0dXJuIGVsZW1lbnRVdGlsaXRpZXMuaXNVbmRpcmVjdGVkRWRnZSggZWRnZSApO1xuICB9XG5cbiAgLy8gZ2V0IGhhbHZlcyBvZiBhIGxpc3QuIEl0IGlzIGFzc3VtZWQgdGhhdCBsaXN0IHNpemUgaXMgYXQgbGVhc3QgMi5cbiAgZnVuY3Rpb24gZ2V0SGFsdmVzKCBsaXN0ICkge1xuICAgIHZhciBzID0gbGlzdC5sZW5ndGg7XG4gICAgdmFyIGhhbGZJbmRleCA9IE1hdGguZmxvb3IoIHMgLyAyICk7XG4gICAgdmFyIGZpcnN0SGFsZiA9IGxpc3Quc2xpY2UoIDAsIGhhbGZJbmRleCApO1xuICAgIHZhciBzZWNvbmRIYWxmID0gbGlzdC5zbGljZSggaGFsZkluZGV4LCBzICk7XG5cbiAgICByZXR1cm4gWyBmaXJzdEhhbGYsIHNlY29uZEhhbGYgXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZUF0KCBhcnIsIGluZGV4ICkge1xuICAgIGFyci5zcGxpY2UoIGluZGV4LCAxICk7XG4gIH1cblxuICByZXR1cm4gdG9wb2xvZ3lHcm91cGluZztcbn07XG4iXSwibmFtZXMiOlsiaXNFcXVhbCIsInJlcXVpcmUiLCJtb2R1bGUiLCJleHBvcnRzIiwiY3kiLCJlbGVtZW50VXRpbGl0aWVzIiwiZ3JvdXBDb21wb3VuZFR5cGUiLCJtZXRhRWRnZUlkZW50aWZpZXIiLCJsb2NrR3JhcGhUb3BvbG9neSIsInNob3VsZEFwcGx5IiwiREVGQVVMVF9HUk9VUF9DT01QT1VORF9UWVBFIiwiRURHRV9TVFlMRV9OQU1FUyIsInRvcG9sb2d5R3JvdXBpbmciLCJwYXJhbSIsInByb3BzIiwic2JnbnZpekluc3RhbmNlVXRpbGl0aWVzIiwiZ2V0Q3kiLCJhcHBsaWVkIiwiaW5pdE1ldGFTdHlsZU1hcCIsImFwcGx5IiwiZXZhbE9wdCIsImxpc3QiLCJub2RlcyIsIm1hcCIsIm5vZGUiLCJncm91cHMiLCJnZXROb2RlR3JvdXBzIiwibWV0YUVkZ2VzIiwiZ2V0TWV0YUVkZ2VzIiwiY29tcG91bmRzIiwiZ2V0R3JvdXBDb21wb3VuZHMiLCJhcHBseUdyb3VwaW5nIiwidW5hcHBseSIsImZvckVhY2giLCJlZGdlIiwidG9SZXN0b3JlIiwiZGF0YSIsInJlbW92ZSIsInJlc3RvcmUiLCJuYW1lIiwib2xkVmFsIiwibWV0YVN0eWxlTWFwIiwiaWQiLCJuZXdWYWwiLCJwYXJlbnRzIiwiY2hhbmdlUGFyZW50IiwiY2hpbGRyZW4iLCJ1bmxvY2tHcmFwaFRvcG9sb2d5IiwiZWRnZXMiLCJjbGFzc05hbWUiLCJjbGVhckFwcGxpZWRGbGFnIiwic2V0QXBwbGllZEZsYWciLCJ0b2dnbGVBcHBsaWVkRmxhZyIsIm9wdCIsImxlbmd0aCIsImhhbHZlcyIsImdldEhhbHZlcyIsImZpcnN0UGFydCIsInNlY29uZFBhcnQiLCJtZXJnZUdyb3VwcyIsImdldFBhcmVudE9yU2VsZiIsInBhcmVudCIsInNpemUiLCJjYWxjR3JvdXBpbmdLZXkiLCJzcmNJZCIsInNvdXJjZSIsInRndElkIiwidGFyZ2V0IiwiZWRnZVR5cGUiLCJnZXRFZGdlVHlwZSIsImpvaW4iLCJhZGRUb01hcENoYWluIiwia2V5IiwidmFsIiwiY29sbGVjdGlvbiIsImFkZCIsImdyb3VwQ29tcG91bmRzIiwiZ3JvdXAiLCJjcmVhdGVHcm91cENvbXBvdW5kIiwiY2hpbGRyZW5FZGdlcyIsImNvbm5lY3RlZEVkZ2VzIiwiZWRnZXNNYXAiLCJPYmplY3QiLCJrZXlzIiwidGVtcCIsIm1ldGFFZGdlIiwiZmlsdGVyIiwiY3JlYXRlTWV0YUVkZ2VGb3IiLCJjcmVhdGVDb21wb3VuZEZvckdpdmVuTm9kZXMiLCJ0eXBlIiwiYWRkRWRnZSIsInN0eWxlTmFtZSIsImNvbW1vblZhbCIsImdldENvbW1vblByb3BlcnR5IiwiZ3JvdXBzMSIsImdyb3VwczIiLCJub3RNZXJnZWRHcnMiLCJtZXJnZWRHcnMiLCJncjEiLCJtZXJnZWQiLCJjb25jYXQiLCJncjIiLCJpbmRleDIiLCJzaG91bGRNZXJnZSIsIm1lcmdlZEdyIiwicmVtb3ZlQXQiLCJwdXNoIiwiZ3JvdXAxIiwiZ3JvdXAyIiwibm9kZTEiLCJub2RlMiIsImdldFVuZGlyZWN0ZWRFZGdlcyIsImlzVW5kaXJlY3RlZEVkZ2UiLCJ1bmRpcjEiLCJ1bmRpcjIiLCJpbjEiLCJpbmNvbWVycyIsIm5vdCIsImluMiIsIm91dDEiLCJvdXRnb2VycyIsIm91dDIiLCJjb21wYXJlRWRnZUdyb3VwIiwiaWQxIiwiaWQyIiwibWFwMSIsImZpbGxJZFRvVHlwZVNldE1hcCIsIm1hcDIiLCJmYWlsZWQiLCJvdGhlcktleSIsImVkZ2VHcm91cCIsIm5vZGVJZCIsImVkZ2VJZCIsIm90aGVyRW5kIiwiYWRkVG9SZWxhdGVkU2V0Iiwic2lkZVN0ciIsInZhbHVlIiwiU2V0IiwicyIsImhhbGZJbmRleCIsIk1hdGgiLCJmbG9vciIsImZpcnN0SGFsZiIsInNsaWNlIiwic2Vjb25kSGFsZiIsImFyciIsImluZGV4Iiwic3BsaWNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/utilities/topology-grouping-factory.js\n");

/***/ }),

/***/ "./src/utilities/ur-action-functions-extender-factory.js":
/*!***************************************************************!*\
  !*** ./src/utilities/ur-action-functions-extender-factory.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Extends sbgnviz.undoRedoActionFunctions\nvar libs = (__webpack_require__(/*! ./lib-utilities */ \"./src/utilities/lib-utilities.js\").getLibs)();\n\nmodule.exports = function () {\n  var sbgnvizInstance, undoRedoActionFunctions, elementUtilities, cy, topologyGrouping;\n\n  function undoRedoActionFunctionsExtender(param) {\n    sbgnvizInstance = param.sbgnvizInstanceUtilities.getInstance();\n    cy = param.sbgnvizInstanceUtilities.getCy();\n    undoRedoActionFunctions = sbgnvizInstance.undoRedoActionFunctions;\n    elementUtilities = param.elementUtilities;\n    topologyGrouping = param.sifTopologyGrouping;\n    extend();\n  } // Extends undoRedoActionFunctions with chise specific features\n\n\n  function extend() {\n    undoRedoActionFunctions.applySIFTopologyGrouping = function (param) {\n      var oldEles, newEles;\n\n      if (param.firstTime) {\n        oldEles = cy.elements();\n\n        if (param.apply) {\n          topologyGrouping.apply();\n        } else {\n          topologyGrouping.unapply();\n        }\n\n        newEles = cy.elements();\n      } else {\n        oldEles = param.oldEles;\n        newEles = param.newEles;\n\n        if (elementUtilities.isGraphTopologyLocked()) {\n          elementUtilities.unlockGraphTopology();\n        } else {\n          elementUtilities.lockGraphTopology();\n        }\n\n        oldEles.remove();\n        newEles.restore();\n        topologyGrouping.toggleAppliedFlag();\n      }\n\n      var result = {\n        oldEles: newEles,\n        newEles: oldEles\n      };\n      return result;\n    }; // Section Start\n    // add/remove action functions\n\n\n    undoRedoActionFunctions.addNode = function (param) {\n      var result;\n\n      if (param.firstTime) {\n        var newNode = param.newNode;\n        result = elementUtilities.addNode(newNode.x, newNode.y, newNode[\"class\"], newNode.id, newNode.parent, newNode.visibility);\n      } else {\n        result = elementUtilities.restoreEles(param);\n      }\n\n      return {\n        eles: result\n      };\n    };\n\n    undoRedoActionFunctions.addEdge = function (param) {\n      var result;\n\n      if (param.firstTime) {\n        var newEdge = param.newEdge;\n        result = elementUtilities.addEdge(newEdge.source, newEdge.target, newEdge[\"class\"], newEdge.id, newEdge.visibility);\n      } else {\n        result = elementUtilities.restoreEles(param);\n      }\n\n      return {\n        eles: result\n      };\n    };\n\n    undoRedoActionFunctions.addProcessWithConvenientEdges = function (param) {\n      var result;\n\n      if (param.firstTime) {\n        result = elementUtilities.addProcessWithConvenientEdges(param.source, param.target, param.processType);\n      } else {\n        result = elementUtilities.restoreEles(param);\n      }\n\n      return {\n        eles: result\n      };\n    };\n\n    undoRedoActionFunctions.createCompoundForGivenNodes = function (param) {\n      var result = {};\n\n      if (param.firstTime) {\n        // Nodes to make compound, their descendants and edges connected to them will be removed during createCompoundForGivenNodes operation\n        // (internally by eles.move() operation), so mark them as removed eles for undo operation.\n        var nodesToMakeCompound = param.nodesToMakeCompound;\n        var removedEles = nodesToMakeCompound.union(nodesToMakeCompound.descendants());\n        removedEles = removedEles.union(removedEles.connectedEdges());\n        result.removedEles = removedEles; // Assume that all nodes to make compound have the same parent\n\n        var oldParentId = nodesToMakeCompound[0].data(\"parent\"); // The parent of new compound will be the old parent of the nodes to make compound\n        // New eles includes new compound and the moved eles and will be used in undo operation.\n\n        result.newEles = elementUtilities.createCompoundForGivenNodes(nodesToMakeCompound, param.compoundType);\n      } else {\n        result.removedEles = param.newEles.remove();\n        result.newEles = param.removedEles.restore();\n        elementUtilities.maintainPointer(result.newEles);\n      }\n\n      return result;\n    }; // Section End\n    // add/remove action functions\n    // Section Start\n    // easy creation action functions\n\n\n    undoRedoActionFunctions.createTemplateReaction = function (param) {\n      var firstTime = param.firstTime;\n      var eles;\n\n      if (firstTime) {\n        eles = elementUtilities.createTemplateReaction(param.templateType, param.macromoleculeList, param.complexName, param.processPosition, param.tilingPaddingVertical, param.tilingPaddingHorizontal, param.edgeLength, param.layoutParam);\n      } else {\n        eles = param;\n        cy.add(eles);\n        cy.elements().unselect();\n        eles.select();\n      }\n\n      return {\n        eles: eles\n      };\n    };\n\n    undoRedoActionFunctions.createActivationReaction = function (param) {\n      var firstTime = param.firstTime;\n      var eles;\n\n      if (firstTime) {\n        eles = elementUtilities.createActivationReaction(param.proteinName, param.processPosition, param.edgeLength, param.reverse);\n      } else {\n        eles = param;\n        cy.add(eles);\n        cy.elements().unselect();\n        eles.select();\n      }\n\n      return {\n        eles: eles\n      };\n    };\n\n    undoRedoActionFunctions.createTranslation = function (param) {\n      var firstTime = param.firstTime;\n      var eles;\n\n      if (firstTime) {\n        eles = elementUtilities.createTranslation(param.regulatorLabel, param.outputLabel, param.orientation);\n      } else {\n        eles = param;\n        cy.add(eles);\n        cy.elements().unselect();\n        eles.select();\n      }\n\n      return {\n        eles: eles\n      };\n    };\n\n    undoRedoActionFunctions.createTranscription = function (param) {\n      var firstTime = param.firstTime;\n      var eles;\n\n      if (firstTime) {\n        eles = elementUtilities.createTranscription(param.label, param.orientation);\n      } else {\n        eles = param;\n        cy.add(eles);\n        cy.elements().unselect();\n        eles.select();\n      }\n\n      return {\n        eles: eles\n      };\n    };\n\n    undoRedoActionFunctions.createDegradation = function (param) {\n      var firstTime = param.firstTime;\n      var eles;\n\n      if (firstTime) {\n        eles = elementUtilities.createDegradation(param.macromolecule, param.orientation);\n      } else {\n        eles = param;\n        cy.add(eles);\n        cy.elements().unselect();\n        eles.select();\n      }\n\n      return {\n        eles: eles\n      };\n    };\n\n    undoRedoActionFunctions.createComplexProteinFormation = function (param) {\n      var firstTime = param.firstTime;\n      var eles;\n\n      if (firstTime) {\n        eles = elementUtilities.createComplexProteinFormation(param.proteinLabels, param.complexLabel, param.regulator, param.orientation, param.reverse);\n      } else {\n        eles = param;\n        cy.add(eles);\n        cy.elements().unselect();\n        eles.select();\n      }\n\n      return {\n        eles: eles\n      };\n    };\n\n    undoRedoActionFunctions.createMultimerization = function (param) {\n      var firstTime = param.firstTime;\n      var eles;\n\n      if (firstTime) {\n        eles = elementUtilities.createMultimerization(param.macromolecule, param.regulator, param.regulatorMultimer, param.orientation);\n      } else {\n        eles = param;\n        cy.add(eles);\n        cy.elements().unselect();\n        eles.select();\n      }\n\n      return {\n        eles: eles\n      };\n    };\n\n    undoRedoActionFunctions.createConversion = function (param) {\n      var firstTime = param.firstTime;\n      var eles;\n\n      if (firstTime) {\n        eles = elementUtilities.createConversion(param.macromolecule, param.regulator, param.regulatorMultimer, param.orientation, param.inputInfoboxLabels, param.outputInfoboxLabels);\n      } else {\n        eles = param;\n        cy.add(eles);\n        cy.elements().unselect();\n        eles.select();\n      }\n\n      return {\n        eles: eles\n      };\n    };\n\n    undoRedoActionFunctions.createMetabolicReaction = function (param) {\n      var firstTime = param.firstTime;\n      var eles;\n\n      if (firstTime) {\n        eles = elementUtilities.createMetabolicReaction(param.inputs, param.outputs, param.reversible, param.regulator, param.regulatorMultimer, param.orientation);\n      } else {\n        eles = param;\n        cy.add(eles);\n        cy.elements().unselect();\n        eles.select();\n      }\n\n      return {\n        eles: eles\n      };\n    };\n\n    undoRedoActionFunctions.createMetabolicCatalyticActivity = function (param) {\n      var firstTime = param.firstTime;\n      var eles;\n\n      if (firstTime) {\n        eles = elementUtilities.createMetabolicCatalyticActivity(param.inputNodeList, param.outputNodeList, param.catalystName, param.catalystType, param.processPosition, param.tilingPaddingVertical, param.tilingPaddingHorizontal, param.edgeLength);\n      } else {\n        eles = param;\n        cy.add(eles);\n        cy.elements().unselect();\n        eles.select();\n      }\n\n      return {\n        eles: eles\n      };\n    };\n\n    undoRedoActionFunctions.createTranscriptionReaction = function (param) {\n      var firstTime = param.firstTime;\n      var eles;\n\n      if (firstTime) {\n        eles = elementUtilities.createTranscriptionReaction(param.geneName, param.mRnaName, param.processPosition, param.edgeLength);\n      } else {\n        eles = param;\n        cy.add(eles);\n        cy.elements().unselect();\n        eles.select();\n      }\n\n      return {\n        eles: eles\n      };\n    };\n\n    undoRedoActionFunctions.createTranslationReaction = function (param) {\n      var firstTime = param.firstTime;\n      var eles;\n\n      if (firstTime) {\n        eles = elementUtilities.createTranslationReaction(param.mRnaName, param.proteinName, param.processPosition, param.edgeLength);\n      } else {\n        eles = param;\n        cy.add(eles);\n        cy.elements().unselect();\n        eles.select();\n      }\n\n      return {\n        eles: eles\n      };\n    }; // Section End\n    // easy creation action functions\n    // Section Start\n    // general action functions\n\n\n    undoRedoActionFunctions.getNodePositions = function () {\n      var positions = {};\n      var nodes = cy.nodes();\n      nodes.each(function (ele, i) {\n        if (typeof ele === \"number\") {\n          ele = i;\n        }\n\n        positions[ele.id()] = {\n          x: ele.position(\"x\"),\n          y: ele.position(\"y\")\n        };\n      });\n      return positions;\n    };\n\n    undoRedoActionFunctions.returnToPositions = function (positions) {\n      var currentPositions = {};\n      cy.nodes().positions(function (ele, i) {\n        if (typeof ele === \"number\") {\n          ele = i;\n        }\n\n        currentPositions[ele.id()] = {\n          x: ele.position(\"x\"),\n          y: ele.position(\"y\")\n        };\n        var pos = positions[ele.id()];\n        return {\n          x: pos.x,\n          y: pos.y\n        };\n      });\n      return currentPositions;\n    };\n\n    undoRedoActionFunctions.resizeNodes = function (param) {\n      var result = {\n        performOperation: true\n      };\n      var nodes = param.nodes;\n      result.sizeMap = {};\n      result.useAspectRatio = false;\n      result.preserveRelativePos = param.preserveRelativePos;\n\n      for (var i = 0; i < nodes.length; i++) {\n        var node = nodes[i];\n\n        if (node.isParent()) {\n          result.sizeMap[node.id()] = {\n            w: node.data(\"minWidth\") || 0,\n            h: node.data(\"minHeight\") || 0,\n            biasL: node.data(\"minWidthBiasLeft\") || 0,\n            biasR: node.data(\"minWidthBiasRight\") || 0,\n            biasT: node.data(\"minHeightBiasTop\") || 0,\n            biasB: node.data(\"minHeightBiasBottom\") || 0 // w: node.css(\"minWidth\") != 0?  node.data(\"minWidth\") : node.children().boundingBox().w,\n            //h: node.css(\"min-height\") != 0?  node.data(\"minHeight\") : node.children().boundingBox().h\n\n          };\n        } else {\n          result.sizeMap[node.id()] = {\n            w: node.width(),\n            h: node.height()\n          };\n        }\n      }\n\n      result.nodes = nodes;\n\n      for (var i = 0; i < nodes.length; i++) {\n        var node = nodes[i];\n\n        if (param.performOperation) {\n          if (param.sizeMap) {\n            /* if (param.preserveRelativePos === true) {\n              var oldWidth = node.data(\"bbox\").w;\n              var oldHeight = node.data(\"bbox\").h;\n            } */\n            if (node.isParent()) {\n              node.data(\"minHeight\", param.sizeMap[node.id()].h);\n              node.data(\"minWidth\", param.sizeMap[node.id()].w);\n              node.data(\"minWidthBiasLeft\", param.sizeMap[node.id()].biasL);\n              node.data(\"minWidthBiasRight\", param.sizeMap[node.id()].biasR);\n              node.data(\"minHeightBiasTop\", param.sizeMap[node.id()].biasT);\n              node.data(\"minHeightBiasBottom\", param.sizeMap[node.id()].biasB);\n            } else {\n              node.data(\"bbox\").w = param.sizeMap[node.id()].w;\n              node.data(\"bbox\").h = param.sizeMap[node.id()].h;\n            }\n            /* if (param.preserveRelativePos === true) {\n              var statesandinfos = node.data('statesandinfos');\n              var topBottom = statesandinfos.filter(box => (box.anchorSide === \"top\" || box.anchorSide === \"bottom\"));\n              var rightLeft = statesandinfos.filter(box => (box.anchorSide === \"right\" || box.anchorSide === \"left\"));\n               topBottom.forEach(function(box){\n                if (box.bbox.x < 0) {\n                  box.bbox.x = 0;\n                }\n                else if (box.bbox.x > oldWidth) {\n                  box.bbox.x = oldWidth;\n                }\n                box.bbox.x = node.data(\"bbox\").w * box.bbox.x / oldWidth;\n              });\n               rightLeft.forEach(function(box){\n                if (box.bbox.y < 0) {\n                  box.bbox.y = 0;\n                }\n                else if (box.bbox.y > oldHeight) {\n                  box.bbox.y = oldHeight;\n                }\n                box.bbox.y = node.data(\"bbox\").h * box.bbox.y / oldHeight;\n              });\n            } */\n\n          } else {\n            elementUtilities.resizeNodes(param.nodes, param.width, param.height, param.useAspectRatio, param.preserveRelativePos);\n          }\n        }\n      }\n\n      cy.style().update();\n      return result;\n    };\n\n    undoRedoActionFunctions.changeNodeLabel = function (param) {\n      var result = {};\n      var nodes = param.nodes;\n      result.nodes = nodes;\n      result.label = {};\n\n      for (var i = 0; i < nodes.length; i++) {\n        var node = nodes[i];\n        result.label[node.id()] = node._private.data.label;\n      }\n\n      if (param.firstTime) {\n        nodes.data('label', param.label);\n      } else {\n        for (var i = 0; i < nodes.length; i++) {\n          var node = nodes[i];\n          node._private.data.label = param.label[node.id()];\n        }\n      }\n\n      return result;\n    };\n\n    undoRedoActionFunctions.updateInfoboxStyle = function (param) {\n      var result = {};\n      var style = param.node.data('statesandinfos')[param.index].style;\n      result.newProps = $.extend({}, style);\n      result.node = param.node;\n      result.index = param.index;\n      elementUtilities.updateInfoboxStyle(param.node, param.index, param.newProps);\n      return result;\n    };\n\n    undoRedoActionFunctions.updateInfoboxObj = function (param) {\n      var result = {};\n      var obj = param.node.data('statesandinfos')[param.index];\n      result.newProps = $.extend({}, obj);\n      result.node = param.node;\n      result.index = param.index;\n      elementUtilities.updateInfoboxObj(param.node, param.index, param.newProps);\n      return result;\n    };\n\n    undoRedoActionFunctions.changeData = function (param) {\n      var result = {};\n      var eles = param.eles;\n      result.name = param.name;\n      result.valueMap = {};\n      result.eles = eles;\n\n      for (var i = 0; i < eles.length; i++) {\n        var ele = eles[i];\n        result.valueMap[ele.id()] = ele.data(param.name);\n      }\n\n      elementUtilities.changeData(param.eles, param.name, param.valueMap);\n      return result;\n    };\n\n    undoRedoActionFunctions.updateSetField = function (param) {\n      var updates = elementUtilities.updateSetField(param.ele, param.fieldName, param.toDelete, param.toAdd, param.callback);\n      var result = {\n        ele: param.ele,\n        fieldName: param.fieldName,\n        callback: param.callback,\n        toDelete: updates.added,\n        toAdd: updates.deleted\n      };\n      return result;\n    };\n\n    undoRedoActionFunctions.changeCss = function (param) {\n      var result = {};\n      var eles = param.eles;\n      result.name = param.name;\n      result.valueMap = {};\n      result.eles = eles;\n\n      for (var i = 0; i < eles.length; i++) {\n        var ele = eles[i];\n        result.valueMap[ele.id()] = ele.css(param.name);\n      }\n\n      elementUtilities.changeCss(param.eles, param.name, param.valueMap);\n      return result;\n    };\n\n    undoRedoActionFunctions.changeFontProperties = function (param) {\n      var result = {};\n      var eles = param.eles;\n      result.data = {};\n      result.eles = eles;\n\n      for (var i = 0; i < eles.length; i++) {\n        var ele = eles[i];\n        result.data[ele.id()] = {};\n        var data = param.firstTime ? param.data : param.data[ele.id()];\n\n        for (var prop in data) {\n          result.data[ele.id()][prop] = ele.data(prop);\n        }\n      }\n\n      if (param.firstTime) {\n        elementUtilities.changeFontProperties(eles, data);\n      } else {\n        for (var i = 0; i < eles.length; i++) {\n          var ele = eles[i];\n          elementUtilities.changeFontProperties(ele, data);\n        }\n      }\n\n      return result;\n    };\n    /*\n     * Show eles and perform layout.\n     */\n\n\n    undoRedoActionFunctions.showAndPerformLayout = function (param) {\n      var eles = param.eles;\n      var result = {};\n      result.positions = undoRedoActionFunctions.getNodePositions();\n\n      if (param.firstTime) {\n        result.eles = elementUtilities.showAndPerformLayout(param.eles, param.layoutparam);\n      } else {\n        result.eles = cy.viewUtilities().show(eles); // Show given eles\n\n        undoRedoActionFunctions.returnToPositions(param.positions);\n      }\n\n      return result;\n    };\n\n    undoRedoActionFunctions.undoShowAndPerformLayout = function (param) {\n      var eles = param.eles;\n      var result = {};\n      result.positions = undoRedoActionFunctions.getNodePositions();\n      result.eles = cy.viewUtilities().hide(eles); // Hide previously unhidden eles;\n\n      undoRedoActionFunctions.returnToPositions(param.positions);\n      return result;\n    };\n    /*\n     * Hide eles and perform layout.\n     */\n\n\n    undoRedoActionFunctions.hideAndPerformLayout = function (param) {\n      var eles = param.eles;\n      var result = {};\n      result.positions = undoRedoActionFunctions.getNodePositions();\n\n      if (param.firstTime) {\n        result.eles = elementUtilities.hideAndPerformLayout(param.eles, param.layoutparam);\n      } else {\n        result.eles = cy.viewUtilities().hide(eles); // Hide given eles\n\n        undoRedoActionFunctions.returnToPositions(param.positions);\n      }\n\n      return result;\n    };\n\n    undoRedoActionFunctions.undoHideAndPerformLayout = function (param) {\n      var eles = param.eles;\n      var result = {};\n      result.positions = undoRedoActionFunctions.getNodePositions();\n      result.eles = cy.viewUtilities().show(eles); // Show previously hidden eles\n\n      undoRedoActionFunctions.returnToPositions(param.positions);\n      return result;\n    };\n    /*\n     * Delete eles and perform layout.\n     */\n\n\n    undoRedoActionFunctions.deleteAndPerformLayout = function (param) {\n      var eles = param.eles;\n      var result = {};\n      result.positions = undoRedoActionFunctions.getNodePositions();\n\n      if (param.firstTime) {\n        result.eles = elementUtilities.deleteAndPerformLayout(param.eles, param.layoutparam);\n      } else {\n        result.eles = eles.remove();\n        undoRedoActionFunctions.returnToPositions(param.positions);\n      }\n\n      return result;\n    };\n\n    undoRedoActionFunctions.undoDeleteAndPerformLayout = function (param) {\n      var eles = param.eles;\n      var result = {};\n      result.positions = undoRedoActionFunctions.getNodePositions();\n      result.eles = elementUtilities.restoreEles(eles);\n      undoRedoActionFunctions.returnToPositions(param.positions);\n      return result;\n    }; // Section End\n    // general action functions\n    // Section Start\n    // sbgn action functions\n\n\n    undoRedoActionFunctions.changeStateOrInfoBox = function (param) {\n      var result = {};\n      result.type = param.type;\n      result.nodes = param.nodes;\n      result.index = param.index;\n      var data = param.data;\n      var tempData = elementUtilities.saveUnits(param.nodes);\n      result.value = elementUtilities.changeStateOrInfoBox(param.nodes, param.index, param.value, param.type);\n      /* var locations = elementUtilities.checkFit(param.nodes);\n      if (locations !== undefined && locations.length > 0) {\n        elementUtilities.fitUnits(param.nodes, locations);\n      } */\n\n      if (data !== undefined) {\n        elementUtilities.restoreUnits(param.nodes, data);\n      }\n\n      cy.forceRender();\n      result.data = tempData;\n      return result;\n    };\n\n    undoRedoActionFunctions.addStateOrInfoBox = function (param) {\n      var obj = param.obj;\n      var nodes = param.nodes;\n      var data = param.data;\n      var tempData = elementUtilities.saveUnits(nodes);\n      var locationObj = elementUtilities.addStateOrInfoBox(nodes, obj);\n      /*  var locations = elementUtilities.checkFit(nodes);\n       if (locations !== undefined && locations.length > 0) {\n         elementUtilities.fitUnits(nodes, locations);\n       } */\n\n      if (data !== undefined) {\n        elementUtilities.restoreUnits(nodes, data);\n      }\n\n      cy.forceRender();\n      var result = {\n        nodes: nodes,\n        locationObj: locationObj,\n        obj: obj,\n        data: tempData\n      };\n      return result;\n    };\n\n    undoRedoActionFunctions.removeStateOrInfoBox = function (param) {\n      var locationObj = param.locationObj;\n      var nodes = param.nodes;\n      var data = param.data;\n      var tempData = elementUtilities.saveUnits(nodes);\n      var obj = elementUtilities.removeStateOrInfoBox(nodes, locationObj);\n\n      if (data !== undefined) {\n        elementUtilities.restoreUnits(nodes, data);\n      }\n\n      cy.forceRender();\n      var result = {\n        nodes: nodes,\n        obj: obj,\n        data: tempData\n      };\n      return result;\n    };\n\n    undoRedoActionFunctions.fitUnits = function (param) {\n      var node = param.node;\n      var locations = param.locations;\n      var obj = elementUtilities.fitUnits(node, locations);\n      cy.forceRender();\n      var result = {\n        node: node,\n        obj: obj,\n        locations: locations\n      };\n      return result;\n    };\n\n    undoRedoActionFunctions.restoreUnits = function (param) {\n      var node = param.node;\n      var locations = param.locations;\n      var obj = param.obj;\n      var index = 0;\n      node.data('statesandinfos').forEach(function (ele) {\n        var box = obj[index++];\n        ele.bbox.x = box.x;\n        ele.bbox.y = box.y;\n        var oldSide = ele.anchorSide;\n        ele.anchorSide = box.anchorSide;\n        elementUtilities.modifyUnits(node, ele, oldSide);\n      });\n      cy.forceRender();\n      var result = {\n        node: node,\n        locations: locations\n      };\n      return result;\n    };\n\n    undoRedoActionFunctions.setMultimerStatus = function (param) {\n      var firstTime = param.firstTime;\n      var nodes = param.nodes;\n      var status = param.status;\n      var resultStatus = {};\n\n      for (var i = 0; i < nodes.length; i++) {\n        var node = nodes[i];\n        var isMultimer = node.data('class').endsWith(' multimer');\n        resultStatus[node.id()] = isMultimer;\n      } // If this is the first time change the status of all nodes at once.\n      // If not change status of each seperately to the values mapped to their id.\n\n\n      if (firstTime) {\n        elementUtilities.setMultimerStatus(nodes, status);\n      } else {\n        for (var i = 0; i < nodes.length; i++) {\n          var node = nodes[i];\n          elementUtilities.setMultimerStatus(node, status[node.id()]);\n        }\n      } //  if (!firstTime && _.isEqual(nodes, cy.nodes(':selected'))) {\n      //    $('#inspector-is-multimer').attr(\"checked\", !$('#inspector-is-multimer').attr(\"checked\"));\n      //  }\n\n\n      var result = {\n        status: resultStatus,\n        nodes: nodes\n      };\n      return result;\n    };\n\n    undoRedoActionFunctions.setActiveStatus = function (param) {\n      var firstTime = param.firstTime;\n      var nodes = param.nodes;\n      var status = param.status;\n      var resultStatus = {};\n\n      for (var i = 0; i < nodes.length; i++) {\n        var node = nodes[i];\n        var isActive = node.data('class').startsWith('active ');\n        resultStatus[node.id()] = isActive;\n      } // If this is the first time change the status of all nodes at once.\n      // If not change status of each seperately to the values mapped to their id.\n\n\n      if (firstTime) {\n        elementUtilities.setActiveStatus(nodes, status);\n      } else {\n        for (var i = 0; i < nodes.length; i++) {\n          var node = nodes[i];\n          elementUtilities.setActiveStatus(node, status[node.id()]);\n        }\n      } //  if (!firstTime && _.isEqual(nodes, cy.nodes(':selected'))) {\n      //    $('#inspector-is-multimer').attr(\"checked\", !$('#inspector-is-multimer').attr(\"checked\"));\n      //  }\n\n\n      var result = {\n        status: resultStatus,\n        nodes: nodes\n      };\n      return result;\n    };\n\n    undoRedoActionFunctions.setHypotheticalStatus = function (param) {\n      var firstTime = param.firstTime;\n      var nodes = param.nodes;\n      var status = param.status;\n      var resultStatus = {};\n\n      for (var i = 0; i < nodes.length; i++) {\n        var node = nodes[i];\n        var isHypothetical = node.data('class').includes('hypothetical');\n        resultStatus[node.id()] = isHypothetical;\n      } // If this is the first time change the status of all nodes at once.\n      // If not change status of each seperately to the values mapped to their id.\n\n\n      if (firstTime) {\n        elementUtilities.setHypotheticalStatus(nodes, status);\n      } else {\n        for (var i = 0; i < nodes.length; i++) {\n          var node = nodes[i];\n          elementUtilities.setHypotheticalStatus(node, status[node.id()]); //elementUtilities.setHypothteticalStatus\n        }\n      } //  if (!firstTime && _.isEqual(nodes, cy.nodes(':selected'))) {\n      //    $('#inspector-is-multimer').attr(\"checked\", !$('#inspector-is-multimer').attr(\"checked\"));\n      //  }\n\n\n      var result = {\n        status: resultStatus,\n        nodes: nodes\n      };\n      return result;\n    };\n\n    undoRedoActionFunctions.setCloneMarkerStatus = function (param) {\n      var nodes = param.nodes;\n      var status = param.status;\n      var firstTime = param.firstTime;\n      var resultStatus = {};\n\n      for (var i = 0; i < nodes.length; i++) {\n        var node = nodes[i];\n        resultStatus[node.id()] = node.data('clonemarker');\n        var currentStatus = firstTime ? status : status[node.id()];\n        elementUtilities.setCloneMarkerStatus(node, currentStatus);\n      } //  if (!firstTime && _.isEqual(nodes, cy.nodes(':selected'))) {\n      //    $('#inspector-is-clone-marker').attr(\"checked\", !$('#inspector-is-clone-marker').attr(\"checked\"));\n      //  }\n\n\n      var result = {\n        status: resultStatus,\n        nodes: nodes\n      };\n      return result;\n    }; // param: {class: sbgnclass, name: propertyName, value: value}\n\n\n    undoRedoActionFunctions.setDefaultProperty = function (param) {\n      var sbgnclass = param[\"class\"];\n      var name = param.name;\n      var value = param.value;\n      var classDefaults = elementUtilities.getDefaultProperties(sbgnclass);\n      var result = {\n        \"class\": sbgnclass,\n        name: name,\n        value: classDefaults.hasOwnProperty(name) ? classDefaults[name] : undefined\n      };\n      var propMap = {};\n      propMap[name] = value;\n      elementUtilities.setDefaultProperties(sbgnclass, propMap);\n      return result;\n    };\n\n    undoRedoActionFunctions.addBackgroundImage = function (param) {\n      var bgObj = param.bgObj;\n      var nodes = param.nodes;\n      var updateInfo = param.updateInfo;\n      var promptInvalidImage = param.promptInvalidImage;\n      var validateURL = param.validateURL;\n      elementUtilities.addBackgroundImage(nodes, bgObj, updateInfo, promptInvalidImage, validateURL);\n      cy.forceRender();\n      var result = {\n        nodes: nodes,\n        bgObj: bgObj,\n        updateInfo: updateInfo,\n        promptInvalidImage: promptInvalidImage,\n        validateURL: validateURL\n      };\n      return result;\n    };\n\n    undoRedoActionFunctions.removeBackgroundImage = function (param) {\n      var bgObj = param.bgObj;\n      var nodes = param.nodes;\n      elementUtilities.removeBackgroundImage(nodes, bgObj);\n      cy.forceRender();\n      var result = {\n        nodes: nodes,\n        bgObj: bgObj\n      };\n      return result;\n    };\n\n    undoRedoActionFunctions.updateBackgroundImage = function (param) {\n      var bgObj = param.bgObj;\n      var nodes = param.nodes;\n      var oldBgObj = elementUtilities.updateBackgroundImage(nodes, bgObj);\n      cy.forceRender();\n      var result = {\n        nodes: nodes,\n        bgObj: oldBgObj\n      };\n      return result;\n    };\n\n    undoRedoActionFunctions.changeBackgroundImage = function (param) {\n      var oldImg = param.oldImg;\n      var newImg = param.newImg;\n      var nodes = param.nodes;\n      var firstTime = param.firstTime;\n      var updateInfo = param.updateInfo;\n      var promptInvalidImage = param.promptInvalidImage;\n      var validateURL = param.validateURL;\n      var result = elementUtilities.changeBackgroundImage(nodes, oldImg, newImg, firstTime, updateInfo, promptInvalidImage, validateURL);\n      cy.forceRender();\n      return result;\n    }; // Section End\n    // sbgn action functions\n\n\n    undoRedoActionFunctions.convertIntoReversibleReaction = function (param) {\n      var collection = cy.collection();\n      var mapType = elementUtilities.getMapType();\n      elementUtilities.setMapType(param.mapType);\n      $('#map-type').val(param.mapType);\n      param.collection.forEach(function (edge) {\n        var sourceNode = edge._private.data.source;\n        var targetNode = edge._private.data.target;\n        edge.move({\n          source: targetNode,\n          target: sourceNode\n        });\n        var convertedEdge = cy.getElementById(edge.id());\n\n        if (convertedEdge.data(\"cyedgebendeditingDistances\")) {\n          var distance = convertedEdge.data(\"cyedgebendeditingDistances\");\n          distance = distance.map(function (element) {\n            return -1 * element;\n          });\n          convertedEdge.data(\"cyedgebendeditingDistances\", distance.reverse());\n          var weight = convertedEdge.data(\"cyedgebendeditingWeights\");\n          weight = weight.map(function (element) {\n            return 1 - element;\n          });\n          convertedEdge.data(\"cyedgebendeditingWeights\", weight.reverse());\n        }\n\n        if (convertedEdge.data(\"cyedgecontroleditingDistances\")) {\n          var _distance = convertedEdge.data(\"cyedgecontroleditingDistances\");\n\n          _distance = _distance.map(function (element) {\n            return -1 * element;\n          });\n          convertedEdge.data(\"cyedgecontroleditingDistances\", _distance.reverse());\n\n          var _weight = convertedEdge.data(\"cyedgecontroleditingWeigths\");\n\n          _weight = _weight.map(function (element) {\n            return 1 - element;\n          });\n          convertedEdge.data(\"cyedgecontroleditingWeigths\", _weight.reverse());\n        }\n\n        if (convertedEdge._private.data[\"class\"] === \"consumption\") {\n          convertedEdge._private.data[\"class\"] = \"production\";\n          convertedEdge._private.data.portsource = targetNode + \".1\";\n          convertedEdge._private.data.porttarget = sourceNode;\n        } else if (convertedEdge._private.data[\"class\"] === \"production\") {\n          convertedEdge._private.data[\"class\"] = \"consumption\";\n          convertedEdge._private.data.portsource = targetNode;\n          convertedEdge._private.data.porttarget = sourceNode + \".1\";\n        }\n\n        collection = collection.add(convertedEdge);\n        cy.style().update();\n      });\n      var result = {\n        collection: collection,\n        mapType: mapType,\n        processId: param.processId\n      };\n      return result;\n    };\n\n    undoRedoActionFunctions.moveEdge = function (param) {\n      var result = {};\n      var edge = param.edge;\n      result.name = param.name;\n      result.source = edge.source().id();\n      result.target = edge.target().id();\n      result.portsource = edge.data(\"portsource\");\n      result.porttarget = edge.data(\"porttarget\");\n      elementUtilities.changeData(edge, 'source', param.source);\n      elementUtilities.changeData(edge, 'target', param.target);\n      elementUtilities.changeData(edge, 'portsource', param.portsource);\n      elementUtilities.changeData(edge, 'porttarget', param.porttarget);\n      edge = edge.move({\n        target: param.target,\n        source: param.source\n      });\n      result.edge = edge;\n      return result;\n    };\n\n    undoRedoActionFunctions.fixError = function (param) {\n      var errorCode = param.errorCode;\n      var result = {};\n      result.errorCode = errorCode;\n\n      if (errorCode == \"pd10101\" || errorCode == 'pd10102') {\n        result.edge = elementUtilities.reverseEdge(param.edge);\n        return result;\n      } else if (errorCode == \"pd10103\" || errorCode == 'pd10107') {\n        param.newNodes.forEach(function (newNode) {\n          elementUtilities.addNode(newNode.x, newNode.y, newNode[\"class\"], newNode.id, undefined);\n        });\n        param.newEdges.forEach(function (newEdge) {\n          elementUtilities.addEdge(newEdge.source, newEdge.target, newEdge[\"class\"]);\n        });\n        param.oldEdges.forEach(function (oldEdge) {\n          cy.elements().unselect(); //return \n\n          oldEdge.remove();\n        });\n        param.node.remove();\n        return param;\n      } else if (errorCode == \"pd10105\" || errorCode == 'pd10106') {\n        result.edge = elementUtilities.reverseEdge(param.edge);\n        return result;\n      } else if (errorCode == \"pd10140\") {\n        param.node.remove();\n        return param;\n      } else if (errorCode == \"pd10104\") {\n        param.edges.forEach(function (edge) {\n          edge.remove();\n        });\n        param.nodes.forEach(function (node) {\n          node.remove();\n        });\n        return param;\n      } else if (errorCode == \"pd10108\") {\n        param.edges.forEach(function (edge) {\n          edge.remove();\n        });\n        param.nodes.forEach(function (node) {\n          node.remove();\n        });\n        return param;\n      } else if (errorCode == \"pd10111\") {\n        param.edges.forEach(function (edge) {\n          edge.remove();\n        });\n        return param;\n      } else if (errorCode == \"pd10126\") {\n        param.edges.forEach(function (edge) {\n          edge.remove();\n        });\n        param.nodes.forEach(function (node) {\n          node.remove();\n        });\n        return param;\n      } else if (errorCode == \"pd10109\" || errorCode == \"pd10124\") {\n        result.newSource = param.edge.data().source;\n        result.newTarget = param.edge.data().target;\n        result.portsource = param.edge.data().portsource;\n        var clonedEdge = param.edge.clone();\n        var edgeParams = {\n          \"class\": clonedEdge.data()[\"class\"],\n          language: clonedEdge.data().language\n        };\n        clonedEdge.data().source = param.newSource;\n        clonedEdge.data().target = param.newTarget;\n        cy.remove(param.edge);\n        result.edge = elementUtilities.addEdge(param.newSource, param.newTarget, edgeParams, clonedEdge.data().id);\n        return result;\n      } else if (errorCode == \"pd10112\") {\n        param.callback = elementUtilities.maintainPointer; // If this is first time we should move the node to its new parent and relocate it by given posDiff params\n        // else we should remove the moved eles and restore the eles to restore\n\n        if (param.firstTime) {\n          var newParentId = param.parentData == undefined ? null : param.parentData; // These eles includes the nodes and their connected edges and will be removed in nodes.move().\n          // They should be restored in undo\n\n          var withDescendant = param.nodes.union(param.nodes.descendants());\n          result.elesToRestore = withDescendant.union(withDescendant.connectedEdges()); // These are the eles created by nodes.move(), they should be removed in undo.\n\n          result.movedEles = param.nodes.move({\n            \"parent\": newParentId\n          });\n          var posDiff = {\n            x: param.posDiffX,\n            y: param.posDiffY\n          };\n          elementUtilities.moveNodes(posDiff, result.movedEles);\n        } else {\n          result.elesToRestore = param.movedEles.remove();\n          result.movedEles = param.elesToRestore.restore();\n        }\n\n        if (param.callback) {\n          result.callback = param.callback; // keep the provided callback so it can be reused after undo/redo\n\n          param.callback(result.movedEles); // apply the callback on newly created elements\n        }\n\n        return result;\n      } else if (errorCode == \"pd10125\") {\n        result.edge = param.edge.remove();\n        result.newEdge = {};\n        var edgeclass = param.newEdge.edgeParams[\"class\"] ? param.newEdge.edgeParams[\"class\"] : param.newEdge.edgeParams;\n        var validation = elementUtilities.validateArrowEnds(edgeclass, cy.getElementById(param.newEdge.source), cy.getElementById(param.newEdge.target));\n\n        if (validation === 'reverse') {\n          var temp = param.newEdge.source;\n          param.newEdge.source = param.newEdge.target;\n          param.newEdge.target = temp;\n        }\n\n        result.newEdge.id = elementUtilities.addEdge(param.newEdge.source, param.newEdge.target, param.newEdge.edgeParams).id();\n        result.newEdge.source = param.newEdge.source;\n        result.newEdge.target = param.newEdge.target;\n        result.newEdge.edgeParams = param.newEdge.edgeParams;\n        return result;\n      } else if (errorCode == \"pd10142\") {\n        result.edge = param.edge.remove();\n        result.newEdge = {};\n        var edgeclass = param.newEdge.edgeParams[\"class\"] ? param.newEdge.edgeParams[\"class\"] : param.newEdge.edgeParams;\n        var validation = elementUtilities.validateArrowEnds(edgeclass, cy.getElementById(param.newEdge.source), cy.getElementById(param.newEdge.target));\n\n        if (validation === 'reverse') {\n          var temp = param.newEdge.source;\n          param.newEdge.source = param.newEdge.target;\n          param.newEdge.target = temp;\n        }\n\n        result.newEdge.id = elementUtilities.addEdge(param.newEdge.source, param.newEdge.target, param.newEdge.edgeParams).id();\n        result.newEdge.source = param.newEdge.source;\n        result.newEdge.target = param.newEdge.target;\n        result.newEdge.edgeParams = param.newEdge.edgeParams;\n        return result;\n      } else {\n        result.newSource = param.edge.source().id();\n        result.newTarget = param.edge.target().id();\n        result.porttarget = param.edge.data(\"porttarget\");\n        result.edge = param.edge.move({\n          target: param.newTarget,\n          source: param.newSource\n        });\n        elementUtilities.changeData(result.edge, 'porttarget', param.porttarget);\n        return result;\n      }\n    };\n\n    undoRedoActionFunctions.unfixError = function (param) {\n      var errorCode = param.errorCode;\n      var result = {};\n      result.errorCode = errorCode;\n\n      if (errorCode == \"pd10101\" || errorCode == 'pd10102') {\n        result.edge = elementUtilities.reverseEdge(param.edge);\n        return result;\n      } else if (errorCode == \"pd10103\" || errorCode == 'pd10107') {\n        param.newNodes.forEach(function (newNode) {\n          cy.remove(cy.$('#' + newNode.id));\n        });\n        param.node.restore();\n        param.oldEdges.forEach(function (oldEdge) {\n          oldEdge.restore();\n        });\n        cy.animate({\n          duration: 100,\n          easing: 'ease',\n          fit: {\n            eles: {},\n            padding: 20\n          },\n          complete: function complete() {}\n        });\n        return param;\n      } else if (errorCode == \"pd10105\" || errorCode == 'pd10106') {\n        result.edge = elementUtilities.reverseEdge(param.edge);\n        return result;\n      } else if (errorCode == \"pd10140\") {\n        param.node.restore();\n        cy.animate({\n          duration: 100,\n          easing: 'ease',\n          fit: {\n            eles: {},\n            padding: 20\n          },\n          complete: function complete() {}\n        });\n        return param;\n      } else if (errorCode == \"pd10104\") {\n        param.nodes.forEach(function (node) {\n          node.restore();\n        });\n        param.edges.forEach(function (edge) {\n          edge.restore();\n        });\n        return param;\n      } else if (errorCode == \"pd10108\") {\n        param.nodes.forEach(function (node) {\n          node.restore();\n        });\n        param.edges.forEach(function (edge) {\n          edge.restore();\n        });\n        return param;\n      } else if (errorCode == \"pd10111\") {\n        param.edges.forEach(function (edge) {\n          edge.restore();\n        });\n        return param;\n      } else if (errorCode == \"pd10126\") {\n        param.nodes.forEach(function (node) {\n          node.restore();\n        });\n        param.edges.forEach(function (edge) {\n          edge.restore();\n        });\n        return param;\n      } else if (errorCode == \"pd10109\" || errorCode == \"pd10124\") {\n        result.newSource = param.edge.source().id();\n        result.newTarget = param.edge.target().id();\n        result.portsource = param.portsource;\n        result.edge = param.edge.move({\n          target: param.newTarget,\n          source: param.newSource\n        });\n        elementUtilities.changeData(result.edge, 'portsource', param.portsource);\n        return result;\n      } else if (errorCode == \"pd10112\") {\n        // If this is first time we should move the node to its new parent and relocate it by given posDiff params\n        // else we should remove the moved eles and restore the eles to restore\n        if (param.firstTime) {\n          var newParentId = param.parentData == undefined ? null : param.parentData; // These eles includes the nodes and their connected edges and will be removed in nodes.move().\n          // They should be restored in undo\n\n          var withDescendant = param.nodes.union(param.nodes.descendants());\n          result.elesToRestore = withDescendant.union(withDescendant.connectedEdges()); // These are the eles created by nodes.move(), they should be removed in undo.\n\n          result.movedEles = param.nodes.move({\n            \"parent\": newParentId\n          });\n          var posDiff = {\n            x: param.posDiffX,\n            y: param.posDiffY\n          };\n          elementUtilities.moveNodes(posDiff, result.movedEles);\n        } else {\n          result.elesToRestore = param.movedEles.remove();\n          result.movedEles = param.elesToRestore.restore();\n        }\n\n        if (param.callback) {\n          result.callback = param.callback; // keep the provided callback so it can be reused after undo/redo\n\n          param.callback(result.movedEles); // apply the callback on newly created elements\n        }\n\n        return result;\n      } else if (errorCode == \"pd10125\") {\n        cy.$('#' + param.newEdge.id).remove();\n        param.edge = param.edge.restore();\n        return param;\n      } else if (errorCode == \"pd10142\") {\n        cy.$('#' + param.newEdge.id).remove();\n        param.edge = param.edge.restore();\n        return param;\n      } else {\n        result.newSource = param.edge.source().id();\n        result.newTarget = param.edge.target().id();\n        result.porttarget = param.edge.data(\"porttarget\");\n        result.edge = param.edge.move({\n          target: param.newTarget,\n          source: param.newSource\n        });\n        elementUtilities.changeData(result.edge, 'porttarget', param.porttarget);\n        return result;\n      }\n    };\n\n    undoRedoActionFunctions.cloneHighDegreeNode = function (node) {\n      var result = {};\n      var oldX = node.position().x;\n      var oldY = node.position().y;\n\n      var claculateNewClonePosition = function claculateNewClonePosition(sourceEndPointX, sourceEndPointY, targetEndPointX, targetEndPointY, desiredDistance, direction) {\n        var distance = Math.sqrt(Math.pow(targetEndPointY - sourceEndPointY, 2) + Math.pow(targetEndPointX - sourceEndPointX, 2));\n        var ratio = desiredDistance / distance;\n        var result = {};\n\n        if (direction == \"source\") {\n          result.cx = (1 - ratio) * sourceEndPointX + ratio * targetEndPointX;\n          result.cy = (1 - ratio) * sourceEndPointY + ratio * targetEndPointY;\n        } else {\n          result.cx = (1 - ratio) * targetEndPointX + ratio * sourceEndPointX;\n          result.cy = (1 - ratio) * targetEndPointY + ratio * sourceEndPointY;\n        }\n\n        return result;\n      };\n\n      var edges = node.connectedEdges();\n      var desiredDistance = (node.height() > node.width() ? node.height() : node.width()) * 0.1;\n\n      for (var i = 1; i < edges.length; i++) {\n        var edge = edges[i];\n        var index = i;\n        var edgeClone = edge.clone();\n        var startPosition = edge.source().id() == node.id() ? \"source\" : \"target\";\n        var newPosition = claculateNewClonePosition(edge.sourceEndpoint().x, edge.sourceEndpoint().y, edge.targetEndpoint().x, edge.targetEndpoint().y, desiredDistance, startPosition);\n        var newNodeId = node.id() + 'clone-' + index; //edgeClone.data().id = edgeClone.data().id+ \"-\"+newNodeId;\n\n        if (edge.source().id() == node.id()) {\n          edgeClone.data().source = newNodeId;\n          edgeClone.data().portsource = newNodeId;\n        } else {\n          edgeClone.data().target = newNodeId;\n          edgeClone.data().porttarget = newNodeId;\n        }\n\n        var newNode = node.clone();\n        newNode.data().id = newNodeId;\n        cy.add(newNode);\n        edge.remove();\n        cy.add(edgeClone);\n        newNode.position({\n          x: newPosition.cx,\n          y: newPosition.cy\n        });\n        elementUtilities.setCloneMarkerStatus(newNode, true);\n      }\n\n      var newPosition = claculateNewClonePosition(edges[0].sourceEndpoint().x, edges[0].sourceEndpoint().y, edges[0].targetEndpoint().x, edges[0].targetEndpoint().y, desiredDistance, edges[0].source().id() == node.id() ? \"source\" : \"target\");\n      var cloneEdge = edges[0].clone(); //cloneEdge.data().id = cloneEdge.data().id+ \"-\"+node.id()+'clone-0';\n\n      edges[0].remove();\n      cy.add(cloneEdge);\n      elementUtilities.setCloneMarkerStatus(node, true);\n      node.position({\n        x: newPosition.cx,\n        y: newPosition.cy\n      });\n      result.oldX = oldX;\n      result.oldY = oldY;\n      result.node = node;\n      result.numberOfEdges = edges.length;\n      return result;\n    };\n\n    undoRedoActionFunctions.unCloneHighDegreeNode = function (param) {\n      var node = param.node;\n      elementUtilities.setCloneMarkerStatus(node, false);\n      node.position({\n        x: param.oldX,\n        y: param.oldY\n      });\n\n      for (var i = 1; i < param.numberOfEdges; i++) {\n        var cloneId = node.id() + 'clone-' + i;\n        var clone = cy.$(\"#\" + cloneId);\n        var cloneEdge = clone.connectedEdges()[0];\n        var edge = cloneEdge.clone();\n\n        if (edge.data().source == cloneId) {\n          edge.data().source = node.id();\n          edge.data().portsource = node.id();\n        } else {\n          edge.data().target = node.id();\n          edge.data().porttarget = node.id();\n        }\n\n        cloneEdge.remove();\n        clone.remove();\n        cy.add(edge);\n      }\n\n      return node;\n    };\n\n    undoRedoActionFunctions.changeMapType = function (param) {\n      var result = {};\n      var currentMapType = elementUtilities.getMapType();\n      elementUtilities.setMapType(param.mapType);\n      result.mapType = currentMapType;\n      result.callback = param.callback;\n      param.callback();\n      return result;\n    };\n  }\n\n  return undoRedoActionFunctionsExtender;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdXRpbGl0aWVzL3VyLWFjdGlvbi1mdW5jdGlvbnMtZXh0ZW5kZXItZmFjdG9yeS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLElBQUlBLElBQUksR0FBR0Msd0ZBQUEsRUFBWDs7QUFFQUUsTUFBTSxDQUFDQyxPQUFQLEdBQWlCLFlBQVk7RUFFM0IsSUFBSUMsZUFBSixFQUFxQkMsdUJBQXJCLEVBQThDQyxnQkFBOUMsRUFBZ0VDLEVBQWhFLEVBQW9FQyxnQkFBcEU7O0VBRUEsU0FBU0MsK0JBQVQsQ0FBMENDLEtBQTFDLEVBQWlEO0lBRS9DTixlQUFlLEdBQUdNLEtBQUssQ0FBQ0Msd0JBQU4sQ0FBK0JDLFdBQS9CLEVBQWxCO0lBQ0FMLEVBQUUsR0FBR0csS0FBSyxDQUFDQyx3QkFBTixDQUErQkUsS0FBL0IsRUFBTDtJQUNBUix1QkFBdUIsR0FBR0QsZUFBZSxDQUFDQyx1QkFBMUM7SUFDQUMsZ0JBQWdCLEdBQUdJLEtBQUssQ0FBQ0osZ0JBQXpCO0lBQ0FFLGdCQUFnQixHQUFHRSxLQUFLLENBQUNJLG1CQUF6QjtJQUVBQyxNQUFNO0VBQ1AsQ0FiMEIsQ0FlM0I7OztFQUNBLFNBQVNBLE1BQVQsR0FBbUI7SUFFakJWLHVCQUF1QixDQUFDVyx3QkFBeEIsR0FBbUQsVUFBU04sS0FBVCxFQUFnQjtNQUNqRSxJQUFJTyxPQUFKLEVBQWFDLE9BQWI7O01BQ0EsSUFBS1IsS0FBSyxDQUFDUyxTQUFYLEVBQXVCO1FBQ3JCRixPQUFPLEdBQUdWLEVBQUUsQ0FBQ2EsUUFBSCxFQUFWOztRQUVBLElBQUlWLEtBQUssQ0FBQ1csS0FBVixFQUFpQjtVQUNmYixnQkFBZ0IsQ0FBQ2EsS0FBakI7UUFDRCxDQUZELE1BR0s7VUFDSGIsZ0JBQWdCLENBQUNjLE9BQWpCO1FBQ0Q7O1FBRURKLE9BQU8sR0FBR1gsRUFBRSxDQUFDYSxRQUFILEVBQVY7TUFDRCxDQVhELE1BWUs7UUFDSEgsT0FBTyxHQUFHUCxLQUFLLENBQUNPLE9BQWhCO1FBQ0FDLE9BQU8sR0FB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QUksQ0FBQ3JLLElBQUwsR0FBWVYsTUFBWixHQUFzQjBFLElBQUksQ0FBQ2xGLEVBQUwsRUFBdEI7VUFDQXVMLElBQUksQ0FBQ3JLLElBQUwsR0FBWWdMLFVBQVosR0FBMEJoSCxJQUFJLENBQUNsRixFQUFMLEVBQTFCO1FBQ0Q7O1FBRUQ0UCxTQUFTLENBQUNwUSxNQUFWO1FBQ0F3TixLQUFLLENBQUN4TixNQUFOO1FBRUFuQixFQUFFLENBQUN5RCxHQUFILENBQU95SixJQUFQO01BQ0Q7O01BRUQsT0FBT3JHLElBQVA7SUFDRCxDQS9CRDs7SUFpQ0EvRyx1QkFBdUIsQ0FBQzZSLGFBQXhCLEdBQXdDLFVBQVN4UixLQUFULEVBQWU7TUFDckQsSUFBSW1CLE1BQU0sR0FBRSxFQUFaO01BQ0EsSUFBSXNRLGNBQWMsR0FBRzdSLGdCQUFnQixDQUFDZ04sVUFBakIsRUFBckI7TUFDQWhOLGdCQUFnQixDQUFDaU4sVUFBakIsQ0FBNEI3TSxLQUFLLENBQUMyTSxPQUFsQztNQUNBeEwsTUFBTSxDQUFDd0wsT0FBUCxHQUFpQjhFLGNBQWpCO01BQ0F0USxNQUFNLENBQUNtSCxRQUFQLEdBQWtCdEksS0FBSyxDQUFDc0ksUUFBeEI7TUFDQXRJLEtBQUssQ0FBQ3NJLFFBQU47TUFDQSxPQUFPbkgsTUFBUDtJQUNELENBUkQ7RUFVQzs7RUFFRCxPQUFPcEIsK0JBQVA7QUFDRCxDQTVsREQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jaGlzZS8uL3NyYy91dGlsaXRpZXMvdXItYWN0aW9uLWZ1bmN0aW9ucy1leHRlbmRlci1mYWN0b3J5LmpzPzNiNTciXSwic291cmNlc0NvbnRlbnQiOlsiLy8gRXh0ZW5kcyBzYmdudml6LnVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zXG52YXIgbGlicyA9IHJlcXVpcmUoJy4vbGliLXV0aWxpdGllcycpLmdldExpYnMoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIHNiZ252aXpJbnN0YW5jZSwgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMsIGVsZW1lbnRVdGlsaXRpZXMsIGN5LCB0b3BvbG9neUdyb3VwaW5nO1xuXG4gIGZ1bmN0aW9uIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zRXh0ZW5kZXIgKHBhcmFtKSB7XG5cbiAgICBzYmdudml6SW5zdGFuY2UgPSBwYXJhbS5zYmdudml6SW5zdGFuY2VVdGlsaXRpZXMuZ2V0SW5zdGFuY2UoKTtcbiAgICBjeSA9IHBhcmFtLnNiZ252aXpJbnN0YW5jZVV0aWxpdGllcy5nZXRDeSgpO1xuICAgIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zID0gc2JnbnZpekluc3RhbmNlLnVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zO1xuICAgIGVsZW1lbnRVdGlsaXRpZXMgPSBwYXJhbS5lbGVtZW50VXRpbGl0aWVzO1xuICAgIHRvcG9sb2d5R3JvdXBpbmcgPSBwYXJhbS5zaWZUb3BvbG9neUdyb3VwaW5nO1xuXG4gICAgZXh0ZW5kKCk7XG4gIH1cblxuICAvLyBFeHRlbmRzIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zIHdpdGggY2hpc2Ugc3BlY2lmaWMgZmVhdHVyZXNcbiAgZnVuY3Rpb24gZXh0ZW5kICgpIHtcblxuICAgIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLmFwcGx5U0lGVG9wb2xvZ3lHcm91cGluZyA9IGZ1bmN0aW9uKHBhcmFtKSB7XG4gICAgICB2YXIgb2xkRWxlcywgbmV3RWxlcztcbiAgICAgIGlmICggcGFyYW0uZmlyc3RUaW1lICkge1xuICAgICAgICBvbGRFbGVzID0gY3kuZWxlbWVudHMoKTtcblxuICAgICAgICBpZiAocGFyYW0uYXBwbHkpIHtcbiAgICAgICAgICB0b3BvbG9neUdyb3VwaW5nLmFwcGx5KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdG9wb2xvZ3lHcm91cGluZy51bmFwcGx5KCk7XG4gICAgICAgIH1cblxuICAgICAgICBuZXdFbGVzID0gY3kuZWxlbWVudHMoKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBvbGRFbGVzID0gcGFyYW0ub2xkRWxlcztcbiAgICAgICAgbmV3RWxlcyA9IHBhcmFtLm5ld0VsZXM7XG5cbiAgICAgICAgaWYgKCBlbGVtZW50VXRpbGl0aWVzLmlzR3JhcGhUb3BvbG9neUxvY2tlZCgpICkge1xuICAgICAgICAgIGVsZW1lbnRVdGlsaXRpZXMudW5sb2NrR3JhcGhUb3BvbG9neSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGVsZW1lbnRVdGlsaXRpZXMubG9ja0dyYXBoVG9wb2xvZ3koKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9sZEVsZXMucmVtb3ZlKCk7XG4gICAgICAgIG5ld0VsZXMucmVzdG9yZSgpO1xuXG4gICAgICAgIHRvcG9sb2d5R3JvdXBpbmcudG9nZ2xlQXBwbGllZEZsYWcoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlc3VsdCA9IHsgb2xkRWxlczogbmV3RWxlcywgbmV3RWxlczogb2xkRWxlcyB9O1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgLy8gU2VjdGlvbiBTdGFydFxuICAgIC8vIGFkZC9yZW1vdmUgYWN0aW9uIGZ1bmN0aW9uc1xuXG4gICAgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMuYWRkTm9kZSA9IGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgdmFyIHJlc3VsdDtcbiAgICAgIGlmIChwYXJhbS5maXJzdFRpbWUpIHtcbiAgICAgICAgdmFyIG5ld05vZGUgPSBwYXJhbS5uZXdOb2RlO1xuICAgICAgICByZXN1bHQgPSBlbGVtZW50VXRpbGl0aWVzLmFkZE5vZGUobmV3Tm9kZS54LCBuZXdOb2RlLnksIG5ld05vZGUuY2xhc3MsIG5ld05vZGUuaWQsIG5ld05vZGUucGFyZW50LCBuZXdOb2RlLnZpc2liaWxpdHkpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IGVsZW1lbnRVdGlsaXRpZXMucmVzdG9yZUVsZXMocGFyYW0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBlbGVzOiByZXN1bHRcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLmFkZEVkZ2UgPSBmdW5jdGlvbiAocGFyYW0pIHtcbiAgICAgIHZhciByZXN1bHQ7XG4gICAgICBpZiAocGFyYW0uZmlyc3RUaW1lKSB7XG4gICAgICAgIHZhciBuZXdFZGdlID0gcGFyYW0ubmV3RWRnZTtcbiAgICAgICAgcmVzdWx0ID0gZWxlbWVudFV0aWxpdGllcy5hZGRFZGdlKG5ld0VkZ2Uuc291cmNlLCBuZXdFZGdlLnRhcmdldCwgbmV3RWRnZS5jbGFzcywgbmV3RWRnZS5pZCwgbmV3RWRnZS52aXNpYmlsaXR5KTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBlbGVtZW50VXRpbGl0aWVzLnJlc3RvcmVFbGVzKHBhcmFtKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZWxlczogcmVzdWx0XG4gICAgICB9O1xuICAgIH07XG5cbiAgICB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5hZGRQcm9jZXNzV2l0aENvbnZlbmllbnRFZGdlcyA9IGZ1bmN0aW9uKHBhcmFtKSB7XG4gICAgICB2YXIgcmVzdWx0O1xuICAgICAgaWYgKHBhcmFtLmZpcnN0VGltZSkge1xuICAgICAgICByZXN1bHQgPSBlbGVtZW50VXRpbGl0aWVzLmFkZFByb2Nlc3NXaXRoQ29udmVuaWVudEVkZ2VzKHBhcmFtLnNvdXJjZSwgcGFyYW0udGFyZ2V0LCBwYXJhbS5wcm9jZXNzVHlwZSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gZWxlbWVudFV0aWxpdGllcy5yZXN0b3JlRWxlcyhwYXJhbSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVsZXM6IHJlc3VsdFxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMuY3JlYXRlQ29tcG91bmRGb3JHaXZlbk5vZGVzID0gZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgICB2YXIgcmVzdWx0ID0ge307XG5cbiAgICAgIGlmIChwYXJhbS5maXJzdFRpbWUpIHtcbiAgICAgICAgLy8gTm9kZXMgdG8gbWFrZSBjb21wb3VuZCwgdGhlaXIgZGVzY2VuZGFudHMgYW5kIGVkZ2VzIGNvbm5lY3RlZCB0byB0aGVtIHdpbGwgYmUgcmVtb3ZlZCBkdXJpbmcgY3JlYXRlQ29tcG91bmRGb3JHaXZlbk5vZGVzIG9wZXJhdGlvblxuICAgICAgICAvLyAoaW50ZXJuYWxseSBieSBlbGVzLm1vdmUoKSBvcGVyYXRpb24pLCBzbyBtYXJrIHRoZW0gYXMgcmVtb3ZlZCBlbGVzIGZvciB1bmRvIG9wZXJhdGlvbi5cbiAgICAgICAgdmFyIG5vZGVzVG9NYWtlQ29tcG91bmQgPSBwYXJhbS5ub2Rlc1RvTWFrZUNvbXBvdW5kO1xuICAgICAgICB2YXIgcmVtb3ZlZEVsZXMgPSBub2Rlc1RvTWFrZUNvbXBvdW5kLnVuaW9uKG5vZGVzVG9NYWtlQ29tcG91bmQuZGVzY2VuZGFudHMoKSk7XG4gICAgICAgIHJlbW92ZWRFbGVzID0gcmVtb3ZlZEVsZXMudW5pb24ocmVtb3ZlZEVsZXMuY29ubmVjdGVkRWRnZXMoKSk7XG4gICAgICAgIHJlc3VsdC5yZW1vdmVkRWxlcyA9IHJlbW92ZWRFbGVzO1xuICAgICAgICAvLyBBc3N1bWUgdGhhdCBhbGwgbm9kZXMgdG8gbWFrZSBjb21wb3VuZCBoYXZlIHRoZSBzYW1lIHBhcmVudFxuICAgICAgICB2YXIgb2xkUGFyZW50SWQgPSBub2Rlc1RvTWFrZUNvbXBvdW5kWzBdLmRhdGEoXCJwYXJlbnRcIik7XG4gICAgICAgIC8vIFRoZSBwYXJlbnQgb2YgbmV3IGNvbXBvdW5kIHdpbGwgYmUgdGhlIG9sZCBwYXJlbnQgb2YgdGhlIG5vZGVzIHRvIG1ha2UgY29tcG91bmRcbiAgICAgICAgLy8gTmV3IGVsZXMgaW5jbHVkZXMgbmV3IGNvbXBvdW5kIGFuZCB0aGUgbW92ZWQgZWxlcyBhbmQgd2lsbCBiZSB1c2VkIGluIHVuZG8gb3BlcmF0aW9uLlxuICAgICAgICByZXN1bHQubmV3RWxlcyA9IGVsZW1lbnRVdGlsaXRpZXMuY3JlYXRlQ29tcG91bmRGb3JHaXZlbk5vZGVzKG5vZGVzVG9NYWtlQ29tcG91bmQsIHBhcmFtLmNvbXBvdW5kVHlwZSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmVzdWx0LnJlbW92ZWRFbGVzID0gcGFyYW0ubmV3RWxlcy5yZW1vdmUoKTtcbiAgICAgICAgcmVzdWx0Lm5ld0VsZXMgPSBwYXJhbS5yZW1vdmVkRWxlcy5yZXN0b3JlKCk7XG4gICAgICAgIGVsZW1lbnRVdGlsaXRpZXMubWFpbnRhaW5Qb2ludGVyKHJlc3VsdC5uZXdFbGVzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgLy8gU2VjdGlvbiBFbmRcbiAgICAvLyBhZGQvcmVtb3ZlIGFjdGlvbiBmdW5jdGlvbnNcblxuICAgIC8vIFNlY3Rpb24gU3RhcnRcbiAgICAvLyBlYXN5IGNyZWF0aW9uIGFjdGlvbiBmdW5jdGlvbnNcblxuICAgIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLmNyZWF0ZVRlbXBsYXRlUmVhY3Rpb24gPSBmdW5jdGlvbiAocGFyYW0pIHtcbiAgICAgIHZhciBmaXJzdFRpbWUgPSBwYXJhbS5maXJzdFRpbWU7XG4gICAgICB2YXIgZWxlcztcblxuICAgICAgaWYgKGZpcnN0VGltZSkge1xuICAgICAgICBlbGVzID0gZWxlbWVudFV0aWxpdGllcy5jcmVhdGVUZW1wbGF0ZVJlYWN0aW9uKHBhcmFtLnRlbXBsYXRlVHlwZSwgcGFyYW0ubWFjcm9tb2xlY3VsZUxpc3QsIHBhcmFtLmNvbXBsZXhOYW1lLCBwYXJhbS5wcm9jZXNzUG9zaXRpb24sIHBhcmFtLnRpbGluZ1BhZGRpbmdWZXJ0aWNhbCwgcGFyYW0udGlsaW5nUGFkZGluZ0hvcml6b250YWwsIHBhcmFtLmVkZ2VMZW5ndGgsIHBhcmFtLmxheW91dFBhcmFtKVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGVsZXMgPSBwYXJhbTtcbiAgICAgICAgY3kuYWRkKGVsZXMpO1xuXG4gICAgICAgIGN5LmVsZW1lbnRzKCkudW5zZWxlY3QoKTtcbiAgICAgICAgZWxlcy5zZWxlY3QoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZWxlczogZWxlc1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMuY3JlYXRlQWN0aXZhdGlvblJlYWN0aW9uID0gZnVuY3Rpb24ocGFyYW0pIHtcbiAgICAgIHZhciBmaXJzdFRpbWUgPSBwYXJhbS5maXJzdFRpbWU7XG4gICAgICB2YXIgZWxlcztcblxuICAgICAgaWYgKGZpcnN0VGltZSkge1xuICAgICAgICBlbGVzID0gZWxlbWVudFV0aWxpdGllcy5jcmVhdGVBY3RpdmF0aW9uUmVhY3Rpb24ocGFyYW0ucHJvdGVpbk5hbWUsIHBhcmFtLnByb2Nlc3NQb3NpdGlvbiwgcGFyYW0uZWRnZUxlbmd0aCwgcGFyYW0ucmV2ZXJzZSlcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBlbGVzID0gcGFyYW07XG4gICAgICAgIGN5LmFkZChlbGVzKTtcblxuICAgICAgICBjeS5lbGVtZW50cygpLnVuc2VsZWN0KCk7XG4gICAgICAgIGVsZXMuc2VsZWN0KCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVsZXM6IGVsZXNcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLmNyZWF0ZVRyYW5zbGF0aW9uID0gZnVuY3Rpb24ocGFyYW0pIHtcbiAgICAgIGxldCBmaXJzdFRpbWUgPSBwYXJhbS5maXJzdFRpbWU7XG4gICAgICBsZXQgZWxlcztcblxuICAgICAgaWYgKGZpcnN0VGltZSkge1xuICAgICAgICBlbGVzID0gZWxlbWVudFV0aWxpdGllcy5jcmVhdGVUcmFuc2xhdGlvbihwYXJhbS5yZWd1bGF0b3JMYWJlbCwgcGFyYW0ub3V0cHV0TGFiZWwsIHBhcmFtLm9yaWVudGF0aW9uKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBlbGVzID0gcGFyYW07XG4gICAgICAgIGN5LmFkZChlbGVzKTtcblxuICAgICAgICBjeS5lbGVtZW50cygpLnVuc2VsZWN0KCk7XG4gICAgICAgIGVsZXMuc2VsZWN0KCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVsZXM6IGVsZXNcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLmNyZWF0ZVRyYW5zY3JpcHRpb24gPSBmdW5jdGlvbihwYXJhbSkge1xuICAgICAgbGV0IGZpcnN0VGltZSA9IHBhcmFtLmZpcnN0VGltZTtcbiAgICAgIGxldCBlbGVzO1xuXG4gICAgICBpZiAoZmlyc3RUaW1lKSB7XG4gICAgICAgIGVsZXMgPSBlbGVtZW50VXRpbGl0aWVzLmNyZWF0ZVRyYW5zY3JpcHRpb24ocGFyYW0ubGFiZWwsIHBhcmFtLm9yaWVudGF0aW9uKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBlbGVzID0gcGFyYW07XG4gICAgICAgIGN5LmFkZChlbGVzKTtcblxuICAgICAgICBjeS5lbGVtZW50cygpLnVuc2VsZWN0KCk7XG4gICAgICAgIGVsZXMuc2VsZWN0KCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVsZXM6IGVsZXNcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLmNyZWF0ZURlZ3JhZGF0aW9uID0gZnVuY3Rpb24ocGFyYW0pIHtcbiAgICAgIGxldCBmaXJzdFRpbWUgPSBwYXJhbS5maXJzdFRpbWU7XG4gICAgICBsZXQgZWxlcztcblxuICAgICAgaWYgKGZpcnN0VGltZSkge1xuICAgICAgICBlbGVzID0gZWxlbWVudFV0aWxpdGllcy5jcmVhdGVEZWdyYWRhdGlvbihwYXJhbS5tYWNyb21vbGVjdWxlLCBwYXJhbS5vcmllbnRhdGlvbik7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZWxlcyA9IHBhcmFtO1xuICAgICAgICBjeS5hZGQoZWxlcyk7XG5cbiAgICAgICAgY3kuZWxlbWVudHMoKS51bnNlbGVjdCgpO1xuICAgICAgICBlbGVzLnNlbGVjdCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBlbGVzOiBlbGVzXG4gICAgICB9O1xuICAgIH07XG5cbiAgICB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5jcmVhdGVDb21wbGV4UHJvdGVpbkZvcm1hdGlvbiA9IGZ1bmN0aW9uKHBhcmFtKSB7XG4gICAgICBsZXQgZmlyc3RUaW1lID0gcGFyYW0uZmlyc3RUaW1lO1xuICAgICAgbGV0IGVsZXM7XG5cbiAgICAgIGlmIChmaXJzdFRpbWUpIHtcbiAgICAgICAgZWxlcyA9IGVsZW1lbnRVdGlsaXRpZXMuY3JlYXRlQ29tcGxleFByb3RlaW5Gb3JtYXRpb24ocGFyYW0ucHJvdGVpbkxhYmVscywgcGFyYW0uY29tcGxleExhYmVsLCBwYXJhbS5yZWd1bGF0b3IsIHBhcmFtLm9yaWVudGF0aW9uLCBwYXJhbS5yZXZlcnNlKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBlbGVzID0gcGFyYW07XG4gICAgICAgIGN5LmFkZChlbGVzKTtcblxuICAgICAgICBjeS5lbGVtZW50cygpLnVuc2VsZWN0KCk7XG4gICAgICAgIGVsZXMuc2VsZWN0KCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVsZXM6IGVsZXNcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLmNyZWF0ZU11bHRpbWVyaXphdGlvbiA9IGZ1bmN0aW9uKHBhcmFtKSB7XG4gICAgICBsZXQgZmlyc3RUaW1lID0gcGFyYW0uZmlyc3RUaW1lO1xuICAgICAgbGV0IGVsZXM7XG5cbiAgICAgIGlmIChmaXJzdFRpbWUpIHtcbiAgICAgICAgZWxlcyA9IGVsZW1lbnRVdGlsaXRpZXMuY3JlYXRlTXVsdGltZXJpemF0aW9uKHBhcmFtLm1hY3JvbW9sZWN1bGUsIHBhcmFtLnJlZ3VsYXRvciwgcGFyYW0ucmVndWxhdG9yTXVsdGltZXIsIHBhcmFtLm9yaWVudGF0aW9uKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBlbGVzID0gcGFyYW07XG4gICAgICAgIGN5LmFkZChlbGVzKTtcblxuICAgICAgICBjeS5lbGVtZW50cygpLnVuc2VsZWN0KCk7XG4gICAgICAgIGVsZXMuc2VsZWN0KCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVsZXM6IGVsZXNcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLmNyZWF0ZUNvbnZlcnNpb24gPSBmdW5jdGlvbihwYXJhbSkge1xuICAgICAgbGV0IGZpcnN0VGltZSA9IHBhcmFtLmZpcnN0VGltZTtcbiAgICAgIGxldCBlbGVzO1xuXG4gICAgICBpZiAoZmlyc3RUaW1lKSB7XG4gICAgICAgIGVsZXMgPSBlbGVtZW50VXRpbGl0aWVzLmNyZWF0ZUNvbnZlcnNpb24ocGFyYW0ubWFjcm9tb2xlY3VsZSwgcGFyYW0ucmVndWxhdG9yLCBwYXJhbS5yZWd1bGF0b3JNdWx0aW1lciwgcGFyYW0ub3JpZW50YXRpb24sIHBhcmFtLmlucHV0SW5mb2JveExhYmVscywgcGFyYW0ub3V0cHV0SW5mb2JveExhYmVscyk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZWxlcyA9IHBhcmFtO1xuICAgICAgICBjeS5hZGQoZWxlcyk7XG5cbiAgICAgICAgY3kuZWxlbWVudHMoKS51bnNlbGVjdCgpO1xuICAgICAgICBlbGVzLnNlbGVjdCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBlbGVzOiBlbGVzXG4gICAgICB9O1xuICAgIH07XG5cbiAgICB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5jcmVhdGVNZXRhYm9saWNSZWFjdGlvbiA9IGZ1bmN0aW9uKHBhcmFtKSB7XG4gICAgICBsZXQgZmlyc3RUaW1lID0gcGFyYW0uZmlyc3RUaW1lO1xuICAgICAgbGV0IGVsZXM7XG5cbiAgICAgIGlmIChmaXJzdFRpbWUpIHtcbiAgICAgICAgZWxlcyA9IGVsZW1lbnRVdGlsaXRpZXMuY3JlYXRlTWV0YWJvbGljUmVhY3Rpb24ocGFyYW0uaW5wdXRzLCBwYXJhbS5vdXRwdXRzLCBwYXJhbS5yZXZlcnNpYmxlLCBwYXJhbS5yZWd1bGF0b3IsIHBhcmFtLnJlZ3VsYXRvck11bHRpbWVyLCBwYXJhbS5vcmllbnRhdGlvbik7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZWxlcyA9IHBhcmFtO1xuICAgICAgICBjeS5hZGQoZWxlcyk7XG5cbiAgICAgICAgY3kuZWxlbWVudHMoKS51bnNlbGVjdCgpO1xuICAgICAgICBlbGVzLnNlbGVjdCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBlbGVzOiBlbGVzXG4gICAgICB9O1xuICAgIH07XG5cbiAgICB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5jcmVhdGVNZXRhYm9saWNDYXRhbHl0aWNBY3Rpdml0eSA9IGZ1bmN0aW9uKHBhcmFtKSB7XG4gICAgICB2YXIgZmlyc3RUaW1lID0gcGFyYW0uZmlyc3RUaW1lO1xuICAgICAgdmFyIGVsZXM7XG5cbiAgICAgIGlmIChmaXJzdFRpbWUpIHtcbiAgICAgICAgZWxlcyA9IGVsZW1lbnRVdGlsaXRpZXMuY3JlYXRlTWV0YWJvbGljQ2F0YWx5dGljQWN0aXZpdHkocGFyYW0uaW5wdXROb2RlTGlzdCwgcGFyYW0ub3V0cHV0Tm9kZUxpc3QsIHBhcmFtLmNhdGFseXN0TmFtZSwgcGFyYW0uY2F0YWx5c3RUeXBlLCBwYXJhbS5wcm9jZXNzUG9zaXRpb24sIHBhcmFtLnRpbGluZ1BhZGRpbmdWZXJ0aWNhbCwgcGFyYW0udGlsaW5nUGFkZGluZ0hvcml6b250YWwsIHBhcmFtLmVkZ2VMZW5ndGgpXG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZWxlcyA9IHBhcmFtO1xuICAgICAgICBjeS5hZGQoZWxlcyk7XG5cbiAgICAgICAgY3kuZWxlbWVudHMoKS51bnNlbGVjdCgpO1xuICAgICAgICBlbGVzLnNlbGVjdCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBlbGVzOiBlbGVzXG4gICAgICB9O1xuICAgIH07XG5cbiAgICB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5jcmVhdGVUcmFuc2NyaXB0aW9uUmVhY3Rpb24gPSBmdW5jdGlvbihwYXJhbSkge1xuICAgICAgdmFyIGZpcnN0VGltZSA9IHBhcmFtLmZpcnN0VGltZTtcbiAgICAgIHZhciBlbGVzO1xuXG4gICAgICBpZiAoZmlyc3RUaW1lKSB7XG4gICAgICAgIGVsZXMgPSBlbGVtZW50VXRpbGl0aWVzLmNyZWF0ZVRyYW5zY3JpcHRpb25SZWFjdGlvbihwYXJhbS5nZW5lTmFtZSwgcGFyYW0ubVJuYU5hbWUsIHBhcmFtLnByb2Nlc3NQb3NpdGlvbiwgcGFyYW0uZWRnZUxlbmd0aClcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBlbGVzID0gcGFyYW07XG4gICAgICAgIGN5LmFkZChlbGVzKTtcblxuICAgICAgICBjeS5lbGVtZW50cygpLnVuc2VsZWN0KCk7XG4gICAgICAgIGVsZXMuc2VsZWN0KCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVsZXM6IGVsZXNcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLmNyZWF0ZVRyYW5zbGF0aW9uUmVhY3Rpb24gPSBmdW5jdGlvbihwYXJhbSkge1xuICAgICAgdmFyIGZpcnN0VGltZSA9IHBhcmFtLmZpcnN0VGltZTtcbiAgICAgIHZhciBlbGVzO1xuXG4gICAgICBpZiAoZmlyc3RUaW1lKSB7XG4gICAgICAgIGVsZXMgPSBlbGVtZW50VXRpbGl0aWVzLmNyZWF0ZVRyYW5zbGF0aW9uUmVhY3Rpb24ocGFyYW0ubVJuYU5hbWUsIHBhcmFtLnByb3RlaW5OYW1lLCBwYXJhbS5wcm9jZXNzUG9zaXRpb24sIHBhcmFtLmVkZ2VMZW5ndGgpXG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZWxlcyA9IHBhcmFtO1xuICAgICAgICBjeS5hZGQoZWxlcyk7XG5cbiAgICAgICAgY3kuZWxlbWVudHMoKS51bnNlbGVjdCgpO1xuICAgICAgICBlbGVzLnNlbGVjdCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBlbGVzOiBlbGVzXG4gICAgICB9O1xuICAgIH07XG5cbiAgICAvLyBTZWN0aW9uIEVuZFxuICAgIC8vIGVhc3kgY3JlYXRpb24gYWN0aW9uIGZ1bmN0aW9uc1xuXG4gICAgLy8gU2VjdGlvbiBTdGFydFxuICAgIC8vIGdlbmVyYWwgYWN0aW9uIGZ1bmN0aW9uc1xuXG4gICAgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMuZ2V0Tm9kZVBvc2l0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwb3NpdGlvbnMgPSB7fTtcbiAgICAgIHZhciBub2RlcyA9IGN5Lm5vZGVzKCk7XG5cbiAgICAgIG5vZGVzLmVhY2goZnVuY3Rpb24oZWxlLCBpKSB7XG4gICAgICAgIGlmKHR5cGVvZiBlbGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICBlbGUgPSBpO1xuICAgICAgICB9XG5cbiAgICAgICAgcG9zaXRpb25zW2VsZS5pZCgpXSA9IHtcbiAgICAgICAgICB4OiBlbGUucG9zaXRpb24oXCJ4XCIpLFxuICAgICAgICAgIHk6IGVsZS5wb3NpdGlvbihcInlcIilcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gcG9zaXRpb25zO1xuICAgIH07XG5cbiAgICB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5yZXR1cm5Ub1Bvc2l0aW9ucyA9IGZ1bmN0aW9uIChwb3NpdGlvbnMpIHtcbiAgICAgIHZhciBjdXJyZW50UG9zaXRpb25zID0ge307XG4gICAgICBjeS5ub2RlcygpLnBvc2l0aW9ucyhmdW5jdGlvbiAoZWxlLCBpKSB7XG4gICAgICAgIGlmKHR5cGVvZiBlbGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICBlbGUgPSBpO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudFBvc2l0aW9uc1tlbGUuaWQoKV0gPSB7XG4gICAgICAgICAgeDogZWxlLnBvc2l0aW9uKFwieFwiKSxcbiAgICAgICAgICB5OiBlbGUucG9zaXRpb24oXCJ5XCIpXG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHBvcyA9IHBvc2l0aW9uc1tlbGUuaWQoKV07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogcG9zLngsXG4gICAgICAgICAgeTogcG9zLnlcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gY3VycmVudFBvc2l0aW9ucztcbiAgICB9O1xuXG4gICAgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMucmVzaXplTm9kZXMgPSBmdW5jdGlvbiAocGFyYW0pIHtcbiAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgIHBlcmZvcm1PcGVyYXRpb246IHRydWVcbiAgICAgIH07XG5cbiAgICAgIHZhciBub2RlcyA9IHBhcmFtLm5vZGVzO1xuXG4gICAgICByZXN1bHQuc2l6ZU1hcCA9IHt9O1xuICAgICAgcmVzdWx0LnVzZUFzcGVjdFJhdGlvID0gZmFsc2U7XG4gICAgICByZXN1bHQucHJlc2VydmVSZWxhdGl2ZVBvcyA9IHBhcmFtLnByZXNlcnZlUmVsYXRpdmVQb3M7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgaWYobm9kZS5pc1BhcmVudCgpKXtcbiAgICAgICAgICByZXN1bHQuc2l6ZU1hcFtub2RlLmlkKCldID0ge1xuICAgICAgICAgICAgdzogbm9kZS5kYXRhKFwibWluV2lkdGhcIikgfHwgMCxcbiAgICAgICAgICAgIGg6IG5vZGUuZGF0YShcIm1pbkhlaWdodFwiKSB8fCAwLFxuICAgICAgICAgICAgYmlhc0wgOiBub2RlLmRhdGEoXCJtaW5XaWR0aEJpYXNMZWZ0XCIpIHx8IDAsXG4gICAgICAgICAgICBiaWFzUiA6IG5vZGUuZGF0YShcIm1pbldpZHRoQmlhc1JpZ2h0XCIpIHx8IDAsXG4gICAgICAgICAgICBiaWFzVCA6IG5vZGUuZGF0YShcIm1pbkhlaWdodEJpYXNUb3BcIikgfHwgMCxcbiAgICAgICAgICAgIGJpYXNCIDogbm9kZS5kYXRhKFwibWluSGVpZ2h0Qmlhc0JvdHRvbVwiKSB8fCAwXG4gICAgICAgICAgIC8vIHc6IG5vZGUuY3NzKFwibWluV2lkdGhcIikgIT0gMD8gIG5vZGUuZGF0YShcIm1pbldpZHRoXCIpIDogbm9kZS5jaGlsZHJlbigpLmJvdW5kaW5nQm94KCkudyxcbiAgICAgICAgICAgIC8vaDogbm9kZS5jc3MoXCJtaW4taGVpZ2h0XCIpICE9IDA/ICBub2RlLmRhdGEoXCJtaW5IZWlnaHRcIikgOiBub2RlLmNoaWxkcmVuKCkuYm91bmRpbmdCb3goKS5oXG4gICAgICAgICAgfTtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgcmVzdWx0LnNpemVNYXBbbm9kZS5pZCgpXSA9IHtcbiAgICAgICAgICAgIHc6IG5vZGUud2lkdGgoKSxcbiAgICAgICAgICAgIGg6IG5vZGUuaGVpZ2h0KClcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgfVxuXG4gICAgICByZXN1bHQubm9kZXMgPSBub2RlcztcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuXG4gICAgICAgIGlmIChwYXJhbS5wZXJmb3JtT3BlcmF0aW9uKSB7XG4gICAgICAgICAgaWYgKHBhcmFtLnNpemVNYXApIHtcbiAgICAgICAgICAgIC8qIGlmIChwYXJhbS5wcmVzZXJ2ZVJlbGF0aXZlUG9zID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgIHZhciBvbGRXaWR0aCA9IG5vZGUuZGF0YShcImJib3hcIikudztcbiAgICAgICAgICAgICAgdmFyIG9sZEhlaWdodCA9IG5vZGUuZGF0YShcImJib3hcIikuaDtcbiAgICAgICAgICAgIH0gKi9cblxuICAgICAgICAgICAgaWYobm9kZS5pc1BhcmVudCgpKXtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIG5vZGUuZGF0YShcIm1pbkhlaWdodFwiICwgcGFyYW0uc2l6ZU1hcFtub2RlLmlkKCldLmgpO1xuICAgICAgICAgICAgICBub2RlLmRhdGEoXCJtaW5XaWR0aFwiICwgcGFyYW0uc2l6ZU1hcFtub2RlLmlkKCldLncpO1xuICAgICAgICAgICAgICBub2RlLmRhdGEoXCJtaW5XaWR0aEJpYXNMZWZ0XCIsIHBhcmFtLnNpemVNYXBbbm9kZS5pZCgpXS5iaWFzTCk7XG4gICAgICAgICAgICAgIG5vZGUuZGF0YShcIm1pbldpZHRoQmlhc1JpZ2h0XCIsIHBhcmFtLnNpemVNYXBbbm9kZS5pZCgpXS5iaWFzUik7XG4gICAgICAgICAgICAgIG5vZGUuZGF0YShcIm1pbkhlaWdodEJpYXNUb3BcIiwgcGFyYW0uc2l6ZU1hcFtub2RlLmlkKCldLmJpYXNUKTtcbiAgICAgICAgICAgICAgbm9kZS5kYXRhKFwibWluSGVpZ2h0Qmlhc0JvdHRvbVwiLCBwYXJhbS5zaXplTWFwW25vZGUuaWQoKV0uYmlhc0IpO1xuXG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgbm9kZS5kYXRhKFwiYmJveFwiKS53ID0gcGFyYW0uc2l6ZU1hcFtub2RlLmlkKCldLnc7XG4gICAgICAgICAgICAgIG5vZGUuZGF0YShcImJib3hcIikuaCA9IHBhcmFtLnNpemVNYXBbbm9kZS5pZCgpXS5oO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICBcblxuICAgICAgICAgICAgLyogaWYgKHBhcmFtLnByZXNlcnZlUmVsYXRpdmVQb3MgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgdmFyIHN0YXRlc2FuZGluZm9zID0gbm9kZS5kYXRhKCdzdGF0ZXNhbmRpbmZvcycpO1xuICAgICAgICAgICAgICB2YXIgdG9wQm90dG9tID0gc3RhdGVzYW5kaW5mb3MuZmlsdGVyKGJveCA9PiAoYm94LmFuY2hvclNpZGUgPT09IFwidG9wXCIgfHwgYm94LmFuY2hvclNpZGUgPT09IFwiYm90dG9tXCIpKTtcbiAgICAgICAgICAgICAgdmFyIHJpZ2h0TGVmdCA9IHN0YXRlc2FuZGluZm9zLmZpbHRlcihib3ggPT4gKGJveC5hbmNob3JTaWRlID09PSBcInJpZ2h0XCIgfHwgYm94LmFuY2hvclNpZGUgPT09IFwibGVmdFwiKSk7XG5cbiAgICAgICAgICAgICAgdG9wQm90dG9tLmZvckVhY2goZnVuY3Rpb24oYm94KXtcbiAgICAgICAgICAgICAgICBpZiAoYm94LmJib3gueCA8IDApIHtcbiAgICAgICAgICAgICAgICAgIGJveC5iYm94LnggPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChib3guYmJveC54ID4gb2xkV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgIGJveC5iYm94LnggPSBvbGRXaWR0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYm94LmJib3gueCA9IG5vZGUuZGF0YShcImJib3hcIikudyAqIGJveC5iYm94LnggLyBvbGRXaWR0aDtcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgcmlnaHRMZWZ0LmZvckVhY2goZnVuY3Rpb24oYm94KXtcbiAgICAgICAgICAgICAgICBpZiAoYm94LmJib3gueSA8IDApIHtcbiAgICAgICAgICAgICAgICAgIGJveC5iYm94LnkgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChib3guYmJveC55ID4gb2xkSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICBib3guYmJveC55ID0gb2xkSGVpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBib3guYmJveC55ID0gbm9kZS5kYXRhKFwiYmJveFwiKS5oICogYm94LmJib3gueSAvIG9sZEhlaWdodDtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9ICovXG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZWxlbWVudFV0aWxpdGllcy5yZXNpemVOb2RlcyhwYXJhbS5ub2RlcywgcGFyYW0ud2lkdGgsIHBhcmFtLmhlaWdodCwgcGFyYW0udXNlQXNwZWN0UmF0aW8sIHBhcmFtLnByZXNlcnZlUmVsYXRpdmVQb3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY3kuc3R5bGUoKS51cGRhdGUoKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLmNoYW5nZU5vZGVMYWJlbCA9IGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgIH07XG4gICAgICB2YXIgbm9kZXMgPSBwYXJhbS5ub2RlcztcbiAgICAgIHJlc3VsdC5ub2RlcyA9IG5vZGVzO1xuICAgICAgcmVzdWx0LmxhYmVsID0ge307XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgcmVzdWx0LmxhYmVsW25vZGUuaWQoKV0gPSBub2RlLl9wcml2YXRlLmRhdGEubGFiZWw7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJhbS5maXJzdFRpbWUpIHtcbiAgICAgICAgbm9kZXMuZGF0YSgnbGFiZWwnLCBwYXJhbS5sYWJlbCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgICAgICAgbm9kZS5fcHJpdmF0ZS5kYXRhLmxhYmVsID0gcGFyYW0ubGFiZWxbbm9kZS5pZCgpXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy51cGRhdGVJbmZvYm94U3R5bGUgPSBmdW5jdGlvbiAocGFyYW0pIHtcbiAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICB9O1xuICAgICAgdmFyIHN0eWxlID0gcGFyYW0ubm9kZS5kYXRhKCdzdGF0ZXNhbmRpbmZvcycpW3BhcmFtLmluZGV4XS5zdHlsZTtcbiAgICAgIHJlc3VsdC5uZXdQcm9wcyA9ICQuZXh0ZW5kKCB7fSwgc3R5bGUgKTtcbiAgICAgIHJlc3VsdC5ub2RlID0gcGFyYW0ubm9kZTtcbiAgICAgIHJlc3VsdC5pbmRleCA9IHBhcmFtLmluZGV4O1xuXG4gICAgICBlbGVtZW50VXRpbGl0aWVzLnVwZGF0ZUluZm9ib3hTdHlsZSggcGFyYW0ubm9kZSwgcGFyYW0uaW5kZXgsIHBhcmFtLm5ld1Byb3BzICk7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLnVwZGF0ZUluZm9ib3hPYmogPSBmdW5jdGlvbiAocGFyYW0pIHtcbiAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICB9O1xuICAgICAgdmFyIG9iaiA9IHBhcmFtLm5vZGUuZGF0YSgnc3RhdGVzYW5kaW5mb3MnKVtwYXJhbS5pbmRleF07XG4gICAgICByZXN1bHQubmV3UHJvcHMgPSAkLmV4dGVuZCgge30sIG9iaiApO1xuICAgICAgcmVzdWx0Lm5vZGUgPSBwYXJhbS5ub2RlO1xuICAgICAgcmVzdWx0LmluZGV4ID0gcGFyYW0uaW5kZXg7XG5cbiAgICAgIGVsZW1lbnRVdGlsaXRpZXMudXBkYXRlSW5mb2JveE9iaiggcGFyYW0ubm9kZSwgcGFyYW0uaW5kZXgsIHBhcmFtLm5ld1Byb3BzICk7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLmNoYW5nZURhdGEgPSBmdW5jdGlvbiAocGFyYW0pIHtcbiAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICB9O1xuICAgICAgdmFyIGVsZXMgPSBwYXJhbS5lbGVzO1xuICAgICAgcmVzdWx0Lm5hbWUgPSBwYXJhbS5uYW1lO1xuICAgICAgcmVzdWx0LnZhbHVlTWFwID0ge307XG4gICAgICByZXN1bHQuZWxlcyA9IGVsZXM7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgICAgcmVzdWx0LnZhbHVlTWFwW2VsZS5pZCgpXSA9IGVsZS5kYXRhKHBhcmFtLm5hbWUpO1xuICAgICAgfVxuXG4gICAgICBlbGVtZW50VXRpbGl0aWVzLmNoYW5nZURhdGEocGFyYW0uZWxlcywgcGFyYW0ubmFtZSwgcGFyYW0udmFsdWVNYXApO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy51cGRhdGVTZXRGaWVsZCA9IGZ1bmN0aW9uKCBwYXJhbSApIHtcbiAgICAgIHZhciB1cGRhdGVzID0gZWxlbWVudFV0aWxpdGllcy51cGRhdGVTZXRGaWVsZCggcGFyYW0uZWxlLCBwYXJhbS5maWVsZE5hbWUsIHBhcmFtLnRvRGVsZXRlLCBwYXJhbS50b0FkZCwgcGFyYW0uY2FsbGJhY2sgKTtcblxuICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgZWxlOiBwYXJhbS5lbGUsXG4gICAgICAgIGZpZWxkTmFtZTogcGFyYW0uZmllbGROYW1lLFxuICAgICAgICBjYWxsYmFjazogcGFyYW0uY2FsbGJhY2ssXG4gICAgICAgIHRvRGVsZXRlOiB1cGRhdGVzLmFkZGVkLFxuICAgICAgICB0b0FkZDogdXBkYXRlcy5kZWxldGVkXG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5jaGFuZ2VDc3MgPSBmdW5jdGlvbiAocGFyYW0pIHtcbiAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICB9O1xuICAgICAgdmFyIGVsZXMgPSBwYXJhbS5lbGVzO1xuICAgICAgcmVzdWx0Lm5hbWUgPSBwYXJhbS5uYW1lO1xuICAgICAgcmVzdWx0LnZhbHVlTWFwID0ge307XG4gICAgICByZXN1bHQuZWxlcyA9IGVsZXM7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgICAgcmVzdWx0LnZhbHVlTWFwW2VsZS5pZCgpXSA9IGVsZS5jc3MocGFyYW0ubmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGVsZW1lbnRVdGlsaXRpZXMuY2hhbmdlQ3NzKHBhcmFtLmVsZXMsIHBhcmFtLm5hbWUsIHBhcmFtLnZhbHVlTWFwKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMuY2hhbmdlRm9udFByb3BlcnRpZXMgPSBmdW5jdGlvbiAocGFyYW0pIHtcbiAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICB9O1xuXG4gICAgICB2YXIgZWxlcyA9IHBhcmFtLmVsZXM7XG4gICAgICByZXN1bHQuZGF0YSA9IHt9O1xuICAgICAgcmVzdWx0LmVsZXMgPSBlbGVzO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG5cbiAgICAgICAgcmVzdWx0LmRhdGFbZWxlLmlkKCldID0ge307XG5cbiAgICAgICAgdmFyIGRhdGEgPSBwYXJhbS5maXJzdFRpbWUgPyBwYXJhbS5kYXRhIDogcGFyYW0uZGF0YVtlbGUuaWQoKV07XG5cbiAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBkYXRhKSB7XG4gICAgICAgICAgcmVzdWx0LmRhdGFbZWxlLmlkKCldW3Byb3BdID0gZWxlLmRhdGEocHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmFtLmZpcnN0VGltZSkge1xuICAgICAgICBlbGVtZW50VXRpbGl0aWVzLmNoYW5nZUZvbnRQcm9wZXJ0aWVzKGVsZXMsIGRhdGEpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuXG4gICAgICAgICAgZWxlbWVudFV0aWxpdGllcy5jaGFuZ2VGb250UHJvcGVydGllcyhlbGUsIGRhdGEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIC8qXG4gICAgICogU2hvdyBlbGVzIGFuZCBwZXJmb3JtIGxheW91dC5cbiAgICAgKi9cbiAgICB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5zaG93QW5kUGVyZm9ybUxheW91dCA9IGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgdmFyIGVsZXMgPSBwYXJhbS5lbGVzO1xuXG4gICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICByZXN1bHQucG9zaXRpb25zID0gdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMuZ2V0Tm9kZVBvc2l0aW9ucygpO1xuXG4gICAgICBpZiAocGFyYW0uZmlyc3RUaW1lKSB7XG4gICAgICAgIHJlc3VsdC5lbGVzID0gZWxlbWVudFV0aWxpdGllcy5zaG93QW5kUGVyZm9ybUxheW91dChwYXJhbS5lbGVzLCBwYXJhbS5sYXlvdXRwYXJhbSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmVzdWx0LmVsZXMgPSBjeS52aWV3VXRpbGl0aWVzKCkuc2hvdyhlbGVzKTsgLy8gU2hvdyBnaXZlbiBlbGVzXG4gICAgICAgIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLnJldHVyblRvUG9zaXRpb25zKHBhcmFtLnBvc2l0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLnVuZG9TaG93QW5kUGVyZm9ybUxheW91dCA9IGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgdmFyIGVsZXMgPSBwYXJhbS5lbGVzO1xuXG4gICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICByZXN1bHQucG9zaXRpb25zID0gdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMuZ2V0Tm9kZVBvc2l0aW9ucygpO1xuICAgICAgcmVzdWx0LmVsZXMgPSBjeS52aWV3VXRpbGl0aWVzKCkuaGlkZShlbGVzKTsgLy8gSGlkZSBwcmV2aW91c2x5IHVuaGlkZGVuIGVsZXM7XG5cbiAgICAgIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLnJldHVyblRvUG9zaXRpb25zKHBhcmFtLnBvc2l0aW9ucyk7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIC8qXG4gICAgICogSGlkZSBlbGVzIGFuZCBwZXJmb3JtIGxheW91dC5cbiAgICAgKi9cbiAgICB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5oaWRlQW5kUGVyZm9ybUxheW91dCA9IGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgICB2YXIgZWxlcyA9IHBhcmFtLmVsZXM7XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICByZXN1bHQucG9zaXRpb25zID0gdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMuZ2V0Tm9kZVBvc2l0aW9ucygpO1xuXG4gICAgICAgIGlmIChwYXJhbS5maXJzdFRpbWUpIHtcbiAgICAgICAgICAgIHJlc3VsdC5lbGVzID0gZWxlbWVudFV0aWxpdGllcy5oaWRlQW5kUGVyZm9ybUxheW91dChwYXJhbS5lbGVzLCBwYXJhbS5sYXlvdXRwYXJhbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQuZWxlcyA9IGN5LnZpZXdVdGlsaXRpZXMoKS5oaWRlKGVsZXMpOyAvLyBIaWRlIGdpdmVuIGVsZXNcbiAgICAgICAgICAgIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLnJldHVyblRvUG9zaXRpb25zKHBhcmFtLnBvc2l0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy51bmRvSGlkZUFuZFBlcmZvcm1MYXlvdXQgPSBmdW5jdGlvbiAocGFyYW0pIHtcbiAgICAgICAgdmFyIGVsZXMgPSBwYXJhbS5lbGVzO1xuXG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgcmVzdWx0LnBvc2l0aW9ucyA9IHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLmdldE5vZGVQb3NpdGlvbnMoKTtcbiAgICAgICAgcmVzdWx0LmVsZXMgPSBjeS52aWV3VXRpbGl0aWVzKCkuc2hvdyhlbGVzKTsgLy8gU2hvdyBwcmV2aW91c2x5IGhpZGRlbiBlbGVzXG5cbiAgICAgICAgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMucmV0dXJuVG9Qb3NpdGlvbnMocGFyYW0ucG9zaXRpb25zKTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICAvKlxuICAgICAqIERlbGV0ZSBlbGVzIGFuZCBwZXJmb3JtIGxheW91dC5cbiAgICAgKi9cbiAgICB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5kZWxldGVBbmRQZXJmb3JtTGF5b3V0ID0gZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgICB2YXIgZWxlcyA9IHBhcmFtLmVsZXM7XG5cbiAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgIHJlc3VsdC5wb3NpdGlvbnMgPSB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5nZXROb2RlUG9zaXRpb25zKCk7XG5cbiAgICAgIGlmIChwYXJhbS5maXJzdFRpbWUpIHtcbiAgICAgICAgICByZXN1bHQuZWxlcyA9IGVsZW1lbnRVdGlsaXRpZXMuZGVsZXRlQW5kUGVyZm9ybUxheW91dChwYXJhbS5lbGVzLCBwYXJhbS5sYXlvdXRwYXJhbSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgICByZXN1bHQuZWxlcyA9IGVsZXMucmVtb3ZlKCk7XG4gICAgICAgICAgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMucmV0dXJuVG9Qb3NpdGlvbnMocGFyYW0ucG9zaXRpb25zKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy51bmRvRGVsZXRlQW5kUGVyZm9ybUxheW91dCA9IGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgdmFyIGVsZXMgPSBwYXJhbS5lbGVzO1xuXG4gICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICByZXN1bHQucG9zaXRpb25zID0gdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMuZ2V0Tm9kZVBvc2l0aW9ucygpO1xuICAgICAgcmVzdWx0LmVsZXMgPSBlbGVtZW50VXRpbGl0aWVzLnJlc3RvcmVFbGVzKGVsZXMpOyBcblxuICAgICAgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMucmV0dXJuVG9Qb3NpdGlvbnMocGFyYW0ucG9zaXRpb25zKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAgIC8vIFNlY3Rpb24gRW5kXG4gICAgLy8gZ2VuZXJhbCBhY3Rpb24gZnVuY3Rpb25zXG5cbiAgICAvLyBTZWN0aW9uIFN0YXJ0XG4gICAgLy8gc2JnbiBhY3Rpb24gZnVuY3Rpb25zXG5cbiAgICB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5jaGFuZ2VTdGF0ZU9ySW5mb0JveCA9IGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgIH07XG4gICAgICByZXN1bHQudHlwZSA9IHBhcmFtLnR5cGU7XG4gICAgICByZXN1bHQubm9kZXMgPSBwYXJhbS5ub2RlcztcbiAgICAgIHJlc3VsdC5pbmRleCA9IHBhcmFtLmluZGV4O1xuICAgICAgdmFyIGRhdGEgPSBwYXJhbS5kYXRhO1xuXG4gICAgICB2YXIgdGVtcERhdGEgPSBlbGVtZW50VXRpbGl0aWVzLnNhdmVVbml0cyhwYXJhbS5ub2Rlcyk7XG4gICAgICByZXN1bHQudmFsdWUgPSBlbGVtZW50VXRpbGl0aWVzLmNoYW5nZVN0YXRlT3JJbmZvQm94KHBhcmFtLm5vZGVzLCBwYXJhbS5pbmRleCwgcGFyYW0udmFsdWUsIHBhcmFtLnR5cGUpO1xuICAgICAgLyogdmFyIGxvY2F0aW9ucyA9IGVsZW1lbnRVdGlsaXRpZXMuY2hlY2tGaXQocGFyYW0ubm9kZXMpO1xuICAgICAgaWYgKGxvY2F0aW9ucyAhPT0gdW5kZWZpbmVkICYmIGxvY2F0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGVsZW1lbnRVdGlsaXRpZXMuZml0VW5pdHMocGFyYW0ubm9kZXMsIGxvY2F0aW9ucyk7XG4gICAgICB9ICovXG4gICAgICBpZiAoZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVsZW1lbnRVdGlsaXRpZXMucmVzdG9yZVVuaXRzKHBhcmFtLm5vZGVzLCBkYXRhKTtcbiAgICAgIH1cblxuICAgICAgY3kuZm9yY2VSZW5kZXIoKTtcbiAgICAgIHJlc3VsdC5kYXRhID0gdGVtcERhdGE7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5hZGRTdGF0ZU9ySW5mb0JveCA9IGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgdmFyIG9iaiA9IHBhcmFtLm9iajtcbiAgICAgIHZhciBub2RlcyA9IHBhcmFtLm5vZGVzO1xuICAgICAgdmFyIGRhdGEgPSBwYXJhbS5kYXRhO1xuXG4gICAgICB2YXIgdGVtcERhdGEgPSBlbGVtZW50VXRpbGl0aWVzLnNhdmVVbml0cyhub2Rlcyk7XG4gICAgICB2YXIgbG9jYXRpb25PYmogPSBlbGVtZW50VXRpbGl0aWVzLmFkZFN0YXRlT3JJbmZvQm94KG5vZGVzLCBvYmopO1xuICAgICAvKiAgdmFyIGxvY2F0aW9ucyA9IGVsZW1lbnRVdGlsaXRpZXMuY2hlY2tGaXQobm9kZXMpO1xuICAgICAgaWYgKGxvY2F0aW9ucyAhPT0gdW5kZWZpbmVkICYmIGxvY2F0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGVsZW1lbnRVdGlsaXRpZXMuZml0VW5pdHMobm9kZXMsIGxvY2F0aW9ucyk7XG4gICAgICB9ICovXG4gICAgICBpZiAoZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVsZW1lbnRVdGlsaXRpZXMucmVzdG9yZVVuaXRzKG5vZGVzLCBkYXRhKTtcbiAgICAgIH1cblxuICAgICAgY3kuZm9yY2VSZW5kZXIoKTtcblxuICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgbm9kZXM6IG5vZGVzLFxuICAgICAgICBsb2NhdGlvbk9iajogbG9jYXRpb25PYmosXG4gICAgICAgIG9iajogb2JqLFxuICAgICAgICBkYXRhOiB0ZW1wRGF0YVxuICAgICAgfTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLnJlbW92ZVN0YXRlT3JJbmZvQm94ID0gZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgICB2YXIgbG9jYXRpb25PYmogPSBwYXJhbS5sb2NhdGlvbk9iajtcbiAgICAgIHZhciBub2RlcyA9IHBhcmFtLm5vZGVzO1xuICAgICAgdmFyIGRhdGEgPSBwYXJhbS5kYXRhO1xuXG4gICAgICB2YXIgdGVtcERhdGEgPSBlbGVtZW50VXRpbGl0aWVzLnNhdmVVbml0cyhub2Rlcyk7XG4gICAgICB2YXIgb2JqID0gZWxlbWVudFV0aWxpdGllcy5yZW1vdmVTdGF0ZU9ySW5mb0JveChub2RlcywgbG9jYXRpb25PYmopO1xuICAgICAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBlbGVtZW50VXRpbGl0aWVzLnJlc3RvcmVVbml0cyhub2RlcywgZGF0YSk7XG4gICAgICB9XG5cbiAgICAgIGN5LmZvcmNlUmVuZGVyKCk7XG5cbiAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgIG5vZGVzOiBub2RlcyxcbiAgICAgICAgb2JqOiBvYmosXG4gICAgICAgIGRhdGE6IHRlbXBEYXRhXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMuZml0VW5pdHMgPSBmdW5jdGlvbiAocGFyYW0pIHtcbiAgICAgIHZhciBub2RlID0gcGFyYW0ubm9kZTtcbiAgICAgIHZhciBsb2NhdGlvbnMgPSBwYXJhbS5sb2NhdGlvbnM7XG4gICAgICB2YXIgb2JqID0gZWxlbWVudFV0aWxpdGllcy5maXRVbml0cyhub2RlLCBsb2NhdGlvbnMpO1xuXG4gICAgICBjeS5mb3JjZVJlbmRlcigpO1xuXG4gICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICBvYmo6IG9iaixcbiAgICAgICAgbG9jYXRpb25zOiBsb2NhdGlvbnNcbiAgICAgIH07XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5yZXN0b3JlVW5pdHMgPSBmdW5jdGlvbiAocGFyYW0pIHtcbiAgICAgIHZhciBub2RlID0gcGFyYW0ubm9kZTtcbiAgICAgIHZhciBsb2NhdGlvbnMgPSBwYXJhbS5sb2NhdGlvbnM7XG4gICAgICB2YXIgb2JqID0gcGFyYW0ub2JqO1xuICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgIG5vZGUuZGF0YSgnc3RhdGVzYW5kaW5mb3MnKS5mb3JFYWNoKCBmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgIHZhciBib3ggPSBvYmpbaW5kZXgrK107XG4gICAgICAgIGVsZS5iYm94LnggPSBib3gueDtcbiAgICAgICAgZWxlLmJib3gueSA9IGJveC55O1xuICAgICAgICB2YXIgb2xkU2lkZSA9IGVsZS5hbmNob3JTaWRlO1xuICAgICAgICBlbGUuYW5jaG9yU2lkZSA9IGJveC5hbmNob3JTaWRlO1xuICAgICAgICBlbGVtZW50VXRpbGl0aWVzLm1vZGlmeVVuaXRzKG5vZGUsIGVsZSwgb2xkU2lkZSk7XG4gICAgICB9KTtcblxuICAgICAgY3kuZm9yY2VSZW5kZXIoKTtcblxuICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgbm9kZTogbm9kZSxcbiAgICAgICAgbG9jYXRpb25zOiBsb2NhdGlvbnNcbiAgICAgIH07XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5zZXRNdWx0aW1lclN0YXR1cyA9IGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgdmFyIGZpcnN0VGltZSA9IHBhcmFtLmZpcnN0VGltZTtcbiAgICAgIHZhciBub2RlcyA9IHBhcmFtLm5vZGVzO1xuICAgICAgdmFyIHN0YXR1cyA9IHBhcmFtLnN0YXR1cztcbiAgICAgIHZhciByZXN1bHRTdGF0dXMgPSB7fTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICB2YXIgaXNNdWx0aW1lciA9IG5vZGUuZGF0YSgnY2xhc3MnKS5lbmRzV2l0aCgnIG11bHRpbWVyJyk7XG5cbiAgICAgICAgcmVzdWx0U3RhdHVzW25vZGUuaWQoKV0gPSBpc011bHRpbWVyO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGlzIGlzIHRoZSBmaXJzdCB0aW1lIGNoYW5nZSB0aGUgc3RhdHVzIG9mIGFsbCBub2RlcyBhdCBvbmNlLlxuICAgICAgLy8gSWYgbm90IGNoYW5nZSBzdGF0dXMgb2YgZWFjaCBzZXBlcmF0ZWx5IHRvIHRoZSB2YWx1ZXMgbWFwcGVkIHRvIHRoZWlyIGlkLlxuICAgICAgaWYgKGZpcnN0VGltZSkge1xuICAgICAgICBlbGVtZW50VXRpbGl0aWVzLnNldE11bHRpbWVyU3RhdHVzKG5vZGVzLCBzdGF0dXMpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICAgIGVsZW1lbnRVdGlsaXRpZXMuc2V0TXVsdGltZXJTdGF0dXMobm9kZSwgc3RhdHVzW25vZGUuaWQoKV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAvLyAgaWYgKCFmaXJzdFRpbWUgJiYgXy5pc0VxdWFsKG5vZGVzLCBjeS5ub2RlcygnOnNlbGVjdGVkJykpKSB7XG4gICAgLy8gICAgJCgnI2luc3BlY3Rvci1pcy1tdWx0aW1lcicpLmF0dHIoXCJjaGVja2VkXCIsICEkKCcjaW5zcGVjdG9yLWlzLW11bHRpbWVyJykuYXR0cihcImNoZWNrZWRcIikpO1xuICAgIC8vICB9XG5cbiAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgIHN0YXR1czogcmVzdWx0U3RhdHVzLFxuICAgICAgICBub2Rlczogbm9kZXNcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLnNldEFjdGl2ZVN0YXR1cyA9IGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgdmFyIGZpcnN0VGltZSA9IHBhcmFtLmZpcnN0VGltZTtcbiAgICAgIHZhciBub2RlcyA9IHBhcmFtLm5vZGVzO1xuICAgICAgdmFyIHN0YXR1cyA9IHBhcmFtLnN0YXR1cztcbiAgICAgIHZhciByZXN1bHRTdGF0dXMgPSB7fTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICB2YXIgaXNBY3RpdmUgPSBub2RlLmRhdGEoJ2NsYXNzJykuc3RhcnRzV2l0aCgnYWN0aXZlICcpO1xuXG4gICAgICAgIHJlc3VsdFN0YXR1c1tub2RlLmlkKCldID0gaXNBY3RpdmU7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoaXMgaXMgdGhlIGZpcnN0IHRpbWUgY2hhbmdlIHRoZSBzdGF0dXMgb2YgYWxsIG5vZGVzIGF0IG9uY2UuXG4gICAgICAvLyBJZiBub3QgY2hhbmdlIHN0YXR1cyBvZiBlYWNoIHNlcGVyYXRlbHkgdG8gdGhlIHZhbHVlcyBtYXBwZWQgdG8gdGhlaXIgaWQuXG4gICAgICBpZiAoZmlyc3RUaW1lKSB7XG4gICAgICAgIGVsZW1lbnRVdGlsaXRpZXMuc2V0QWN0aXZlU3RhdHVzKG5vZGVzLCBzdGF0dXMpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICAgIGVsZW1lbnRVdGlsaXRpZXMuc2V0QWN0aXZlU3RhdHVzKG5vZGUsIHN0YXR1c1tub2RlLmlkKCldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgLy8gIGlmICghZmlyc3RUaW1lICYmIF8uaXNFcXVhbChub2RlcywgY3kubm9kZXMoJzpzZWxlY3RlZCcpKSkge1xuICAgIC8vICAgICQoJyNpbnNwZWN0b3ItaXMtbXVsdGltZXInKS5hdHRyKFwiY2hlY2tlZFwiLCAhJCgnI2luc3BlY3Rvci1pcy1tdWx0aW1lcicpLmF0dHIoXCJjaGVja2VkXCIpKTtcbiAgICAvLyAgfVxuXG4gICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICBzdGF0dXM6IHJlc3VsdFN0YXR1cyxcbiAgICAgICAgbm9kZXM6IG5vZGVzXG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cblxuICAgIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLnNldEh5cG90aGV0aWNhbFN0YXR1cyA9IGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgdmFyIGZpcnN0VGltZSA9IHBhcmFtLmZpcnN0VGltZTtcbiAgICAgIHZhciBub2RlcyA9IHBhcmFtLm5vZGVzO1xuICAgICAgdmFyIHN0YXR1cyA9IHBhcmFtLnN0YXR1cztcbiAgICAgIHZhciByZXN1bHRTdGF0dXMgPSB7fTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICB2YXIgaXNIeXBvdGhldGljYWwgPSBub2RlLmRhdGEoJ2NsYXNzJykuaW5jbHVkZXMoJ2h5cG90aGV0aWNhbCcpO1xuXG4gICAgICAgIHJlc3VsdFN0YXR1c1tub2RlLmlkKCldID0gaXNIeXBvdGhldGljYWw7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoaXMgaXMgdGhlIGZpcnN0IHRpbWUgY2hhbmdlIHRoZSBzdGF0dXMgb2YgYWxsIG5vZGVzIGF0IG9uY2UuXG4gICAgICAvLyBJZiBub3QgY2hhbmdlIHN0YXR1cyBvZiBlYWNoIHNlcGVyYXRlbHkgdG8gdGhlIHZhbHVlcyBtYXBwZWQgdG8gdGhlaXIgaWQuXG4gICAgICBpZiAoZmlyc3RUaW1lKSB7XG4gICAgICAgIGVsZW1lbnRVdGlsaXRpZXMuc2V0SHlwb3RoZXRpY2FsU3RhdHVzKG5vZGVzLCBzdGF0dXMpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICAgIGVsZW1lbnRVdGlsaXRpZXMuc2V0SHlwb3RoZXRpY2FsU3RhdHVzKG5vZGUsIHN0YXR1c1tub2RlLmlkKCldKTtcbiAgICAgICAgICAvL2VsZW1lbnRVdGlsaXRpZXMuc2V0SHlwb3RodGV0aWNhbFN0YXR1c1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAvLyAgaWYgKCFmaXJzdFRpbWUgJiYgXy5pc0VxdWFsKG5vZGVzLCBjeS5ub2RlcygnOnNlbGVjdGVkJykpKSB7XG4gICAgLy8gICAgJCgnI2luc3BlY3Rvci1pcy1tdWx0aW1lcicpLmF0dHIoXCJjaGVja2VkXCIsICEkKCcjaW5zcGVjdG9yLWlzLW11bHRpbWVyJykuYXR0cihcImNoZWNrZWRcIikpO1xuICAgIC8vICB9XG5cbiAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgIHN0YXR1czogcmVzdWx0U3RhdHVzLFxuICAgICAgICBub2Rlczogbm9kZXNcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLnNldENsb25lTWFya2VyU3RhdHVzID0gZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgICB2YXIgbm9kZXMgPSBwYXJhbS5ub2RlcztcbiAgICAgIHZhciBzdGF0dXMgPSBwYXJhbS5zdGF0dXM7XG4gICAgICB2YXIgZmlyc3RUaW1lID0gcGFyYW0uZmlyc3RUaW1lO1xuICAgICAgdmFyIHJlc3VsdFN0YXR1cyA9IHt9O1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIHJlc3VsdFN0YXR1c1tub2RlLmlkKCldID0gbm9kZS5kYXRhKCdjbG9uZW1hcmtlcicpO1xuICAgICAgICB2YXIgY3VycmVudFN0YXR1cyA9IGZpcnN0VGltZSA/IHN0YXR1cyA6IHN0YXR1c1tub2RlLmlkKCldO1xuICAgICAgICBlbGVtZW50VXRpbGl0aWVzLnNldENsb25lTWFya2VyU3RhdHVzKG5vZGUsIGN1cnJlbnRTdGF0dXMpO1xuICAgICAgfVxuXG4gICAgLy8gIGlmICghZmlyc3RUaW1lICYmIF8uaXNFcXVhbChub2RlcywgY3kubm9kZXMoJzpzZWxlY3RlZCcpKSkge1xuICAgIC8vICAgICQoJyNpbnNwZWN0b3ItaXMtY2xvbmUtbWFya2VyJykuYXR0cihcImNoZWNrZWRcIiwgISQoJyNpbnNwZWN0b3ItaXMtY2xvbmUtbWFya2VyJykuYXR0cihcImNoZWNrZWRcIikpO1xuICAgIC8vICB9XG5cbiAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgIHN0YXR1czogcmVzdWx0U3RhdHVzLFxuICAgICAgICBub2Rlczogbm9kZXNcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIC8vIHBhcmFtOiB7Y2xhc3M6IHNiZ25jbGFzcywgbmFtZTogcHJvcGVydHlOYW1lLCB2YWx1ZTogdmFsdWV9XG4gICAgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMuc2V0RGVmYXVsdFByb3BlcnR5ID0gZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgICB2YXIgc2JnbmNsYXNzID0gcGFyYW0uY2xhc3M7XG4gICAgICB2YXIgbmFtZSA9IHBhcmFtLm5hbWU7XG4gICAgICB2YXIgdmFsdWUgPSBwYXJhbS52YWx1ZTtcbiAgICAgIHZhciBjbGFzc0RlZmF1bHRzID0gZWxlbWVudFV0aWxpdGllcy5nZXREZWZhdWx0UHJvcGVydGllcyhzYmduY2xhc3MpO1xuICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgY2xhc3M6IHNiZ25jbGFzcyxcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgdmFsdWU6IGNsYXNzRGVmYXVsdHMuaGFzT3duUHJvcGVydHkobmFtZSkgPyBjbGFzc0RlZmF1bHRzW25hbWVdIDogdW5kZWZpbmVkXG4gICAgICB9O1xuXG4gICAgICB2YXIgcHJvcE1hcCA9IHt9O1xuICAgICAgcHJvcE1hcFsgbmFtZSBdID0gdmFsdWU7XG5cbiAgICAgIGVsZW1lbnRVdGlsaXRpZXMuc2V0RGVmYXVsdFByb3BlcnRpZXMoIHNiZ25jbGFzcywgcHJvcE1hcCApO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5hZGRCYWNrZ3JvdW5kSW1hZ2UgPSBmdW5jdGlvbiAocGFyYW0pIHtcbiAgICAgIHZhciBiZ09iaiA9IHBhcmFtLmJnT2JqO1xuICAgICAgdmFyIG5vZGVzID0gcGFyYW0ubm9kZXM7XG4gICAgICB2YXIgdXBkYXRlSW5mbyA9IHBhcmFtLnVwZGF0ZUluZm87XG4gICAgICB2YXIgcHJvbXB0SW52YWxpZEltYWdlID0gcGFyYW0ucHJvbXB0SW52YWxpZEltYWdlO1xuICAgICAgdmFyIHZhbGlkYXRlVVJMID0gcGFyYW0udmFsaWRhdGVVUkw7XG5cbiAgICAgIGVsZW1lbnRVdGlsaXRpZXMuYWRkQmFja2dyb3VuZEltYWdlKG5vZGVzLCBiZ09iaiwgdXBkYXRlSW5mbywgcHJvbXB0SW52YWxpZEltYWdlLCB2YWxpZGF0ZVVSTCk7XG5cbiAgICAgIGN5LmZvcmNlUmVuZGVyKCk7XG5cbiAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgIG5vZGVzOiBub2RlcyxcbiAgICAgICAgYmdPYmo6IGJnT2JqLFxuICAgICAgICB1cGRhdGVJbmZvOiB1cGRhdGVJbmZvLFxuICAgICAgICBwcm9tcHRJbnZhbGlkSW1hZ2U6IHByb21wdEludmFsaWRJbWFnZSxcbiAgICAgICAgdmFsaWRhdGVVUkw6IHZhbGlkYXRlVVJMXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMucmVtb3ZlQmFja2dyb3VuZEltYWdlID0gZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgICB2YXIgYmdPYmogPSBwYXJhbS5iZ09iajtcbiAgICAgIHZhciBub2RlcyA9IHBhcmFtLm5vZGVzO1xuXG4gICAgICBlbGVtZW50VXRpbGl0aWVzLnJlbW92ZUJhY2tncm91bmRJbWFnZShub2RlcywgYmdPYmopO1xuXG4gICAgICBjeS5mb3JjZVJlbmRlcigpO1xuXG4gICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICBub2Rlczogbm9kZXMsXG4gICAgICAgIGJnT2JqOiBiZ09ialxuICAgICAgfTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLnVwZGF0ZUJhY2tncm91bmRJbWFnZSA9IGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgdmFyIGJnT2JqID0gcGFyYW0uYmdPYmo7XG4gICAgICB2YXIgbm9kZXMgPSBwYXJhbS5ub2RlcztcblxuICAgICAgdmFyIG9sZEJnT2JqID0gZWxlbWVudFV0aWxpdGllcy51cGRhdGVCYWNrZ3JvdW5kSW1hZ2Uobm9kZXMsIGJnT2JqKTtcblxuICAgICAgY3kuZm9yY2VSZW5kZXIoKTtcblxuICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgbm9kZXM6IG5vZGVzLFxuICAgICAgICBiZ09iajogb2xkQmdPYmpcbiAgICAgIH07XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5jaGFuZ2VCYWNrZ3JvdW5kSW1hZ2UgPSBmdW5jdGlvbiAocGFyYW0pIHtcbiAgICAgIHZhciBvbGRJbWcgPSBwYXJhbS5vbGRJbWc7XG4gICAgICB2YXIgbmV3SW1nID0gcGFyYW0ubmV3SW1nO1xuICAgICAgdmFyIG5vZGVzID0gcGFyYW0ubm9kZXM7XG4gICAgICB2YXIgZmlyc3RUaW1lID0gcGFyYW0uZmlyc3RUaW1lO1xuICAgICAgdmFyIHVwZGF0ZUluZm8gPSBwYXJhbS51cGRhdGVJbmZvO1xuICAgICAgdmFyIHByb21wdEludmFsaWRJbWFnZSA9IHBhcmFtLnByb21wdEludmFsaWRJbWFnZTtcbiAgICAgIHZhciB2YWxpZGF0ZVVSTD0gcGFyYW0udmFsaWRhdGVVUkw7XG5cbiAgICAgIHZhciByZXN1bHQgPSBlbGVtZW50VXRpbGl0aWVzLmNoYW5nZUJhY2tncm91bmRJbWFnZShub2Rlcywgb2xkSW1nLCBuZXdJbWcsIGZpcnN0VGltZSwgdXBkYXRlSW5mbywgcHJvbXB0SW52YWxpZEltYWdlLCB2YWxpZGF0ZVVSTCk7XG5cbiAgICAgIGN5LmZvcmNlUmVuZGVyKCk7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIC8vIFNlY3Rpb24gRW5kXG4gICAgLy8gc2JnbiBhY3Rpb24gZnVuY3Rpb25zXG4gICAgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMuY29udmVydEludG9SZXZlcnNpYmxlUmVhY3Rpb24gPSBmdW5jdGlvbiAocGFyYW0pIHtcbiAgICAgIGxldCBjb2xsZWN0aW9uID0gY3kuY29sbGVjdGlvbigpO1xuICAgICAgbGV0IG1hcFR5cGUgPSBlbGVtZW50VXRpbGl0aWVzLmdldE1hcFR5cGUoKTtcbiAgICAgIGVsZW1lbnRVdGlsaXRpZXMuc2V0TWFwVHlwZShwYXJhbS5tYXBUeXBlKTtcbiAgICAgICQoJyNtYXAtdHlwZScpLnZhbChwYXJhbS5tYXBUeXBlKTtcblxuICAgICAgcGFyYW0uY29sbGVjdGlvbi5mb3JFYWNoKGZ1bmN0aW9uKGVkZ2UpIHtcbiAgICAgICAgdmFyIHNvdXJjZU5vZGUgPSBlZGdlLl9wcml2YXRlLmRhdGEuc291cmNlO1xuICAgICAgICB2YXIgdGFyZ2V0Tm9kZSA9IGVkZ2UuX3ByaXZhdGUuZGF0YS50YXJnZXQ7XG5cbiAgICAgICAgZWRnZS5tb3ZlKHtzb3VyY2U6IHRhcmdldE5vZGUsIHRhcmdldDogc291cmNlTm9kZX0pO1xuXG4gICAgICAgIGxldCBjb252ZXJ0ZWRFZGdlID0gY3kuZ2V0RWxlbWVudEJ5SWQoZWRnZS5pZCgpKTtcblxuICAgICAgICBpZihjb252ZXJ0ZWRFZGdlLmRhdGEoXCJjeWVkZ2ViZW5kZWRpdGluZ0Rpc3RhbmNlc1wiKSl7XG4gICAgICAgICAgbGV0IGRpc3RhbmNlID0gY29udmVydGVkRWRnZS5kYXRhKFwiY3llZGdlYmVuZGVkaXRpbmdEaXN0YW5jZXNcIik7XG4gICAgICAgICAgZGlzdGFuY2UgPSBkaXN0YW5jZS5tYXAoZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIC0xKmVsZW1lbnQ7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29udmVydGVkRWRnZS5kYXRhKFwiY3llZGdlYmVuZGVkaXRpbmdEaXN0YW5jZXNcIiwgZGlzdGFuY2UucmV2ZXJzZSgpKTtcblxuICAgICAgICAgIGxldCB3ZWlnaHQgPSBjb252ZXJ0ZWRFZGdlLmRhdGEoXCJjeWVkZ2ViZW5kZWRpdGluZ1dlaWdodHNcIik7XG4gICAgICAgICAgd2VpZ2h0ID0gd2VpZ2h0Lm1hcChmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gMS1lbGVtZW50O1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnZlcnRlZEVkZ2UuZGF0YShcImN5ZWRnZWJlbmRlZGl0aW5nV2VpZ2h0c1wiLCB3ZWlnaHQucmV2ZXJzZSgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGNvbnZlcnRlZEVkZ2UuZGF0YShcImN5ZWRnZWNvbnRyb2xlZGl0aW5nRGlzdGFuY2VzXCIpKXtcbiAgICAgICAgICBsZXQgZGlzdGFuY2UgPSBjb252ZXJ0ZWRFZGdlLmRhdGEoXCJjeWVkZ2Vjb250cm9sZWRpdGluZ0Rpc3RhbmNlc1wiKTtcbiAgICAgICAgICBkaXN0YW5jZSA9IGRpc3RhbmNlLm1hcChmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gLTEqZWxlbWVudDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb252ZXJ0ZWRFZGdlLmRhdGEoXCJjeWVkZ2Vjb250cm9sZWRpdGluZ0Rpc3RhbmNlc1wiLCBkaXN0YW5jZS5yZXZlcnNlKCkpO1xuXG4gICAgICAgICAgbGV0IHdlaWdodCA9IGNvbnZlcnRlZEVkZ2UuZGF0YShcImN5ZWRnZWNvbnRyb2xlZGl0aW5nV2VpZ3Roc1wiKTtcbiAgICAgICAgICB3ZWlnaHQgPSB3ZWlnaHQubWFwKGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiAxLWVsZW1lbnQ7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29udmVydGVkRWRnZS5kYXRhKFwiY3llZGdlY29udHJvbGVkaXRpbmdXZWlndGhzXCIsIHdlaWdodC5yZXZlcnNlKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbnZlcnRlZEVkZ2UuX3ByaXZhdGUuZGF0YS5jbGFzcyA9PT0gXCJjb25zdW1wdGlvblwiKSB7XG4gICAgICAgICAgY29udmVydGVkRWRnZS5fcHJpdmF0ZS5kYXRhLmNsYXNzID0gXCJwcm9kdWN0aW9uXCI7XG4gICAgICAgICAgY29udmVydGVkRWRnZS5fcHJpdmF0ZS5kYXRhLnBvcnRzb3VyY2UgPSB0YXJnZXROb2RlICsgXCIuMVwiO1xuICAgICAgICAgIGNvbnZlcnRlZEVkZ2UuX3ByaXZhdGUuZGF0YS5wb3J0dGFyZ2V0ID0gc291cmNlTm9kZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb252ZXJ0ZWRFZGdlLl9wcml2YXRlLmRhdGEuY2xhc3MgPT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgY29udmVydGVkRWRnZS5fcHJpdmF0ZS5kYXRhLmNsYXNzID0gXCJjb25zdW1wdGlvblwiO1xuICAgICAgICAgIGNvbnZlcnRlZEVkZ2UuX3ByaXZhdGUuZGF0YS5wb3J0c291cmNlID0gdGFyZ2V0Tm9kZTtcbiAgICAgICAgICBjb252ZXJ0ZWRFZGdlLl9wcml2YXRlLmRhdGEucG9ydHRhcmdldCA9IHNvdXJjZU5vZGUgKyBcIi4xXCI7XG4gICAgICAgIH1cblxuICAgICAgICBjb2xsZWN0aW9uID0gY29sbGVjdGlvbi5hZGQoY29udmVydGVkRWRnZSk7XG4gICAgICAgIGN5LnN0eWxlKCkudXBkYXRlKCk7XG4gICAgICB9KTtcblxuICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgY29sbGVjdGlvbjogY29sbGVjdGlvbixcbiAgICAgICAgbWFwVHlwZTogbWFwVHlwZSxcbiAgICAgICAgcHJvY2Vzc0lkOiBwYXJhbS5wcm9jZXNzSWRcbiAgICAgIH07XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLm1vdmVFZGdlID0gZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgfTtcbiAgICAgIHZhciBlZGdlID0gcGFyYW0uZWRnZTtcbiAgICAgIHJlc3VsdC5uYW1lID0gcGFyYW0ubmFtZTsgICAgICBcbiAgICAgXG5cbiAgICAgIHJlc3VsdC5zb3VyY2UgPSBlZGdlLnNvdXJjZSgpLmlkKCk7XG4gICAgICByZXN1bHQudGFyZ2V0ID0gZWRnZS50YXJnZXQoKS5pZCgpOyAgICAgIFxuICAgICAgcmVzdWx0LnBvcnRzb3VyY2UgID1lZGdlLmRhdGEoXCJwb3J0c291cmNlXCIpO1xuICAgICAgcmVzdWx0LnBvcnR0YXJnZXQgPSBlZGdlLmRhdGEoXCJwb3J0dGFyZ2V0XCIpO1xuICAgICAgZWxlbWVudFV0aWxpdGllcy5jaGFuZ2VEYXRhKGVkZ2UsICdzb3VyY2UnLCBwYXJhbS5zb3VyY2UpO1xuICAgICAgZWxlbWVudFV0aWxpdGllcy5jaGFuZ2VEYXRhKGVkZ2UsICd0YXJnZXQnLCBwYXJhbS50YXJnZXQpO1xuICAgICAgZWxlbWVudFV0aWxpdGllcy5jaGFuZ2VEYXRhKGVkZ2UsICdwb3J0c291cmNlJywgcGFyYW0ucG9ydHNvdXJjZSk7XG4gICAgICBlbGVtZW50VXRpbGl0aWVzLmNoYW5nZURhdGEoZWRnZSwgJ3BvcnR0YXJnZXQnLCBwYXJhbS5wb3J0dGFyZ2V0KTsgXG4gICAgICBlZGdlID0gZWRnZS5tb3ZlKHtcbiAgICAgICAgdGFyZ2V0OiBwYXJhbS50YXJnZXQsXG4gICAgICAgIHNvdXJjZSA6IHBhcmFtLnNvdXJjZVxuICAgIFxuICAgICB9KTtcblxuICAgICByZXN1bHQuZWRnZSA9IGVkZ2U7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5maXhFcnJvciA9IGZ1bmN0aW9uKHBhcmFtKXtcbiAgICAgIFxuICAgICAgdmFyIGVycm9yQ29kZSA9IHBhcmFtLmVycm9yQ29kZTtcbiAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgIHJlc3VsdC5lcnJvckNvZGUgPSBlcnJvckNvZGU7XG4gICAgICBpZihlcnJvckNvZGUgPT0gXCJwZDEwMTAxXCIgfHwgZXJyb3JDb2RlID09ICdwZDEwMTAyJyl7XG5cbiAgICAgICAgcmVzdWx0LmVkZ2UgPSBlbGVtZW50VXRpbGl0aWVzLnJldmVyc2VFZGdlKHBhcmFtLmVkZ2UpO1xuXG4gICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfWVsc2UgaWYoZXJyb3JDb2RlID09IFwicGQxMDEwM1wiIHx8IGVycm9yQ29kZSA9PSAncGQxMDEwNycpe1xuXG4gICAgICAgXG4gICAgICAgIFxuICAgICAgICBwYXJhbS5uZXdOb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKG5ld05vZGUpe1xuICAgICAgICAgZWxlbWVudFV0aWxpdGllcy5hZGROb2RlKG5ld05vZGUueCwgbmV3Tm9kZS55LCBuZXdOb2RlLmNsYXNzLCBuZXdOb2RlLmlkLCB1bmRlZmluZWQpO1xuXG4gICAgICAgICAgXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHBhcmFtLm5ld0VkZ2VzLmZvckVhY2goZnVuY3Rpb24obmV3RWRnZSl7ICAgICAgICAgIFxuICAgICAgICAgIGVsZW1lbnRVdGlsaXRpZXMuYWRkRWRnZShuZXdFZGdlLnNvdXJjZSxuZXdFZGdlLnRhcmdldCxuZXdFZGdlLmNsYXNzKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcGFyYW0ub2xkRWRnZXMuZm9yRWFjaChmdW5jdGlvbihvbGRFZGdlKXtcbiAgICAgICAgICBjeS5lbGVtZW50cygpLnVuc2VsZWN0KCk7XG4gICAgICAgICAgLy9yZXR1cm4gXG4gICAgICAgICAgb2xkRWRnZS5yZW1vdmUoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcGFyYW0ubm9kZS5yZW1vdmUoKTtcblxuICAgICAgICByZXR1cm4gcGFyYW07XG5cbiAgICAgIH1lbHNlIGlmKGVycm9yQ29kZSA9PSBcInBkMTAxMDVcIiB8fCBlcnJvckNvZGUgPT0gJ3BkMTAxMDYnKXtcbiAgIFxuICAgICAgICByZXN1bHQuZWRnZSA9IGVsZW1lbnRVdGlsaXRpZXMucmV2ZXJzZUVkZ2UocGFyYW0uZWRnZSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9ZWxzZSBpZihlcnJvckNvZGUgPT0gXCJwZDEwMTQwXCIpe1xuICAgICAgICBwYXJhbS5ub2RlLnJlbW92ZSgpO1xuICAgICAgICByZXR1cm4gcGFyYW07XG4gICAgICB9ZWxzZSBpZihlcnJvckNvZGUgPT0gXCJwZDEwMTA0XCIpIHtcbiAgICAgICAgXG4gICAgICAgIHBhcmFtLmVkZ2VzLmZvckVhY2goZnVuY3Rpb24oZWRnZSl7XG4gICAgICAgICAgZWRnZS5yZW1vdmUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHBhcmFtLm5vZGVzLmZvckVhY2goZnVuY3Rpb24obm9kZSl7XG4gICAgICAgICAgbm9kZS5yZW1vdmUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwYXJhbTtcbiAgICAgIH1lbHNlIGlmKGVycm9yQ29kZSA9PSBcInBkMTAxMDhcIil7XG4gICAgICAgIHBhcmFtLmVkZ2VzLmZvckVhY2goZnVuY3Rpb24oZWRnZSl7XG4gICAgICAgICAgZWRnZS5yZW1vdmUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHBhcmFtLm5vZGVzLmZvckVhY2goZnVuY3Rpb24obm9kZSl7XG4gICAgICAgICAgbm9kZS5yZW1vdmUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwYXJhbTtcbiAgICAgIH1lbHNlIGlmKGVycm9yQ29kZSA9PSBcInBkMTAxMTFcIil7XG4gICAgICAgIHBhcmFtLmVkZ2VzLmZvckVhY2goZnVuY3Rpb24oZWRnZSl7XG4gICAgICAgICAgZWRnZS5yZW1vdmUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwYXJhbTtcbiAgICAgIH1lbHNlIGlmKGVycm9yQ29kZSA9PSBcInBkMTAxMjZcIil7XG4gICAgICAgIHBhcmFtLmVkZ2VzLmZvckVhY2goZnVuY3Rpb24oZWRnZSl7XG4gICAgICAgICAgZWRnZS5yZW1vdmUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHBhcmFtLm5vZGVzLmZvckVhY2goZnVuY3Rpb24obm9kZSl7XG4gICAgICAgICAgbm9kZS5yZW1vdmUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwYXJhbTtcbiAgICAgIH1lbHNlIGlmKGVycm9yQ29kZSA9PSBcInBkMTAxMDlcIiB8fCBlcnJvckNvZGUgPT0gXCJwZDEwMTI0XCIpIHtcbiAgICAgICAgXG4gICAgICAgIHJlc3VsdC5uZXdTb3VyY2UgPSBwYXJhbS5lZGdlLmRhdGEoKS5zb3VyY2U7XG4gICAgICAgIHJlc3VsdC5uZXdUYXJnZXQgPSBwYXJhbS5lZGdlLmRhdGEoKS50YXJnZXQ7XG4gICAgICAgIHJlc3VsdC5wb3J0c291cmNlID0gcGFyYW0uZWRnZS5kYXRhKCkucG9ydHNvdXJjZTtcbiAgICAgICAgdmFyIGNsb25lZEVkZ2UgPSBwYXJhbS5lZGdlLmNsb25lKCk7XG4gICAgICAgXG4gICAgICAgIHZhciBlZGdlUGFyYW1zID0ge2NsYXNzIDogY2xvbmVkRWRnZS5kYXRhKCkuY2xhc3MsIGxhbmd1YWdlIDpjbG9uZWRFZGdlLmRhdGEoKS5sYW5ndWFnZX07XG4gICAgICAgIGNsb25lZEVkZ2UuZGF0YSgpLnNvdXJjZSA9IHBhcmFtLm5ld1NvdXJjZTtcbiAgICAgICAgY2xvbmVkRWRnZS5kYXRhKCkudGFyZ2V0ID0gcGFyYW0ubmV3VGFyZ2V0O1xuICAgICAgICBjeS5yZW1vdmUocGFyYW0uZWRnZSk7XG4gICAgICAgIHJlc3VsdC5lZGdlID0gZWxlbWVudFV0aWxpdGllcy5hZGRFZGdlKHBhcmFtLm5ld1NvdXJjZSxwYXJhbS5uZXdUYXJnZXQsZWRnZVBhcmFtcywgY2xvbmVkRWRnZS5kYXRhKCkuaWQpOyAgICAgIFxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgICB9ZWxzZSBpZihlcnJvckNvZGUgPT0gXCJwZDEwMTEyXCIpIHsgICAgXG4gICAgICAgIFxuICAgICAgICBwYXJhbS5jYWxsYmFjayA9IGVsZW1lbnRVdGlsaXRpZXMubWFpbnRhaW5Qb2ludGVyOyAgXG4gICAgICAgIC8vIElmIHRoaXMgaXMgZmlyc3QgdGltZSB3ZSBzaG91bGQgbW92ZSB0aGUgbm9kZSB0byBpdHMgbmV3IHBhcmVudCBhbmQgcmVsb2NhdGUgaXQgYnkgZ2l2ZW4gcG9zRGlmZiBwYXJhbXNcbiAgICAgICAgLy8gZWxzZSB3ZSBzaG91bGQgcmVtb3ZlIHRoZSBtb3ZlZCBlbGVzIGFuZCByZXN0b3JlIHRoZSBlbGVzIHRvIHJlc3RvcmVcbiAgICAgICAgaWYgKHBhcmFtLmZpcnN0VGltZSkge1xuICAgICAgICAgIHZhciBuZXdQYXJlbnRJZCA9IHBhcmFtLnBhcmVudERhdGEgPT0gdW5kZWZpbmVkID8gbnVsbCA6IHBhcmFtLnBhcmVudERhdGE7XG4gICAgICAgICAgLy8gVGhlc2UgZWxlcyBpbmNsdWRlcyB0aGUgbm9kZXMgYW5kIHRoZWlyIGNvbm5lY3RlZCBlZGdlcyBhbmQgd2lsbCBiZSByZW1vdmVkIGluIG5vZGVzLm1vdmUoKS5cbiAgICAgICAgICAvLyBUaGV5IHNob3VsZCBiZSByZXN0b3JlZCBpbiB1bmRvXG4gICAgICAgICAgdmFyIHdpdGhEZXNjZW5kYW50ID0gcGFyYW0ubm9kZXMudW5pb24ocGFyYW0ubm9kZXMuZGVzY2VuZGFudHMoKSk7XG4gICAgICAgICAgcmVzdWx0LmVsZXNUb1Jlc3RvcmUgPSB3aXRoRGVzY2VuZGFudC51bmlvbih3aXRoRGVzY2VuZGFudC5jb25uZWN0ZWRFZGdlcygpKTtcbiAgICAgICAgICAvLyBUaGVzZSBhcmUgdGhlIGVsZXMgY3JlYXRlZCBieSBub2Rlcy5tb3ZlKCksIHRoZXkgc2hvdWxkIGJlIHJlbW92ZWQgaW4gdW5kby5cbiAgICAgICAgICByZXN1bHQubW92ZWRFbGVzID0gcGFyYW0ubm9kZXMubW92ZSh7XCJwYXJlbnRcIjogbmV3UGFyZW50SWR9KTtcblxuICAgICAgICAgIHZhciBwb3NEaWZmID0ge1xuICAgICAgICAgICAgeDogcGFyYW0ucG9zRGlmZlgsXG4gICAgICAgICAgICB5OiBwYXJhbS5wb3NEaWZmWVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBlbGVtZW50VXRpbGl0aWVzLm1vdmVOb2Rlcyhwb3NEaWZmLCByZXN1bHQubW92ZWRFbGVzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXN1bHQuZWxlc1RvUmVzdG9yZSA9IHBhcmFtLm1vdmVkRWxlcy5yZW1vdmUoKTtcbiAgICAgICAgICByZXN1bHQubW92ZWRFbGVzID0gcGFyYW0uZWxlc1RvUmVzdG9yZS5yZXN0b3JlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFyYW0uY2FsbGJhY2spIHtcbiAgICAgICAgICByZXN1bHQuY2FsbGJhY2sgPSBwYXJhbS5jYWxsYmFjazsgLy8ga2VlcCB0aGUgcHJvdmlkZWQgY2FsbGJhY2sgc28gaXQgY2FuIGJlIHJldXNlZCBhZnRlciB1bmRvL3JlZG9cbiAgICAgICAgICBwYXJhbS5jYWxsYmFjayhyZXN1bHQubW92ZWRFbGVzKTsgLy8gYXBwbHkgdGhlIGNhbGxiYWNrIG9uIG5ld2x5IGNyZWF0ZWQgZWxlbWVudHNcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICBcbiAgICAgIH1lbHNlIGlmKGVycm9yQ29kZSA9PSBcInBkMTAxMjVcIikge1xuXG4gICAgICAgcmVzdWx0LmVkZ2UgPSBwYXJhbS5lZGdlLnJlbW92ZSgpOyAgICAgICBcbiAgICAgICByZXN1bHQubmV3RWRnZSA9e307XG4gICAgICAgdmFyIGVkZ2VjbGFzcyA9IHBhcmFtLm5ld0VkZ2UuZWRnZVBhcmFtcy5jbGFzcyA/IHBhcmFtLm5ld0VkZ2UuZWRnZVBhcmFtcy5jbGFzcyA6IHBhcmFtLm5ld0VkZ2UuZWRnZVBhcmFtcztcbiAgICAgICB2YXIgdmFsaWRhdGlvbiA9IGVsZW1lbnRVdGlsaXRpZXMudmFsaWRhdGVBcnJvd0VuZHMoZWRnZWNsYXNzLCBjeS5nZXRFbGVtZW50QnlJZChwYXJhbS5uZXdFZGdlLnNvdXJjZSksIGN5LmdldEVsZW1lbnRCeUlkKHBhcmFtLm5ld0VkZ2UudGFyZ2V0KSk7XG5cbiAgICAgICBpZiAodmFsaWRhdGlvbiA9PT0gJ3JldmVyc2UnKSB7XG4gICAgICAgIHZhciB0ZW1wID0gcGFyYW0ubmV3RWRnZS5zb3VyY2U7XG4gICAgICAgIHBhcmFtLm5ld0VkZ2Uuc291cmNlID0gcGFyYW0ubmV3RWRnZS50YXJnZXQ7XG4gICAgICAgIHBhcmFtLm5ld0VkZ2UudGFyZ2V0ID0gdGVtcDtcbiAgICAgIH1cbiAgICAgICByZXN1bHQubmV3RWRnZS5pZCA9ZWxlbWVudFV0aWxpdGllcy5hZGRFZGdlKHBhcmFtLm5ld0VkZ2Uuc291cmNlLHBhcmFtLm5ld0VkZ2UudGFyZ2V0LHBhcmFtLm5ld0VkZ2UuZWRnZVBhcmFtcykuaWQoKTtcbiAgICAgICByZXN1bHQubmV3RWRnZS5zb3VyY2UgPSBwYXJhbS5uZXdFZGdlLnNvdXJjZTtcbiAgICAgICByZXN1bHQubmV3RWRnZS50YXJnZXQgPSBwYXJhbS5uZXdFZGdlLnRhcmdldDtcbiAgICAgICByZXN1bHQubmV3RWRnZS5lZGdlUGFyYW1zID0gcGFyYW0ubmV3RWRnZS5lZGdlUGFyYW1zO1xuICAgICAgIFxuICAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICAgICAgXG4gICAgICB9ZWxzZSBpZihlcnJvckNvZGUgPT0gXCJwZDEwMTQyXCIpIHtcbiAgICAgICAgcmVzdWx0LmVkZ2UgPSBwYXJhbS5lZGdlLnJlbW92ZSgpOyAgICAgICBcbiAgICAgICAgcmVzdWx0Lm5ld0VkZ2UgPXt9O1xuICAgICAgICB2YXIgZWRnZWNsYXNzID0gcGFyYW0ubmV3RWRnZS5lZGdlUGFyYW1zLmNsYXNzID8gcGFyYW0ubmV3RWRnZS5lZGdlUGFyYW1zLmNsYXNzIDogcGFyYW0ubmV3RWRnZS5lZGdlUGFyYW1zO1xuICAgICAgICB2YXIgdmFsaWRhdGlvbiA9IGVsZW1lbnRVdGlsaXRpZXMudmFsaWRhdGVBcnJvd0VuZHMoZWRnZWNsYXNzLCBjeS5nZXRFbGVtZW50QnlJZChwYXJhbS5uZXdFZGdlLnNvdXJjZSksIGN5LmdldEVsZW1lbnRCeUlkKHBhcmFtLm5ld0VkZ2UudGFyZ2V0KSk7XG5cbiAgICAgICAgaWYgKHZhbGlkYXRpb24gPT09ICdyZXZlcnNlJykge1xuICAgICAgICAgdmFyIHRlbXAgPSBwYXJhbS5uZXdFZGdlLnNvdXJjZTtcbiAgICAgICAgIHBhcmFtLm5ld0VkZ2Uuc291cmNlID0gcGFyYW0ubmV3RWRnZS50YXJnZXQ7XG4gICAgICAgICBwYXJhbS5uZXdFZGdlLnRhcmdldCA9IHRlbXA7XG4gICAgICAgfVxuICAgICAgICByZXN1bHQubmV3RWRnZS5pZCA9ZWxlbWVudFV0aWxpdGllcy5hZGRFZGdlKHBhcmFtLm5ld0VkZ2Uuc291cmNlLHBhcmFtLm5ld0VkZ2UudGFyZ2V0LHBhcmFtLm5ld0VkZ2UuZWRnZVBhcmFtcykuaWQoKTtcbiAgICAgICAgcmVzdWx0Lm5ld0VkZ2Uuc291cmNlID0gcGFyYW0ubmV3RWRnZS5zb3VyY2U7XG4gICAgICAgIHJlc3VsdC5uZXdFZGdlLnRhcmdldCA9IHBhcmFtLm5ld0VkZ2UudGFyZ2V0O1xuICAgICAgICByZXN1bHQubmV3RWRnZS5lZGdlUGFyYW1zID0gcGFyYW0ubmV3RWRnZS5lZGdlUGFyYW1zO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1lbHNlIHtcblxuICAgICAgICByZXN1bHQubmV3U291cmNlID0gcGFyYW0uZWRnZS5zb3VyY2UoKS5pZCgpO1xuICAgICAgICByZXN1bHQubmV3VGFyZ2V0ID0gcGFyYW0uZWRnZS50YXJnZXQoKS5pZCgpO1xuICAgICAgICByZXN1bHQucG9ydHRhcmdldCA9IHBhcmFtLmVkZ2UuZGF0YShcInBvcnR0YXJnZXRcIik7XG4gICAgICAgIHJlc3VsdC5lZGdlID0gcGFyYW0uZWRnZS5tb3ZlKHtcbiAgICAgICAgICB0YXJnZXQ6IHBhcmFtLm5ld1RhcmdldCxcbiAgICAgICAgICBzb3VyY2UgOiBwYXJhbS5uZXdTb3VyY2UgICAgICBcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZWxlbWVudFV0aWxpdGllcy5jaGFuZ2VEYXRhKHJlc3VsdC5lZGdlLCAncG9ydHRhcmdldCcsIHBhcmFtLnBvcnR0YXJnZXQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICBcbiAgICAgIH1cbiAgICAgIFxuICB9XG4gIFxuICB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy51bmZpeEVycm9yID0gZnVuY3Rpb24ocGFyYW0pe1xuICAgIHZhciBlcnJvckNvZGUgPSBwYXJhbS5lcnJvckNvZGU7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIHJlc3VsdC5lcnJvckNvZGUgPSBlcnJvckNvZGU7XG4gICAgaWYoZXJyb3JDb2RlID09IFwicGQxMDEwMVwiIHx8IGVycm9yQ29kZSA9PSAncGQxMDEwMicpe1xuICAgICBcbiAgICAgICAgcmVzdWx0LmVkZ2UgPSBlbGVtZW50VXRpbGl0aWVzLnJldmVyc2VFZGdlKHBhcmFtLmVkZ2UpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9ZWxzZSBpZihlcnJvckNvZGUgPT0gXCJwZDEwMTAzXCIgfHwgZXJyb3JDb2RlID09ICdwZDEwMTA3Jyl7XG5cbiAgICAgIHBhcmFtLm5ld05vZGVzLmZvckVhY2goZnVuY3Rpb24obmV3Tm9kZSl7ICAgIFxuICAgICAgICBjeS5yZW1vdmUoY3kuJCgnIycrbmV3Tm9kZS5pZCkpICAgICAgXG4gICAgICAgIFxuICAgICAgfSk7XG5cbiAgICAgIHBhcmFtLm5vZGUucmVzdG9yZSgpO1xuXG4gICAgICBwYXJhbS5vbGRFZGdlcy5mb3JFYWNoKGZ1bmN0aW9uKG9sZEVkZ2UpeyAgXG4gICAgICAgIG9sZEVkZ2UucmVzdG9yZSgpO1xuICAgICAgfSk7XG5cbiAgICAgIGN5LmFuaW1hdGUoe1xuICAgICAgICBkdXJhdGlvbjogMTAwLFxuICAgICAgICBlYXNpbmc6ICdlYXNlJyxcbiAgICAgICAgZml0IDp7ZWxlczp7fSxwYWRkaW5nOjIwfSwgXG4gICAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICBcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBwYXJhbTtcblxuICAgIH1lbHNlIGlmKGVycm9yQ29kZSA9PSBcInBkMTAxMDVcIiB8fCBlcnJvckNvZGUgPT0gJ3BkMTAxMDYnKXsgIFxuXG4gICAgICByZXN1bHQuZWRnZSA9IGVsZW1lbnRVdGlsaXRpZXMucmV2ZXJzZUVkZ2UocGFyYW0uZWRnZSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgfWVsc2UgaWYoZXJyb3JDb2RlID09IFwicGQxMDE0MFwiKXtcbiAgICAgIHBhcmFtLm5vZGUucmVzdG9yZSgpO1xuICAgICAgY3kuYW5pbWF0ZSh7XG4gICAgICAgIGR1cmF0aW9uOiAxMDAsXG4gICAgICAgIGVhc2luZzogJ2Vhc2UnLFxuICAgICAgICBmaXQgOntlbGVzOnt9LHBhZGRpbmc6MjB9LCBcbiAgICAgICAgY29tcGxldGU6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgIFxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBwYXJhbTtcbiAgICB9ZWxzZSBpZihlcnJvckNvZGUgPT0gXCJwZDEwMTA0XCIpIHtcbiAgICAgIFxuICAgICAgcGFyYW0ubm9kZXMuZm9yRWFjaChmdW5jdGlvbihub2RlKXtcbiAgICAgICAgbm9kZS5yZXN0b3JlKCk7XG4gICAgICB9KTtcbiAgICAgIHBhcmFtLmVkZ2VzLmZvckVhY2goZnVuY3Rpb24oZWRnZSl7XG4gICAgICAgIGVkZ2UucmVzdG9yZSgpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcGFyYW07XG4gICAgfWVsc2UgaWYoZXJyb3JDb2RlID09IFwicGQxMDEwOFwiKXtcbiAgICAgIFxuICAgICAgcGFyYW0ubm9kZXMuZm9yRWFjaChmdW5jdGlvbihub2RlKXtcbiAgICAgICAgbm9kZS5yZXN0b3JlKCk7XG4gICAgICB9KTtcbiAgICAgIHBhcmFtLmVkZ2VzLmZvckVhY2goZnVuY3Rpb24oZWRnZSl7XG4gICAgICAgIGVkZ2UucmVzdG9yZSgpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcGFyYW07XG4gICAgfWVsc2UgaWYoZXJyb3JDb2RlID09IFwicGQxMDExMVwiKXtcbiAgICAgIHBhcmFtLmVkZ2VzLmZvckVhY2goZnVuY3Rpb24oZWRnZSl7XG4gICAgICAgIGVkZ2UucmVzdG9yZSgpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcGFyYW07XG4gICAgfWVsc2UgaWYoZXJyb3JDb2RlID09IFwicGQxMDEyNlwiKXtcbiAgICAgIHBhcmFtLm5vZGVzLmZvckVhY2goZnVuY3Rpb24obm9kZSl7XG4gICAgICAgIG5vZGUucmVzdG9yZSgpO1xuICAgICAgfSk7XG4gICAgICBwYXJhbS5lZGdlcy5mb3JFYWNoKGZ1bmN0aW9uKGVkZ2Upe1xuICAgICAgICBlZGdlLnJlc3RvcmUoKTtcbiAgICAgIH0pOyAgICAgICBcbiAgICAgIHJldHVybiBwYXJhbTtcbiAgICB9ZWxzZSBpZihlcnJvckNvZGUgPT0gXCJwZDEwMTA5XCIgfHwgZXJyb3JDb2RlID09IFwicGQxMDEyNFwiKSB7XG5cbiAgICAgIHJlc3VsdC5uZXdTb3VyY2UgPSBwYXJhbS5lZGdlLnNvdXJjZSgpLmlkKCk7XG4gICAgICByZXN1bHQubmV3VGFyZ2V0ID0gcGFyYW0uZWRnZS50YXJnZXQoKS5pZCgpO1xuICAgICAgcmVzdWx0LnBvcnRzb3VyY2UgPSBwYXJhbS5wb3J0c291cmNlO1xuICAgICAgcmVzdWx0LmVkZ2UgPSBwYXJhbS5lZGdlLm1vdmUoe1xuICAgICAgICB0YXJnZXQ6IHBhcmFtLm5ld1RhcmdldCxcbiAgICAgICAgc291cmNlIDogcGFyYW0ubmV3U291cmNlICAgICAgXG4gICAgICB9KTtcblxuICAgICAgZWxlbWVudFV0aWxpdGllcy5jaGFuZ2VEYXRhKHJlc3VsdC5lZGdlLCAncG9ydHNvdXJjZScsIHBhcmFtLnBvcnRzb3VyY2UpOyBcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfWVsc2UgaWYoZXJyb3JDb2RlID09IFwicGQxMDExMlwiKSB7XG4gICAgIFxuICAgICAgLy8gSWYgdGhpcyBpcyBmaXJzdCB0aW1lIHdlIHNob3VsZCBtb3ZlIHRoZSBub2RlIHRvIGl0cyBuZXcgcGFyZW50IGFuZCByZWxvY2F0ZSBpdCBieSBnaXZlbiBwb3NEaWZmIHBhcmFtc1xuICAgICAgLy8gZWxzZSB3ZSBzaG91bGQgcmVtb3ZlIHRoZSBtb3ZlZCBlbGVzIGFuZCByZXN0b3JlIHRoZSBlbGVzIHRvIHJlc3RvcmVcbiAgICAgIGlmIChwYXJhbS5maXJzdFRpbWUpIHtcbiAgICAgICAgdmFyIG5ld1BhcmVudElkID0gcGFyYW0ucGFyZW50RGF0YSA9PSB1bmRlZmluZWQgPyBudWxsIDogcGFyYW0ucGFyZW50RGF0YTtcbiAgICAgICAgLy8gVGhlc2UgZWxlcyBpbmNsdWRlcyB0aGUgbm9kZXMgYW5kIHRoZWlyIGNvbm5lY3RlZCBlZGdlcyBhbmQgd2lsbCBiZSByZW1vdmVkIGluIG5vZGVzLm1vdmUoKS5cbiAgICAgICAgLy8gVGhleSBzaG91bGQgYmUgcmVzdG9yZWQgaW4gdW5kb1xuICAgICAgICB2YXIgd2l0aERlc2NlbmRhbnQgPSBwYXJhbS5ub2Rlcy51bmlvbihwYXJhbS5ub2Rlcy5kZXNjZW5kYW50cygpKTtcbiAgICAgICAgcmVzdWx0LmVsZXNUb1Jlc3RvcmUgPSB3aXRoRGVzY2VuZGFudC51bmlvbih3aXRoRGVzY2VuZGFudC5jb25uZWN0ZWRFZGdlcygpKTtcbiAgICAgICAgLy8gVGhlc2UgYXJlIHRoZSBlbGVzIGNyZWF0ZWQgYnkgbm9kZXMubW92ZSgpLCB0aGV5IHNob3VsZCBiZSByZW1vdmVkIGluIHVuZG8uXG4gICAgICAgIHJlc3VsdC5tb3ZlZEVsZXMgPSBwYXJhbS5ub2Rlcy5tb3ZlKHtcInBhcmVudFwiOiBuZXdQYXJlbnRJZH0pO1xuXG4gICAgICAgIHZhciBwb3NEaWZmID0ge1xuICAgICAgICAgIHg6IHBhcmFtLnBvc0RpZmZYLFxuICAgICAgICAgIHk6IHBhcmFtLnBvc0RpZmZZXG4gICAgICAgIH07XG5cbiAgICAgICAgZWxlbWVudFV0aWxpdGllcy5tb3ZlTm9kZXMocG9zRGlmZiwgcmVzdWx0Lm1vdmVkRWxlcyk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmVzdWx0LmVsZXNUb1Jlc3RvcmUgPSBwYXJhbS5tb3ZlZEVsZXMucmVtb3ZlKCk7XG4gICAgICAgIHJlc3VsdC5tb3ZlZEVsZXMgPSBwYXJhbS5lbGVzVG9SZXN0b3JlLnJlc3RvcmUoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmFtLmNhbGxiYWNrKSB7XG4gICAgICAgIHJlc3VsdC5jYWxsYmFjayA9IHBhcmFtLmNhbGxiYWNrOyAvLyBrZWVwIHRoZSBwcm92aWRlZCBjYWxsYmFjayBzbyBpdCBjYW4gYmUgcmV1c2VkIGFmdGVyIHVuZG8vcmVkb1xuICAgICAgICBwYXJhbS5jYWxsYmFjayhyZXN1bHQubW92ZWRFbGVzKTsgLy8gYXBwbHkgdGhlIGNhbGxiYWNrIG9uIG5ld2x5IGNyZWF0ZWQgZWxlbWVudHNcbiAgICAgIH1cblxuICAgICBcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICBcbiAgICB9ZWxzZSBpZihlcnJvckNvZGUgPT0gXCJwZDEwMTI1XCIpIHtcblxuICAgICAgY3kuJCgnIycrcGFyYW0ubmV3RWRnZS5pZCkucmVtb3ZlKCk7XG4gICAgICBwYXJhbS5lZGdlID0gcGFyYW0uZWRnZS5yZXN0b3JlKCk7XG5cbiAgICBcbiAgICAgIHJldHVybiBwYXJhbTtcbiAgICAgIFxuICAgIH1lbHNlIGlmKGVycm9yQ29kZSA9PSBcInBkMTAxNDJcIikge1xuICAgICAgY3kuJCgnIycrcGFyYW0ubmV3RWRnZS5pZCkucmVtb3ZlKCk7XG4gICAgICBwYXJhbS5lZGdlID0gcGFyYW0uZWRnZS5yZXN0b3JlKCk7XG5cbiAgICBcbiAgICAgIHJldHVybiBwYXJhbTtcbiAgICB9ZWxzZSB7XG5cbiAgICAgIHJlc3VsdC5uZXdTb3VyY2UgPSBwYXJhbS5lZGdlLnNvdXJjZSgpLmlkKCk7XG4gICAgICByZXN1bHQubmV3VGFyZ2V0ID0gcGFyYW0uZWRnZS50YXJnZXQoKS5pZCgpO1xuICAgICAgcmVzdWx0LnBvcnR0YXJnZXQgPSBwYXJhbS5lZGdlLmRhdGEoXCJwb3J0dGFyZ2V0XCIpO1xuICAgICAgcmVzdWx0LmVkZ2UgPSBwYXJhbS5lZGdlLm1vdmUoe1xuICAgICAgICB0YXJnZXQ6IHBhcmFtLm5ld1RhcmdldCxcbiAgICAgICAgc291cmNlIDogcGFyYW0ubmV3U291cmNlICAgICAgXG4gICAgICB9KTtcblxuICAgICAgZWxlbWVudFV0aWxpdGllcy5jaGFuZ2VEYXRhKHJlc3VsdC5lZGdlLCAncG9ydHRhcmdldCcsIHBhcmFtLnBvcnR0YXJnZXQpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgICAgXG4gICAgfVxuICAgIFxuICB9XG5cbiAgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMuY2xvbmVIaWdoRGVncmVlTm9kZSA9IGZ1bmN0aW9uKG5vZGUpe1xuXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIHZhciBvbGRYID0gbm9kZS5wb3NpdGlvbigpLng7XG4gICAgdmFyIG9sZFkgPSBub2RlLnBvc2l0aW9uKCkueTtcbiAgICBcbiAgICBcbiAgICB2YXIgY2xhY3VsYXRlTmV3Q2xvbmVQb3NpdGlvbiA9IGZ1bmN0aW9uKHNvdXJjZUVuZFBvaW50WCxzb3VyY2VFbmRQb2ludFksdGFyZ2V0RW5kUG9pbnRYLHRhcmdldEVuZFBvaW50WSxkZXNpcmVkRGlzdGFuY2UsZGlyZWN0aW9uKXtcbiAgICAgIHZhciBkaXN0YW5jZSA9IE1hdGguc3FydChNYXRoLnBvdyh0YXJnZXRFbmRQb2ludFktc291cmNlRW5kUG9pbnRZLDIpKyBNYXRoLnBvdyh0YXJnZXRFbmRQb2ludFgtc291cmNlRW5kUG9pbnRYLDIpKTtcbiAgICAgIHZhciByYXRpbyA9IGRlc2lyZWREaXN0YW5jZS9kaXN0YW5jZTtcbiAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgIGlmKGRpcmVjdGlvbiA9PSBcInNvdXJjZVwiKXsgXG4gICAgICAgIHJlc3VsdC5jeCA9ICgoMS1yYXRpbykgKiBzb3VyY2VFbmRQb2ludFgpICArIChyYXRpbyAqIHRhcmdldEVuZFBvaW50WCk7XG4gICAgICAgIHJlc3VsdC5jeSA9ICgoMS1yYXRpbykgKiBzb3VyY2VFbmRQb2ludFkpICArIChyYXRpbyAqIHRhcmdldEVuZFBvaW50WSk7XG4gICAgICB9ZWxzZXsgICAgICBcbiAgICAgICAgcmVzdWx0LmN4ID0gKCgxLXJhdGlvKSAqIHRhcmdldEVuZFBvaW50WCkgICsgKHJhdGlvICogc291cmNlRW5kUG9pbnRYKTtcbiAgICAgICAgcmVzdWx0LmN5ID0gKCgxLXJhdGlvKSAqIHRhcmdldEVuZFBvaW50WSkgICsgKHJhdGlvICogc291cmNlRW5kUG9pbnRZKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9OyAgIFxuICAgIHZhciBlZGdlcyA9IG5vZGUuY29ubmVjdGVkRWRnZXMoKTtcbiAgICB2YXIgZGVzaXJlZERpc3RhbmNlID0gKG5vZGUuaGVpZ2h0KCkgPiBub2RlLndpZHRoKCk/IG5vZGUuaGVpZ2h0KCk6IG5vZGUud2lkdGgoKSkqIDAuMTtcbiAgICBmb3IodmFyIGkgPSAxIDsgaSA8IGVkZ2VzLmxlbmd0aCA7IGkrKyl7XG4gICAgICB2YXIgZWRnZSA9IGVkZ2VzW2ldO1xuICAgICAgdmFyIGluZGV4ID0gaTtcbiAgICAgIHZhciBlZGdlQ2xvbmUgPSBlZGdlLmNsb25lKCk7XG4gICAgICB2YXIgc3RhcnRQb3NpdGlvbiA9IGVkZ2Uuc291cmNlKCkuaWQoKSA9PSBub2RlLmlkKCkgPyBcInNvdXJjZVwiIDogXCJ0YXJnZXRcIjsgICAgXG4gICAgICB2YXIgbmV3UG9zaXRpb24gPSBjbGFjdWxhdGVOZXdDbG9uZVBvc2l0aW9uKGVkZ2Uuc291cmNlRW5kcG9pbnQoKS54LGVkZ2Uuc291cmNlRW5kcG9pbnQoKS55LGVkZ2UudGFyZ2V0RW5kcG9pbnQoKS54LGVkZ2UudGFyZ2V0RW5kcG9pbnQoKS55LGRlc2lyZWREaXN0YW5jZSxzdGFydFBvc2l0aW9uKTsgXG4gICAgICB2YXIgbmV3Tm9kZUlkID0gbm9kZS5pZCgpKydjbG9uZS0nK2luZGV4O1xuICAgICAgLy9lZGdlQ2xvbmUuZGF0YSgpLmlkID0gZWRnZUNsb25lLmRhdGEoKS5pZCsgXCItXCIrbmV3Tm9kZUlkO1xuICAgICAgaWYoZWRnZS5zb3VyY2UoKS5pZCgpID09IG5vZGUuaWQoKSl7ICAgICAgICBcbiAgICAgICAgZWRnZUNsb25lLmRhdGEoKS5zb3VyY2UgPSBuZXdOb2RlSWQ7XG4gICAgICAgIGVkZ2VDbG9uZS5kYXRhKCkucG9ydHNvdXJjZSA9IG5ld05vZGVJZDsgICAgXG4gICAgICB9ZWxzZXtcbiAgICAgICAgICBcbiAgICAgICAgZWRnZUNsb25lLmRhdGEoKS50YXJnZXQgPSBuZXdOb2RlSWQ7XG4gICAgICAgIGVkZ2VDbG9uZS5kYXRhKCkucG9ydHRhcmdldCA9IG5ld05vZGVJZDsgICAgXG4gICAgICB9XG4gICAgICB2YXIgbmV3Tm9kZSA9IG5vZGUuY2xvbmUoKTtcbiAgICAgIG5ld05vZGUuZGF0YSgpLmlkID0gbmV3Tm9kZUlkO1xuICAgICAgY3kuYWRkKG5ld05vZGUpO1xuICAgICBcbiAgICAgIGVkZ2UucmVtb3ZlKCk7XG4gICAgICBjeS5hZGQoZWRnZUNsb25lKTtcbiAgICAgIG5ld05vZGUucG9zaXRpb24oe1xuICAgICAgICB4OiBuZXdQb3NpdGlvbi5jeCxcbiAgICAgICAgeTogbmV3UG9zaXRpb24uY3lcbiAgICAgIH0pO1xuICAgICAgZWxlbWVudFV0aWxpdGllcy5zZXRDbG9uZU1hcmtlclN0YXR1cyhuZXdOb2RlLCB0cnVlKTtcbiAgICAgIFxuICAgIH0gIFxuICAgIFxuICAgIHZhciBuZXdQb3NpdGlvbiA9IGNsYWN1bGF0ZU5ld0Nsb25lUG9zaXRpb24oXG4gICAgICBlZGdlc1swXS5zb3VyY2VFbmRwb2ludCgpLngsXG4gICAgICBlZGdlc1swXS5zb3VyY2VFbmRwb2ludCgpLnksXG4gICAgICBlZGdlc1swXS50YXJnZXRFbmRwb2ludCgpLngsXG4gICAgICBlZGdlc1swXS50YXJnZXRFbmRwb2ludCgpLnksXG4gICAgICBkZXNpcmVkRGlzdGFuY2UsZWRnZXNbMF0uc291cmNlKCkuaWQoKSA9PSBub2RlLmlkKCkgPyBcInNvdXJjZVwiIDogXCJ0YXJnZXRcIlxuICAgICAgKTtcbiAgXG4gICAgdmFyIGNsb25lRWRnZSA9IGVkZ2VzWzBdLmNsb25lKCk7XG4gICAgLy9jbG9uZUVkZ2UuZGF0YSgpLmlkID0gY2xvbmVFZGdlLmRhdGEoKS5pZCsgXCItXCIrbm9kZS5pZCgpKydjbG9uZS0wJztcbiAgICBcbiAgICBlZGdlc1swXS5yZW1vdmUoKTtcbiAgICBjeS5hZGQoY2xvbmVFZGdlKTtcbiAgICBlbGVtZW50VXRpbGl0aWVzLnNldENsb25lTWFya2VyU3RhdHVzKG5vZGUsdHJ1ZSk7XG4gICAgbm9kZS5wb3NpdGlvbih7XG4gICAgICB4OiBuZXdQb3NpdGlvbi5jeCxcbiAgICAgIHk6IG5ld1Bvc2l0aW9uLmN5XG4gICAgfSk7XG4gIFxuICAgIHJlc3VsdC5vbGRYID0gb2xkWDsgICAgXG4gICAgcmVzdWx0Lm9sZFkgPSBvbGRZO1xuICAgIHJlc3VsdC5ub2RlID0gbm9kZTtcbiAgICByZXN1bHQubnVtYmVyT2ZFZGdlcyA9IGVkZ2VzLmxlbmd0aDtcbiAgICByZXR1cm4gcmVzdWx0O1xuXG4gIH1cblxuICB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy51bkNsb25lSGlnaERlZ3JlZU5vZGUgPSBmdW5jdGlvbihwYXJhbSl7XG5cbiAgICB2YXIgbm9kZSA9IHBhcmFtLm5vZGU7XG4gICAgZWxlbWVudFV0aWxpdGllcy5zZXRDbG9uZU1hcmtlclN0YXR1cyhub2RlLGZhbHNlKTtcbiAgICBub2RlLnBvc2l0aW9uKHtcbiAgICAgIHg6IHBhcmFtLm9sZFgsXG4gICAgICB5OiBwYXJhbS5vbGRZXG4gICAgfSk7XG4gIFxuICAgIGZvcih2YXIgaSA9IDEgOyBpIDwgcGFyYW0ubnVtYmVyT2ZFZGdlcyA7IGkrKyl7XG4gICAgICB2YXIgY2xvbmVJZCA9IG5vZGUuaWQoKSsnY2xvbmUtJytpO1xuICAgICAgdmFyIGNsb25lID0gY3kuJChcIiNcIitjbG9uZUlkKTtcbiAgICAgIHZhciBjbG9uZUVkZ2UgPSBjbG9uZS5jb25uZWN0ZWRFZGdlcygpWzBdO1xuICAgICAgdmFyIGVkZ2UgPSBjbG9uZUVkZ2UuY2xvbmUoKTtcbiAgICAgIFxuICAgIFxuICAgICAgaWYoZWRnZS5kYXRhKCkuc291cmNlID09IGNsb25lSWQpeyAgICAgICAgXG4gICAgICAgIGVkZ2UuZGF0YSgpLnNvdXJjZSA9IG5vZGUuaWQoKTtcbiAgICAgICAgZWRnZS5kYXRhKCkucG9ydHNvdXJjZSA9ICBub2RlLmlkKCk7ICAgIFxuICAgICAgfWVsc2V7ICAgICAgICAgIFxuICAgICAgICBlZGdlLmRhdGEoKS50YXJnZXQgPSAgbm9kZS5pZCgpO1xuICAgICAgICBlZGdlLmRhdGEoKS5wb3J0dGFyZ2V0ID0gIG5vZGUuaWQoKTsgICAgXG4gICAgICB9XG5cbiAgICAgIGNsb25lRWRnZS5yZW1vdmUoKTtcbiAgICAgIGNsb25lLnJlbW92ZSgpO1xuICAgICAgXG4gICAgICBjeS5hZGQoZWRnZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5jaGFuZ2VNYXBUeXBlID0gZnVuY3Rpb24ocGFyYW0pe1xuICAgIHZhciByZXN1bHQgPXt9O1xuICAgIHZhciBjdXJyZW50TWFwVHlwZSA9IGVsZW1lbnRVdGlsaXRpZXMuZ2V0TWFwVHlwZSgpO1xuICAgIGVsZW1lbnRVdGlsaXRpZXMuc2V0TWFwVHlwZShwYXJhbS5tYXBUeXBlKTtcbiAgICByZXN1bHQubWFwVHlwZSA9IGN1cnJlbnRNYXBUeXBlO1xuICAgIHJlc3VsdC5jYWxsYmFjayA9IHBhcmFtLmNhbGxiYWNrO1xuICAgIHBhcmFtLmNhbGxiYWNrKCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIH1cblxuICByZXR1cm4gdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnNFeHRlbmRlcjtcbn07XG4iXSwibmFtZXMiOlsibGlicyIsInJlcXVpcmUiLCJnZXRMaWJzIiwibW9kdWxlIiwiZXhwb3J0cyIsInNiZ252aXpJbnN0YW5jZSIsInVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zIiwiZWxlbWVudFV0aWxpdGllcyIsImN5IiwidG9wb2xvZ3lHcm91cGluZyIsInVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zRXh0ZW5kZXIiLCJwYXJhbSIsInNiZ252aXpJbnN0YW5jZVV0aWxpdGllcyIsImdldEluc3RhbmNlIiwiZ2V0Q3kiLCJzaWZUb3BvbG9neUdyb3VwaW5nIiwiZXh0ZW5kIiwiYXBwbHlTSUZUb3BvbG9neUdyb3VwaW5nIiwib2xkRWxlcyIsIm5ld0VsZXMiLCJmaXJzdFRpbWUiLCJlbGVtZW50cyIsImFwcGx5IiwidW5hcHBseSIsImlzR3JhcGhUb3BvbG9neUxvY2tlZCIsInVubG9ja0dyYXBoVG9wb2xvZ3kiLCJsb2NrR3JhcGhUb3BvbG9neSIsInJlbW92ZSIsInJlc3RvcmUiLCJ0b2dnbGVBcHBsaWVkRmxhZyIsInJlc3VsdCIsImFkZE5vZGUiLCJuZXdOb2RlIiwieCIsInkiLCJpZCIsInBhcmVudCIsInZpc2liaWxpdHkiLCJyZXN0b3JlRWxlcyIsImVsZXMiLCJhZGRFZGdlIiwibmV3RWRnZSIsInNvdXJjZSIsInRhcmdldCIsImFkZFByb2Nlc3NXaXRoQ29udmVuaWVudEVkZ2VzIiwicHJvY2Vzc1R5cGUiLCJjcmVhdGVDb21wb3VuZEZvckdpdmVuTm9kZXMiLCJub2Rlc1RvTWFrZUNvbXBvdW5kIiwicmVtb3ZlZEVsZXMiLCJ1bmlvbiIsImRlc2NlbmRhbnRzIiwiY29ubmVjdGVkRWRnZXMiLCJvbGRQYXJlbnRJZCIsImRhdGEiLCJjb21wb3VuZFR5cGUiLCJtYWludGFpblBvaW50ZXIiLCJjcmVhdGVUZW1wbGF0ZVJlYWN0aW9uIiwidGVtcGxhdGVUeXBlIiwibWFjcm9tb2xlY3VsZUxpc3QiLCJjb21wbGV4TmFtZSIsInByb2Nlc3NQb3NpdGlvbiIsInRpbGluZ1BhZGRpbmdWZXJ0aWNhbCIsInRpbGluZ1BhZGRpbmdIb3Jpem9udGFsIiwiZWRnZUxlbmd0aCIsImxheW91dFBhcmFtIiwiYWRkIiwidW5zZWxlY3QiLCJzZWxlY3QiLCJjcmVhdGVBY3RpdmF0aW9uUmVhY3Rpb24iLCJwcm90ZWluTmFtZSIsInJldmVyc2UiLCJjcmVhdGVUcmFuc2xhdGlvbiIsInJlZ3VsYXRvckxhYmVsIiwib3V0cHV0TGFiZWwiLCJvcmllbnRhdGlvbiIsImNyZWF0ZVRyYW5zY3JpcHRpb24iLCJsYWJlbCIsImNyZWF0ZURlZ3JhZGF0aW9uIiwibWFjcm9tb2xlY3VsZSIsImNyZWF0ZUNvbXBsZXhQcm90ZWluRm9ybWF0aW9uIiwicHJvdGVpbkxhYmVscyIsImNvbXBsZXhMYWJlbCIsInJlZ3VsYXRvciIsImNyZWF0ZU11bHRpbWVyaXphdGlvbiIsInJlZ3VsYXRvck11bHRpbWVyIiwiY3JlYXRlQ29udmVyc2lvbiIsImlucHV0SW5mb2JveExhYmVscyIsIm91dHB1dEluZm9ib3hMYWJlbHMiLCJjcmVhdGVNZXRhYm9saWNSZWFjdGlvbiIsImlucHV0cyIsIm91dHB1dHMiLCJyZXZlcnNpYmxlIiwiY3JlYXRlTWV0YWJvbGljQ2F0YWx5dGljQWN0aXZpdHkiLCJpbnB1dE5vZGVMaXN0Iiwib3V0cHV0Tm9kZUxpc3QiLCJjYXRhbHlzdE5hbWUiLCJjYXRhbHlzdFR5cGUiLCJjcmVhdGVUcmFuc2NyaXB0aW9uUmVhY3Rpb24iLCJnZW5lTmFtZSIsIm1SbmFOYW1lIiwiY3JlYXRlVHJhbnNsYXRpb25SZWFjdGlvbiIsImdldE5vZGVQb3NpdGlvbnMiLCJwb3NpdGlvbnMiLCJub2RlcyIsImVhY2giLCJlbGUiLCJpIiwicG9zaXRpb24iLCJyZXR1cm5Ub1Bvc2l0aW9ucyIsImN1cnJlbnRQb3NpdGlvbnMiLCJwb3MiLCJyZXNpemVOb2RlcyIsInBlcmZvcm1PcGVyYXRpb24iLCJzaXplTWFwIiwidXNlQXNwZWN0UmF0aW8iLCJwcmVzZXJ2ZVJlbGF0aXZlUG9zIiwibGVuZ3RoIiwibm9kZSIsImlzUGFyZW50IiwidyIsImgiLCJiaWFzTCIsImJpYXNSIiwiYmlhc1QiLCJiaWFzQiIsIndpZHRoIiwiaGVpZ2h0Iiwic3R5bGUiLCJ1cGRhdGUiLCJjaGFuZ2VOb2RlTGFiZWwiLCJfcHJpdmF0ZSIsInVwZGF0ZUluZm9ib3hTdHlsZSIsImluZGV4IiwibmV3UHJvcHMiLCIkIiwidXBkYXRlSW5mb2JveE9iaiIsIm9iaiIsImNoYW5nZURhdGEiLCJuYW1lIiwidmFsdWVNYXAiLCJ1cGRhdGVTZXRGaWVsZCIsInVwZGF0ZXMiLCJmaWVsZE5hbWUiLCJ0b0RlbGV0ZSIsInRvQWRkIiwiY2FsbGJhY2siLCJhZGRlZCIsImRlbGV0ZWQiLCJjaGFuZ2VDc3MiLCJjc3MiLCJjaGFuZ2VGb250UHJvcGVydGllcyIsInByb3AiLCJzaG93QW5kUGVyZm9ybUxheW91dCIsImxheW91dHBhcmFtIiwidmlld1V0aWxpdGllcyIsInNob3ciLCJ1bmRvU2hvd0FuZFBlcmZvcm1MYXlvdXQiLCJoaWRlIiwiaGlkZUFuZFBlcmZvcm1MYXlvdXQiLCJ1bmRvSGlkZUFuZFBlcmZvcm1MYXlvdXQiLCJkZWxldGVBbmRQZXJmb3JtTGF5b3V0IiwidW5kb0RlbGV0ZUFuZFBlcmZvcm1MYXlvdXQiLCJjaGFuZ2VTdGF0ZU9ySW5mb0JveCIsInR5cGUiLCJ0ZW1wRGF0YSIsInNhdmVVbml0cyIsInZhbHVlIiwidW5kZWZpbmVkIiwicmVzdG9yZVVuaXRzIiwiZm9yY2VSZW5kZXIiLCJhZGRTdGF0ZU9ySW5mb0JveCIsImxvY2F0aW9uT2JqIiwicmVtb3ZlU3RhdGVPckluZm9Cb3giLCJmaXRVbml0cyIsImxvY2F0aW9ucyIsImZvckVhY2giLCJib3giLCJiYm94Iiwib2xkU2lkZSIsImFuY2hvclNpZGUiLCJtb2RpZnlVbml0cyIsInNldE11bHRpbWVyU3RhdHVzIiwic3RhdHVzIiwicmVzdWx0U3RhdHVzIiwiaXNNdWx0aW1lciIsImVuZHNXaXRoIiwic2V0QWN0aXZlU3RhdHVzIiwiaXNBY3RpdmUiLCJzdGFydHNXaXRoIiwic2V0SHlwb3RoZXRpY2FsU3RhdHVzIiwiaXNIeXBvdGhldGljYWwiLCJpbmNsdWRlcyIsInNldENsb25lTWFya2VyU3RhdHVzIiwiY3VycmVudFN0YXR1cyIsInNldERlZmF1bHRQcm9wZXJ0eSIsInNiZ25jbGFzcyIsImNsYXNzRGVmYXVsdHMiLCJnZXREZWZhdWx0UHJvcGVydGllcyIsImhhc093blByb3BlcnR5IiwicHJvcE1hcCIsInNldERlZmF1bHRQcm9wZXJ0aWVzIiwiYWRkQmFja2dyb3VuZEltYWdlIiwiYmdPYmoiLCJ1cGRhdGVJbmZvIiwicHJvbXB0SW52YWxpZEltYWdlIiwidmFsaWRhdGVVUkwiLCJyZW1vdmVCYWNrZ3JvdW5kSW1hZ2UiLCJ1cGRhdGVCYWNrZ3JvdW5kSW1hZ2UiLCJvbGRCZ09iaiIsImNoYW5nZUJhY2tncm91bmRJbWFnZSIsIm9sZEltZyIsIm5ld0ltZyIsImNvbnZlcnRJbnRvUmV2ZXJzaWJsZVJlYWN0aW9uIiwiY29sbGVjdGlvbiIsIm1hcFR5cGUiLCJnZXRNYXBUeXBlIiwic2V0TWFwVHlwZSIsInZhbCIsImVkZ2UiLCJzb3VyY2VOb2RlIiwidGFyZ2V0Tm9kZSIsIm1vdmUiLCJjb252ZXJ0ZWRFZGdlIiwiZ2V0RWxlbWVudEJ5SWQiLCJkaXN0YW5jZSIsIm1hcCIsImVsZW1lbnQiLCJ3ZWlnaHQiLCJwb3J0c291cmNlIiwicG9ydHRhcmdldCIsInByb2Nlc3NJZCIsIm1vdmVFZGdlIiwiZml4RXJyb3IiLCJlcnJvckNvZGUiLCJyZXZlcnNlRWRnZSIsIm5ld05vZGVzIiwibmV3RWRnZXMiLCJvbGRFZGdlcyIsIm9sZEVkZ2UiLCJlZGdlcyIsIm5ld1NvdXJjZSIsIm5ld1RhcmdldCIsImNsb25lZEVkZ2UiLCJjbG9uZSIsImVkZ2VQYXJhbXMiLCJsYW5ndWFnZSIsIm5ld1BhcmVudElkIiwicGFyZW50RGF0YSIsIndpdGhEZXNjZW5kYW50IiwiZWxlc1RvUmVzdG9yZSIsIm1vdmVkRWxlcyIsInBvc0RpZmYiLCJwb3NEaWZmWCIsInBvc0RpZmZZIiwibW92ZU5vZGVzIiwiZWRnZWNsYXNzIiwidmFsaWRhdGlvbiIsInZhbGlkYXRlQXJyb3dFbmRzIiwidGVtcCIsInVuZml4RXJyb3IiLCJhbmltYXRlIiwiZHVyYXRpb24iLCJlYXNpbmciLCJmaXQiLCJwYWRkaW5nIiwiY29tcGxldGUiLCJjbG9uZUhpZ2hEZWdyZWVOb2RlIiwib2xkWCIsIm9sZFkiLCJjbGFjdWxhdGVOZXdDbG9uZVBvc2l0aW9uIiwic291cmNlRW5kUG9pbnRYIiwic291cmNlRW5kUG9pbnRZIiwidGFyZ2V0RW5kUG9pbnRYIiwidGFyZ2V0RW5kUG9pbnRZIiwiZGVzaXJlZERpc3RhbmNlIiwiZGlyZWN0aW9uIiwiTWF0aCIsInNxcnQiLCJwb3ciLCJyYXRpbyIsImN4IiwiZWRnZUNsb25lIiwic3RhcnRQb3NpdGlvbiIsIm5ld1Bvc2l0aW9uIiwic291cmNlRW5kcG9pbnQiLCJ0YXJnZXRFbmRwb2ludCIsIm5ld05vZGVJZCIsImNsb25lRWRnZSIsIm51bWJlck9mRWRnZXMiLCJ1bkNsb25lSGlnaERlZ3JlZU5vZGUiLCJjbG9uZUlkIiwiY2hhbmdlTWFwVHlwZSIsImN1cnJlbnRNYXBUeXBlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/utilities/ur-action-functions-extender-factory.js\n");

/***/ }),

/***/ "./node_modules/lodash.isequal/index.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash.isequal/index.js ***!
  \**********************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n/**\n * Lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright JS Foundation and other contributors <https://js.foundation/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    asyncTag = '[object AsyncFunction]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    nullTag = '[object Null]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    proxyTag = '[object Proxy]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]',\n    undefinedTag = '[object Undefined]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Detect free variable `exports`. */\nvar freeExports =  true && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && \"object\" == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * A specialized version of `_.filter` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction arrayFilter(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      resIndex = 0,\n      result = [];\n\n  while (++index < length) {\n    var value = array[index];\n    if (predicate(value, index, array)) {\n      result[resIndex++] = value;\n    }\n  }\n  return result;\n}\n\n/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\n/**\n * A specialized version of `_.some` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n */\nfunction arraySome(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (predicate(array[index], index, array)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\n/**\n * Checks if a `cache` value for `key` exists.\n *\n * @private\n * @param {Object} cache The cache to query.\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction cacheHas(cache, key) {\n  return cache.has(key);\n}\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Converts `map` to its key-value pairs.\n *\n * @private\n * @param {Object} map The map to convert.\n * @returns {Array} Returns the key-value pairs.\n */\nfunction mapToArray(map) {\n  var index = -1,\n      result = Array(map.size);\n\n  map.forEach(function(value, key) {\n    result[++index] = [key, value];\n  });\n  return result;\n}\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\n/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined,\n    Symbol = root.Symbol,\n    Uint8Array = root.Uint8Array,\n    propertyIsEnumerable = objectProto.propertyIsEnumerable,\n    splice = arrayProto.splice,\n    symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols,\n    nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,\n    nativeKeys = overArg(Object.keys, Object);\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView'),\n    Map = getNative(root, 'Map'),\n    Promise = getNative(root, 'Promise'),\n    Set = getNative(root, 'Set'),\n    WeakMap = getNative(root, 'WeakMap'),\n    nativeCreate = getNative(Object, 'create');\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n *\n * Creates an array cache object to store unique values.\n *\n * @private\n * @constructor\n * @param {Array} [values] The values to cache.\n */\nfunction SetCache(values) {\n  var index = -1,\n      length = values == null ? 0 : values.length;\n\n  this.__data__ = new MapCache;\n  while (++index < length) {\n    this.add(values[index]);\n  }\n}\n\n/**\n * Adds `value` to the array cache.\n *\n * @private\n * @name add\n * @memberOf SetCache\n * @alias push\n * @param {*} value The value to cache.\n * @returns {Object} Returns the cache instance.\n */\nfunction setCacheAdd(value) {\n  this.__data__.set(value, HASH_UNDEFINED);\n  return this;\n}\n\n/**\n * Checks if `value` is in the array cache.\n *\n * @private\n * @name has\n * @memberOf SetCache\n * @param {*} value The value to search for.\n * @returns {number} Returns `true` if `value` is found, else `false`.\n */\nfunction setCacheHas(value) {\n  return this.__data__.has(value);\n}\n\n// Add methods to `SetCache`.\nSetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\nSetCache.prototype.has = setCacheHas;\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  var data = this.__data__ = new ListCache(entries);\n  this.size = data.size;\n}\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  var data = this.__data__,\n      result = data['delete'](key);\n\n  this.size = data.size;\n  return result;\n}\n\n/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\n/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var data = this.__data__;\n  if (data instanceof ListCache) {\n    var pairs = data.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      this.size = ++data.size;\n      return this;\n    }\n    data = this.__data__ = new MapCache(pairs);\n  }\n  data.set(key, value);\n  this.size = data.size;\n  return this;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n}\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\n/**\n * The base implementation of `_.isEqual` which supports partial comparisons\n * and tracks traversed objects.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Unordered comparison\n *  2 - Partial comparison\n * @param {Function} [customizer] The function to customize comparisons.\n * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n */\nfunction baseIsEqual(value, other, bitmask, customizer, stack) {\n  if (value === other) {\n    return true;\n  }\n  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {\n    return value !== value && other !== other;\n  }\n  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n}\n\n/**\n * A specialized version of `baseIsEqual` for arrays and objects which performs\n * deep comparisons and tracks traversed objects enabling objects with circular\n * references to be compared.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n  var objIsArr = isArray(object),\n      othIsArr = isArray(other),\n      objTag = objIsArr ? arrayTag : getTag(object),\n      othTag = othIsArr ? arrayTag : getTag(other);\n\n  objTag = objTag == argsTag ? objectTag : objTag;\n  othTag = othTag == argsTag ? objectTag : othTag;\n\n  var objIsObj = objTag == objectTag,\n      othIsObj = othTag == objectTag,\n      isSameTag = objTag == othTag;\n\n  if (isSameTag && isBuffer(object)) {\n    if (!isBuffer(other)) {\n      return false;\n    }\n    objIsArr = true;\n    objIsObj = false;\n  }\n  if (isSameTag && !objIsObj) {\n    stack || (stack = new Stack);\n    return (objIsArr || isTypedArray(object))\n      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)\n      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n  }\n  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {\n    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n    if (objIsWrapped || othIsWrapped) {\n      var objUnwrapped = objIsWrapped ? object.value() : object,\n          othUnwrapped = othIsWrapped ? other.value() : other;\n\n      stack || (stack = new Stack);\n      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n    }\n  }\n  if (!isSameTag) {\n    return false;\n  }\n  stack || (stack = new Stack);\n  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for arrays with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Array} array The array to compare.\n * @param {Array} other The other array to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `array` and `other` objects.\n * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n */\nfunction equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      arrLength = array.length,\n      othLength = other.length;\n\n  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n    return false;\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(array);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var index = -1,\n      result = true,\n      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;\n\n  stack.set(array, other);\n  stack.set(other, array);\n\n  // Ignore non-index properties.\n  while (++index < arrLength) {\n    var arrValue = array[index],\n        othValue = other[index];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, arrValue, index, other, array, stack)\n        : customizer(arrValue, othValue, index, array, other, stack);\n    }\n    if (compared !== undefined) {\n      if (compared) {\n        continue;\n      }\n      result = false;\n      break;\n    }\n    // Recursively compare arrays (susceptible to call stack limits).\n    if (seen) {\n      if (!arraySome(other, function(othValue, othIndex) {\n            if (!cacheHas(seen, othIndex) &&\n                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n              return seen.push(othIndex);\n            }\n          })) {\n        result = false;\n        break;\n      }\n    } else if (!(\n          arrValue === othValue ||\n            equalFunc(arrValue, othValue, bitmask, customizer, stack)\n        )) {\n      result = false;\n      break;\n    }\n  }\n  stack['delete'](array);\n  stack['delete'](other);\n  return result;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for comparing objects of\n * the same `toStringTag`.\n *\n * **Note:** This function only supports comparing values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {string} tag The `toStringTag` of the objects to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n  switch (tag) {\n    case dataViewTag:\n      if ((object.byteLength != other.byteLength) ||\n          (object.byteOffset != other.byteOffset)) {\n        return false;\n      }\n      object = object.buffer;\n      other = other.buffer;\n\n    case arrayBufferTag:\n      if ((object.byteLength != other.byteLength) ||\n          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n        return false;\n      }\n      return true;\n\n    case boolTag:\n    case dateTag:\n    case numberTag:\n      // Coerce booleans to `1` or `0` and dates to milliseconds.\n      // Invalid dates are coerced to `NaN`.\n      return eq(+object, +other);\n\n    case errorTag:\n      return object.name == other.name && object.message == other.message;\n\n    case regexpTag:\n    case stringTag:\n      // Coerce regexes to strings and treat strings, primitives and objects,\n      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n      // for more details.\n      return object == (other + '');\n\n    case mapTag:\n      var convert = mapToArray;\n\n    case setTag:\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;\n      convert || (convert = setToArray);\n\n      if (object.size != other.size && !isPartial) {\n        return false;\n      }\n      // Assume cyclic values are equal.\n      var stacked = stack.get(object);\n      if (stacked) {\n        return stacked == other;\n      }\n      bitmask |= COMPARE_UNORDERED_FLAG;\n\n      // Recursively compare objects (susceptible to call stack limits).\n      stack.set(object, other);\n      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n      stack['delete'](object);\n      return result;\n\n    case symbolTag:\n      if (symbolValueOf) {\n        return symbolValueOf.call(object) == symbolValueOf.call(other);\n      }\n  }\n  return false;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for objects with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      objProps = getAllKeys(object),\n      objLength = objProps.length,\n      othProps = getAllKeys(other),\n      othLength = othProps.length;\n\n  if (objLength != othLength && !isPartial) {\n    return false;\n  }\n  var index = objLength;\n  while (index--) {\n    var key = objProps[index];\n    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n      return false;\n    }\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(object);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var result = true;\n  stack.set(object, other);\n  stack.set(other, object);\n\n  var skipCtor = isPartial;\n  while (++index < objLength) {\n    key = objProps[index];\n    var objValue = object[key],\n        othValue = other[key];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, objValue, key, other, object, stack)\n        : customizer(objValue, othValue, key, object, other, stack);\n    }\n    // Recursively compare objects (susceptible to call stack limits).\n    if (!(compared === undefined\n          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))\n          : compared\n        )) {\n      result = false;\n      break;\n    }\n    skipCtor || (skipCtor = key == 'constructor');\n  }\n  if (result && !skipCtor) {\n    var objCtor = object.constructor,\n        othCtor = other.constructor;\n\n    // Non `Object` object instances with different constructors are not equal.\n    if (objCtor != othCtor &&\n        ('constructor' in object && 'constructor' in other) &&\n        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n          typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n      result = false;\n    }\n  }\n  stack['delete'](object);\n  stack['delete'](other);\n  return result;\n}\n\n/**\n * Creates an array of own enumerable property names and symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeys(object) {\n  return baseGetAllKeys(object, keys, getSymbols);\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\n/**\n * Creates an array of the own enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbols = !nativeGetSymbols ? stubArray : function(object) {\n  if (object == null) {\n    return [];\n  }\n  object = Object(object);\n  return arrayFilter(nativeGetSymbols(object), function(symbol) {\n    return propertyIsEnumerable.call(object, symbol);\n  });\n};\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = baseGetTag(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : '';\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  length = length == null ? MAX_SAFE_INTEGER : length;\n  return !!length &&\n    (typeof value == 'number' || reIsUint.test(value)) &&\n    (value > -1 && value % 1 == 0 && value < length);\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\n/**\n * Performs a deep comparison between two values to determine if they are\n * equivalent.\n *\n * **Note:** This method supports comparing arrays, array buffers, booleans,\n * date objects, error objects, maps, numbers, `Object` objects, regexes,\n * sets, strings, symbols, and typed arrays. `Object` objects are compared\n * by their own, not inherited, enumerable properties. Functions and DOM\n * nodes are compared by strict equality, i.e. `===`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.isEqual(object, other);\n * // => true\n *\n * object === other;\n * // => false\n */\nfunction isEqual(value, other) {\n  return baseIsEqual(value, other);\n}\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\n/**\n * This method returns a new empty array.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {Array} Returns the new empty array.\n * @example\n *\n * var arrays = _.times(2, _.stubArray);\n *\n * console.log(arrays);\n * // => [[], []]\n *\n * console.log(arrays[0] === arrays[1]);\n * // => false\n */\nfunction stubArray() {\n  return [];\n}\n\n/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = isEqual;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbG9kYXNoLmlzZXF1YWwvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DOztBQUVwQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLHFCQUFNLGdCQUFnQixxQkFBTSxJQUFJLHFCQUFNLHNCQUFzQixxQkFBTTs7QUFFMUY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLEtBQTBCOztBQUU1QztBQUNBLGdDQUFnQyxRQUFhOztBQUU3QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxVQUFVO0FBQ3JCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsVUFBVTtBQUNyQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsR0FBRztBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsVUFBVTtBQUNyQixhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsR0FBRztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLEdBQUc7QUFDZCxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FB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QTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsVUFBVTtBQUNyQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQixXQUFXLFVBQVU7QUFDckIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NoaXNlLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC5pc2VxdWFsL2luZGV4LmpzPzVkYTEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBMb2Rhc2ggKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCBKUyBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vanMuZm91bmRhdGlvbi8+XG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKi9cblxuLyoqIFVzZWQgYXMgdGhlIHNpemUgdG8gZW5hYmxlIGxhcmdlIGFycmF5IG9wdGltaXphdGlvbnMuICovXG52YXIgTEFSR0VfQVJSQVlfU0laRSA9IDIwMDtcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBhc3luY1RhZyA9ICdbb2JqZWN0IEFzeW5jRnVuY3Rpb25dJyxcbiAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICBwcm9taXNlVGFnID0gJ1tvYmplY3QgUHJvbWlzZV0nLFxuICAgIHByb3h5VGFnID0gJ1tvYmplY3QgUHJveHldJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJyxcbiAgICB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqXG4gKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgXG4gKiBbc3ludGF4IGNoYXJhY3RlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXBhdHRlcm5zKS5cbiAqL1xudmFyIHJlUmVnRXhwQ2hhciA9IC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkpLiAqL1xudmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cbi8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi9cbnZhciByZUlzVWludCA9IC9eKD86MHxbMS05XVxcZCopJC87XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIG9mIHR5cGVkIGFycmF5cy4gKi9cbnZhciB0eXBlZEFycmF5VGFncyA9IHt9O1xudHlwZWRBcnJheVRhZ3NbZmxvYXQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1tmbG9hdDY0VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG50eXBlZEFycmF5VGFnc1thcmdzVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9XG50eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tib29sVGFnXSA9XG50eXBlZEFycmF5VGFnc1tkYXRhVmlld1RhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9XG50eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPSB0eXBlZEFycmF5VGFnc1tmdW5jVGFnXSA9XG50eXBlZEFycmF5VGFnc1ttYXBUYWddID0gdHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9XG50eXBlZEFycmF5VGFnc1tvYmplY3RUYWddID0gdHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnXSA9XG50eXBlZEFycmF5VGFnc1tzZXRUYWddID0gdHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9XG50eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBwcm9jZXNzYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZVByb2Nlc3MgPSBtb2R1bGVFeHBvcnRzICYmIGZyZWVHbG9iYWwucHJvY2VzcztcblxuLyoqIFVzZWQgdG8gYWNjZXNzIGZhc3RlciBOb2RlLmpzIGhlbHBlcnMuICovXG52YXIgbm9kZVV0aWwgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGZyZWVQcm9jZXNzICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcgJiYgZnJlZVByb2Nlc3MuYmluZGluZygndXRpbCcpO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxuLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbnZhciBub2RlSXNUeXBlZEFycmF5ID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNUeXBlZEFycmF5O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5maWx0ZXJgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlGaWx0ZXIoYXJyYXksIHByZWRpY2F0ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQXBwZW5kcyB0aGUgZWxlbWVudHMgb2YgYHZhbHVlc2AgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGFwcGVuZC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBhcnJheVB1c2goYXJyYXksIHZhbHVlcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICBvZmZzZXQgPSBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhcnJheVtvZmZzZXQgKyBpbmRleF0gPSB2YWx1ZXNbaW5kZXhdO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc29tZWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgZWxlbWVudCBwYXNzZXMgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5U29tZShhcnJheSwgcHJlZGljYXRlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50aW1lc2Agd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzXG4gKiBvciBtYXggYXJyYXkgbGVuZ3RoIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBpbnZva2UgYGl0ZXJhdGVlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUaW1lcyhuLCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG4pO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbikge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShpbmRleCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmFyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBzdG9yaW5nIG1ldGFkYXRhLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVVuYXJ5KGZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmModmFsdWUpO1xuICB9O1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIGBjYWNoZWAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGNhY2hlIFRoZSBjYWNoZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBjYWNoZUhhcyhjYWNoZSwga2V5KSB7XG4gIHJldHVybiBjYWNoZS5oYXMoa2V5KTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gZ2V0VmFsdWUob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG59XG5cbi8qKlxuICogQ29udmVydHMgYG1hcGAgdG8gaXRzIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGtleS12YWx1ZSBwYWlycy5cbiAqL1xuZnVuY3Rpb24gbWFwVG9BcnJheShtYXApIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShtYXAuc2l6ZSk7XG5cbiAgbWFwLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IFtrZXksIHZhbHVlXTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHVuYXJ5IGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnQgdHJhbnNmb3JtZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xuICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpO1xuICB9O1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGBzZXRgIHRvIGFuIGFycmF5IG9mIGl0cyB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZXQgVGhlIHNldCB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIHNldFRvQXJyYXkoc2V0KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkoc2V0LnNpemUpO1xuXG4gIHNldC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gdmFsdWU7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZSxcbiAgICBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb3ZlcnJlYWNoaW5nIGNvcmUtanMgc2hpbXMuICovXG52YXIgY29yZUpzRGF0YSA9IHJvb3RbJ19fY29yZS1qc19zaGFyZWRfXyddO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWV0aG9kcyBtYXNxdWVyYWRpbmcgYXMgbmF0aXZlLiAqL1xudmFyIG1hc2tTcmNLZXkgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciB1aWQgPSAvW14uXSskLy5leGVjKGNvcmVKc0RhdGEgJiYgY29yZUpzRGF0YS5rZXlzICYmIGNvcmVKc0RhdGEua2V5cy5JRV9QUk9UTyB8fCAnJyk7XG4gIHJldHVybiB1aWQgPyAoJ1N5bWJvbChzcmMpXzEuJyArIHVpZCkgOiAnJztcbn0oKSk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xudmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgZnVuY1RvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG4pO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gcm9vdC5CdWZmZXIgOiB1bmRlZmluZWQsXG4gICAgU3ltYm9sID0gcm9vdC5TeW1ib2wsXG4gICAgVWludDhBcnJheSA9IHJvb3QuVWludDhBcnJheSxcbiAgICBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlLFxuICAgIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlLFxuICAgIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlR2V0U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsXG4gICAgbmF0aXZlSXNCdWZmZXIgPSBCdWZmZXIgPyBCdWZmZXIuaXNCdWZmZXIgOiB1bmRlZmluZWQsXG4gICAgbmF0aXZlS2V5cyA9IG92ZXJBcmcoT2JqZWN0LmtleXMsIE9iamVjdCk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBEYXRhVmlldyA9IGdldE5hdGl2ZShyb290LCAnRGF0YVZpZXcnKSxcbiAgICBNYXAgPSBnZXROYXRpdmUocm9vdCwgJ01hcCcpLFxuICAgIFByb21pc2UgPSBnZXROYXRpdmUocm9vdCwgJ1Byb21pc2UnKSxcbiAgICBTZXQgPSBnZXROYXRpdmUocm9vdCwgJ1NldCcpLFxuICAgIFdlYWtNYXAgPSBnZXROYXRpdmUocm9vdCwgJ1dlYWtNYXAnKSxcbiAgICBuYXRpdmVDcmVhdGUgPSBnZXROYXRpdmUoT2JqZWN0LCAnY3JlYXRlJyk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtYXBzLCBzZXRzLCBhbmQgd2Vha21hcHMuICovXG52YXIgZGF0YVZpZXdDdG9yU3RyaW5nID0gdG9Tb3VyY2UoRGF0YVZpZXcpLFxuICAgIG1hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShNYXApLFxuICAgIHByb21pc2VDdG9yU3RyaW5nID0gdG9Tb3VyY2UoUHJvbWlzZSksXG4gICAgc2V0Q3RvclN0cmluZyA9IHRvU291cmNlKFNldCksXG4gICAgd2Vha01hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShXZWFrTWFwKTtcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFZhbHVlT2YgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnZhbHVlT2YgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGhhc2ggb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBIYXNoKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIEhhc2hcbiAqL1xuZnVuY3Rpb24gaGFzaENsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmF0aXZlQ3JlYXRlID8gbmF0aXZlQ3JlYXRlKG51bGwpIDoge307XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7T2JqZWN0fSBoYXNoIFRoZSBoYXNoIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5oYXMoa2V5KSAmJiBkZWxldGUgdGhpcy5fX2RhdGFfX1trZXldO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgaGFzaCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBoYXNoR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChuYXRpdmVDcmVhdGUpIHtcbiAgICB2YXIgcmVzdWx0ID0gZGF0YVtrZXldO1xuICAgIHJldHVybiByZXN1bHQgPT09IEhBU0hfVU5ERUZJTkVEID8gdW5kZWZpbmVkIDogcmVzdWx0O1xuICB9XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSkgPyBkYXRhW2tleV0gOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgaGFzaCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaEhhcyhrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICByZXR1cm4gbmF0aXZlQ3JlYXRlID8gKGRhdGFba2V5XSAhPT0gdW5kZWZpbmVkKSA6IGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBoYXNoIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaGFzaCBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gaGFzaFNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgdGhpcy5zaXplICs9IHRoaXMuaGFzKGtleSkgPyAwIDogMTtcbiAgZGF0YVtrZXldID0gKG5hdGl2ZUNyZWF0ZSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSA/IEhBU0hfVU5ERUZJTkVEIDogdmFsdWU7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgSGFzaGAuXG5IYXNoLnByb3RvdHlwZS5jbGVhciA9IGhhc2hDbGVhcjtcbkhhc2gucHJvdG90eXBlWydkZWxldGUnXSA9IGhhc2hEZWxldGU7XG5IYXNoLnByb3RvdHlwZS5nZXQgPSBoYXNoR2V0O1xuSGFzaC5wcm90b3R5cGUuaGFzID0gaGFzaEhhcztcbkhhc2gucHJvdG90eXBlLnNldCA9IGhhc2hTZXQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBsaXN0IGNhY2hlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTGlzdENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IFtdO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgbGFzdEluZGV4ID0gZGF0YS5sZW5ndGggLSAxO1xuICBpZiAoaW5kZXggPT0gbGFzdEluZGV4KSB7XG4gICAgZGF0YS5wb3AoKTtcbiAgfSBlbHNlIHtcbiAgICBzcGxpY2UuY2FsbChkYXRhLCBpbmRleCwgMSk7XG4gIH1cbiAgLS10aGlzLnNpemU7XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgcmV0dXJuIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IGRhdGFbaW5kZXhdWzFdO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gYXNzb2NJbmRleE9mKHRoaXMuX19kYXRhX18sIGtleSkgPiAtMTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBsaXN0IGNhY2hlIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBsaXN0IGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICArK3RoaXMuc2l6ZTtcbiAgICBkYXRhLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSBlbHNlIHtcbiAgICBkYXRhW2luZGV4XVsxXSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTGlzdENhY2hlYC5cbkxpc3RDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBsaXN0Q2FjaGVDbGVhcjtcbkxpc3RDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbGlzdENhY2hlRGVsZXRlO1xuTGlzdENhY2hlLnByb3RvdHlwZS5nZXQgPSBsaXN0Q2FjaGVHZXQ7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmhhcyA9IGxpc3RDYWNoZUhhcztcbkxpc3RDYWNoZS5wcm90b3R5cGUuc2V0ID0gbGlzdENhY2hlU2V0O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXAgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTWFwQ2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUNsZWFyKCkge1xuICB0aGlzLnNpemUgPSAwO1xuICB0aGlzLl9fZGF0YV9fID0ge1xuICAgICdoYXNoJzogbmV3IEhhc2gsXG4gICAgJ21hcCc6IG5ldyAoTWFwIHx8IExpc3RDYWNoZSksXG4gICAgJ3N0cmluZyc6IG5ldyBIYXNoXG4gIH07XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IGdldE1hcERhdGEodGhpcywga2V5KVsnZGVsZXRlJ10oa2V5KTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIG1hcCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVHZXQoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuZ2V0KGtleSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbWFwIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuaGFzKGtleSk7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgbWFwIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG1hcCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IGdldE1hcERhdGEodGhpcywga2V5KSxcbiAgICAgIHNpemUgPSBkYXRhLnNpemU7XG5cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSArPSBkYXRhLnNpemUgPT0gc2l6ZSA/IDAgOiAxO1xuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cbk1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG5NYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbWFwQ2FjaGVEZWxldGU7XG5NYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwQ2FjaGVHZXQ7XG5NYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XG5NYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gbWFwQ2FjaGVTZXQ7XG5cbi8qKlxuICpcbiAqIENyZWF0ZXMgYW4gYXJyYXkgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIHVuaXF1ZSB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gU2V0Q2FjaGUodmFsdWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gdmFsdWVzID09IG51bGwgPyAwIDogdmFsdWVzLmxlbmd0aDtcblxuICB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHRoaXMuYWRkKHZhbHVlc1tpbmRleF0pO1xuICB9XG59XG5cbi8qKlxuICogQWRkcyBgdmFsdWVgIHRvIHRoZSBhcnJheSBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgYWRkXG4gKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAqIEBhbGlhcyBwdXNoXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjYWNoZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzZXRDYWNoZUFkZCh2YWx1ZSkge1xuICB0aGlzLl9fZGF0YV9fLnNldCh2YWx1ZSwgSEFTSF9VTkRFRklORUQpO1xuICByZXR1cm4gdGhpcztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBpbiB0aGUgYXJyYXkgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIFNldENhY2hlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzZXRDYWNoZUhhcyh2YWx1ZSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXModmFsdWUpO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU2V0Q2FjaGVgLlxuU2V0Q2FjaGUucHJvdG90eXBlLmFkZCA9IFNldENhY2hlLnByb3RvdHlwZS5wdXNoID0gc2V0Q2FjaGVBZGQ7XG5TZXRDYWNoZS5wcm90b3R5cGUuaGFzID0gc2V0Q2FjaGVIYXM7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0YWNrIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFN0YWNrKGVudHJpZXMpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZShlbnRyaWVzKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIFN0YWNrXG4gKi9cbmZ1bmN0aW9uIHN0YWNrQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0RlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgcmVzdWx0ID0gZGF0YVsnZGVsZXRlJ10oa2V5KTtcblxuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgc3RhY2sgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrR2V0KGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQoa2V5KTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBzdGFjayB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrSGFzKGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoa2V5KTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBzdGFjayBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBzdGFjayBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgTGlzdENhY2hlKSB7XG4gICAgdmFyIHBhaXJzID0gZGF0YS5fX2RhdGFfXztcbiAgICBpZiAoIU1hcCB8fCAocGFpcnMubGVuZ3RoIDwgTEFSR0VfQVJSQVlfU0laRSAtIDEpKSB7XG4gICAgICBwYWlycy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICB0aGlzLnNpemUgPSArK2RhdGEuc2l6ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZShwYWlycyk7XG4gIH1cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBTdGFja2AuXG5TdGFjay5wcm90b3R5cGUuY2xlYXIgPSBzdGFja0NsZWFyO1xuU3RhY2sucHJvdG90eXBlWydkZWxldGUnXSA9IHN0YWNrRGVsZXRlO1xuU3RhY2sucHJvdG90eXBlLmdldCA9IHN0YWNrR2V0O1xuU3RhY2sucHJvdG90eXBlLmhhcyA9IHN0YWNrSGFzO1xuU3RhY2sucHJvdG90eXBlLnNldCA9IHN0YWNrU2V0O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgdGhlIGFycmF5LWxpa2UgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluaGVyaXRlZCBTcGVjaWZ5IHJldHVybmluZyBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZXMuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBhcnJheUxpa2VLZXlzKHZhbHVlLCBpbmhlcml0ZWQpIHtcbiAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSksXG4gICAgICBpc0FyZyA9ICFpc0FyciAmJiBpc0FyZ3VtZW50cyh2YWx1ZSksXG4gICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgIWlzQXJnICYmIGlzQnVmZmVyKHZhbHVlKSxcbiAgICAgIGlzVHlwZSA9ICFpc0FyciAmJiAhaXNBcmcgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkodmFsdWUpLFxuICAgICAgc2tpcEluZGV4ZXMgPSBpc0FyciB8fCBpc0FyZyB8fCBpc0J1ZmYgfHwgaXNUeXBlLFxuICAgICAgcmVzdWx0ID0gc2tpcEluZGV4ZXMgPyBiYXNlVGltZXModmFsdWUubGVuZ3RoLCBTdHJpbmcpIDogW10sXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmICgoaW5oZXJpdGVkIHx8IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpICYmXG4gICAgICAgICEoc2tpcEluZGV4ZXMgJiYgKFxuICAgICAgICAgICAvLyBTYWZhcmkgOSBoYXMgZW51bWVyYWJsZSBgYXJndW1lbnRzLmxlbmd0aGAgaW4gc3RyaWN0IG1vZGUuXG4gICAgICAgICAgIGtleSA9PSAnbGVuZ3RoJyB8fFxuICAgICAgICAgICAvLyBOb2RlLmpzIDAuMTAgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gYnVmZmVycy5cbiAgICAgICAgICAgKGlzQnVmZiAmJiAoa2V5ID09ICdvZmZzZXQnIHx8IGtleSA9PSAncGFyZW50JykpIHx8XG4gICAgICAgICAgIC8vIFBoYW50b21KUyAyIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIHR5cGVkIGFycmF5cy5cbiAgICAgICAgICAgKGlzVHlwZSAmJiAoa2V5ID09ICdidWZmZXInIHx8IGtleSA9PSAnYnl0ZUxlbmd0aCcgfHwga2V5ID09ICdieXRlT2Zmc2V0JykpIHx8XG4gICAgICAgICAgIC8vIFNraXAgaW5kZXggcHJvcGVydGllcy5cbiAgICAgICAgICAgaXNJbmRleChrZXksIGxlbmd0aClcbiAgICAgICAgKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGBrZXlgIGlzIGZvdW5kIGluIGBhcnJheWAgb2Yga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSwga2V5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIGlmIChlcShhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XG4gICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldEFsbEtleXNgIGFuZCBgZ2V0QWxsS2V5c0luYCB3aGljaCB1c2VzXG4gKiBga2V5c0Z1bmNgIGFuZCBgc3ltYm9sc0Z1bmNgIHRvIGdldCB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAqIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzeW1ib2xzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzRnVuYywgc3ltYm9sc0Z1bmMpIHtcbiAgdmFyIHJlc3VsdCA9IGtleXNGdW5jKG9iamVjdCk7XG4gIHJldHVybiBpc0FycmF5KG9iamVjdCkgPyByZXN1bHQgOiBhcnJheVB1c2gocmVzdWx0LCBzeW1ib2xzRnVuYyhvYmplY3QpKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYCB3aXRob3V0IGZhbGxiYWNrcyBmb3IgYnVnZ3kgZW52aXJvbm1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZFRhZyA6IG51bGxUYWc7XG4gIH1cbiAgcmV0dXJuIChzeW1Ub1N0cmluZ1RhZyAmJiBzeW1Ub1N0cmluZ1RhZyBpbiBPYmplY3QodmFsdWUpKVxuICAgID8gZ2V0UmF3VGFnKHZhbHVlKVxuICAgIDogb2JqZWN0VG9TdHJpbmcodmFsdWUpO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzQXJndW1lbnRzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0FyZ3VtZW50cyh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBhcmdzVGFnO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzRXF1YWxgIHdoaWNoIHN1cHBvcnRzIHBhcnRpYWwgY29tcGFyaXNvbnNcbiAqIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtib29sZWFufSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLlxuICogIDEgLSBVbm9yZGVyZWQgY29tcGFyaXNvblxuICogIDIgLSBQYXJ0aWFsIGNvbXBhcmlzb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBgdmFsdWVgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNFcXVhbCh2YWx1ZSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gIGlmICh2YWx1ZSA9PT0gb3RoZXIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCB8fCBvdGhlciA9PSBudWxsIHx8ICghaXNPYmplY3RMaWtlKHZhbHVlKSAmJiAhaXNPYmplY3RMaWtlKG90aGVyKSkpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcjtcbiAgfVxuICByZXR1cm4gYmFzZUlzRXF1YWxEZWVwKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgYmFzZUlzRXF1YWwsIHN0YWNrKTtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gKiBkZWVwIGNvbXBhcmlzb25zIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gKiByZWZlcmVuY2VzIHRvIGJlIGNvbXBhcmVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNFcXVhbERlZXAob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgb2JqSXNBcnIgPSBpc0FycmF5KG9iamVjdCksXG4gICAgICBvdGhJc0FyciA9IGlzQXJyYXkob3RoZXIpLFxuICAgICAgb2JqVGFnID0gb2JqSXNBcnIgPyBhcnJheVRhZyA6IGdldFRhZyhvYmplY3QpLFxuICAgICAgb3RoVGFnID0gb3RoSXNBcnIgPyBhcnJheVRhZyA6IGdldFRhZyhvdGhlcik7XG5cbiAgb2JqVGFnID0gb2JqVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvYmpUYWc7XG4gIG90aFRhZyA9IG90aFRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb3RoVGFnO1xuXG4gIHZhciBvYmpJc09iaiA9IG9ialRhZyA9PSBvYmplY3RUYWcsXG4gICAgICBvdGhJc09iaiA9IG90aFRhZyA9PSBvYmplY3RUYWcsXG4gICAgICBpc1NhbWVUYWcgPSBvYmpUYWcgPT0gb3RoVGFnO1xuXG4gIGlmIChpc1NhbWVUYWcgJiYgaXNCdWZmZXIob2JqZWN0KSkge1xuICAgIGlmICghaXNCdWZmZXIob3RoZXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIG9iaklzQXJyID0gdHJ1ZTtcbiAgICBvYmpJc09iaiA9IGZhbHNlO1xuICB9XG4gIGlmIChpc1NhbWVUYWcgJiYgIW9iaklzT2JqKSB7XG4gICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICByZXR1cm4gKG9iaklzQXJyIHx8IGlzVHlwZWRBcnJheShvYmplY3QpKVxuICAgICAgPyBlcXVhbEFycmF5cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKVxuICAgICAgOiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIG9ialRhZywgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gIH1cbiAgaWYgKCEoYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHKSkge1xuICAgIHZhciBvYmpJc1dyYXBwZWQgPSBvYmpJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgJ19fd3JhcHBlZF9fJyksXG4gICAgICAgIG90aElzV3JhcHBlZCA9IG90aElzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsICdfX3dyYXBwZWRfXycpO1xuXG4gICAgaWYgKG9iaklzV3JhcHBlZCB8fCBvdGhJc1dyYXBwZWQpIHtcbiAgICAgIHZhciBvYmpVbndyYXBwZWQgPSBvYmpJc1dyYXBwZWQgPyBvYmplY3QudmFsdWUoKSA6IG9iamVjdCxcbiAgICAgICAgICBvdGhVbndyYXBwZWQgPSBvdGhJc1dyYXBwZWQgPyBvdGhlci52YWx1ZSgpIDogb3RoZXI7XG5cbiAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICByZXR1cm4gZXF1YWxGdW5jKG9ialVud3JhcHBlZCwgb3RoVW53cmFwcGVkLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgfVxuICB9XG4gIGlmICghaXNTYW1lVGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gIHJldHVybiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYXRpdmVgIHdpdGhvdXQgYmFkIHNoaW0gY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTmF0aXZlKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpIHx8IGlzTWFza2VkKHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcGF0dGVybiA9IGlzRnVuY3Rpb24odmFsdWUpID8gcmVJc05hdGl2ZSA6IHJlSXNIb3N0Q3RvcjtcbiAgcmV0dXJuIHBhdHRlcm4udGVzdCh0b1NvdXJjZSh2YWx1ZSkpO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzVHlwZWRBcnJheWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNUeXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmXG4gICAgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhIXR5cGVkQXJyYXlUYWdzW2Jhc2VHZXRUYWcodmFsdWUpXTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzKG9iamVjdCkge1xuICBpZiAoIWlzUHJvdG90eXBlKG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5cyhvYmplY3QpO1xuICB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGtleSAhPSAnY29uc3RydWN0b3InKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgYXJyYXlzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge0FycmF5fSBvdGhlciBUaGUgb3RoZXIgYXJyYXkgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYGFycmF5YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcnJheXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxBcnJheXMoYXJyYXksIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICBhcnJMZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBvdGhMZW5ndGggPSBvdGhlci5sZW5ndGg7XG5cbiAgaWYgKGFyckxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIShpc1BhcnRpYWwgJiYgb3RoTGVuZ3RoID4gYXJyTGVuZ3RoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KGFycmF5KTtcbiAgaWYgKHN0YWNrZWQgJiYgc3RhY2suZ2V0KG90aGVyKSkge1xuICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICB9XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gdHJ1ZSxcbiAgICAgIHNlZW4gPSAoYml0bWFzayAmIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcpID8gbmV3IFNldENhY2hlIDogdW5kZWZpbmVkO1xuXG4gIHN0YWNrLnNldChhcnJheSwgb3RoZXIpO1xuICBzdGFjay5zZXQob3RoZXIsIGFycmF5KTtcblxuICAvLyBJZ25vcmUgbm9uLWluZGV4IHByb3BlcnRpZXMuXG4gIHdoaWxlICgrK2luZGV4IDwgYXJyTGVuZ3RoKSB7XG4gICAgdmFyIGFyclZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2luZGV4XTtcblxuICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBhcnJWYWx1ZSwgaW5kZXgsIG90aGVyLCBhcnJheSwgc3RhY2spXG4gICAgICAgIDogY3VzdG9taXplcihhcnJWYWx1ZSwgb3RoVmFsdWUsIGluZGV4LCBhcnJheSwgb3RoZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgaWYgKGNvbXBhcmVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChjb21wYXJlZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgaWYgKHNlZW4pIHtcbiAgICAgIGlmICghYXJyYXlTb21lKG90aGVyLCBmdW5jdGlvbihvdGhWYWx1ZSwgb3RoSW5kZXgpIHtcbiAgICAgICAgICAgIGlmICghY2FjaGVIYXMoc2Vlbiwgb3RoSW5kZXgpICYmXG4gICAgICAgICAgICAgICAgKGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzZWVuLnB1c2gob3RoSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKSB7XG4gICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEoXG4gICAgICAgICAgYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8XG4gICAgICAgICAgICBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaylcbiAgICAgICAgKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgc3RhY2tbJ2RlbGV0ZSddKGFycmF5KTtcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGNvbXBhcmluZyBvYmplY3RzIG9mXG4gKiB0aGUgc2FtZSBgdG9TdHJpbmdUYWdgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY29tcGFyaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIG9yIGBTdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3RzIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCB0YWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlIGRhdGFWaWV3VGFnOlxuICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgIChvYmplY3QuYnl0ZU9mZnNldCAhPSBvdGhlci5ieXRlT2Zmc2V0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBvYmplY3QgPSBvYmplY3QuYnVmZmVyO1xuICAgICAgb3RoZXIgPSBvdGhlci5idWZmZXI7XG5cbiAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgICFlcXVhbEZ1bmMobmV3IFVpbnQ4QXJyYXkob2JqZWN0KSwgbmV3IFVpbnQ4QXJyYXkob3RoZXIpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGNhc2UgYm9vbFRhZzpcbiAgICBjYXNlIGRhdGVUYWc6XG4gICAgY2FzZSBudW1iZXJUYWc6XG4gICAgICAvLyBDb2VyY2UgYm9vbGVhbnMgdG8gYDFgIG9yIGAwYCBhbmQgZGF0ZXMgdG8gbWlsbGlzZWNvbmRzLlxuICAgICAgLy8gSW52YWxpZCBkYXRlcyBhcmUgY29lcmNlZCB0byBgTmFOYC5cbiAgICAgIHJldHVybiBlcSgrb2JqZWN0LCArb3RoZXIpO1xuXG4gICAgY2FzZSBlcnJvclRhZzpcbiAgICAgIHJldHVybiBvYmplY3QubmFtZSA9PSBvdGhlci5uYW1lICYmIG9iamVjdC5tZXNzYWdlID09IG90aGVyLm1lc3NhZ2U7XG5cbiAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgIC8vIENvZXJjZSByZWdleGVzIHRvIHN0cmluZ3MgYW5kIHRyZWF0IHN0cmluZ3MsIHByaW1pdGl2ZXMgYW5kIG9iamVjdHMsXG4gICAgICAvLyBhcyBlcXVhbC4gU2VlIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1yZWdleHAucHJvdG90eXBlLnRvc3RyaW5nXG4gICAgICAvLyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgcmV0dXJuIG9iamVjdCA9PSAob3RoZXIgKyAnJyk7XG5cbiAgICBjYXNlIG1hcFRhZzpcbiAgICAgIHZhciBjb252ZXJ0ID0gbWFwVG9BcnJheTtcblxuICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRztcbiAgICAgIGNvbnZlcnQgfHwgKGNvbnZlcnQgPSBzZXRUb0FycmF5KTtcblxuICAgICAgaWYgKG9iamVjdC5zaXplICE9IG90aGVyLnNpemUgJiYgIWlzUGFydGlhbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gICAgICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICAgICAgaWYgKHN0YWNrZWQpIHtcbiAgICAgICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gICAgICB9XG4gICAgICBiaXRtYXNrIHw9IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUc7XG5cbiAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICAgICAgdmFyIHJlc3VsdCA9IGVxdWFsQXJyYXlzKGNvbnZlcnQob2JqZWN0KSwgY29udmVydChvdGhlciksIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICAgICAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICBpZiAoc3ltYm9sVmFsdWVPZikge1xuICAgICAgICByZXR1cm4gc3ltYm9sVmFsdWVPZi5jYWxsKG9iamVjdCkgPT0gc3ltYm9sVmFsdWVPZi5jYWxsKG90aGVyKTtcbiAgICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBvYmplY3RzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICBvYmpQcm9wcyA9IGdldEFsbEtleXMob2JqZWN0KSxcbiAgICAgIG9iakxlbmd0aCA9IG9ialByb3BzLmxlbmd0aCxcbiAgICAgIG90aFByb3BzID0gZ2V0QWxsS2V5cyhvdGhlciksXG4gICAgICBvdGhMZW5ndGggPSBvdGhQcm9wcy5sZW5ndGg7XG5cbiAgaWYgKG9iakxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIWlzUGFydGlhbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgaW5kZXggPSBvYmpMZW5ndGg7XG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgdmFyIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICBpZiAoIShpc1BhcnRpYWwgPyBrZXkgaW4gb3RoZXIgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCBrZXkpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gIGlmIChzdGFja2VkICYmIHN0YWNrLmdldChvdGhlcikpIHtcbiAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgfVxuICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICBzdGFjay5zZXQob3RoZXIsIG9iamVjdCk7XG5cbiAgdmFyIHNraXBDdG9yID0gaXNQYXJ0aWFsO1xuICB3aGlsZSAoKytpbmRleCA8IG9iakxlbmd0aCkge1xuICAgIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltrZXldO1xuXG4gICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIG9ialZhbHVlLCBrZXksIG90aGVyLCBvYmplY3QsIHN0YWNrKVxuICAgICAgICA6IGN1c3RvbWl6ZXIob2JqVmFsdWUsIG90aFZhbHVlLCBrZXksIG9iamVjdCwgb3RoZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgaWYgKCEoY29tcGFyZWQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gKG9ialZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMob2JqVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpXG4gICAgICAgICAgOiBjb21wYXJlZFxuICAgICAgICApKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBza2lwQ3RvciB8fCAoc2tpcEN0b3IgPSBrZXkgPT0gJ2NvbnN0cnVjdG9yJyk7XG4gIH1cbiAgaWYgKHJlc3VsdCAmJiAhc2tpcEN0b3IpIHtcbiAgICB2YXIgb2JqQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcixcbiAgICAgICAgb3RoQ3RvciA9IG90aGVyLmNvbnN0cnVjdG9yO1xuXG4gICAgLy8gTm9uIGBPYmplY3RgIG9iamVjdCBpbnN0YW5jZXMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1YWwuXG4gICAgaWYgKG9iakN0b3IgIT0gb3RoQ3RvciAmJlxuICAgICAgICAoJ2NvbnN0cnVjdG9yJyBpbiBvYmplY3QgJiYgJ2NvbnN0cnVjdG9yJyBpbiBvdGhlcikgJiZcbiAgICAgICAgISh0eXBlb2Ygb2JqQ3RvciA9PSAnZnVuY3Rpb24nICYmIG9iakN0b3IgaW5zdGFuY2VvZiBvYmpDdG9yICYmXG4gICAgICAgICAgdHlwZW9mIG90aEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvdGhDdG9yIGluc3RhbmNlb2Ygb3RoQ3RvcikpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBnZXRBbGxLZXlzKG9iamVjdCkge1xuICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzLCBnZXRTeW1ib2xzKTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBkYXRhIGZvciBgbWFwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcmVmZXJlbmNlIGtleS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXAgZGF0YS5cbiAqL1xuZnVuY3Rpb24gZ2V0TWFwRGF0YShtYXAsIGtleSkge1xuICB2YXIgZGF0YSA9IG1hcC5fX2RhdGFfXztcbiAgcmV0dXJuIGlzS2V5YWJsZShrZXkpXG4gICAgPyBkYXRhW3R5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyAnc3RyaW5nJyA6ICdoYXNoJ11cbiAgICA6IGRhdGEubWFwO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZ1bmN0aW9uIGlmIGl0J3MgbmF0aXZlLCBlbHNlIGB1bmRlZmluZWRgLlxuICovXG5mdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgdmFyIHZhbHVlID0gZ2V0VmFsdWUob2JqZWN0LCBrZXkpO1xuICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmF3IGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkge1xuICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyksXG4gICAgICB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG5cbiAgdHJ5IHtcbiAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB1bmRlZmluZWQ7XG4gICAgdmFyIHVubWFza2VkID0gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge31cblxuICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIGlmICh1bm1hc2tlZCkge1xuICAgIGlmIChpc093bikge1xuICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdGFnO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2Ygc3ltYm9scy5cbiAqL1xudmFyIGdldFN5bWJvbHMgPSAhbmF0aXZlR2V0U3ltYm9scyA/IHN0dWJBcnJheSA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gIHJldHVybiBhcnJheUZpbHRlcihuYXRpdmVHZXRTeW1ib2xzKG9iamVjdCksIGZ1bmN0aW9uKHN5bWJvbCkge1xuICAgIHJldHVybiBwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iamVjdCwgc3ltYm9sKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIGB0b1N0cmluZ1RhZ2Agb2YgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG52YXIgZ2V0VGFnID0gYmFzZUdldFRhZztcblxuLy8gRmFsbGJhY2sgZm9yIGRhdGEgdmlld3MsIG1hcHMsIHNldHMsIGFuZCB3ZWFrIG1hcHMgaW4gSUUgMTEgYW5kIHByb21pc2VzIGluIE5vZGUuanMgPCA2LlxuaWYgKChEYXRhVmlldyAmJiBnZXRUYWcobmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigxKSkpICE9IGRhdGFWaWV3VGFnKSB8fFxuICAgIChNYXAgJiYgZ2V0VGFnKG5ldyBNYXApICE9IG1hcFRhZykgfHxcbiAgICAoUHJvbWlzZSAmJiBnZXRUYWcoUHJvbWlzZS5yZXNvbHZlKCkpICE9IHByb21pc2VUYWcpIHx8XG4gICAgKFNldCAmJiBnZXRUYWcobmV3IFNldCkgIT0gc2V0VGFnKSB8fFxuICAgIChXZWFrTWFwICYmIGdldFRhZyhuZXcgV2Vha01hcCkgIT0gd2Vha01hcFRhZykpIHtcbiAgZ2V0VGFnID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgcmVzdWx0ID0gYmFzZUdldFRhZyh2YWx1ZSksXG4gICAgICAgIEN0b3IgPSByZXN1bHQgPT0gb2JqZWN0VGFnID8gdmFsdWUuY29uc3RydWN0b3IgOiB1bmRlZmluZWQsXG4gICAgICAgIGN0b3JTdHJpbmcgPSBDdG9yID8gdG9Tb3VyY2UoQ3RvcikgOiAnJztcblxuICAgIGlmIChjdG9yU3RyaW5nKSB7XG4gICAgICBzd2l0Y2ggKGN0b3JTdHJpbmcpIHtcbiAgICAgICAgY2FzZSBkYXRhVmlld0N0b3JTdHJpbmc6IHJldHVybiBkYXRhVmlld1RhZztcbiAgICAgICAgY2FzZSBtYXBDdG9yU3RyaW5nOiByZXR1cm4gbWFwVGFnO1xuICAgICAgICBjYXNlIHByb21pc2VDdG9yU3RyaW5nOiByZXR1cm4gcHJvbWlzZVRhZztcbiAgICAgICAgY2FzZSBzZXRDdG9yU3RyaW5nOiByZXR1cm4gc2V0VGFnO1xuICAgICAgICBjYXNlIHdlYWtNYXBDdG9yU3RyaW5nOiByZXR1cm4gd2Vha01hcFRhZztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuICByZXR1cm4gISFsZW5ndGggJiZcbiAgICAodHlwZW9mIHZhbHVlID09ICdudW1iZXInIHx8IHJlSXNVaW50LnRlc3QodmFsdWUpKSAmJlxuICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3IgdXNlIGFzIHVuaXF1ZSBvYmplY3Qga2V5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5YWJsZSh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICh0eXBlID09ICdzdHJpbmcnIHx8IHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJylcbiAgICA/ICh2YWx1ZSAhPT0gJ19fcHJvdG9fXycpXG4gICAgOiAodmFsdWUgPT09IG51bGwpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGl0cyBzb3VyY2UgbWFza2VkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2VkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzTWFza2VkKGZ1bmMpIHtcbiAgcmV0dXJuICEhbWFza1NyY0tleSAmJiAobWFza1NyY0tleSBpbiBmdW5jKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7XG4gIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXG4gICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcblxuICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgdXNpbmcgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGBmdW5jYCB0byBpdHMgc291cmNlIGNvZGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzb3VyY2UgY29kZS5cbiAqL1xuZnVuY3Rpb24gdG9Tb3VyY2UoZnVuYykge1xuICBpZiAoZnVuYyAhPSBudWxsKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmdW5jVG9TdHJpbmcuY2FsbChmdW5jKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gKGZ1bmMgKyAnJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogUGVyZm9ybXMgYVxuICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAqXG4gKiBfLmVxKG9iamVjdCwgb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKCdhJywgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKCdhJywgT2JqZWN0KCdhJykpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKE5hTiwgTmFOKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gZXEodmFsdWUsIG90aGVyKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgKHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXIpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcmd1bWVudHMgPSBiYXNlSXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPyBiYXNlSXNBcmd1bWVudHMgOiBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xuICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxuICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgIWlzRnVuY3Rpb24odmFsdWUpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4zLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IEJ1ZmZlcigyKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgVWludDhBcnJheSgyKSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNCdWZmZXIgPSBuYXRpdmVJc0J1ZmZlciB8fCBzdHViRmFsc2U7XG5cbi8qKlxuICogUGVyZm9ybXMgYSBkZWVwIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZVxuICogZXF1aXZhbGVudC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2Qgc3VwcG9ydHMgY29tcGFyaW5nIGFycmF5cywgYXJyYXkgYnVmZmVycywgYm9vbGVhbnMsXG4gKiBkYXRlIG9iamVjdHMsIGVycm9yIG9iamVjdHMsIG1hcHMsIG51bWJlcnMsIGBPYmplY3RgIG9iamVjdHMsIHJlZ2V4ZXMsXG4gKiBzZXRzLCBzdHJpbmdzLCBzeW1ib2xzLCBhbmQgdHlwZWQgYXJyYXlzLiBgT2JqZWN0YCBvYmplY3RzIGFyZSBjb21wYXJlZFxuICogYnkgdGhlaXIgb3duLCBub3QgaW5oZXJpdGVkLCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuIEZ1bmN0aW9ucyBhbmQgRE9NXG4gKiBub2RlcyBhcmUgY29tcGFyZWQgYnkgc3RyaWN0IGVxdWFsaXR5LCBpLmUuIGA9PT1gLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAqXG4gKiBfLmlzRXF1YWwob2JqZWN0LCBvdGhlcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogb2JqZWN0ID09PSBvdGhlcjtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRXF1YWwodmFsdWUsIG90aGVyKSB7XG4gIHJldHVybiBiYXNlSXNFcXVhbCh2YWx1ZSwgb3RoZXIpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgLy8gaW4gU2FmYXJpIDkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXlzIGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG4gIHZhciB0YWcgPSBiYXNlR2V0VGFnKHZhbHVlKTtcbiAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWcgfHwgdGFnID09IGFzeW5jVGFnIHx8IHRhZyA9PSBwcm94eVRhZztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNMZW5ndGgoMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcbiAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgdHlwZWQgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShuZXcgVWludDhBcnJheSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkoW10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzVHlwZWRBcnJheSA9IG5vZGVJc1R5cGVkQXJyYXkgPyBiYXNlVW5hcnkobm9kZUlzVHlwZWRBcnJheSkgOiBiYXNlSXNUeXBlZEFycmF5O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLiBTZWUgdGhlXG4gKiBbRVMgc3BlY10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5cyhuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiBfLmtleXMoJ2hpJyk7XG4gKiAvLyA9PiBbJzAnLCAnMSddXG4gKi9cbmZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QpIDogYmFzZUtleXMob2JqZWN0KTtcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGVtcHR5IGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZW1wdHkgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBhcnJheXMgPSBfLnRpbWVzKDIsIF8uc3R1YkFycmF5KTtcbiAqXG4gKiBjb25zb2xlLmxvZyhhcnJheXMpO1xuICogLy8gPT4gW1tdLCBbXV1cbiAqXG4gKiBjb25zb2xlLmxvZyhhcnJheXNbMF0gPT09IGFycmF5c1sxXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBzdHViQXJyYXkoKSB7XG4gIHJldHVybiBbXTtcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGBmYWxzZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRpbWVzKDIsIF8uc3R1YkZhbHNlKTtcbiAqIC8vID0+IFtmYWxzZSwgZmFsc2VdXG4gKi9cbmZ1bmN0aW9uIHN0dWJGYWxzZSgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRXF1YWw7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/lodash.isequal/index.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});