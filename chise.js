/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["chise"] = factory();
	else
		root["chise"] = factory();
})(self, function() {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("(function () {\n  var chise = function chise(_options) {\n    var param = {}; // Access the libs\n\n    var libs = __webpack_require__(/*! ./utilities/lib-utilities */ \"./src/utilities/lib-utilities.js\").getLibs();\n\n    var optionUtilities = __webpack_require__(/*! ./utilities/option-utilities-factory */ \"./src/utilities/option-utilities-factory.js\")();\n\n    var options = optionUtilities.extendOptions(_options); // Extends the default options with the given options\n    // Create an sbgnviz instance\n\n    var sbgnvizInstanceUtilities = __webpack_require__(/*! ./utilities/sbgnviz-instance-utilities-factory */ \"./src/utilities/sbgnviz-instance-utilities-factory.js\")();\n\n    var sbgnvizInstance = sbgnvizInstanceUtilities(options); // Register undo/redo actions\n\n    var registerUndoRedoActions = __webpack_require__(/*! ./utilities/register-undo-redo-actions-factory */ \"./src/utilities/register-undo-redo-actions-factory.js\")();\n\n    var mainUtilities = __webpack_require__(/*! ./utilities/main-utilities-factory */ \"./src/utilities/main-utilities-factory.js\")();\n\n    var elementUtilitiesExtender = __webpack_require__(/*! ./utilities/element-utilities-extender-factory */ \"./src/utilities/element-utilities-extender-factory.js\")();\n\n    var undoRedoActionFunctionsExtender = __webpack_require__(/*! ./utilities/ur-action-functions-extender-factory */ \"./src/utilities/ur-action-functions-extender-factory.js\")();\n\n    var sifTopologyGrouping = __webpack_require__(/*! ./utilities/topology-grouping-factory */ \"./src/utilities/topology-grouping-factory.js\")();\n\n    var elementUtilities = sbgnvizInstance.elementUtilities;\n    var undoRedoActionFunctions = sbgnvizInstance.undoRedoActionFunctions;\n    param.sbgnvizInstanceUtilities = sbgnvizInstanceUtilities;\n    param.optionUtilities = optionUtilities;\n    param.elementUtilities = elementUtilities;\n    param.undoRedoActionFunctions = undoRedoActionFunctions;\n    param.sifTopologyGrouping = sifTopologyGrouping;\n\n    var shouldApply = function shouldApply() {\n      return param.elementUtilities.mapType === 'SIF';\n    };\n\n    undoRedoActionFunctionsExtender(param);\n    elementUtilitiesExtender(param);\n    registerUndoRedoActions(param);\n    mainUtilities(param);\n    sifTopologyGrouping(param, {\n      metaEdgeIdentifier: 'sif-meta',\n      lockGraphTopology: true,\n      shouldApply: shouldApply\n    }); // Expose the api\n\n    var api = {}; // Expose the properties inherited from sbgnviz\n    // then override some of these properties and expose some new properties\n\n    for (var prop in sbgnvizInstance) {\n      api[prop] = sbgnvizInstance[prop];\n    } // Expose each main utility seperately\n\n\n    for (var prop in mainUtilities) {\n      api[prop] = mainUtilities[prop];\n    } // Expose getSbgnvizInstance()\n\n\n    api.getSbgnvizInstance = sbgnvizInstanceUtilities.getInstance; // Expose elementUtilities and undoRedoActionFunctions as is\n\n    api.elementUtilities = elementUtilities;\n    api.undoRedoActionFunctions = undoRedoActionFunctions;\n    api.sifTopologyGrouping = sifTopologyGrouping;\n    return api;\n  }; // Register chise with given libraries\n\n\n  chise.register = function (_libs) {\n    var libs = {};\n    libs.jQuery = _libs.jQuery || jQuery;\n    libs.cytoscape = _libs.cytoscape || cytoscape;\n    libs.sbgnviz = _libs.sbgnviz || sbgnviz;\n    libs.saveAs = _libs.filesaver ? _libs.filesaver.saveAs : saveAs;\n    libs.sbgnviz.register(_libs); // Register sbgnviz with the given libs\n    // inherit exposed static properties of sbgnviz other than register\n\n    for (var prop in libs.sbgnviz) {\n      if (prop !== 'register') {\n        chise[prop] = libs.sbgnviz[prop];\n      }\n    } // Set the libraries to access them from any file\n\n\n    var libUtilities = __webpack_require__(/*! ./utilities/lib-utilities */ \"./src/utilities/lib-utilities.js\");\n\n    libUtilities.setLibs(libs);\n  };\n\n  if ( true && module.exports) {\n    module.exports = chise;\n  }\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jaGlzZS8uL3NyYy9pbmRleC5qcz9iNjM1Il0sIm5hbWVzIjpbImNoaXNlIiwiX29wdGlvbnMiLCJwYXJhbSIsImxpYnMiLCJyZXF1aXJlIiwib3B0aW9uVXRpbGl0aWVzIiwib3B0aW9ucyIsImV4dGVuZE9wdGlvbnMiLCJzYmdudml6SW5zdGFuY2VVdGlsaXRpZXMiLCJzYmdudml6SW5zdGFuY2UiLCJyZWdpc3RlclVuZG9SZWRvQWN0aW9ucyIsIm1haW5VdGlsaXRpZXMiLCJlbGVtZW50VXRpbGl0aWVzRXh0ZW5kZXIiLCJ1bmRvUmVkb0FjdGlvbkZ1bmN0aW9uc0V4dGVuZGVyIiwic2lmVG9wb2xvZ3lHcm91cGluZyIsImVsZW1lbnRVdGlsaXRpZXMiLCJ1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucyIsInNob3VsZEFwcGx5IiwibWFwVHlwZSIsIm1ldGFFZGdlSWRlbnRpZmllciIsImxvY2tHcmFwaFRvcG9sb2d5IiwiYXBpIiwicHJvcCIsImdldFNiZ252aXpJbnN0YW5jZSIsImdldEluc3RhbmNlIiwicmVnaXN0ZXIiLCJfbGlicyIsImpRdWVyeSIsImN5dG9zY2FwZSIsInNiZ252aXoiLCJzYXZlQXMiLCJmaWxlc2F2ZXIiLCJsaWJVdGlsaXRpZXMiLCJzZXRMaWJzIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6IkFBQUEsQ0FBQyxZQUFVO0FBQ1QsTUFBSUEsS0FBSyxHQUFHLFNBQVJBLEtBQVEsQ0FBU0MsUUFBVCxFQUFtQjtBQUU3QixRQUFJQyxLQUFLLEdBQUcsRUFBWixDQUY2QixDQUk3Qjs7QUFDQSxRQUFJQyxJQUFJLEdBQUdDLGdHQUFBLEVBQVg7O0FBRUEsUUFBSUMsZUFBZSxHQUFHRCxtQkFBTyxDQUFDLHlGQUFELENBQVAsRUFBdEI7O0FBQ0EsUUFBSUUsT0FBTyxHQUFHRCxlQUFlLENBQUNFLGFBQWhCLENBQThCTixRQUE5QixDQUFkLENBUjZCLENBUTBCO0FBRXZEOztBQUNBLFFBQUlPLHdCQUF3QixH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QWxDLEdBQTJDQSxNQUF6RDtBQUVBM0IsUUFBSSxDQUFDMEIsT0FBTCxDQUFhSixRQUFiLENBQXNCQyxLQUF0QixFQVJnQyxDQVFGO0FBRTlCOztBQUNBLFNBQUssSUFBSUosSUFBVCxJQUFpQm5CLElBQUksQ0FBQzBCLE9BQXRCLEVBQStCO0FBQzdCLFVBQUlQLElBQUksS0FBSyxVQUFiLEVBQXlCO0FBQ3ZCdEIsYUFBSyxDQUFDc0IsSUFBRCxDQUFMLEdBQWNuQixJQUFJLENBQUMwQixPQUFMLENBQWFQLElBQWIsQ0FBZDtBQUNEO0FBQ0YsS0FmK0IsQ0FpQmhDOzs7QUFDQSxRQUFJVSxZQUFZLEdBQUc1QixtQkFBTyxDQUFDLG1FQUFELENBQTFCOztBQUNBNEIsZ0JBQVksQ0FBQ0MsT0FBYixDQUFxQjlCLElBQXJCO0FBQ0QsR0FwQkQ7O0FBc0JBLE1BQUssU0FBaUMrQixNQUFNLENBQUNDLE9BQTdDLEVBQXVEO0FBQ3JERCxVQUFNLENBQUNDLE9BQVAsR0FBaUJuQyxLQUFqQjtBQUNEO0FBQ0YsQ0E3RkQiLCJmaWxlIjoiLi9zcmMvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtcbiAgdmFyIGNoaXNlID0gZnVuY3Rpb24oX29wdGlvbnMpIHtcblxuICAgIHZhciBwYXJhbSA9IHt9O1xuXG4gICAgLy8gQWNjZXNzIHRoZSBsaWJzXG4gICAgdmFyIGxpYnMgPSByZXF1aXJlKCcuL3V0aWxpdGllcy9saWItdXRpbGl0aWVzJykuZ2V0TGlicygpO1xuXG4gICAgdmFyIG9wdGlvblV0aWxpdGllcyA9IHJlcXVpcmUoJy4vdXRpbGl0aWVzL29wdGlvbi11dGlsaXRpZXMtZmFjdG9yeScpKCk7XG4gICAgdmFyIG9wdGlvbnMgPSBvcHRpb25VdGlsaXRpZXMuZXh0ZW5kT3B0aW9ucyhfb3B0aW9ucyk7IC8vIEV4dGVuZHMgdGhlIGRlZmF1bHQgb3B0aW9ucyB3aXRoIHRoZSBnaXZlbiBvcHRpb25zXG5cbiAgICAvLyBDcmVhdGUgYW4gc2JnbnZpeiBpbnN0YW5jZVxuICAgIHZhciBzYmdudml6SW5zdGFuY2VVdGlsaXRpZXMgPSByZXF1aXJlKCcuL3V0aWxpdGllcy9zYmdudml6LWluc3RhbmNlLXV0aWxpdGllcy1mYWN0b3J5JykoKTtcbiAgICB2YXIgc2JnbnZpekluc3RhbmNlID0gc2JnbnZpekluc3RhbmNlVXRpbGl0aWVzKG9wdGlvbnMpO1xuXG4gICAgLy8gUmVnaXN0ZXIgdW5kby9yZWRvIGFjdGlvbnNcbiAgICB2YXIgcmVnaXN0ZXJVbmRvUmVkb0FjdGlvbnMgPSByZXF1aXJlKCcuL3V0aWxpdGllcy9yZWdpc3Rlci11bmRvLXJlZG8tYWN0aW9ucy1mYWN0b3J5JykoKTtcblxuICAgIHZhciBtYWluVXRpbGl0aWVzID0gcmVxdWlyZSgnLi91dGlsaXRpZXMvbWFpbi11dGlsaXRpZXMtZmFjdG9yeScpKCk7XG4gICAgdmFyIGVsZW1lbnRVdGlsaXRpZXNFeHRlbmRlciA9IHJlcXVpcmUoJy4vdXRpbGl0aWVzL2VsZW1lbnQtdXRpbGl0aWVzLWV4dGVuZGVyLWZhY3RvcnknKSgpO1xuICAgIHZhciB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9uc0V4dGVuZGVyID0gcmVxdWlyZSgnLi91dGlsaXRpZXMvdXItYWN0aW9uLWZ1bmN0aW9ucy1leHRlbmRlci1mYWN0b3J5JykoKTtcbiAgICB2YXIgc2lmVG9wb2xvZ3lHcm91cGluZyA9IHJlcXVpcmUoJy4vdXRpbGl0aWVzL3RvcG9sb2d5LWdyb3VwaW5nLWZhY3RvcnknKSgpO1xuXG4gICAgdmFyIGVsZW1lbnRVdGlsaXRpZXMgPSAgc2JnbnZpekluc3RhbmNlLmVsZW1lbnRVdGlsaXRpZXM7XG4gICAgdmFyIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zID0gc2JnbnZpekluc3RhbmNlLnVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zO1xuXG4gICAgcGFyYW0uc2JnbnZpekluc3RhbmNlVXRpbGl0aWVzID0gc2JnbnZpekluc3RhbmNlVXRpbGl0aWVzO1xuICAgIHBhcmFtLm9wdGlvblV0aWxpdGllcyA9IG9wdGlvblV0aWxpdGllcztcbiAgICBwYXJhbS5lbGVtZW50VXRpbGl0aWVzID0gZWxlbWVudFV0aWxpdGllcztcbiAgICBwYXJhbS51bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucyA9IHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zO1xuICAgIHBhcmFtLnNpZlRvcG9sb2d5R3JvdXBpbmcgPSBzaWZUb3BvbG9neUdyb3VwaW5nO1xuXG4gICAgdmFyIHNob3VsZEFwcGx5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcGFyYW0uZWxlbWVudFV0aWxpdGllcy5tYXBUeXBlID09PSAnU0lGJztcbiAgICB9O1xuXG4gICAgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnNFeHRlbmRlcihwYXJhbSk7XG4gICAgZWxlbWVudFV0aWxpdGllc0V4dGVuZGVyKHBhcmFtKTtcbiAgICByZWdpc3RlclVuZG9SZWRvQWN0aW9ucyhwYXJhbSk7XG4gICAgbWFpblV0aWxpdGllcyhwYXJhbSk7XG4gICAgc2lmVG9wb2xvZ3lHcm91cGluZyhwYXJhbSwge21ldGFFZGdlSWRlbnRpZmllcjogJ3NpZi1tZXRhJywgbG9ja0dyYXBoVG9wb2xvZ3k6IHRydWUsIHNob3VsZEFwcGx5fSk7XG5cbiAgICAvLyBFeHBvc2UgdGhlIGFwaVxuICAgIHZhciBhcGkgPSB7fTtcblxuICAgIC8vIEV4cG9zZSB0aGUgcHJvcGVydGllcyBpbmhlcml0ZWQgZnJvbSBzYmdudml6XG4gICAgLy8gdGhlbiBvdmVycmlkZSBzb21lIG9mIHRoZXNlIHByb3BlcnRpZXMgYW5kIGV4cG9zZSBzb21lIG5ldyBwcm9wZXJ0aWVzXG4gICAgZm9yICh2YXIgcHJvcCBpbiBzYmdudml6SW5zdGFuY2UpIHtcbiAgICAgIGFwaVtwcm9wXSA9IHNiZ252aXpJbnN0YW5jZVtwcm9wXTtcbiAgICB9XG5cbiAgICAvLyBFeHBvc2UgZWFjaCBtYWluIHV0aWxpdHkgc2VwZXJhdGVseVxuICAgIGZvciAodmFyIHByb3AgaW4gbWFpblV0aWxpdGllcykge1xuICAgICAgYXBpW3Byb3BdID0gbWFpblV0aWxpdGllc1twcm9wXTtcbiAgICB9XG5cbiAgICAvLyBFeHBvc2UgZ2V0U2JnbnZpekluc3RhbmNlKClcbiAgICBhcGkuZ2V0U2JnbnZpekluc3RhbmNlID0gc2JnbnZpekluc3RhbmNlVXRpbGl0aWVzLmdldEluc3RhbmNlO1xuXG4gICAgLy8gRXhwb3NlIGVsZW1lbnRVdGlsaXRpZXMgYW5kIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zIGFzIGlzXG4gICAgYXBpLmVsZW1lbnRVdGlsaXRpZXMgPSBlbGVtZW50VXRpbGl0aWVzO1xuICAgIGFwaS51bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucyA9IHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zO1xuICAgIGFwaS5zaWZUb3BvbG9neUdyb3VwaW5nID0gc2lmVG9wb2xvZ3lHcm91cGluZztcblxuICAgIHJldHVybiBhcGk7XG4gIH07XG5cbiAgLy8gUmVnaXN0ZXIgY2hpc2Ugd2l0aCBnaXZlbiBsaWJyYXJpZXNcbiAgY2hpc2UucmVnaXN0ZXIgPSBmdW5jdGlvbiAoX2xpYnMpIHtcblxuICAgIHZhciBsaWJzID0ge307XG4gICAgbGlicy5qUXVlcnkgPSBfbGlicy5qUXVlcnkgfHwgalF1ZXJ5O1xuICAgIGxpYnMuY3l0b3NjYXBlID0gX2xpYnMuY3l0b3NjYXBlIHx8IGN5dG9zY2FwZTtcbiAgICBsaWJzLnNiZ252aXogPSBfbGlicy5zYmdudml6IHx8IHNiZ252aXo7XG4gICAgbGlicy5zYXZlQXMgPSBfbGlicy5maWxlc2F2ZXIgPyBfbGlicy5maWxlc2F2ZXIuc2F2ZUFzIDogc2F2ZUFzO1xuXG4gICAgbGlicy5zYmdudml6LnJlZ2lzdGVyKF9saWJzKTsgLy8gUmVnaXN0ZXIgc2JnbnZpeiB3aXRoIHRoZSBnaXZlbiBsaWJzXG5cbiAgICAvLyBpbmhlcml0IGV4cG9zZWQgc3RhdGljIHByb3BlcnRpZXMgb2Ygc2JnbnZpeiBvdGhlciB0aGFuIHJlZ2lzdGVyXG4gICAgZm9yICh2YXIgcHJvcCBpbiBsaWJzLnNiZ252aXopIHtcbiAgICAgIGlmIChwcm9wICE9PSAncmVnaXN0ZXInKSB7XG4gICAgICAgIGNoaXNlW3Byb3BdID0gbGlicy5zYmdudml6W3Byb3BdO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNldCB0aGUgbGlicmFyaWVzIHRvIGFjY2VzcyB0aGVtIGZyb20gYW55IGZpbGVcbiAgICB2YXIgbGliVXRpbGl0aWVzID0gcmVxdWlyZSgnLi91dGlsaXRpZXMvbGliLXV0aWxpdGllcycpO1xuICAgIGxpYlV0aWxpdGllcy5zZXRMaWJzKGxpYnMpO1xuICB9O1xuXG4gIGlmICggdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMgKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBjaGlzZTtcbiAgfVxufSkoKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/index.js\n");

/***/ }),

/***/ "./src/utilities/element-utilities-extender-factory.js":
/*!*************************************************************!*\
  !*** ./src/utilities/element-utilities-extender-factory.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n// Extends sbgnviz.elementUtilities\nvar libs = __webpack_require__(/*! ./lib-utilities */ \"./src/utilities/lib-utilities.js\").getLibs();\n\nvar jQuery = $ = libs.jQuery;\n\nmodule.exports = function () {\n  var options, sbgnvizInstance, elementUtilities, cy;\n\n  function elementUtilitiesExtender(param) {\n    sbgnvizInstance = param.sbgnvizInstanceUtilities.getInstance();\n    options = param.optionUtilities.getOptions();\n    elementUtilities = sbgnvizInstance.elementUtilities;\n    cy = param.sbgnvizInstanceUtilities.getCy();\n    extend(); // Return the extended elementUtilities\n\n    return elementUtilities;\n  } // Extends elementUtilities with chise specific facilities\n\n\n  function extend() {\n    // Section Start\n    // Add remove utilities\n    elementUtilities.addNode = function (x, y, nodeParams, id, parent, visibility) {\n      if (_typeof(nodeParams) != 'object') {\n        var sbgnclass = nodeParams;\n      } else {\n        var sbgnclass = nodeParams[\"class\"];\n        var language = nodeParams.language;\n      }\n\n      var css = {}; // if there is no specific default width or height for\n      // sbgnclass these sizes are used\n\n      var defaultWidth = 50;\n      var defaultHeight = 50;\n\n      if (visibility) {\n        css.visibility = visibility;\n      }\n\n      var data = {\n        \"class\": sbgnclass,\n        language: language,\n        bbox: {\n          w: defaultWidth,\n          h: defaultHeight,\n          x: x,\n          y: y\n        },\n        statesandinfos: [],\n        ports: []\n      };\n\n      if (id) {\n        data.id = id;\n      } else {\n        data.id = elementUtilities.generateNodeId();\n      }\n\n      if (parent) {\n        data.parent = parent;\n      }\n\n      this.extendNodeDataWithClassDefaults(data, sbgnclass); // some defaults are not set by extendNodeDataWithClassDefaults()\n\n      var defaults = this.getDefaultProperties(sbgnclass);\n\n      if (defaults['multimer']) {\n        data[\"class\"] += ' multimer';\n      }\n\n      if (defaults['clonemarker']) {\n        data['clonemarker'] = true;\n      }\n\n      data.bbox['w'] = defaults['width'];\n      data.bbox['h'] = defaults['height'];\n      var eles = cy.add({\n        group: \"nodes\",\n        data: data,\n        css: css,\n        position: {\n          x: x,\n          y: y\n        }\n      });\n      var newNode = eles[eles.length - 1]; // Get the default ports ordering for the nodes with given sbgnclass\n\n      var ordering = defaults['ports-ordering']; // If there is a default ports ordering for the nodes with given sbgnclass and it is different than 'none' set the ports ordering to that ordering\n\n      if (ordering && ordering !== 'none') {\n        this.setPortsOrdering(newNode, ordering);\n      }\n\n      if (language == \"AF\" && !elementUtilities.canHaveMultipleUnitOfInformation(newNode)) {\n        if (sbgnclass != \"BA plain\") {\n          // if AF node can have label i.e: not plain biological activity\n          var uoi_obj = {\n            clazz: \"unit of information\"\n          };\n          uoi_obj.label = {\n            text: \"\"\n          };\n          uoi_obj.bbox = {\n            w: 12,\n            h: 12\n          };\n          elementUtilities.addStateOrInfoBox(newNode, uoi_obj);\n        }\n      } // node bg image was unexpectedly not rendered until it is clicked\n      // use this dirty hack until finding a solution to the problem\n\n\n      var bgImage = newNode.data('background-image');\n\n      if (bgImage) {\n        newNode.data('background-image', bgImage);\n      }\n\n      return newNode;\n    }; //Saves old aux units of given node\n\n\n    elementUtilities.saveUnits = function (node) {\n      var tempData = [];\n      var index = 0;\n      node.data('statesandinfos').forEach(function (ele) {\n        tempData.push({\n          x: ele.bbox.x,\n          y: ele.bbox.y,\n          anchorSide: ele.anchorSide\n        });\n        index++;\n      });\n      return tempData;\n    }; //Restores from given data\n\n\n    elementUtilities.restoreUnits = function (node, data) {\n      var index = 0;\n      node.data('statesandinfos').forEach(function (ele) {\n        if (data !== undefined) {\n          ele.bbox.x = data[index].x;\n          ele.bbox.y = data[index].y;\n          var anchorSide = ele.anchorSide;\n          ele.anchorSide = data[index].anchorSide;\n          elementUtilities.modifyUnits(node, ele, anchorSide);\n          index++;\n        }\n      });\n    }; //Modify aux unit layouts\n\n\n    elementUtilities.modifyUnits = function (node, ele, anchorSide) {\n      instance.classes.AuxUnitLayout.modifyUnits(node, ele, anchorSide, cy);\n    }; //For reversible reactions both side of the process can be input/output\n    //Group ID identifies to which group of nodes the edge is going to be connected for reversible reactions(0: group 1 ID and 1:group 2 ID)\n\n\n    elementUtilities.addEdge = function (source, target, edgeParams, id, visibility, groupID) {\n      if (_typeof(edgeParams) != 'object') {\n        var sbgnclass = edgeParams;\n      } else {\n        var sbgnclass = edgeParams[\"class\"];\n        var language = edgeParams.language;\n      }\n\n      var css = {};\n\n      if (visibility) {\n        css.visibility = visibility;\n      }\n\n      var data = {\n        source: source,\n        target: target,\n        \"class\": sbgnclass,\n        language: language\n      };\n      var defaults = elementUtilities.getDefaultProperties(sbgnclass); // extend the data with default properties of edge style\n\n      Object.keys(defaults).forEach(function (prop) {\n        data[prop] = defaults[prop];\n      });\n\n      if (id) {\n        data.id = id;\n      } else {\n        data.id = elementUtilities.generateEdgeId();\n      }\n\n      if (elementUtilities.canHaveSBGNCardinality(sbgnclass)) {\n        data.cardinality = 0;\n      }\n\n      var sourceNode = cy.getElementById(source); // The original source node\n\n      var targetNode = cy.getElementById(target); // The original target node\n\n      var sourceHasPorts = sourceNode.data('ports').length === 2;\n      var targetHasPorts = targetNode.data('ports').length === 2; // The portsource and porttarget variables\n\n      var portsource;\n      var porttarget;\n      /*\n       * Get input/output port id's of a node with the assumption that the node has valid ports.\n       */\n\n      var getIOPortIds = function getIOPortIds(node) {\n        var nodeInputPortId, nodeOutputPortId;\n        var nodePortsOrdering = sbgnvizInstance.elementUtilities.getPortsOrdering(node);\n        var nodePorts = node.data('ports');\n\n        if (nodePortsOrdering === 'L-to-R' || nodePortsOrdering === 'R-to-L') {\n          var leftPortId = nodePorts[0].x < 0 ? nodePorts[0].id : nodePorts[1].id; // The x value of left port is supposed to be negative\n\n          var rightPortId = nodePorts[0].x > 0 ? nodePorts[0].id : nodePorts[1].id; // The x value of right port is supposed to be positive\n\n          /*\n           * If the port ordering is left to right then the input port is the left port and the output port is the right port.\n           * Else if it is right to left it is vice versa\n           */\n\n          nodeInputPortId = nodePortsOrdering === 'L-to-R' ? leftPortId : rightPortId;\n          nodeOutputPortId = nodePortsOrdering === 'R-to-L' ? leftPortId : rightPortId;\n        } else if (nodePortsOrdering === 'T-to-B' || nodePortsOrdering === 'B-to-T') {\n          var topPortId = nodePorts[0].y < 0 ? nodePorts[0].id : nodePorts[1].id; // The y value of top port is supposed to be negative\n\n          var bottomPortId = nodePorts[0].y > 0 ? nodePorts[0].id : nodePorts[1].id; // The y value of bottom port is supposed to be positive\n\n          /*\n           * If the port ordering is top to bottom then the input port is the top port and the output port is the bottom port.\n           * Else if it is right to left it is vice versa\n           */\n\n          nodeInputPortId = nodePortsOrdering === 'T-to-B' ? topPortId : bottomPortId;\n          nodeOutputPortId = nodePortsOrdering === 'B-to-T' ? topPortId : bottomPortId;\n        } // Return an object containing the IO ports of the node\n\n\n        return {\n          inputPortId: nodeInputPortId,\n          outputPortId: nodeOutputPortId\n        };\n      }; // If at least one end of the edge has ports then we should determine the ports where the edge should be connected.\n\n\n      if (sourceHasPorts || targetHasPorts) {\n        var sourceNodeInputPortId, sourceNodeOutputPortId, targetNodeInputPortId, targetNodeOutputPortId; // If source node has ports set the variables dedicated for its IO ports\n\n        if (sourceHasPorts) {\n          var ioPorts = getIOPortIds(sourceNode);\n          sourceNodeInputPortId = ioPorts.inputPortId;\n          sourceNodeOutputPortId = ioPorts.outputPortId;\n        } // If target node has ports set the variables dedicated for its IO ports\n\n\n        if (targetHasPorts) {\n          var ioPorts = getIOPortIds(targetNode);\n          targetNodeInputPortId = ioPorts.inputPortId;\n          targetNodeOutputPortId = ioPorts.outputPortId;\n        }\n\n        if (sbgnclass === 'consumption') {\n          // A consumption edge should be connected to the input port of the target node which is supposed to be a process (any kind of)\n          portsource = sourceNodeOutputPortId;\n          porttarget = targetNodeInputPortId;\n        } else if (sbgnclass === 'production') {\n          // A production edge should be connected to the output port of the source node which is supposed to be a process (any kind of)\n          // A modulation edge may have a logical operator as source node in this case the edge should be connected to the output port of it\n          // The below assignment satisfy all of these condition\n          if (groupID == 0 || groupID == undefined) {\n            // groupID 0 for reversible reactions group 0\n            portsource = sourceNodeOutputPortId;\n            porttarget = targetNodeInputPortId;\n          } else {\n            //if reaction is reversible and edge belongs to group 1\n            portsource = sourceNodeInputPortId;\n          }\n        } else if (elementUtilities.isModulationArcClass(sbgnclass) || elementUtilities.isAFArcClass(sbgnclass)) {\n          portsource = sourceNodeOutputPortId;\n        } else if (sbgnclass === 'logic arc') {\n          var srcClass = sourceNode.data('class');\n          var tgtClass = targetNode.data('class');\n          var isSourceLogicalOp = srcClass === 'and' || srcClass === 'or' || srcClass === 'not';\n          var isTargetLogicalOp = tgtClass === 'and' || tgtClass === 'or' || tgtClass === 'not';\n\n          if (isSourceLogicalOp && isTargetLogicalOp) {\n            // If both end are logical operators then the edge should be connected to the input port of the target and the output port of the input\n            porttarget = targetNodeInputPortId;\n            portsource = sourceNodeOutputPortId;\n          } // If just one end of logical operator then the edge should be connected to the input port of the logical operator\n          else if (isSourceLogicalOp) {\n              portsource = sourceNodeInputPortId;\n              porttarget = targetNodeOutputPortId;\n            } else if (isTargetLogicalOp) {\n              portsource = sourceNodeOutputPortId;\n              porttarget = targetNodeInputPortId;\n            }\n        }\n      } // The default portsource/porttarget are the source/target themselves. If they are not set use these defaults.\n      // The portsource and porttarget are determined set them in data object.\n\n\n      data.portsource = portsource || source;\n      data.porttarget = porttarget || target;\n      var eles = cy.add({\n        group: \"edges\",\n        data: data,\n        css: css\n      });\n      var newEdge = eles[eles.length - 1];\n      return newEdge;\n    };\n\n    elementUtilities.addProcessWithConvenientEdges = function (_source, _target, nodeParams) {\n      // If source and target IDs are given get the elements by IDs\n      var source = typeof _source === 'string' ? cy.getElementById(_source) : _source;\n      var target = typeof _target === 'string' ? cy.getElementById(_target) : _target; // Process parent should be the closest common ancestor of the source and target nodes\n\n      var processParent = cy.collection([source[0], target[0]]).commonAncestors().first(); // Process should be at the middle of the source and target nodes\n\n      var x = (source.position('x') + target.position('x')) / 2;\n      var y = (source.position('y') + target.position('y')) / 2; // Create the process with given/calculated variables\n\n      var process = elementUtilities.addNode(x, y, nodeParams, undefined, processParent.id());\n      var xdiff = source.position('x') - target.position('x');\n      var ydiff = source.position('y') - target.position('y');\n\n      if (Math.abs(xdiff) >= Math.abs(ydiff)) {\n        if (xdiff < 0) elementUtilities.setPortsOrdering(process, 'L-to-R');else elementUtilities.setPortsOrdering(process, 'R-to-L');\n      } else {\n        if (ydiff < 0) elementUtilities.setPortsOrdering(process, 'T-to-B');else elementUtilities.setPortsOrdering(process, 'B-to-T');\n      } // Create the edges one is between the process and the source node (which should be a consumption),\n      // the other one is between the process and the target node (which should be a production).\n      // For more information please refer to SBGN-PD reference card.\n\n\n      var edgeBtwSrc = elementUtilities.addEdge(source.id(), process.id(), {\n        \"class\": 'consumption',\n        language: nodeParams.language\n      });\n      var edgeBtwTgt = elementUtilities.addEdge(process.id(), target.id(), {\n        \"class\": 'production',\n        language: nodeParams.language\n      }); // Create a collection including the elements and to be returned\n\n      var collection = cy.collection([process[0], edgeBtwSrc[0], edgeBtwTgt[0]]);\n      return collection;\n    };\n    /*\n     * This method assumes that param.nodesToMakeCompound contains at least one node\n     * and all of the nodes including in it have the same parent. It creates a compound fot the given nodes an having the given type.\n     */\n\n\n    elementUtilities.createCompoundForGivenNodes = function (nodesToMakeCompound, compoundType) {\n      var oldParentId = nodesToMakeCompound[0].data(\"parent\");\n      var language = nodesToMakeCompound[0].data(\"language\"); // if nodesToMakeCompound contain both PD and AF nodes, then set language of compound as Unknown\n\n      for (var i = 1; i < nodesToMakeCompound.length; i++) {\n        if (nodesToMakeCompound[i] != language) {\n          language = \"Unknown\";\n          break;\n        }\n      } // The parent of new compound will be the old parent of the nodes to make compound. x, y and id parameters are not set.\n\n\n      var newCompound = elementUtilities.addNode(undefined, undefined, {\n        \"class\": compoundType,\n        language: language\n      }, undefined, oldParentId);\n      var newCompoundId = newCompound.id();\n      var newEles = elementUtilities.changeParent(nodesToMakeCompound, newCompoundId);\n      newEles = newEles.union(newCompound);\n      return newEles;\n    };\n\n    elementUtilities.createTranslationReaction = function (mRnaName, proteinName, processPosition, edgeLength) {\n      var defaultProcessProperties = elementUtilities.getDefaultProperties(\"translation\");\n      var defaultSourceAndSinkProperties = elementUtilities.getDefaultProperties(\"empty set\");\n      var defaultNucleicAcidFeatureProperties = elementUtilities.getDefaultProperties(\"nucleic acid feature\");\n      var defaultMacromoleculeProperties = elementUtilities.getDefaultProperties(\"macromolecule\");\n      var macromoleculeWidth = defaultMacromoleculeProperties.width || 50;\n      var sourceAndSinkWidth = defaultSourceAndSinkProperties.width || 50;\n      var nucleicAcidFeatureHeight = defaultNucleicAcidFeatureProperties.height || 50;\n      var processWidth = defaultProcessProperties.width || 50;\n      var processHeight = defaultProcessProperties.height || 50;\n      var processPosition = processPosition || elementUtilities.convertToModelPosition({\n        x: cy.width() / 2,\n        y: cy.height() / 2\n      });\n      var edgeLength = edgeLength || 60;\n      cy.startBatch();\n\n      if (!elementUtilities.getMapType()) {\n        elementUtilities.setMapType(\"PD\");\n      }\n\n      var processNode = elementUtilities.addNode(processPosition.x, processPosition.y, {\n        \"class\": \"process\",\n        language: \"PD\"\n      });\n      elementUtilities.setPortsOrdering(processNode, \"L-to-R\");\n      processNode.data('justAdded', true);\n      var xPosOfSourceAndSinkNode = processPosition.x - edgeLength - processWidth / 2 - sourceAndSinkWidth / 2;\n      var yPosOfSourceAndSinkNode = processPosition.y;\n      var sourceAndSinkNode = elementUtilities.addNode(xPosOfSourceAndSinkNode, yPosOfSourceAndSinkNode, {\n        \"class\": 'empty set',\n        language: 'PD'\n      });\n      sourceAndSinkNode.data('justAdded', true);\n      var consumptionEdge = elementUtilities.addEdge(sourceAndSinkNode.id(), processNode.id(), {\n        \"class\": 'consumption',\n        language: 'PD'\n      });\n      consumptionEdge.data('justAdded', true);\n      var xPosOfmRnaNode = processPosition.x;\n      var yPosOfmRnaNode = processPosition.y - edgeLength - processHeight / 2 - nucleicAcidFeatureHeight / 2;\n      var mRnaNode = elementUtilities.addNode(xPosOfmRnaNode, yPosOfmRnaNode, {\n        \"class\": 'nucleic acid feature',\n        language: 'PD'\n      });\n      mRnaNode.data('justAdded', true);\n      mRnaNode.data('label', mRnaName);\n      var infoboxObjectOfGene = {\n        clazz: \"unit of information\",\n        label: {\n          text: 'ct:mRNA'\n        },\n        bbox: {\n          w: 45,\n          h: 15\n        }\n      };\n      elementUtilities.addStateOrInfoBox(mRnaNode, infoboxObjectOfGene);\n      var necessaryStimulationEdge = elementUtilities.addEdge(mRnaNode.id(), processNode.id(), {\n        \"class\": 'necessary stimulation',\n        language: 'PD'\n      });\n      necessaryStimulationEdge.data('justAdded', true);\n      var xPosOfProteinNode = processPosition.x + edgeLength + processWidth / 2 + macromoleculeWidth / 2;\n      var yPostOfProteinNode = processPosition.y;\n      var proteinNode = elementUtilities.addNode(xPosOfProteinNode, yPostOfProteinNode, {\n        \"class\": 'macromolecule',\n        language: 'PD'\n      });\n      proteinNode.data('justAdded', true);\n      proteinNode.data('label', proteinName);\n      var productionEdge = elementUtilities.addEdge(processNode.id(), proteinNode.id(), {\n        \"class\": 'production',\n        language: 'PD'\n      });\n      productionEdge.data('justAdded', true);\n      cy.endBatch(); //filter the just added elememts to return them and remove just added mark\n\n      var eles = cy.elements('[justAdded]');\n      eles.removeData('justAdded');\n      cy.elements().unselect();\n      eles.select();\n      return eles; // Return the just added elements\n    };\n\n    elementUtilities.createTranscriptionReaction = function (geneName, mRnaName, processPosition, edgeLength) {\n      var defaultProcessProperties = elementUtilities.getDefaultProperties(\"transcription\");\n      var defaultSourceAndSinkProperties = elementUtilities.getDefaultProperties(\"empty set\");\n      var defaultNucleicAcidFeatureProperties = elementUtilities.getDefaultProperties(\"nucleic acid feature\");\n      var sourceAndSinkWidth = defaultSourceAndSinkProperties.width || 50;\n      var nucleicAcidFeatureHeight = defaultNucleicAcidFeatureProperties.height || 50;\n      var nucleicAcidFeatureWidth = defaultNucleicAcidFeatureProperties.width || 50;\n      var processWidth = defaultProcessProperties.width || 50;\n      var processHeight = defaultProcessProperties.height || 50;\n      var processPosition = processPosition || elementUtilities.convertToModelPosition({\n        x: cy.width() / 2,\n        y: cy.height() / 2\n      });\n      var edgeLength = edgeLength || 60;\n      cy.startBatch();\n\n      if (!elementUtilities.getMapType()) {\n        elementUtilities.setMapType(\"PD\");\n      }\n\n      var processNode = elementUtilities.addNode(processPosition.x, processPosition.y, {\n        \"class\": \"process\",\n        language: \"PD\"\n      });\n      elementUtilities.setPortsOrdering(processNode, \"L-to-R\");\n      processNode.data('justAdded', true);\n      var xPosOfSourceAndSinkNode = processPosition.x - edgeLength - processWidth / 2 - sourceAndSinkWidth / 2;\n      var yPosOfSourceAndSinkNode = processPosition.y;\n      var sourceAndSinkNode = elementUtilities.addNode(xPosOfSourceAndSinkNode, yPosOfSourceAndSinkNode, {\n        \"class\": 'empty set',\n        language: 'PD'\n      });\n      sourceAndSinkNode.data('justAdded', true);\n      var consumptionEdge = elementUtilities.addEdge(sourceAndSinkNode.id(), processNode.id(), {\n        \"class\": 'consumption',\n        language: 'PD'\n      });\n      consumptionEdge.data('justAdded', true);\n      var xPosOfGeneNode = processPosition.x;\n      var yPosOfGeneNode = processPosition.y - edgeLength - processHeight / 2 - nucleicAcidFeatureHeight / 2;\n      var geneNode = elementUtilities.addNode(xPosOfGeneNode, yPosOfGeneNode, {\n        \"class\": 'nucleic acid feature',\n        language: 'PD'\n      });\n      geneNode.data('justAdded', true);\n      geneNode.data('label', geneName);\n      var infoboxObjectOfGene = {\n        clazz: \"unit of information\",\n        label: {\n          text: 'ct:gene'\n        },\n        bbox: {\n          w: 36,\n          h: 15\n        }\n      };\n      elementUtilities.addStateOrInfoBox(geneNode, infoboxObjectOfGene);\n      var necessaryStimulationEdge = elementUtilities.addEdge(geneNode.id(), processNode.id(), {\n        \"class\": 'necessary stimulation',\n        language: 'PD'\n      });\n      necessaryStimulationEdge.data('justAdded', true);\n      var xPosOfmRnaNode = processPosition.x + edgeLength + processWidth / 2 + nucleicAcidFeatureWidth / 2;\n      var yPostOfmRnaNode = processPosition.y;\n      var mRnaNode = elementUtilities.addNode(xPosOfmRnaNode, yPostOfmRnaNode, {\n        \"class\": 'nucleic acid feature',\n        language: 'PD'\n      });\n      mRnaNode.data('justAdded', true);\n      mRnaNode.data('label', mRnaName);\n      var infoboxObjectOfmRna = {\n        clazz: \"unit of information\",\n        label: {\n          text: 'ct:mRNA'\n        },\n        bbox: {\n          w: 45,\n          h: 15\n        }\n      };\n      elementUtilities.addStateOrInfoBox(mRnaNode, infoboxObjectOfmRna);\n      var productionEdge = elementUtilities.addEdge(processNode.id(), mRnaNode.id(), {\n        \"class\": 'production',\n        language: 'PD'\n      });\n      productionEdge.data('justAdded', true);\n      cy.endBatch(); //filter the just added elememts to return them and remove just added mark\n\n      var eles = cy.elements('[justAdded]');\n      eles.removeData('justAdded');\n      cy.elements().unselect();\n      eles.select();\n      return eles; // Return the just added elements\n    };\n\n    elementUtilities.rotate90 = function (point, center) {\n      var relativeX = center.x - point.x;\n      var relativeY = center.y - point.y;\n      var relativeRotatedX = relativeY;\n      var relativeRotatedY = -1 * relativeX;\n      var resultX = relativeRotatedX + center.x;\n      var resultY = relativeRotatedY + center.y;\n      return {\n        x: resultX,\n        y: resultY\n      };\n    };\n\n    elementUtilities.createTranslation = function (regulatorLabel, outputLabel, orientation) {\n      var defaultSourceAndSinkProperties = elementUtilities.getDefaultProperties(\"empty set\");\n      var defaultNucleicAcidFeatureProperties = elementUtilities.getDefaultProperties(\"nucleic acid feature\");\n      var defaultMacromoleculePropeties = elementUtilities.getDefaultProperties(\"macromolecule\");\n      var defaultProcessProperties = elementUtilities.getDefaultProperties(\"process\");\n      var sourceAndSinkWidth = defaultSourceAndSinkProperties.width || 50;\n      var nucleicAcidFeatureWidth = defaultNucleicAcidFeatureProperties.width || 50;\n      var nucleicAcidFeatureHeight = defaultNucleicAcidFeatureProperties.height || 50;\n      var macromoleculeWidth = defaultMacromoleculePropeties.width || 50;\n      var processWidth = defaultProcessProperties.width || 50;\n      var processHeight = defaultProcessProperties.height || 50;\n      var processPosition = elementUtilities.convertToModelPosition({\n        x: cy.width() / 2,\n        y: cy.height() / 2\n      });\n      var edgeLength = 30;\n      var vertical = orientation === \"vertical\";\n      var processPortsOrdering = vertical ? \"T-to-B\" : \"L-to-R\";\n      var minInfoboxDimension = 15;\n      var widthPerChar = 6;\n      var regulatorInfoboxLabel = \"ct:mRNA\";\n      cy.startBatch();\n\n      if (!elementUtilities.getMapType()) {\n        elementUtilities.setMapType(\"PD\");\n      }\n\n      var processNode = elementUtilities.addNode(processPosition.x, processPosition.y, {\n        \"class\": \"process\",\n        language: \"PD\"\n      });\n      elementUtilities.setPortsOrdering(processNode, processPortsOrdering);\n      processNode.data('justAdded', true);\n      var xPosOfInput = processPosition.x - edgeLength - processWidth / 2 - sourceAndSinkWidth / 2;\n      var xPosOfOutput = processPosition.x + edgeLength + processWidth / 2 + macromoleculeWidth / 2;\n      var yPosOfInput = processPosition.y;\n      var yPosOfOutput = processPosition.y;\n      var nodePosition = {\n        x: xPosOfInput,\n        y: yPosOfInput\n      };\n\n      if (vertical) {\n        nodePosition = elementUtilities.rotate90(nodePosition, processPosition);\n      }\n\n      var inputNode = elementUtilities.addNode(nodePosition.x, nodePosition.y, {\n        \"class\": 'empty set',\n        language: 'PD'\n      });\n      inputNode.data(\"justAdded\", true);\n      inputNode.data(\"label\", label);\n      var inputEdge = elementUtilities.addEdge(inputNode.id(), processNode.id(), {\n        \"class\": 'consumption',\n        language: 'PD'\n      });\n      inputEdge.data(\"justAdded\", true);\n      nodePosition = {\n        x: xPosOfOutput,\n        y: yPosOfOutput\n      };\n\n      if (vertical) {\n        nodePosition = elementUtilities.rotate90(nodePosition, processPosition);\n      }\n\n      var outputNode = elementUtilities.addNode(nodePosition.x, nodePosition.y, {\n        \"class\": \"macromolecule\",\n        language: 'PD'\n      });\n      outputNode.data(\"justAdded\", true);\n      outputNode.data(\"label\", outputLabel);\n      var outputEdge = elementUtilities.addEdge(processNode.id(), outputNode.id(), {\n        \"class\": 'production',\n        language: 'PD'\n      });\n      outputEdge.data(\"justAdded\", true);\n      var xPosOfRegulator = processPosition.x;\n      var dimension = vertical ? nucleicAcidFeatureWidth : nucleicAcidFeatureHeight;\n      var yPosOfRegulator = processPosition.y - (processHeight / 2 + dimension / 2 + edgeLength);\n      nodePosition = {\n        x: xPosOfRegulator,\n        y: yPosOfRegulator\n      };\n\n      if (vertical) {\n        nodePosition = elementUtilities.rotate90(nodePosition, processPosition);\n      }\n\n      var regulatorNode = elementUtilities.addNode(nodePosition.x, nodePosition.y, {\n        \"class\": \"nucleic acid feature\",\n        language: 'PD'\n      });\n      regulatorNode.data('justAdded', true);\n      regulatorNode.data('label', regulatorLabel);\n      infoboxObject = {\n        clazz: \"unit of information\",\n        label: {\n          text: regulatorInfoboxLabel\n        },\n        bbox: {\n          w: Math.max(regulatorInfoboxLabel.length * widthPerChar, minInfoboxDimension),\n          h: minInfoboxDimension\n        }\n      };\n      elementUtilities.addStateOrInfoBox(regulatorNode, infoboxObject);\n      var regulatorEdge = elementUtilities.addEdge(regulatorNode.id(), processNode.id(), {\n        \"class\": 'necessary stimulation',\n        language: 'PD'\n      });\n      regulatorEdge.data('justAdded', true);\n      cy.endBatch();\n      var eles = cy.elements('[justAdded]');\n      eles.removeData('justAdded');\n      cy.elements().unselect();\n      eles.select();\n      return eles;\n    };\n\n    elementUtilities.createTranscription = function (label, orientation) {\n      var defaultSourceAndSinkProperties = elementUtilities.getDefaultProperties(\"empty set\");\n      var defaultNucleicAcidFeatureProperties = elementUtilities.getDefaultProperties(\"nucleic acid feature\");\n      var defaultProcessProperties = elementUtilities.getDefaultProperties(\"process\");\n      var sourceAndSinkWidth = defaultSourceAndSinkProperties.width || 50;\n      var nucleicAcidFeatureWidth = defaultNucleicAcidFeatureProperties.width || 50;\n      var nucleicAcidFeatureHeight = defaultNucleicAcidFeatureProperties.height || 50;\n      var processWidth = defaultProcessProperties.width || 50;\n      var processHeight = defaultProcessProperties.height || 50;\n      var processPosition = elementUtilities.convertToModelPosition({\n        x: cy.width() / 2,\n        y: cy.height() / 2\n      });\n      var edgeLength = 30;\n      var vertical = orientation === \"vertical\";\n      var processPortsOrdering = vertical ? \"T-to-B\" : \"L-to-R\";\n      var minInfoboxDimension = 15;\n      var widthPerChar = 6;\n      var outputInfoboxLabel = \"ct:mRNA\";\n      var regulatorInfoboxLabel = \"ct:gene\";\n      cy.startBatch();\n\n      if (!elementUtilities.getMapType()) {\n        elementUtilities.setMapType(\"PD\");\n      }\n\n      var processNode = elementUtilities.addNode(processPosition.x, processPosition.y, {\n        \"class\": \"process\",\n        language: \"PD\"\n      });\n      elementUtilities.setPortsOrdering(processNode, processPortsOrdering);\n      processNode.data('justAdded', true);\n      var xPosOfInput = processPosition.x - edgeLength - processWidth / 2 - sourceAndSinkWidth / 2;\n      var xPosOfOutput = processPosition.x + edgeLength + processWidth / 2 + nucleicAcidFeatureWidth / 2;\n      var yPosOfInput = processPosition.y;\n      var yPosOfOutput = processPosition.y;\n      var nodePosition = {\n        x: xPosOfInput,\n        y: yPosOfInput\n      };\n\n      if (vertical) {\n        nodePosition = elementUtilities.rotate90(nodePosition, processPosition);\n      }\n\n      var inputNode = elementUtilities.addNode(nodePosition.x, nodePosition.y, {\n        \"class\": 'empty set',\n        language: 'PD'\n      });\n      inputNode.data(\"justAdded\", true);\n      var inputEdge = elementUtilities.addEdge(inputNode.id(), processNode.id(), {\n        \"class\": 'consumption',\n        language: 'PD'\n      });\n      inputEdge.data(\"justAdded\", true);\n      nodePosition = {\n        x: xPosOfOutput,\n        y: yPosOfOutput\n      };\n\n      if (vertical) {\n        nodePosition = elementUtilities.rotate90(nodePosition, processPosition);\n      }\n\n      var outputNode = elementUtilities.addNode(nodePosition.x, nodePosition.y, {\n        \"class\": 'nucleic acid feature',\n        language: 'PD'\n      });\n      outputNode.data(\"justAdded\", true);\n      outputNode.data(\"label\", label);\n      infoboxObject = {\n        clazz: \"unit of information\",\n        label: {\n          text: outputInfoboxLabel\n        },\n        bbox: {\n          w: Math.max(outputInfoboxLabel.length * widthPerChar, minInfoboxDimension),\n          h: minInfoboxDimension\n        }\n      };\n      elementUtilities.addStateOrInfoBox(outputNode, infoboxObject);\n      var outputEdge = elementUtilities.addEdge(processNode.id(), outputNode.id(), {\n        \"class\": 'production',\n        language: 'PD'\n      });\n      outputEdge.data(\"justAdded\", true);\n      var xPosOfRegulator = processPosition.x;\n      var dimension = vertical ? nucleicAcidFeatureWidth : nucleicAcidFeatureHeight;\n      var yPosOfRegulator = processPosition.y - (processHeight / 2 + dimension / 2 + edgeLength);\n      nodePosition = {\n        x: xPosOfRegulator,\n        y: yPosOfRegulator\n      };\n\n      if (vertical) {\n        nodePosition = elementUtilities.rotate90(nodePosition, processPosition);\n      }\n\n      var regulatorNode = elementUtilities.addNode(nodePosition.x, nodePosition.y, {\n        \"class\": \"nucleic acid feature\",\n        language: 'PD'\n      });\n      regulatorNode.data('justAdded', true);\n      regulatorNode.data('label', label);\n      infoboxObject = {\n        clazz: \"unit of information\",\n        label: {\n          text: regulatorInfoboxLabel\n        },\n        bbox: {\n          w: Math.max(regulatorInfoboxLabel.length * widthPerChar, minInfoboxDimension),\n          h: minInfoboxDimension\n        }\n      };\n      elementUtilities.addStateOrInfoBox(regulatorNode, infoboxObject);\n      var regulatorEdge = elementUtilities.addEdge(regulatorNode.id(), processNode.id(), {\n        \"class\": 'necessary stimulation',\n        language: 'PD'\n      });\n      regulatorEdge.data('justAdded', true);\n      cy.endBatch();\n      var eles = cy.elements('[justAdded]');\n      eles.removeData('justAdded');\n      cy.elements().unselect();\n      eles.select();\n      return eles;\n    };\n\n    elementUtilities.createDegradation = function (macromolecule, orientation) {\n      var macromoleculeName = macromolecule.name;\n      var defaultMacromoleculeProperties = elementUtilities.getDefaultProperties(\"macromolecule\");\n      var macromoleculeWidth = defaultMacromoleculeProperties.width || 50;\n      var defaultProcessProperties = elementUtilities.getDefaultProperties(\"catalytic\");\n      var processWidth = defaultProcessProperties.width || 50;\n      var processPosition = elementUtilities.convertToModelPosition({\n        x: cy.width() / 2,\n        y: cy.height() / 2\n      });\n      var edgeLength = 30;\n      var vertical = orientation === \"vertical\";\n      var processPortsOrdering = vertical ? \"T-to-B\" : \"L-to-R\";\n      cy.startBatch();\n\n      if (!elementUtilities.getMapType()) {\n        elementUtilities.setMapType(\"PD\");\n      }\n\n      var processNode = elementUtilities.addNode(processPosition.x, processPosition.y, {\n        \"class\": \"process\",\n        language: \"PD\"\n      });\n      elementUtilities.setPortsOrdering(processNode, processPortsOrdering);\n      processNode.data('justAdded', true);\n      var xPosOfInput = processPosition.x - edgeLength - processWidth / 2 - macromoleculeWidth / 2;\n      var xPosOfOutput = processPosition.x + edgeLength + processWidth / 2 + macromoleculeWidth / 2;\n      var yPosOfInput = processPosition.y;\n      var yPosOfOutput = processPosition.y;\n      var nodePosition = {\n        x: xPosOfInput,\n        y: yPosOfInput\n      };\n\n      if (vertical) {\n        nodePosition = elementUtilities.rotate90(nodePosition, processPosition);\n      }\n\n      var inputNode = elementUtilities.addNode(nodePosition.x, nodePosition.y, {\n        \"class\": 'macromolecule',\n        language: 'PD'\n      });\n      inputNode.data(\"justAdded\", true);\n      inputNode.data(\"label\", macromoleculeName);\n      var inputEdge = elementUtilities.addEdge(inputNode.id(), processNode.id(), {\n        \"class\": 'consumption',\n        language: 'PD'\n      });\n      inputEdge.data(\"justAdded\", true);\n      nodePosition = {\n        x: xPosOfOutput,\n        y: yPosOfOutput\n      };\n\n      if (vertical) {\n        nodePosition = elementUtilities.rotate90(nodePosition, processPosition);\n      }\n\n      var outputNode = elementUtilities.addNode(nodePosition.x, nodePosition.y, {\n        \"class\": 'empty set',\n        language: 'PD'\n      });\n      outputNode.data(\"justAdded\", true);\n      var outputEdge = elementUtilities.addEdge(processNode.id(), outputNode.id(), {\n        \"class\": 'production',\n        language: 'PD'\n      });\n      outputEdge.data(\"justAdded\", true);\n      cy.endBatch();\n      var eles = cy.elements('[justAdded]');\n      eles.removeData('justAdded');\n      cy.elements().unselect();\n      eles.select();\n      return eles;\n    };\n\n    elementUtilities.createComplexProteinFormation = function (proteinLabels, complexLabel, regulator, orientation, reverse) {\n      var hasRegulator = regulator.name !== undefined;\n      var defaultMacromoleculeProperties = elementUtilities.getDefaultProperties(\"macromolecule\");\n      var defaultRegulatorProperties = hasRegulator ? elementUtilities.getDefaultProperties(regulator.type) : {};\n      var defaultProcessProperties = elementUtilities.getDefaultProperties(\"catalytic\");\n      var processWidth = defaultProcessProperties.width || 50;\n      var macromoleculeWidth = defaultMacromoleculeProperties.width || 50;\n      var macromoleculeHeight = defaultMacromoleculeProperties.height || 50;\n      var processHeight = defaultProcessProperties.height || 50;\n      var regulatorHeight = defaultRegulatorProperties.height || 50;\n      var processPosition = elementUtilities.convertToModelPosition({\n        x: cy.width() / 2,\n        y: cy.height() / 2\n      });\n      var edgeLength = 30;\n      var processPortsOrdering = orientation === \"vertical\" ? \"T-to-B\" : \"L-to-R\";\n      var minInfoboxDimension = 20;\n      var widthPerChar = 6;\n      var tilingPaddingVertical = 15;\n      var tilingPaddingHorizontal = 15;\n      var multimerOffset = 6;\n      cy.startBatch();\n\n      if (!elementUtilities.getMapType()) {\n        elementUtilities.setMapType(\"PD\");\n      }\n\n      var processNode = elementUtilities.addNode(processPosition.x, processPosition.y, {\n        \"class\": \"process\",\n        language: \"PD\"\n      });\n      elementUtilities.setPortsOrdering(processNode, processPortsOrdering);\n      processNode.data('justAdded', true);\n      var offsetX = processWidth / 2 + edgeLength + macromoleculeWidth / 2;\n      var xPosOfProtein = reverse ? processPosition.x + offsetX : processPosition.x - offsetX;\n      var proteinCount = proteinLabels.length;\n      var macromoleculeDimension = orientation === \"vertical\" ? macromoleculeWidth : macromoleculeHeight;\n      var stepOffset = macromoleculeDimension + tilingPaddingVertical;\n      var offsetY = (proteinCount - 1) / 2 * (macromoleculeDimension + tilingPaddingVertical);\n      var horizontalOffsetX = (proteinCount - 1) / 2 * (macromoleculeDimension + tilingPaddingHorizontal);\n      var yPosOfProtein = processPosition.y - offsetY;\n      proteinLabels.forEach(function (label) {\n        var nodePosition = {\n          x: xPosOfProtein,\n          y: yPosOfProtein\n        };\n\n        if (orientation === \"vertical\") {\n          nodePosition = elementUtilities.rotate90(nodePosition, processPosition);\n        }\n\n        var node = elementUtilities.addNode(nodePosition.x, nodePosition.y, {\n          \"class\": \"macromolecule\",\n          language: \"PD\"\n        });\n        node.data(\"label\", label);\n        node.data(\"justAdded\", true);\n        yPosOfProtein += stepOffset;\n        var source = reverse ? processNode.id() : node.id();\n        var target = reverse ? node.id() : processNode.id();\n        var edgeClass = reverse ? \"production\" : \"consumption\";\n        var edge = elementUtilities.addEdge(source, target, {\n          \"class\": edgeClass,\n          language: \"PD\"\n        });\n        edge.data(\"justAdded\", true);\n      });\n      var complexPos = {\n        x: processPosition.x + (reverse ? -1 : 1) * offsetX,\n        y: processPosition.y\n      };\n\n      if (orientation === \"vertical\") {\n        complexPos = elementUtilities.rotate90(complexPos, processPosition);\n      }\n\n      var complex = elementUtilities.addNode(complexPos.x, complexPos.y, {\n        \"class\": \"complex\",\n        language: \"PD\"\n      });\n      complex.data(\"label\", complexLabel);\n      complex.data(\"justAdded\", true);\n      var source = reverse ? complex.id() : processNode.id();\n      var target = reverse ? processNode.id() : complex.id();\n      var edgeClass = reverse ? \"consumption\" : \"production\";\n      var complexEdge = elementUtilities.addEdge(source, target, {\n        \"class\": edgeClass,\n        language: \"PD\"\n      });\n      complexEdge.data(\"justAdded\", true);\n\n      if (orientation === \"vertical\") {\n        xPosOfProtein = complex.position(\"x\") - horizontalOffsetX;\n        yPosOfProtein = complex.position(\"y\");\n      } else {\n        xPosOfProtein = complex.position(\"x\");\n        yPosOfProtein = complex.position(\"y\") - offsetY;\n      }\n\n      proteinLabels.forEach(function (label) {\n        var nodePosition = {\n          x: xPosOfProtein,\n          y: yPosOfProtein\n        };\n        var node = elementUtilities.addNode(nodePosition.x, nodePosition.y, {\n          \"class\": \"macromolecule\",\n          language: \"PD\"\n        }, undefined, complex.id());\n        node.data(\"label\", label);\n        node.data(\"justAdded\", true);\n\n        if (orientation === \"vertical\") {\n          xPosOfProtein += stepOffset;\n        } else {\n          yPosOfProtein += stepOffset;\n        }\n      });\n\n      if (hasRegulator) {\n        var regulatorName = regulator.name;\n        var regulatorType = regulator.type;\n        var regulatorEdgeType = regulator.edgeType;\n        var regulatorMultimer = regulator.multimer;\n        var xPosOfRegulator = processPosition.x;\n\n        if (regulatorMultimer.enabled && orientation === \"horizontal\") {\n          xPosOfRegulator -= multimerOffset;\n        }\n\n        var yPosOfRegulator = processPosition.y - (processHeight / 2 + regulatorHeight / 2 + edgeLength);\n        nodePosition = {\n          x: xPosOfRegulator,\n          y: yPosOfRegulator\n        };\n\n        if (orientation === \"vertical\") {\n          nodePosition = elementUtilities.rotate90(nodePosition, processPosition);\n        }\n\n        var regulatorNode = elementUtilities.addNode(nodePosition.x, nodePosition.y, {\n          \"class\": regulatorType,\n          language: 'PD'\n        });\n        regulatorNode.data('justAdded', true);\n        regulatorNode.data('label', regulatorName);\n\n        if (regulatorMultimer.enabled) {\n          elementUtilities.setMultimerStatus(regulatorNode, true);\n          var cardinality = regulatorMultimer.cardinality;\n\n          if (cardinality != '') {\n            var infoboxLabel = \"N:\" + cardinality;\n            infoboxObject = {\n              clazz: \"unit of information\",\n              label: {\n                text: infoboxLabel\n              },\n              bbox: {\n                w: infoboxLabel.length * widthPerChar,\n                h: minInfoboxDimension\n              }\n            };\n            elementUtilities.addStateOrInfoBox(regulatorNode, infoboxObject);\n          }\n        }\n\n        var regulatorEdge = elementUtilities.addEdge(regulatorNode.id(), processNode.id(), {\n          \"class\": regulatorEdgeType,\n          language: 'PD'\n        });\n        regulatorEdge.data('justAdded', true);\n      }\n\n      cy.endBatch();\n      var eles = cy.elements('[justAdded]');\n      eles.removeData('justAdded');\n      cy.elements().unselect();\n      eles.select();\n      return eles;\n    };\n\n    elementUtilities.createMultimerization = function (macromolecule, regulator, regulatorMultimer, orientation) {\n      var hasRegulator = regulator.name !== undefined;\n      var macromoleculeName = macromolecule.name;\n      var macromoleculeMultimerCardinality = macromolecule.cardinality;\n      var defaultMacromoleculeProperties = elementUtilities.getDefaultProperties(\"macromolecule\");\n      var defaultRegulatorProperties = hasRegulator ? elementUtilities.getDefaultProperties(regulator.type) : {};\n      var defaultProcessProperties = elementUtilities.getDefaultProperties(\"catalytic\");\n      var processWidth = defaultProcessProperties.width || 50;\n      var macromoleculeWidth = defaultMacromoleculeProperties.width || 50;\n      var macromoleculeHeight = defaultMacromoleculeProperties.height || 50;\n      var processHeight = defaultProcessProperties.height || 50;\n      var regulatorHeight = defaultRegulatorProperties.height || 50;\n      var processPosition = elementUtilities.convertToModelPosition({\n        x: cy.width() / 2,\n        y: cy.height() / 2\n      });\n      var edgeLength = 30;\n      var processPortsOrdering = orientation === \"vertical\" ? \"T-to-B\" : \"L-to-R\";\n      var minInfoboxDimension = 20;\n      var widthPerChar = 6;\n      var multimerOffset = 6;\n      cy.startBatch();\n\n      if (!elementUtilities.getMapType()) {\n        elementUtilities.setMapType(\"PD\");\n      }\n\n      var xPosOfInput = processPosition.x - edgeLength - processWidth / 2 - macromoleculeWidth / 2;\n      var xPosOfOutput = processPosition.x + edgeLength + processWidth / 2 + macromoleculeWidth / 2;\n      var yPosOfInput = processPosition.y;\n      var yPosOfOutput = processPosition.y;\n      var processNode = elementUtilities.addNode(processPosition.x, processPosition.y, {\n        \"class\": \"process\",\n        language: \"PD\"\n      });\n      elementUtilities.setPortsOrdering(processNode, processPortsOrdering);\n      processNode.data('justAdded', true);\n      var nodePosition = {\n        x: xPosOfInput,\n        y: yPosOfInput\n      };\n\n      if (orientation === \"vertical\") {\n        nodePosition = elementUtilities.rotate90(nodePosition, processPosition);\n      }\n\n      var inputNode = elementUtilities.addNode(nodePosition.x, nodePosition.y, {\n        \"class\": 'macromolecule',\n        language: 'PD'\n      });\n      inputNode.data(\"justAdded\", true);\n      inputNode.data(\"label\", macromoleculeName);\n      var inputEdge = elementUtilities.addEdge(inputNode.id(), processNode.id(), {\n        \"class\": 'consumption',\n        language: 'PD'\n      });\n      inputEdge.data(\"justAdded\", true);\n      var cardinality = macromoleculeMultimerCardinality;\n\n      if (cardinality !== '') {\n        inputEdge.data(\"cardinality\", cardinality);\n      }\n\n      nodePosition = {\n        x: xPosOfOutput,\n        y: yPosOfOutput\n      };\n\n      if (orientation === \"vertical\") {\n        nodePosition = elementUtilities.rotate90(nodePosition, processPosition);\n      }\n\n      var outputNode = elementUtilities.addNode(nodePosition.x, nodePosition.y, {\n        \"class\": 'macromolecule',\n        language: 'PD'\n      });\n      outputNode.data(\"justAdded\", true);\n      outputNode.data(\"label\", macromoleculeName);\n      elementUtilities.setMultimerStatus(outputNode, true);\n\n      if (cardinality !== '') {\n        var infoboxLabel = \"N:\" + cardinality;\n        infoboxObject = {\n          clazz: \"unit of information\",\n          label: {\n            text: infoboxLabel\n          },\n          bbox: {\n            w: infoboxLabel.length * widthPerChar,\n            h: minInfoboxDimension\n          }\n        };\n        elementUtilities.addStateOrInfoBox(outputNode, infoboxObject);\n      }\n\n      var outputEdge = elementUtilities.addEdge(processNode.id(), outputNode.id(), {\n        \"class\": 'production',\n        language: 'PD'\n      });\n      outputEdge.data(\"justAdded\", true);\n\n      if (hasRegulator) {\n        var regulatorName = regulator.name;\n        var regulatorType = regulator.type;\n        var regulatorEdgeType = regulator.edgeType;\n        var xPosOfRegulator = processPosition.x;\n\n        if (regulatorMultimer.enabled && orientation === \"horizontal\") {\n          xPosOfRegulator -= multimerOffset;\n        }\n\n        var yPosOfRegulator = processPosition.y - (processHeight / 2 + regulatorHeight / 2 + edgeLength);\n        nodePosition = {\n          x: xPosOfRegulator,\n          y: yPosOfRegulator\n        };\n\n        if (orientation === \"vertical\") {\n          nodePosition = elementUtilities.rotate90(nodePosition, processPosition);\n        }\n\n        var regulatorNode = elementUtilities.addNode(nodePosition.x, nodePosition.y, {\n          \"class\": regulatorType,\n          language: 'PD'\n        });\n        regulatorNode.data('justAdded', true);\n        regulatorNode.data('label', regulatorName);\n\n        if (regulatorMultimer.enabled) {\n          elementUtilities.setMultimerStatus(regulatorNode, true);\n          var _cardinality = regulatorMultimer.cardinality;\n\n          if (_cardinality != '') {\n            var _infoboxLabel = \"N:\" + _cardinality;\n\n            infoboxObject = {\n              clazz: \"unit of information\",\n              label: {\n                text: _infoboxLabel\n              },\n              bbox: {\n                w: _infoboxLabel.length * widthPerChar,\n                h: minInfoboxDimension\n              }\n            };\n            elementUtilities.addStateOrInfoBox(regulatorNode, infoboxObject);\n          }\n        }\n\n        var regulatorEdge = elementUtilities.addEdge(regulatorNode.id(), processNode.id(), {\n          \"class\": regulatorEdgeType,\n          language: 'PD'\n        });\n        regulatorEdge.data('justAdded', true);\n      }\n\n      cy.endBatch();\n      var eles = cy.elements('[justAdded]');\n      eles.removeData('justAdded');\n      cy.elements().unselect();\n      eles.select();\n      return eles;\n    };\n\n    elementUtilities.createConversion = function (macromolecule, regulator, regulatorMultimer, orientation, inputInfoboxLabels, outputInfoboxLabels) {\n      var hasRegulator = regulator.name !== undefined;\n      var macromoleculeName = macromolecule.name;\n      var macromoleculeIsMultimer = macromolecule.multimer.enabled;\n      var macromoleculeMultimerCardinality = macromolecule.multimer.cardinality;\n      var defaultMacromoleculeProperties = elementUtilities.getDefaultProperties(\"macromolecule\");\n      var defaultRegulatorProperties = hasRegulator ? elementUtilities.getDefaultProperties(regulator.type) : {};\n      var defaultProcessProperties = elementUtilities.getDefaultProperties(\"catalytic\");\n      var processWidth = defaultProcessProperties.width || 50;\n      var macromoleculeWidth = defaultMacromoleculeProperties.width || 50;\n      var macromoleculeHeight = defaultMacromoleculeProperties.height || 50;\n      var processHeight = defaultProcessProperties.height || 50;\n      var regulatorHeight = defaultRegulatorProperties.height || 50;\n      var processPosition = elementUtilities.convertToModelPosition({\n        x: cy.width() / 2,\n        y: cy.height() / 2\n      });\n      var edgeLength = 30;\n      var processPortsOrdering = orientation === \"vertical\" ? \"T-to-B\" : \"L-to-R\";\n      var minInfoboxDimension = 20;\n      var widthPerChar = 6;\n      var multimerOffset = 6;\n      cy.startBatch();\n\n      if (!elementUtilities.getMapType()) {\n        elementUtilities.setMapType(\"PD\");\n      }\n\n      var xPosOfInput = processPosition.x - edgeLength - processWidth / 2 - macromoleculeWidth / 2;\n      var xPosOfOutput = processPosition.x + edgeLength + processWidth / 2 + macromoleculeWidth / 2;\n      var yPosOfInput = processPosition.y;\n      var yPosOfOutput = processPosition.y;\n      var processNode = elementUtilities.addNode(processPosition.x, processPosition.y, {\n        \"class\": \"process\",\n        language: \"PD\"\n      });\n      elementUtilities.setPortsOrdering(processNode, processPortsOrdering);\n      processNode.data('justAdded', true);\n      var nodePosition = {\n        x: xPosOfInput,\n        y: yPosOfInput\n      };\n\n      if (orientation === \"vertical\") {\n        nodePosition = elementUtilities.rotate90(nodePosition, processPosition);\n      }\n\n      var inputNode = elementUtilities.addNode(nodePosition.x, nodePosition.y, {\n        \"class\": 'macromolecule',\n        language: 'PD'\n      });\n      inputNode.data(\"justAdded\", true);\n      inputNode.data(\"label\", macromoleculeName);\n\n      if (macromoleculeIsMultimer) {\n        elementUtilities.setMultimerStatus(inputNode, true);\n        var cardinality = macromoleculeMultimerCardinality;\n\n        if (cardinality != '') {\n          var infoboxLabel = \"N:\" + cardinality;\n          infoboxObject = {\n            clazz: \"unit of information\",\n            label: {\n              text: infoboxLabel\n            },\n            bbox: {\n              w: infoboxLabel.length * widthPerChar,\n              h: minInfoboxDimension\n            }\n          };\n          elementUtilities.addStateOrInfoBox(inputNode, infoboxObject);\n        }\n      }\n\n      inputInfoboxLabels.forEach(function (label) {\n        var inputInfoboxWidth = label.length > 0 ? Math.max(widthPerChar * label.length, minInfoboxDimension) : minInfoboxDimension;\n        var infoboxObject = {\n          clazz: \"unit of information\",\n          label: {\n            text: label\n          },\n          bbox: {\n            w: inputInfoboxWidth,\n            h: minInfoboxDimension\n          },\n          style: {\n            \"shape-name\": \"ellipse\"\n          }\n        };\n        elementUtilities.addStateOrInfoBox(inputNode, infoboxObject);\n      });\n      var inputEdge = elementUtilities.addEdge(inputNode.id(), processNode.id(), {\n        \"class\": 'consumption',\n        language: 'PD'\n      });\n      inputEdge.data(\"justAdded\", true);\n      nodePosition = {\n        x: xPosOfOutput,\n        y: yPosOfOutput\n      };\n\n      if (orientation === \"vertical\") {\n        nodePosition = elementUtilities.rotate90(nodePosition, processPosition);\n      }\n\n      var outputNode = elementUtilities.addNode(nodePosition.x, nodePosition.y, {\n        \"class\": 'macromolecule',\n        language: 'PD'\n      });\n      outputNode.data(\"justAdded\", true);\n      outputNode.data(\"label\", macromoleculeName);\n\n      if (macromoleculeIsMultimer) {\n        elementUtilities.setMultimerStatus(outputNode, true);\n        var _cardinality2 = macromoleculeMultimerCardinality;\n\n        if (_cardinality2 != '') {\n          var _infoboxLabel2 = \"N:\" + _cardinality2;\n\n          infoboxObject = {\n            clazz: \"unit of information\",\n            label: {\n              text: _infoboxLabel2\n            },\n            bbox: {\n              w: _infoboxLabel2.length * widthPerChar,\n              h: minInfoboxDimension\n            }\n          };\n          elementUtilities.addStateOrInfoBox(outputNode, infoboxObject);\n        }\n      }\n\n      outputInfoboxLabels.forEach(function (label) {\n        var outputInfoboxWidth = label.length > 0 ? Math.max(widthPerChar * label.length, minInfoboxDimension) : minInfoboxDimension;\n        infoboxObject = {\n          clazz: \"unit of information\",\n          label: {\n            text: label\n          },\n          bbox: {\n            w: outputInfoboxWidth,\n            h: minInfoboxDimension\n          },\n          style: {\n            \"shape-name\": \"ellipse\"\n          }\n        };\n        elementUtilities.addStateOrInfoBox(outputNode, infoboxObject);\n      });\n      [inputNode, outputNode].forEach(function (node) {\n        var width = elementUtilities.calculateMinWidth(node);\n        elementUtilities.resizeNodes(node, width, macromoleculeHeight, false, true);\n      });\n\n      if (orientation === \"horizontal\") {\n        var newInputXPos = processPosition.x - edgeLength - processWidth / 2 - inputNode.data('bbox').w / 2;\n        inputNode.position('x', newInputXPos);\n        var newOutputXPos = processPosition.x + edgeLength + processWidth / 2 + outputNode.data('bbox').w / 2;\n        outputNode.position('x', newOutputXPos);\n      } else {\n        var newInputYPos = processPosition.y - edgeLength - processWidth / 2 - inputNode.data('bbox').h / 2;\n        inputNode.position('y', newInputYPos);\n        var newOutputYPos = processPosition.y + edgeLength + processWidth / 2 + outputNode.data('bbox').h / 2;\n        outputNode.position('y', newOutputYPos);\n      }\n\n      var outputEdge = elementUtilities.addEdge(processNode.id(), outputNode.id(), {\n        \"class\": 'production',\n        language: 'PD'\n      });\n      outputEdge.data(\"justAdded\", true);\n\n      if (hasRegulator) {\n        var regulatorName = regulator.name;\n        var regulatorType = regulator.type;\n        var xPosOfRegulator = processPosition.x;\n\n        if (regulatorMultimer.enabled && orientation === \"horizontal\") {\n          xPosOfRegulator -= multimerOffset;\n        }\n\n        var yPosOfRegulator = processPosition.y - (processHeight / 2 + regulatorHeight / 2 + edgeLength);\n        nodePosition = {\n          x: xPosOfRegulator,\n          y: yPosOfRegulator\n        };\n\n        if (orientation === \"vertical\") {\n          nodePosition = elementUtilities.rotate90(nodePosition, processPosition);\n        }\n\n        var regulatorNode = elementUtilities.addNode(nodePosition.x, nodePosition.y, {\n          \"class\": regulatorType,\n          language: 'PD'\n        });\n        regulatorNode.data('justAdded', true);\n        regulatorNode.data('label', regulatorName);\n\n        if (regulatorMultimer.enabled) {\n          elementUtilities.setMultimerStatus(regulatorNode, true);\n          var _cardinality3 = regulatorMultimer.cardinality;\n\n          if (_cardinality3 != '') {\n            var _infoboxLabel3 = \"N:\" + _cardinality3;\n\n            infoboxObject = {\n              clazz: \"unit of information\",\n              label: {\n                text: _infoboxLabel3\n              },\n              bbox: {\n                w: _infoboxLabel3.length * widthPerChar,\n                h: minInfoboxDimension\n              }\n            };\n            elementUtilities.addStateOrInfoBox(regulatorNode, infoboxObject);\n          }\n        }\n\n        var regulatorEdge = elementUtilities.addEdge(regulatorNode.id(), processNode.id(), {\n          \"class\": 'catalysis',\n          language: 'PD'\n        });\n        regulatorEdge.data('justAdded', true);\n      }\n\n      cy.endBatch();\n      var eles = cy.elements('[justAdded]');\n      eles.removeData('justAdded');\n      cy.elements().unselect();\n      eles.select();\n      return eles;\n    };\n\n    elementUtilities.createMetabolicReaction = function (inputs, outputs, reversible, regulator, regulatorMultimer, orientation) {\n      var rotate90 = function rotate90(point, center) {\n        var relativeX = center.x - point.x;\n        var relativeY = center.y - point.y;\n        var relativeRotatedX = relativeY;\n        var relativeRotatedY = -1 * relativeX;\n        var resultX = relativeRotatedX + center.x;\n        var resultY = relativeRotatedY + center.y;\n        return {\n          x: resultX,\n          y: resultY\n        };\n      };\n\n      var hasRegulator = regulator.name !== undefined;\n      var defaultSimpleChemicalProperties = elementUtilities.getDefaultProperties(\"simple chemical\");\n      var defaultRegulatorProperties = hasRegulator ? elementUtilities.getDefaultProperties(regulator.type) : {};\n      var defaultProcessProperties = elementUtilities.getDefaultProperties(\"catalytic\");\n      var processWidth = defaultProcessProperties.width || 50;\n      var processHeight = defaultProcessProperties.height || 50;\n      var simpleChemicalHeight = defaultSimpleChemicalProperties.height || 35;\n      var simpleChemicalWidth = defaultSimpleChemicalProperties.width || 35;\n      var regulatorHeight = defaultRegulatorProperties.height || 50;\n      var processPosition = elementUtilities.convertToModelPosition({\n        x: cy.width() / 2,\n        y: cy.height() / 2\n      });\n      var tilingPaddingVertical = 15;\n      var edgeLength = 30;\n      var processLeftSideEdgeType = reversible ? \"production\" : \"consumption\";\n      var processRightSideEdgeType = \"production\";\n      var processPortsOrdering = orientation === \"vertical\" ? \"T-to-B\" : \"L-to-R\";\n      var multimerOffset = 6;\n      cy.startBatch();\n\n      if (!elementUtilities.getMapType()) {\n        elementUtilities.setMapType(\"PD\");\n      }\n\n      var xPosOfInput = processPosition.x - edgeLength - processWidth / 2 - simpleChemicalWidth / 2;\n      var xPosOfOutput = processPosition.x + edgeLength + processWidth / 2 + simpleChemicalWidth / 2;\n      var processNode = elementUtilities.addNode(processPosition.x, processPosition.y, {\n        \"class\": \"process\",\n        language: \"PD\"\n      });\n      elementUtilities.setPortsOrdering(processNode, processPortsOrdering);\n      processNode.data('justAdded', true);\n      var numOfInputNodes = inputs.length;\n      var numOfOutputNodes = outputs.length;\n      var yPosOfInput = processPosition.y - (numOfInputNodes - 1) / 2 * (simpleChemicalHeight + tilingPaddingVertical);\n      inputs.forEach(function (data, index) {\n        var nodeName = data.name;\n        var nodeType = data.type;\n\n        if (index === 0) {\n          yPosOfInput = processPosition.y;\n        } else if (index % 2 === 1) {\n          yPosOfInput = processPosition.y - (simpleChemicalHeight + tilingPaddingVertical) * Math.ceil(index / 2);\n        } else {\n          yPosOfInput = processPosition.y + (simpleChemicalHeight + tilingPaddingVertical) * (index / 2);\n        }\n\n        var nodePosition = {\n          x: xPosOfInput,\n          y: yPosOfInput\n        };\n\n        if (orientation === \"vertical\") {\n          nodePosition = rotate90(nodePosition, processPosition);\n        }\n\n        var newNode = elementUtilities.addNode(nodePosition.x, nodePosition.y, {\n          \"class\": nodeType.toLowerCase(),\n          language: \"PD\"\n        });\n        newNode.data(\"justAdded\", true);\n        newNode.data(\"label\", nodeName);\n        var newEdge;\n\n        if (reversible) {\n          newEdge = elementUtilities.addEdge(processNode.id(), newNode.id(), {\n            \"class\": processLeftSideEdgeType,\n            language: \"PD\"\n          }, undefined, undefined, 1);\n        } else {\n          newEdge = elementUtilities.addEdge(newNode.id(), processNode.id(), {\n            \"class\": processLeftSideEdgeType,\n            language: \"PD\"\n          });\n        }\n\n        newEdge.data(\"justAdded\", true);\n      });\n      var yPosOfOutput = processPosition.y - (numOfOutputNodes - 1) / 2 * (simpleChemicalHeight + tilingPaddingVertical);\n      outputs.forEach(function (data, index) {\n        var nodeName = data.name;\n        var nodeType = data.type;\n\n        if (index === 0) {\n          yPosOfOutput = processPosition.y;\n        } else if (index % 2 === 1) {\n          yPosOfOutput = processPosition.y - (simpleChemicalHeight + tilingPaddingVertical) * Math.ceil(index / 2);\n        } else {\n          yPosOfOutput = processPosition.y + (simpleChemicalHeight + tilingPaddingVertical) * (index / 2);\n        }\n\n        var nodePosition = {\n          x: xPosOfOutput,\n          y: yPosOfOutput\n        };\n\n        if (orientation === \"vertical\") {\n          nodePosition = rotate90(nodePosition, processPosition);\n        }\n\n        var newNode = elementUtilities.addNode(nodePosition.x, nodePosition.y, {\n          \"class\": nodeType.toLowerCase(),\n          language: \"PD\"\n        });\n        newNode.data(\"justAdded\", true);\n        newNode.data(\"label\", nodeName);\n        var newEdge = elementUtilities.addEdge(processNode.id(), newNode.id(), {\n          \"class\": processRightSideEdgeType,\n          language: \"PD\"\n        }, undefined, undefined, 0);\n        newEdge.data(\"justAdded\", true);\n      }); // add regulator node\n\n      if (hasRegulator) {\n        var regulatorName = regulator.name;\n        var regulatorType = regulator.type;\n        var xPosOfRegulator = processPosition.x;\n\n        if (regulatorMultimer.enabled && orientation === \"horizontal\") {\n          xPosOfRegulator -= multimerOffset;\n        }\n\n        var yPosOfRegulator = processPosition.y - (processHeight / 2 + regulatorHeight / 2 + edgeLength);\n        var _nodePosition = {\n          x: xPosOfRegulator,\n          y: yPosOfRegulator\n        };\n\n        if (orientation === \"vertical\") {\n          _nodePosition = rotate90(_nodePosition, processPosition);\n        }\n\n        var regulatorNode = elementUtilities.addNode(_nodePosition.x, _nodePosition.y, {\n          \"class\": regulatorType,\n          language: 'PD'\n        });\n        regulatorNode.data('justAdded', true);\n        regulatorNode.data('label', regulatorName);\n\n        if (regulatorMultimer.enabled) {\n          elementUtilities.setMultimerStatus(regulatorNode, true);\n          var cardinality = regulatorMultimer.cardinality;\n\n          if (cardinality != '') {\n            var infoboxLabel = \"N:\" + cardinality;\n            infoboxObject = {\n              clazz: \"unit of information\",\n              label: {\n                text: infoboxLabel\n              },\n              bbox: {\n                w: infoboxLabel.length * 6,\n                h: 15\n              }\n            };\n            elementUtilities.addStateOrInfoBox(regulatorNode, infoboxObject);\n          }\n        }\n\n        var regulatorEdge = elementUtilities.addEdge(regulatorNode.id(), processNode.id(), {\n          \"class\": 'catalysis',\n          language: 'PD'\n        });\n        regulatorEdge.data('justAdded', true);\n      }\n\n      cy.endBatch();\n      var eles = cy.elements('[justAdded]');\n      eles.removeData('justAdded');\n      cy.elements().unselect();\n      eles.select();\n      return eles;\n    };\n\n    elementUtilities.createMetabolicCatalyticActivity = function (inputNodeList, outputNodeList, catalystName, catalystType, processPosition, tilingPaddingVertical, tilingPaddingHorizontal, edgeLength) {\n      var defaultMacromoleculProperties = elementUtilities.getDefaultProperties(\"macromolecule\");\n      var defaultSimpleChemicalProperties = elementUtilities.getDefaultProperties(\"simple chemical\");\n      var defaultCatalystTypeProperties = elementUtilities.getDefaultProperties(catalystType);\n      var defaultProcessProperties = elementUtilities.getDefaultProperties(\"catalytic\");\n      var processWidth = defaultProcessProperties.width || 50;\n      var processHeight = defaultProcessProperties.height || 50;\n      var simpleChemicalHeight = defaultSimpleChemicalProperties.height || 35;\n      var macromoleculeWidth = defaultMacromoleculProperties.width || 50;\n      var macromoleculeHeight = defaultMacromoleculProperties.height || 50;\n      var catalystHeight = defaultCatalystTypeProperties.height || 50;\n      var processPosition = processPosition || elementUtilities.convertToModelPosition({\n        x: cy.width() / 2,\n        y: cy.height() / 2\n      });\n      var tilingPaddingVertical = tilingPaddingVertical || 15;\n      var tilingPaddingHorizontal = tilingPaddingHorizontal || 15;\n      var edgeLength = edgeLength || 60;\n      cy.startBatch();\n\n      if (!elementUtilities.getMapType()) {\n        elementUtilities.setMapType(\"PD\");\n      }\n\n      var xPosOfInput = processPosition.x - edgeLength - processWidth / 2 - macromoleculeWidth / 2;\n      var xPosOfOutput = processPosition.x + edgeLength + processWidth / 2 + macromoleculeWidth / 2;\n      var processNode = elementUtilities.addNode(processPosition.x, processPosition.y, {\n        \"class\": \"process\",\n        language: \"PD\"\n      });\n      elementUtilities.setPortsOrdering(processNode, \"L-to-R\");\n      processNode.data('justAdded', true);\n      var numOfInputNodes = inputNodeList.length;\n      var numOfOutputNodes = outputNodeList.length;\n      var yPosOfInput = processPosition.y - (numOfInputNodes - 1) / 2 * (macromoleculeHeight + tilingPaddingVertical); // add input side nodes\n\n      for (var i = 0; i < numOfInputNodes; i++) {\n        if (inputNodeList[i].type == \"Simple Chemical\") {\n          var newNode = elementUtilities.addNode(xPosOfInput, yPosOfInput, {\n            \"class\": 'simple chemical',\n            language: 'PD'\n          });\n          yPosOfInput += simpleChemicalHeight + tilingPaddingVertical;\n        } else {\n          var newNode = elementUtilities.addNode(xPosOfInput, yPosOfInput, {\n            \"class\": 'macromolecule',\n            language: 'PD'\n          }); //update the y position\n\n          yPosOfInput += macromoleculeHeight + tilingPaddingVertical;\n        }\n\n        newNode.data('justAdded', true);\n        newNode.data('label', inputNodeList[i].name);\n        var newEdge = elementUtilities.addEdge(newNode.id(), processNode.id(), {\n          \"class\": 'consumption',\n          language: 'PD'\n        });\n        newEdge.data('justAdded', true);\n      }\n\n      var yPosOfOutput = processPosition.y - (numOfOutputNodes - 1) / 2 * (macromoleculeHeight + tilingPaddingVertical); // add output side nodes\n\n      for (var i = 0; i < numOfOutputNodes; i++) {\n        if (outputNodeList[i].type == \"Simple Chemical\") {\n          var newNode = elementUtilities.addNode(xPosOfOutput, yPosOfOutput, {\n            \"class\": 'simple chemical',\n            language: 'PD'\n          });\n          yPosOfOutput += simpleChemicalHeight + tilingPaddingVertical;\n        } else {\n          var newNode = elementUtilities.addNode(xPosOfOutput, yPosOfOutput, {\n            \"class\": 'macromolecule',\n            language: 'PD'\n          }); //update the y position\n\n          yPosOfOutput += macromoleculeHeight + tilingPaddingVertical;\n        }\n\n        newNode.data('justAdded', true);\n        newNode.data('label', outputNodeList[i].name);\n        var newEdge = elementUtilities.addEdge(processNode.id(), newNode.id(), {\n          \"class\": 'production',\n          language: 'PD'\n        });\n        newEdge.data('justAdded', true);\n      } // add catalyst node\n\n\n      var xPosOfCatalyst = processPosition.x;\n      var yPosOfCatalyst = processPosition.y - (processHeight + catalystHeight + tilingPaddingVertical);\n      var catalystNode = elementUtilities.addNode(xPosOfCatalyst, yPosOfCatalyst, {\n        \"class\": catalystType,\n        language: 'PD'\n      });\n      catalystNode.data('justAdded', true);\n      catalystNode.data('label', catalystName);\n      var catalystEdge = elementUtilities.addEdge(catalystNode.id(), processNode.id(), {\n        \"class\": 'catalysis',\n        language: 'PD'\n      });\n      catalystEdge.data('justAdded', true);\n      cy.endBatch(); //filter the just added elememts to return them and remove just added mark\n\n      var eles = cy.elements('[justAdded]');\n      eles.removeData('justAdded');\n      cy.elements().unselect();\n      eles.select();\n      return eles; // Return the just added elements\n    };\n\n    elementUtilities.createActivationReaction = function (proteinName, processPosition, edgeLength, reverse) {\n      var defaultMacromoleculProperties = elementUtilities.getDefaultProperties(\"macromolecule\");\n      var defaultProcessProperties = elementUtilities.getDefaultProperties(\"activation\");\n      var processWidth = defaultProcessProperties.width || 50;\n      var macromoleculeWidth = defaultMacromoleculProperties.width || 50;\n      var processPosition = processPosition || elementUtilities.convertToModelPosition({\n        x: cy.width() / 2,\n        y: cy.height() / 2\n      });\n      var edgeLength = edgeLength || 60;\n      cy.startBatch();\n\n      if (!elementUtilities.getMapType()) {\n        elementUtilities.setMapType(\"PD\");\n      }\n\n      var xPosOfInput = processPosition.x - edgeLength - processWidth / 2 - macromoleculeWidth / 2;\n      var xPosOfOutput = processPosition.x + edgeLength + processWidth / 2 + macromoleculeWidth / 2;\n      var processNode = elementUtilities.addNode(processPosition.x, processPosition.y, {\n        \"class\": \"process\",\n        language: \"PD\"\n      });\n      elementUtilities.setPortsOrdering(processNode, \"L-to-R\");\n      processNode.data('justAdded', true);\n      var yPosition = processPosition.y;\n      var inputNode = elementUtilities.addNode(xPosOfInput, yPosition, {\n        \"class\": \"macromolecule\",\n        language: \"PD\"\n      });\n      inputNode.data(\"justAdded\", true);\n      inputNode.data(\"label\", proteinName);\n      var infoboxObject = {\n        clazz: \"unit of information\",\n        label: {\n          text: reverse ? \"active\" : \"inactive\"\n        },\n        style: {\n          \"shape-name\": \"ellipse\"\n        },\n        bbox: {\n          w: 36,\n          h: 15\n        }\n      };\n      elementUtilities.addStateOrInfoBox(inputNode, infoboxObject);\n      var outputNode = elementUtilities.addNode(xPosOfOutput, yPosition, {\n        \"class\": \"macromolecule\",\n        language: \"PD\"\n      });\n      outputNode.data(\"justAdded\", true);\n      outputNode.data(\"label\", proteinName);\n      infoboxObject = {\n        clazz: \"unit of information\",\n        label: {\n          text: reverse ? \"inactive\" : \"active\"\n        },\n        style: {\n          \"shape-name\": \"ellipse\"\n        },\n        bbox: {\n          w: 36,\n          h: 15\n        }\n      };\n      elementUtilities.addStateOrInfoBox(outputNode, infoboxObject);\n      var inputSideEdge = elementUtilities.addEdge(inputNode.id(), processNode.id(), {\n        \"class\": \"consumption\",\n        language: \"PD\"\n      });\n      inputSideEdge.data(\"justAdded\", true);\n      var outputSideEdge = elementUtilities.addEdge(processNode.id(), outputNode.id(), {\n        \"class\": \"production\",\n        language: \"PD\"\n      });\n      outputSideEdge.data(\"justAdded\", true);\n      cy.endBatch(); //filter the just added elememts to return them and remove just added mark\n\n      var eles = cy.elements('[justAdded]');\n      eles.removeData('justAdded');\n      cy.elements().unselect();\n      eles.select();\n      return eles; // Return the just added elements\n    };\n    /*\n     * Creates a template reaction with given parameters. Requires cose-bilkent layout to tile the free macromolecules included\n     * in the complex. Parameters are explained below.\n     * templateType: The type of the template reaction. It may be 'association', 'dissociation', 'reversible' or 'irreversible'.\n     * nodeList: The list of the names and types of molecules which will involve in the reaction.\n     * complexName: The name of the complex in the reaction.\n     * processPosition: The modal position of the process in the reaction. The default value is the center of the canvas.\n     * tilingPaddingVertical: This option will be passed to the cose-bilkent layout with the same name. The default value is 15.\n     * tilingPaddingHorizontal: This option will be passed to the cose-bilkent layout with the same name. The default value is 15.\n     * edgeLength: The distance between the process and the macromolecules at the both sides.\n     */\n\n\n    elementUtilities.createTemplateReaction = function (templateType, nodeList, complexName, processPosition, tilingPaddingVertical, tilingPaddingHorizontal, edgeLength, layoutParam) {\n      var defaultMacromoleculProperties = elementUtilities.getDefaultProperties(\"macromolecule\");\n      var defaultSimpleChemicalProperties = elementUtilities.getDefaultProperties(\"simple chemical\");\n      var defaultProcessProperties = elementUtilities.getDefaultProperties(templateType);\n      var processWidth = defaultProcessProperties.width || 50;\n      var macromoleculeWidth = defaultMacromoleculProperties.width || 50;\n      var macromoleculeHeight = defaultMacromoleculProperties.height || 50;\n      var simpleChemicalWidth = defaultSimpleChemicalProperties.width || 35;\n      var simpleChemicalHeight = defaultSimpleChemicalProperties.height || 35;\n      var processPosition = processPosition || elementUtilities.convertToModelPosition({\n        x: cy.width() / 2,\n        y: cy.height() / 2\n      });\n      var nodeList = nodeList;\n      var complexName = complexName;\n      var numOfMolecules = nodeList.length;\n      var tilingPaddingVertical = tilingPaddingVertical || 15;\n      var tilingPaddingHorizontal = tilingPaddingHorizontal || 15;\n      var edgeLength = edgeLength || 60;\n      cy.startBatch();\n\n      if (!elementUtilities.getMapType()) {\n        elementUtilities.setMapType(\"PD\");\n      }\n\n      var xPositionOfFreeMacromolecules;\n      var xPositionOfInputMacromolecules;\n\n      if (templateType === 'association') {\n        xPositionOfFreeMacromolecules = processPosition.x - edgeLength - processWidth / 2 - macromoleculeWidth / 2;\n      } else if (templateType === 'dissociation') {\n        xPositionOfFreeMacromolecules = processPosition.x + edgeLength + processWidth / 2 + macromoleculeWidth / 2;\n      } else {\n        xPositionOfFreeMacromolecules = processPosition.x - edgeLength - processWidth / 2 - macromoleculeWidth / 2;\n        xPositionOfInputMacromolecules = processPosition.x + edgeLength + processWidth / 2 + macromoleculeWidth / 2;\n      } //Create the process in template type\n\n\n      var process;\n\n      if (templateType === 'reversible' || templateType === 'irreversible') {\n        process = elementUtilities.addNode(processPosition.x, processPosition.y, {\n          \"class\": 'process',\n          language: 'PD'\n        });\n        elementUtilities.setPortsOrdering(process, 'L-to-R');\n      } else {\n        process = elementUtilities.addNode(processPosition.x, processPosition.y, {\n          \"class\": templateType,\n          language: 'PD'\n        });\n        elementUtilities.setPortsOrdering(process, 'L-to-R');\n      }\n\n      process.data('justAdded', true); //Define the starting y position\n\n      var yPosition = processPosition.y - (numOfMolecules - 1) / 2 * (macromoleculeHeight + tilingPaddingVertical); //Create the free molecules\n\n      for (var i = 0; i < numOfMolecules; i++) {\n        // node addition operation is determined by molecule type\n        if (nodeList[i].type == \"Simple Chemical\") {\n          var newNode = elementUtilities.addNode(xPositionOfFreeMacromolecules, yPosition, {\n            \"class\": 'simple chemical',\n            language: 'PD'\n          }); //update the y position\n\n          yPosition += simpleChemicalHeight + tilingPaddingVertical;\n        } else {\n          var newNode = elementUtilities.addNode(xPositionOfFreeMacromolecules, yPosition, {\n            \"class\": 'macromolecule',\n            language: 'PD'\n          }); //update the y position\n\n          yPosition += macromoleculeHeight + tilingPaddingVertical;\n        }\n\n        newNode.data('justAdded', true);\n        newNode.data('label', nodeList[i].name); //create the edge connected to the new molecule\n\n        var newEdge;\n\n        if (templateType === 'association') {\n          newEdge = elementUtilities.addEdge(newNode.id(), process.id(), {\n            \"class\": 'consumption',\n            language: 'PD'\n          });\n        } else if (templateType === 'dissociation') {\n          newEdge = elementUtilities.addEdge(process.id(), newNode.id(), {\n            \"class\": 'production',\n            language: 'PD'\n          });\n        } else {\n          //Group right or top elements in group id 1\n          if (templateType === \"irreversible\") {\n            newEdge = elementUtilities.addEdge(newNode.id(), process.id(), {\n              \"class\": \"consumption\",\n              language: 'PD'\n            });\n          } else {\n            newEdge = elementUtilities.addEdge(process.id(), newNode.id(), {\n              \"class\": \"production\",\n              language: 'PD'\n            }, undefined, undefined, 1);\n          }\n        }\n\n        newEdge.data('justAdded', true);\n      }\n\n      if (templateType === 'association' || templateType == 'dissociation') {\n        //Create the complex including macromolecules inside of it\n        //Temprorarily add it to the process position we will move it according to the last size of it\n        var complex = elementUtilities.addNode(processPosition.x, processPosition.y, {\n          \"class\": 'complex',\n          language: 'PD'\n        });\n        complex.data('justAdded', true);\n        complex.data('justAddedLayoutNode', true); //If a name is specified for the complex set its label accordingly\n\n        if (complexName) {\n          complex.data('label', complexName);\n        } //create the edge connnected to the complex\n\n\n        var edgeOfComplex;\n\n        if (templateType === 'association') {\n          edgeOfComplex = elementUtilities.addEdge(process.id(), complex.id(), {\n            \"class\": 'production',\n            language: 'PD'\n          });\n        } else {\n          edgeOfComplex = elementUtilities.addEdge(complex.id(), process.id(), {\n            \"class\": 'consumption',\n            language: 'PD'\n          });\n        }\n\n        edgeOfComplex.data('justAdded', true);\n\n        for (var i = 0; i < numOfMolecules; i++) {\n          // Add a molecule(dependent on it's type) not having a previously defined id and having the complex created in this reaction as parent\n          if (nodeList[i].type == 'Simple Chemical') {\n            var newNode = elementUtilities.addNode(complex.position('x'), complex.position('y'), {\n              \"class\": 'simple chemical',\n              language: 'PD'\n            }, undefined, complex.id());\n          } else {\n            var newNode = elementUtilities.addNode(complex.position('x'), complex.position('y'), {\n              \"class\": 'macromolecule',\n              language: 'PD'\n            }, undefined, complex.id());\n          }\n\n          newNode.data('justAdded', true);\n          newNode.data('label', nodeList[i].name);\n          newNode.data('justAddedLayoutNode', true);\n        }\n      } else {\n        //Create the input macromolecules\n        var numOfInputMacromolecules = complexName.length;\n        yPosition = processPosition.y - (numOfInputMacromolecules - 1) / 2 * (macromoleculeHeight + tilingPaddingVertical);\n\n        for (var i = 0; i < numOfInputMacromolecules; i++) {\n          if (complexName[i].type == 'Simple Chemical') {\n            var newNode = elementUtilities.addNode(xPositionOfInputMacromolecules, yPosition, {\n              \"class\": 'simple chemical',\n              language: 'PD'\n            });\n            yPosition += simpleChemicalHeight + tilingPaddingVertical;\n          } else {\n            var newNode = elementUtilities.addNode(xPositionOfInputMacromolecules, yPosition, {\n              \"class\": 'macromolecule',\n              language: 'PD'\n            });\n            yPosition += macromoleculeHeight + tilingPaddingVertical;\n          }\n\n          newNode.data('justAdded', true);\n          newNode.data('label', complexName[i].name); //create the edge connected to the new macromolecule\n\n          var newEdge; //Group the left or bottom elements in group id 0 if reversible\n\n          if (templateType === \"irreversible\") {\n            newEdge = elementUtilities.addEdge(process.id(), newNode.id(), {\n              \"class\": \"production\",\n              language: 'PD'\n            });\n          } else {\n            newEdge = elementUtilities.addEdge(process.id(), newNode.id(), {\n              \"class\": \"production\",\n              language: 'PD'\n            }, undefined, undefined, 0);\n          }\n\n          newEdge.data('justAdded', true);\n        }\n      }\n\n      cy.endBatch();\n      var layoutNodes = cy.nodes('[justAddedLayoutNode]');\n      layoutNodes.removeData('justAddedLayoutNode');\n      var layout = layoutNodes.layout({\n        name: layoutParam.name,\n        randomize: false,\n        fit: false,\n        animate: false,\n        tilingPaddingVertical: tilingPaddingVertical,\n        tilingPaddingHorizontal: tilingPaddingHorizontal,\n        stop: function stop() {\n          //If it is a reversible reaction no need to re-position complexes\n          if (templateType === 'reversible') return; //re-position the nodes inside the complex\n\n          var supposedXPosition;\n          var supposedYPosition = processPosition.y;\n\n          if (templateType === 'association') {\n            supposedXPosition = processPosition.x + edgeLength + processWidth / 2 + complex.outerWidth() / 2;\n          } else {\n            supposedXPosition = processPosition.x - edgeLength - processWidth / 2 - complex.outerWidth() / 2;\n          }\n\n          var positionDiffX = (supposedXPosition - complex.position('x')) / 2;\n          var positionDiffY = (supposedYPosition - complex.position('y')) / 2;\n          elementUtilities.moveNodes({\n            x: positionDiffX,\n            y: positionDiffY\n          }, complex);\n        }\n      }); // Do this check for cytoscape.js backward compatibility\n\n      if (layout && layout.run && templateType !== 'reversible' && templateType !== 'irreversible') {\n        layout.run();\n      } //filter the just added elememts to return them and remove just added mark\n\n\n      var eles = cy.elements('[justAdded]');\n      eles.removeData('justAdded');\n      cy.elements().unselect();\n      eles.select();\n      return eles; // Return the just added elements\n    };\n    /*\n     * Move the nodes to a new parent and change their position if possDiff params are set.\n     */\n\n\n    elementUtilities.changeParent = function (nodes, newParent, posDiffX, posDiffY) {\n      var newParentId = newParent == undefined || typeof newParent === 'string' ? newParent : newParent.id();\n      var movedEles = nodes.move({\n        \"parent\": newParentId\n      });\n\n      if (typeof posDiffX != 'undefined' || typeof posDiffY != 'undefined') {\n        elementUtilities.moveNodes({\n          x: posDiffX,\n          y: posDiffY\n        }, nodes);\n      }\n\n      elementUtilities.maintainPointer(movedEles);\n      return movedEles;\n    };\n\n    elementUtilities.updateInfoboxStyle = function (node, index, newProps) {\n      var infoboxObj = node.data('statesandinfos')[index];\n      $.extend(infoboxObj.style, newProps);\n      cy.style().update();\n    };\n\n    elementUtilities.updateInfoboxObj = function (node, index, newProps) {\n      var infoboxObj = node.data('statesandinfos')[index];\n      $.extend(infoboxObj, newProps);\n    }; // Resize given nodes if useAspectRatio is truthy one of width or height should not be set.\n\n\n    elementUtilities.resizeNodes = function (nodes, width, height, useAspectRatio, preserveRelativePos) {\n      for (var i = 0; i < nodes.length; i++) {\n        var node = nodes[i];\n        var ratio = undefined;\n        var eleMustBeSquare = elementUtilities.mustBeSquare(node.data('class'));\n\n        if (preserveRelativePos === true) {\n          var oldWidth = node.data(\"bbox\").w;\n          var oldHeight = node.data(\"bbox\").h;\n        } // Note that both width and height should not be set if useAspectRatio is truthy\n\n\n        if (!node.isParent()) {\n          if (width) {\n            if (useAspectRatio || eleMustBeSquare) {\n              ratio = width / node.width();\n            }\n\n            node.data(\"bbox\").w = width;\n          }\n\n          if (height) {\n            if (useAspectRatio || eleMustBeSquare) {\n              ratio = height / node.height();\n            }\n\n            node.data(\"bbox\").h = height;\n          }\n\n          if (ratio && !height) {\n            node.data(\"bbox\").h = node.height() * ratio;\n          } else if (ratio && !width) {\n            node.data(\"bbox\").w = node.width() * ratio;\n          }\n        } else {\n          node.data(\"minHeight\", \"\" + height);\n          node.data(\"minWidth\", \"\" + width);\n          node.data(\"minWidthBiasLeft\", \"50%\");\n          node.data(\"minWidthBiasRight\", \"50%\");\n          node.data(\"minHeightBiasTop\", \"50%\");\n          node.data(\"minHeightBiasBottom\", \"50%\");\n        }\n        /*    if (preserveRelativePos === true) {\n             var statesandinfos = node.data('statesandinfos');\n             var topBottom = statesandinfos.filter(box => (box.anchorSide === \"top\" || box.anchorSide === \"bottom\"));\n             var rightLeft = statesandinfos.filter(box => (box.anchorSide === \"right\" || box.anchorSide === \"left\"));\n              topBottom.forEach(function(box){\n               if (box.bbox.x < 0) {\n                 box.bbox.x = 0;\n               }\n               else if (box.bbox.x > oldWidth) {\n                 box.bbox.x = oldWidth;\n               }\n               box.bbox.x = node.data(\"bbox\").w * box.bbox.x / oldWidth;\n             });\n              rightLeft.forEach(function(box){\n               if (box.bbox.y < 0) {\n                 box.bbox.y = 0;\n               }\n               else if (box.bbox.y > oldHeight) {\n                 box.bbox.y = oldHeight;\n               }\n               box.bbox.y = node.data(\"bbox\").h * box.bbox.y / oldHeight;\n             });\n           } */\n\n      }\n    };\n\n    elementUtilities.calculateMinWidth = function (node) {\n      var defaultWidth = this.getDefaultProperties(node.data('class')).width; // Label width calculation\n\n      var style = node.style();\n      var fontFamiliy = style['font-family'];\n      var fontSize = style['font-size'];\n      var labelText = style['label'];\n\n      if (labelText === \"\" && node.data('label') && node.data('label') !== \"\") {\n        labelText = node.data('label');\n      }\n\n      var labelWidth = elementUtilities.getWidthByContent(labelText, fontFamiliy, fontSize);\n      var statesandinfos = node.data('statesandinfos'); //Top and bottom infoBoxes\n      //var topInfoBoxes = statesandinfos.filter(box => (box.anchorSide === \"top\" || ((box.anchorSide === \"right\" || box.anchorSide === \"left\") && (box.bbox.y <= 12))));\n      //var bottomInfoBoxes = statesandinfos.filter(box => (box.anchorSide === \"bottom\" || ((box.anchorSide === \"right\" || box.anchorSide === \"left\") && (box.bbox.y >= node.data('bbox').h - 12))));\n\n      var unitGap = 5;\n      var topIdealWidth = unitGap;\n      var bottomIdealWidth = unitGap;\n      var rightMaxWidth = 0;\n      var leftMaxWidth = 0;\n      statesandinfos.forEach(function (box) {\n        if (box.anchorSide === \"top\") {\n          topIdealWidth += box.bbox.w + unitGap;\n        } else if (box.anchorSide === \"bottom\") {\n          bottomIdealWidth += box.bbox.w + unitGap;\n        } else if (box.anchorSide === \"right\") {\n          rightMaxWidth = box.bbox.w > rightMaxWidth ? box.bbox.w : rightMaxWidth;\n        } else {\n          leftMaxWidth = box.bbox.w > leftMaxWidth ? box.bbox.w : leftMaxWidth;\n        }\n      });\n      var middleWidth = labelWidth + 2 * Math.max(rightMaxWidth / 2, leftMaxWidth / 2);\n      var compoundWidth = 0;\n\n      if (node.isParent()) {\n        compoundWidth = node.children().boundingBox().w;\n      }\n\n      return Math.max(middleWidth, defaultWidth / 2, topIdealWidth, bottomIdealWidth, compoundWidth);\n    };\n\n    elementUtilities.calculateMinHeight = function (node) {\n      var statesandinfos = node.data('statesandinfos');\n      var margin = 7;\n      var unitGap = 5;\n      var defaultHeight = this.getDefaultProperties(node.data('class')).height;\n      var leftInfoBoxes = statesandinfos.filter(function (box) {\n        return box.anchorSide === \"left\";\n      });\n      var leftHeight = unitGap;\n      leftInfoBoxes.forEach(function (box) {\n        leftHeight += box.bbox.h + unitGap;\n      });\n      var rightInfoBoxes = statesandinfos.filter(function (box) {\n        return box.anchorSide === \"right\";\n      });\n      var rightHeight = unitGap;\n      rightInfoBoxes.forEach(function (box) {\n        rightHeight += box.bbox.h + unitGap;\n      });\n      var style = node.style();\n      var labelText = style['label'].split(\"\\n\").filter(function (text) {\n        return text !== '';\n      });\n      var fontSize = parseFloat(style['font-size'].substring(0, style['font-size'].length - 2));\n      var totalHeight = labelText.length * fontSize + 2 * margin;\n      var compoundHeight = 0;\n\n      if (node.isParent()) {\n        compoundHeight = node.children().boundingBox().h;\n      }\n\n      return Math.max(totalHeight, defaultHeight / 2, leftHeight, rightHeight, compoundHeight);\n    };\n\n    elementUtilities.isResizedToContent = function (node) {\n      if (!node || !node.isNode() || !node.data('bbox')) {\n        return false;\n      } //var w = node.data('bbox').w;\n      //var h = node.data('bbox').h;\n\n\n      var w = node.width();\n      var h = node.height();\n      var minW = elementUtilities.calculateMinWidth(node);\n      var minH = elementUtilities.calculateMinHeight(node);\n      if (w === minW && h === minH) return true;else return false;\n    }; // Section End\n    // Add remove utilities\n    // Relocates state and info boxes. This function is expected to be called after add/remove state and info boxes\n\n\n    elementUtilities.relocateStateAndInfos = function (ele) {\n      var stateAndInfos = ele.isNode && ele.isNode() ? ele.data('statesandinfos') : ele;\n      var length = stateAndInfos.length;\n\n      if (length == 0) {\n        return;\n      } else if (length == 1) {\n        stateAndInfos[0].bbox.x = 0;\n        stateAndInfos[0].bbox.y = -50;\n      } else if (length == 2) {\n        stateAndInfos[0].bbox.x = 0;\n        stateAndInfos[0].bbox.y = -50;\n        stateAndInfos[1].bbox.x = 0;\n        stateAndInfos[1].bbox.y = 50;\n      } else if (length == 3) {\n        stateAndInfos[0].bbox.x = -25;\n        stateAndInfos[0].bbox.y = -50;\n        stateAndInfos[1].bbox.x = 25;\n        stateAndInfos[1].bbox.y = -50;\n        stateAndInfos[2].bbox.x = 0;\n        stateAndInfos[2].bbox.y = 50;\n      } else {\n        stateAndInfos[0].bbox.x = -25;\n        stateAndInfos[0].bbox.y = -50;\n        stateAndInfos[1].bbox.x = 25;\n        stateAndInfos[1].bbox.y = -50;\n        stateAndInfos[2].bbox.x = -25;\n        stateAndInfos[2].bbox.y = 50;\n        stateAndInfos[3].bbox.x = 25;\n        stateAndInfos[3].bbox.y = 50;\n      }\n    }; // Change state value or unit of information box of given nodes with given index.\n    // Type parameter indicates whether to change value or variable, it is valid if the box at the given index is a state variable.\n    // Value parameter is the new value to set.\n    // This method returns the old value of the changed data (We assume that the old value of the changed data was the same for all nodes).\n    // Each character assumed to occupy 8 unit\n    // Each infobox can have at most 32 units of width\n\n\n    elementUtilities.changeStateOrInfoBox = function (nodes, index, value, type) {\n      var result;\n\n      for (var i = 0; i < nodes.length; i++) {\n        var node = nodes[i];\n        var sbgnclass = node.data('class');\n        var stateAndInfos = node.data('statesandinfos');\n        var box = stateAndInfos[index];\n        var oldLength = box.bbox.w;\n        var newLength = 0;\n        var content = '';\n\n        if (box.clazz == \"state variable\") {\n          if (!result) {\n            result = box.state[type];\n          }\n\n          box.state[type] = value;\n\n          if (box.state[\"value\"] !== undefined) {\n            content += box.state[\"value\"];\n          }\n\n          if (box.state[\"variable\"] !== undefined && box.state[\"variable\"].length > 0) {\n            content += box.state[\"variable\"] + \"@\";\n          }\n        } else if (box.clazz == \"unit of information\") {\n          if (!result) {\n            result = box.label.text;\n          }\n\n          content += value;\n          box.label.text = value;\n        }\n\n        var min = sbgnclass === 'SIF macromolecule' || sbgnclass === 'SIF simple chemical' ? 15 : 12;\n        var fontFamily = box.style['font-family'];\n        var fontSize = box.style['font-size'];\n        var borderWidth = box.style['border-width'];\n        var opts = {\n          min: min,\n          max: 48,\n          margin: borderWidth / 2 + 0.5\n        };\n        var previousWidth = box.bbox.w;\n        box.bbox.w = elementUtilities.getWidthByContent(content, fontFamily, fontSize, opts);\n\n        if (box.anchorSide == \"top\" || box.anchorSide == \"bottom\") {\n          var unitLayout = node.data()[\"auxunitlayouts\"][box.anchorSide];\n\n          if (unitLayout.units[unitLayout.units.length - 1].id == box.id) {\n            var borderWidth = node.data()['border-width'];\n            var shiftAmount = (box.bbox.w - previousWidth) / 2 * 100 / (node.outerWidth() - borderWidth);\n\n            if (shiftAmount >= 0) {\n              if (box.bbox.x + shiftAmount <= 100) {\n                box.bbox.x = box.bbox.x + shiftAmount;\n              }\n            }\n            /*  else{\n               var previousInfoBbox = {x : 0, w:0};\n               if(unitLayout.units.length > 1){\n                 previousInfoBbox= unitLayout.units[unitLayout.units.length-2].bbox;      \n               }\n                \n               \n               sbgnvizInstance.classes.AuxUnitLayout.setIdealGap(node, box.anchorSide);\n               var idealGap = sbgnvizInstance.classes.AuxUnitLayout.getCurrentGap(box.anchorSide);\n               var newPosition = previousInfoBbox.x + (previousInfoBbox.w/2 + idealGap + box.bbox.w/2)*100 / (node.outerWidth() - borderWidth);\n               box.bbox.x = newPosition;\n               \n             } */\n\n          }\n        }\n        /* if (box.anchorSide === \"top\" || box.anchorSide === \"bottom\") {\n          box.bbox.x += (box.bbox.w - oldLength) / 2;\n          var units = (node.data('auxunitlayouts')[box.anchorSide]).units;\n          var shiftIndex = 0;\n          for (var i = 0; i < units.length; i++) {\n            if(units[i] === box){\n              shiftIndex = i;\n              break;\n            }\n          }\n          for (var j = shiftIndex+1; j < units.length; j++) {\n              units[j].bbox.x += (box.bbox.w - oldLength);\n          }\n        } */\n\n      } //TODO find a way to elimate this redundancy to update info-box positions\n\n\n      node.data('border-width', node.data('border-width'));\n      return result;\n    }; // Add a new state or info box to given nodes.\n    // The box is represented by the parameter obj.\n    // This method returns the index of the just added box.\n\n\n    elementUtilities.addStateOrInfoBox = function (nodes, obj) {\n      for (var i = 0; i < nodes.length; i++) {\n        var node = nodes[i];\n        var locationObj;\n        var defaultProps = elementUtilities.getDefaultProperties(node.data('class'));\n        var infoboxProps = defaultProps[obj.clazz];\n        var bbox = obj.bbox || {\n          w: infoboxProps.width,\n          h: infoboxProps.height\n        };\n        var style = elementUtilities.getDefaultInfoboxStyle(node.data('class'), obj.clazz);\n\n        if (obj.style) {\n          $.extend(style, obj.style);\n        }\n\n        if (obj.clazz == \"unit of information\") {\n          locationObj = sbgnvizInstance.classes.UnitOfInformation.create(node, cy, obj.label.text, bbox, obj.location, obj.position, style, obj.index, obj.id);\n        } else if (obj.clazz == \"state variable\") {\n          locationObj = sbgnvizInstance.classes.StateVariable.create(node, cy, obj.state.value, obj.state.variable, bbox, obj.location, obj.position, style, obj.index, obj.id);\n        }\n      }\n\n      return locationObj;\n    }; // Remove the state or info boxes of the given nodes at given index.\n    // Returns the removed box.\n\n\n    elementUtilities.removeStateOrInfoBox = function (nodes, locationObj) {\n      var obj;\n\n      for (var i = 0; i < nodes.length; i++) {\n        var node = nodes[i];\n        var stateAndInfos = node.data('statesandinfos');\n        var unit = stateAndInfos[locationObj.index];\n        var unitClass = sbgnvizInstance.classes.getAuxUnitClass(unit);\n        obj = unitClass.remove(unit, cy);\n      }\n\n      return obj;\n    }; //Tiles informations boxes for given anchorSides\n\n\n    elementUtilities.fitUnits = function (node, locations) {\n      var obj = [];\n      node.data('statesandinfos').forEach(function (ele) {\n        obj.push({\n          x: ele.bbox.x,\n          y: ele.bbox.y,\n          anchorSide: ele.anchorSide\n        });\n      });\n      sbgnvizInstance.classes.AuxUnitLayout.fitUnits(node, cy, locations);\n      return obj;\n    }; //Check which anchorsides fits\n\n\n    elementUtilities.checkFit = function (node, location) {\n      //if no location given, it checks all possible locations\n      return sbgnvizInstance.classes.AuxUnitLayout.checkFit(node, cy, location);\n    }; //Modify array of aux layout units\n\n\n    elementUtilities.modifyUnits = function (node, unit, anchorSide) {\n      sbgnvizInstance.classes.AuxUnitLayout.modifyUnits(node, unit, anchorSide, cy);\n    }; // Set multimer status of the given nodes to the given status.\n\n\n    elementUtilities.setMultimerStatus = function (nodes, status) {\n      for (var i = 0; i < nodes.length; i++) {\n        var node = nodes[i];\n        var sbgnclass = node.data('class');\n        var isMultimer = node.data('class').endsWith(' multimer');\n\n        if (status) {\n          // Make multimer status true\n          if (!isMultimer) {\n            node.data('class', sbgnclass + ' multimer');\n          }\n        } else {\n          // Make multimer status false\n          if (isMultimer) {\n            node.data('class', sbgnclass.replace(' multimer', ''));\n          }\n        }\n      }\n    }; // Change font properties of the given elements with given font data\n\n\n    elementUtilities.changeFontProperties = function (eles, data) {\n      for (var prop in data) {\n        eles.data(prop, data[prop]);\n      }\n    }; // This function gets an edge, and ends of that edge (Optionally it may take just the classes of the edge as well) as parameters.\n    // It may return 'valid' (that ends is valid for that edge), 'reverse' (that ends is not valid for that edge but they would be valid\n    // if you reverse the source and target), 'invalid' (that ends are totally invalid for that edge).\n\n\n    elementUtilities.validateArrowEnds = function (edge, source, target, isReplacement) {\n      // if map type is Unknown -- no rules applied\n      if (elementUtilities.getMapType() == \"HybridAny\" || elementUtilities.getMapType() == \"HybridSbgn\" || !elementUtilities.getMapType()) return \"valid\";\n      var edgeclass = typeof edge === 'string' ? edge : edge.data('class');\n      var sourceclass = source.data('class');\n      var targetclass = target.data('class');\n      var mapType = elementUtilities.getMapType();\n      var edgeConstraints = elementUtilities[mapType].connectivityConstraints[edgeclass];\n\n      if (mapType == \"AF\") {\n        if (sourceclass.startsWith(\"BA\")) // we have separate classes for each biological activity\n          sourceclass = \"biological activity\"; // but same rule applies to all of them\n\n        if (targetclass.startsWith(\"BA\")) // we have separate classes for each biological activity\n          targetclass = \"biological activity\"; // but same rule applies to all of them\n      } else if (mapType == \"PD\") {\n        sourceclass = sourceclass.replace(/\\s*multimer$/, '');\n        targetclass = targetclass.replace(/\\s*multimer$/, '');\n      } // given a node, acting as source or target, returns boolean wether or not it has too many edges already\n\n\n      function hasTooManyEdges(node, sourceOrTarget) {\n        var nodeclass = node.data('class');\n        nodeclass = nodeclass.replace(/\\s*multimer$/, '');\n        if (nodeclass.startsWith(\"BA\")) nodeclass = \"biological activity\";\n        /*\n          On the logic below:\n           Current edge count (incoming or outgoing) of nodes should be strictly less \n          than the maximum allowed if we are adding an edge to the node. This way\n          it will never exceed the max count.\n          \n          Edges can be added in two different ways. Either they are added directly or\n          they are added by being replaced from another node, i.e disconnected from\n          one and connected to another.\n           We can detect if the edge being added is added from a replacement by checking\n          whether the source stayed the same when checking edge counts of the source node,\n          and whether the target stayed the same when checking edge counts of the\n          target node.\n           Current edge count of nodes can be allowed to be equal to the maximum in \n          cases where a replacement is made. But we should be careful that this\n          replacement operation is not also an addition operation as described above.\n        */\n\n        var totalTooMany = true;\n        var edgeTooMany = true;\n\n        if (sourceOrTarget == \"source\") {\n          var sameEdgeCountOut = node.outgoers('edge[class=\"' + edgeclass + '\"]').size();\n          var totalEdgeCountOut = node.outgoers('edge').size();\n          var maxTotal = edgeConstraints[nodeclass].asSource.maxTotal;\n          var maxEdge = edgeConstraints[nodeclass].asSource.maxEdge;\n          var compareStrict = !(isReplacement && edge.source() === source);\n          var withinLimits = !maxTotal || compareStrict && totalEdgeCountOut < maxTotal || !compareStrict && totalEdgeCountOut <= maxTotal;\n\n          if (withinLimits) {\n            totalTooMany = false;\n          } // then check limits for this specific edge class\n\n\n          withinLimits = !maxEdge || compareStrict && sameEdgeCountOut < maxEdge || !compareStrict && sameEdgeCountOut <= maxEdge;\n\n          if (withinLimits) {\n            edgeTooMany = false;\n          } // if only one of the limits is reached then edge is invalid\n\n\n          return totalTooMany || edgeTooMany;\n        } else {\n          // node is used as target\n          var sameEdgeCountIn = node.incomers('edge[class=\"' + edgeclass + '\"]').size();\n          var totalEdgeCountIn = node.incomers('edge').size();\n          var maxTotal = edgeConstraints[nodeclass].asTarget.maxTotal;\n          var maxEdge = edgeConstraints[nodeclass].asTarget.maxEdge;\n          var compareStrict = !(isReplacement && edge.target() === target);\n          var withinLimits = !maxTotal || compareStrict && totalEdgeCountIn < maxTotal || !compareStrict && totalEdgeCountIn <= maxTotal;\n\n          if (withinLimits) {\n            totalTooMany = false;\n          }\n\n          withinLimits = !maxEdge || compareStrict && sameEdgeCountIn < maxEdge || !compareStrict && sameEdgeCountIn <= maxEdge;\n\n          if (withinLimits) {\n            edgeTooMany = false;\n          }\n\n          return totalTooMany || edgeTooMany;\n        }\n      }\n\n      function isInComplex(node) {\n        var parentClass = node.parent().data('class');\n        return parentClass && parentClass.startsWith('complex');\n      }\n\n      if (isInComplex(source) || isInComplex(target)) {\n        // subunits of a complex are no longer EPNs, no connection allowed\n        return 'invalid';\n      } // check nature of connection\n\n\n      if (edgeConstraints[sourceclass].asSource.isAllowed && edgeConstraints[targetclass].asTarget.isAllowed) {\n        // check amount of connections\n        if (!hasTooManyEdges(source, \"source\") && !hasTooManyEdges(target, \"target\")) {\n          return 'valid';\n        }\n      } // try to reverse\n\n\n      if (edgeConstraints[targetclass].asSource.isAllowed && edgeConstraints[sourceclass].asTarget.isAllowed) {\n        if (!hasTooManyEdges(target, \"source\") && !hasTooManyEdges(source, \"target\")) {\n          return 'reverse';\n        }\n      }\n\n      return 'invalid';\n    };\n\n    elementUtilities.deleteAndPerformLayout = function (eles, layoutparam) {\n      var result = eles.remove();\n\n      if (typeof layoutparam === 'function') {\n        layoutparam(); // If layoutparam is a function execute it\n      } else {\n        var layout = cy.layout(layoutparam); // If layoutparam is layout options call layout with that options.\n        // Do this check for cytoscape.js backward compatibility\n\n        if (layout && layout.run) {\n          layout.run();\n        }\n      }\n\n      return result;\n    };\n    /*\n     * Hide given eles and perform given layout afterward. Layout parameter may be layout options\n     * or a function to call.\n     */\n\n\n    elementUtilities.hideAndPerformLayout = function (eles, layoutparam) {\n      var result = cy.viewUtilities().hide(eles); // Hide given eles\n\n      if (typeof layoutparam === 'function') {\n        layoutparam(); // If layoutparam is a function execute it\n      } else {\n        var layout = cy.layout(layoutparam); // If layoutparam is layout options call layout with that options.\n        // Do this check for cytoscape.js backward compatibility\n\n        if (layout && layout.run) {\n          layout.run();\n        }\n      }\n\n      return result;\n    };\n    /*\n     * Unhide given eles and perform given layout afterward. Layout parameter may be layout options\n     * or a function to call.\n     */\n\n\n    elementUtilities.showAndPerformLayout = function (eles, layoutparam) {\n      var result = cy.viewUtilities().show(eles); // Show given eles\n\n      if (typeof layoutparam === 'function') {\n        layoutparam(); // If layoutparam is a function execute it\n      } else {\n        var layout = cy.layout(layoutparam); // If layoutparam is layout options call layout with that options.\n        // Do this check for cytoscape.js backward compatibility\n\n        if (layout && layout.run) {\n          layout.run();\n        }\n      }\n\n      return result;\n    };\n    /*\n     * Change style/css of given eles by setting getting property name to the given value/values (Note that valueMap parameter may be\n     * a single string or an id to value map).\n     */\n\n\n    elementUtilities.changeCss = function (eles, name, valueMap) {\n      if (_typeof(valueMap) === 'object') {\n        cy.startBatch();\n\n        for (var i = 0; i < eles.length; i++) {\n          var ele = cy.getElementById(eles[i].id());\n          ele.css(name, valueMap[ele.id()]); // valueMap is an id to value map use it in this way\n        }\n\n        cy.endBatch();\n      } else {\n        eles.css(name, valueMap); // valueMap is just a string set css('name') for all eles to this value\n      }\n    };\n    /*\n     * Change data of given eles by setting getting property name to the given value/values (Note that valueMap parameter may be\n     * a single string or an id to value map).\n     */\n\n\n    elementUtilities.changeData = function (eles, name, valueMap) {\n      if (_typeof(valueMap) === 'object') {\n        cy.startBatch();\n\n        for (var i = 0; i < eles.length; i++) {\n          var ele = cy.getElementById(eles[i].id());\n          ele.data(name, valueMap[ele.id()]); // valueMap is an id to value map use it in this way\n        }\n\n        cy.endBatch();\n      } else {\n        eles.data(name, valueMap); // valueMap is just a string set css('name') for all eles to this value\n      }\n    };\n\n    elementUtilities.updateSetField = function (ele, fieldName, toDelete, toAdd, callback) {\n      var set = ele.data(fieldName);\n\n      if (!set) {\n        return;\n      }\n\n      var updates = {};\n\n      if (toDelete != null && set[toDelete]) {\n        delete set[toDelete];\n        updates.deleted = toDelete;\n      }\n\n      if (toAdd != null) {\n        set[toAdd] = true;\n        updates.added = toAdd;\n      }\n\n      if (callback && (updates['deleted'] != null || updates['added'] != null)) {\n        callback();\n      }\n\n      return updates;\n    };\n    /*\n     * Return the set of all nodes present under the given position\n     * renderedPos must be a point defined relatively to cytoscape container\n     * (like renderedPosition field of a node)\n     */\n\n\n    elementUtilities.getNodesAt = function (renderedPos) {\n      var nodes = cy.nodes();\n      var x = renderedPos.x;\n      var y = renderedPos.y;\n      var resultNodes = [];\n\n      for (var i = 0; i < nodes.length; i++) {\n        var node = nodes[i];\n        var renderedBbox = node.renderedBoundingBox({\n          includeNodes: true,\n          includeEdges: false,\n          includeLabels: false,\n          includeShadows: false\n        });\n\n        if (x >= renderedBbox.x1 && x <= renderedBbox.x2) {\n          if (y >= renderedBbox.y1 && y <= renderedBbox.y2) {\n            resultNodes.push(node);\n          }\n        }\n      }\n\n      return resultNodes;\n    };\n\n    elementUtilities.demultimerizeClass = function (sbgnclass) {\n      return sbgnclass.replace(\" multimer\", \"\");\n    };\n    /**\n     * @param mapType - type of the current map (PD, AF or Unknown)\n     */\n\n\n    elementUtilities.setMapType = function (mapType) {\n      elementUtilities.mapType = mapType;\n      return mapType;\n    };\n    /**\n     * return - map type\n     */\n\n\n    elementUtilities.getMapType = function () {\n      return elementUtilities.mapType;\n    };\n    /**\n     * Resets map type\n     */\n\n\n    elementUtilities.resetMapType = function () {\n      elementUtilities.mapType = undefined;\n    };\n    /**\n     * Keep consistency of links to self inside the data() structure.\n     * This is needed whenever a node changes parents, for example,\n     * as it is destroyed and recreated. But the data() stays identical.\n     * This creates inconsistencies for the pointers stored in data(),\n     * as they now point to a deleted node.\n     */\n\n\n    elementUtilities.maintainPointer = function (eles) {\n      eles.nodes().forEach(function (ele) {\n        // restore background images\n        ele.emit('data'); // skip nodes without any auxiliary units\n\n        if (!ele.data('statesandinfos') || ele.data('statesandinfos').length == 0) {\n          return;\n        }\n\n        for (var side in ele.data('auxunitlayouts')) {\n          ele.data('auxunitlayouts')[side].parentNode = ele.id();\n        }\n\n        for (var i = 0; i < ele.data('statesandinfos').length; i++) {\n          ele.data('statesandinfos')[i].parent = ele.id();\n        }\n      });\n    };\n\n    elementUtilities.anyHasBackgroundImage = function (eles) {\n      var obj = elementUtilities.getBackgroundImageObjs(eles);\n      if (obj === undefined) return false;else {\n        for (var key in obj) {\n          var value = obj[key];\n          if (value && !$.isEmptyObject(value)) return true;\n        }\n\n        return false;\n      }\n    };\n\n    elementUtilities.hasBackgroundImage = function (ele) {\n      if (!ele.isNode() || !ele.data('background-image')) {\n        return false;\n      }\n\n      var bg;\n\n      if (typeof ele.data('background-image') === \"string\") {\n        bg = ele.data('background-image').split(\" \");\n      } else if (Array.isArray(obj['background-image'])) {\n        bg = ele.data('background-image');\n      }\n\n      if (!bg) return false;\n      var cloneImg = 'data:image/svg+xml;utf8,%3Csvg%20width%3D%22100%22%20height%3D%22100%22%20viewBox%3D%220%200%20100%20100%22%20style%3D%22fill%3Anone%3Bstroke%3Ablack%3Bstroke-width%3A0%3B%22%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20%3E%3Crect%20x%3D%220%22%20y%3D%220%22%20width%3D%22100%22%20height%3D%22100%22%20style%3D%22fill%3A%23838383%22/%3E%20%3C/svg%3E'; // If cloneImg is not the only image or there are multiple images there is a background image\n\n      var onlyHasCloneMarkerAsBgImage = bg.length === 1 && bg.indexOf(cloneImg) === 0;\n      if (bg.length > 1 || !onlyHasCloneMarkerAsBgImage) return true;\n      return false;\n    };\n\n    elementUtilities.getBackgroundImageURL = function (eles) {\n      if (!eles || eles.length < 1) return;\n      var commonURL = \"\";\n\n      for (var i = 0; i < eles.length; i++) {\n        var ele = eles[i];\n        if (!ele.isNode() || !elementUtilities.hasBackgroundImage(ele)) return;\n        var url = ele.data('background-image').split(\" \").pop();\n        if (!url || url.indexOf('http') !== 0 || commonURL !== \"\" && commonURL !== url) return;else if (commonURL === \"\") commonURL = url;\n      }\n\n      return commonURL;\n    };\n\n    elementUtilities.getBackgroundImageObjs = function (eles) {\n      if (!eles || eles.length < 1) return;\n      var list = {};\n\n      for (var i = 0; i < eles.length; i++) {\n        var ele = eles[i];\n        var obj = getBgObj(ele);\n        if (Object.keys(obj).length < 1) return;\n        list[ele.data('id')] = obj;\n      }\n\n      return list;\n\n      function getBgObj(ele) {\n        if (ele.isNode() && elementUtilities.hasBackgroundImage(ele)) {\n          var keys = ['background-image', 'background-fit', 'background-image-opacity', 'background-position-x', 'background-position-y', 'background-height', 'background-width'];\n          var obj = {};\n          keys.forEach(function (key) {\n            var value;\n\n            if (ele.data(key) && typeof ele.data(key) === \"string\") {\n              value = ele.data(key).split(\" \")[0];\n            } else {\n              value = ele.data(key);\n            }\n\n            obj[key] = value;\n          });\n          return obj;\n        } else if (ele.isNode()) return {};\n      }\n    };\n\n    elementUtilities.getBackgroundFitOptions = function (eles) {\n      if (!eles || eles.length < 1) return;\n      var commonFit = \"\";\n\n      for (var i = 0; i < eles.length; i++) {\n        var node = eles[i];\n        if (!node.isNode()) return;\n        var fit = getFitOption(node);\n        if (!fit || commonFit !== \"\" && fit !== commonFit) return;else if (commonFit === \"\") commonFit = fit;\n      }\n\n      var options = '<option value=\"none\">None</option>' + '<option value=\"fit\">Fit</option>' + '<option value=\"cover\">Cover</option>' + '<option value=\"contain\">Contain</option>';\n      var searchKey = 'value=\"' + commonFit + '\"';\n      var index = options.indexOf(searchKey) + searchKey.length;\n      return options.substr(0, index) + ' selected' + options.substr(index);\n\n      function getFitOption(node) {\n        if (!elementUtilities.hasBackgroundImage(node)) return;\n        var f = node.data('background-fit');\n        var h = node.data('background-height');\n        if (!f || !h) return;\n        f = f.split(\" \");\n        h = h.split(\" \");\n        if (f[f.length - 1] === \"none\") return h[h.length - 1] === \"auto\" ? \"none\" : \"fit\";else return f[f.length - 1];\n      }\n    };\n\n    elementUtilities.updateBackgroundImage = function (nodes, bgObj) {\n      if (!nodes || nodes.length == 0 || !bgObj) return;\n\n      for (var i = 0; i < nodes.length; i++) {\n        var node = nodes[i];\n        var obj = bgObj[node.data('id')];\n        if (!obj || $.isEmptyObject(obj)) continue;\n        var imgs = node.data('background-image') ? node.data('background-image').split(\" \") : [];\n        var xPos = node.data('background-position-x') ? node.data('background-position-x').split(\" \") : [];\n        var yPos = node.data('background-position-y') ? node.data('background-position-y').split(\" \") : [];\n        var widths = node.data('background-width') ? node.data('background-width').split(\" \") : [];\n        var heights = node.data('background-height') ? node.data('background-height').split(\" \") : [];\n        var fits = node.data('background-fit') ? node.data('background-fit').split(\" \") : [];\n        var opacities = node.data('background-image-opacity') ? (\"\" + node.data('background-image-opacity')).split(\" \") : [];\n        var index = -1;\n        if (typeof obj['background-image'] === \"string\") index = imgs.indexOf(obj['background-image']);else if (Array.isArray(obj['background-image'])) index = imgs.indexOf(obj['background-image'][0]);\n        if (index < 0) continue;\n\n        if (obj['background-image'] && imgs.length > index) {\n          var tmp = imgs[index];\n          imgs[index] = obj['background-image'];\n          obj['background-image'] = tmp;\n        }\n\n        if (obj['background-fit'] && fits.length > index) {\n          var tmp = fits[index];\n          fits[index] = obj['background-fit'];\n          obj['background-fit'] = tmp;\n        }\n\n        if (obj['background-width'] && widths.length > index) {\n          var tmp = widths[index];\n          widths[index] = obj['background-width'];\n          obj['background-width'] = tmp;\n        }\n\n        if (obj['background-height'] && heights.length > index) {\n          var tmp = heights[index];\n          heights[index] = obj['background-height'];\n          obj['background-height'] = tmp;\n        }\n\n        if (obj['background-position-x'] && xPos.length > index) {\n          var tmp = xPos[index];\n          xPos[index] = obj['background-position-x'];\n          obj['background-position-x'] = tmp;\n        }\n\n        if (obj['background-position-y'] && yPos.length > index) {\n          var tmp = yPos[index];\n          yPos[index] = obj['background-position-y'];\n          obj['background-position-y'] = tmp;\n        }\n\n        if (obj['background-image-opacity'] && opacities.length > index) {\n          var tmp = opacities[index];\n          opacities[index] = obj['background-image-opacity'];\n          obj['background-image-opacity'] = tmp;\n        }\n\n        node.data('background-image', imgs.join(\" \"));\n        node.data('background-position-x', xPos.join(\" \"));\n        node.data('background-position-y', yPos.join(\" \"));\n        node.data('background-width', widths.join(\" \"));\n        node.data('background-height', heights.join(\" \"));\n        node.data('background-fit', fits.join(\" \"));\n        node.data('background-image-opacity', opacities.join(\" \"));\n      }\n\n      return bgObj;\n    };\n\n    elementUtilities.changeBackgroundImage = function (nodes, oldImg, newImg, firstTime, updateInfo, promptInvalidImage, validateURL) {\n      if (!nodes || nodes.length == 0 || !oldImg || !newImg) return;\n      elementUtilities.removeBackgroundImage(nodes, oldImg);\n\n      for (var key in newImg) {\n        newImg[key]['firstTime'] = firstTime;\n      }\n\n      elementUtilities.addBackgroundImage(nodes, newImg, updateInfo, promptInvalidImage, validateURL);\n      return {\n        nodes: nodes,\n        oldImg: newImg,\n        newImg: oldImg,\n        firstTime: false,\n        promptInvalidImage: promptInvalidImage,\n        validateURL: validateURL\n      };\n    }; // Add a background image to given nodes.\n\n\n    elementUtilities.addBackgroundImage = function (nodes, bgObj, updateInfo, promptInvalidImage, validateURL) {\n      if (!nodes || nodes.length == 0 || !bgObj) return;\n\n      for (var i = 0; i < nodes.length; i++) {\n        var node = nodes[i];\n        var obj = bgObj[node.data('id')];\n        if (!obj || $.isEmptyObject(obj)) continue; // Load the image from local, else just put the URL\n\n        if (obj['fromFile']) loadBackgroundThenApply(node, obj); // Validity of given URL should be checked before applying it\n        else if (obj['firstTime']) {\n            if (typeof validateURL === 'function') validateURL(node, obj, applyBackground, promptInvalidImage);else checkGivenURL(node, obj);\n          } else applyBackground(node, obj);\n      }\n\n      function loadBackgroundThenApply(node, bgObj) {\n        var reader = new FileReader();\n        var imgFile = bgObj['background-image']; // Check whether given file is an image file\n\n        if (imgFile.type.indexOf(\"image\") !== 0) {\n          if (promptInvalidImage) promptInvalidImage(\"Invalid image file is given!\");\n          return;\n        }\n\n        reader.readAsDataURL(imgFile);\n\n        reader.onload = function (e) {\n          var img = reader.result;\n\n          if (img) {\n            bgObj['background-image'] = img;\n            bgObj['fromFile'] = false;\n            applyBackground(node, bgObj);\n          } else {\n            if (promptInvalidImage) promptInvalidImage(\"Given file could not be read!\");\n          }\n        };\n      }\n\n      function checkGivenURL(node, bgObj) {\n        var url = bgObj['background-image'];\n        var extension = url.split(/[?#]/)[0].split(\".\").pop();\n        var validExtensions = [\"png\", \"svg\", \"jpg\", \"jpeg\"];\n\n        if (!validExtensions.includes(extension)) {\n          if (typeof promptInvalidImage === 'function') promptInvalidImage(\"Invalid URL is given!\");\n          return;\n        }\n\n        $.ajax({\n          url: url,\n          type: 'GET',\n          success: function success(result, status, xhr) {\n            applyBackground(node, bgObj);\n          },\n          error: function error(xhr, status, _error) {\n            if (promptInvalidImage) promptInvalidImage(\"Invalid URL is given!\");\n          }\n        });\n      }\n\n      function applyBackground(node, bgObj) {\n        if (elementUtilities.hasBackgroundImage(node)) return;\n        var imgs = node.data('background-image') ? node.data('background-image').split(\" \") : [];\n        var xPos = node.data('background-position-x') ? node.data('background-position-x').split(\" \") : [];\n        var yPos = node.data('background-position-y') ? node.data('background-position-y').split(\" \") : [];\n        var widths = node.data('background-width') ? node.data('background-width').split(\" \") : [];\n        var heights = node.data('background-height') ? node.data('background-height').split(\" \") : [];\n        var fits = node.data('background-fit') ? node.data('background-fit').split(\" \") : [];\n        var opacities = node.data('background-image-opacity') ? (\"\" + node.data('background-image-opacity')).split(\" \") : [];\n        var indexToInsert = imgs.length; // insert to length-1\n\n        if (elementUtilities.hasCloneMarker(imgs)) {\n          indexToInsert--;\n        }\n\n        imgs.splice(indexToInsert, 0, bgObj['background-image']);\n        fits.splice(indexToInsert, 0, bgObj['background-fit']);\n        opacities.splice(indexToInsert, 0, bgObj['background-image-opacity']);\n        xPos.splice(indexToInsert, 0, bgObj['background-position-x']);\n        yPos.splice(indexToInsert, 0, bgObj['background-position-y']);\n        widths.splice(indexToInsert, 0, bgObj['background-width']);\n        heights.splice(indexToInsert, 0, bgObj['background-height']);\n        node.data('background-image', imgs.join(\" \"));\n        node.data('background-position-x', xPos.join(\" \"));\n        node.data('background-position-y', yPos.join(\" \"));\n        node.data('background-width', widths.join(\" \"));\n        node.data('background-height', heights.join(\" \"));\n        node.data('background-fit', fits.join(\" \"));\n        node.data('background-image-opacity', opacities.join(\" \"));\n        bgObj['firstTime'] = false;\n        if (updateInfo) updateInfo();\n      }\n    };\n\n    elementUtilities.hasCloneMarker = function (imgs) {\n      var cloneImg = 'data:image/svg+xml;utf8,%3Csvg%20width%3D%22100%22%20height%3D%22100%22%20viewBox%3D%220%200%20100%20100%22%20style%3D%22fill%3Anone%3Bstroke%3Ablack%3Bstroke-width%3A0%3B%22%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20%3E%3Crect%20x%3D%220%22%20y%3D%220%22%20width%3D%22100%22%20height%3D%22100%22%20style%3D%22fill%3A%23838383%22/%3E%20%3C/svg%3E';\n      return imgs.indexOf(cloneImg) > -1;\n    }; // Remove a background image from given nodes.\n\n\n    elementUtilities.removeBackgroundImage = function (nodes, bgObj) {\n      if (!nodes || nodes.length == 0 || !bgObj) return;\n\n      for (var i = 0; i < nodes.length; i++) {\n        var node = nodes[i];\n        var obj = bgObj[node.data('id')];\n        if (!obj) continue;\n        var imgs = node.data('background-image') ? node.data('background-image').split(\" \") : [];\n        var xPos = node.data('background-position-x') ? node.data('background-position-x').split(\" \") : [];\n        var yPos = node.data('background-position-y') ? node.data('background-position-y').split(\" \") : [];\n        var widths = node.data('background-width') ? node.data('background-width').split(\" \") : [];\n        var heights = node.data('background-height') ? node.data('background-height').split(\" \") : [];\n        var fits = node.data('background-fit') ? node.data('background-fit').split(\" \") : [];\n        var opacities = node.data('background-image-opacity') ? (\"\" + node.data('background-image-opacity')).split(\" \") : [];\n        var index = -1;\n        if (typeof obj['background-image'] === \"string\") index = imgs.indexOf(obj['background-image'].split(\" \")[0]);else if (Array.isArray(obj['background-image'])) index = imgs.indexOf(obj['background-image'][0]);\n\n        if (index > -1) {\n          imgs.splice(index, 1);\n          fits.splice(index, 1);\n          opacities.splice(index, 1);\n          xPos.splice(index, 1);\n          yPos.splice(index, 1);\n          widths.splice(index, 1);\n          heights.splice(index, 1);\n        }\n\n        node.data('background-image', imgs.join(\" \"));\n        node.data('background-position-x', xPos.join(\" \"));\n        node.data('background-position-y', yPos.join(\" \"));\n        node.data('background-width', widths.join(\" \"));\n        node.data('background-height', heights.join(\" \"));\n        node.data('background-fit', fits.join(\" \"));\n        node.data('background-image-opacity', opacities.join(\" \"));\n        bgObj['firstTime'] = false;\n      }\n    };\n\n    elementUtilities.reverseEdge = function (edge) {\n      var oldSource = edge.source().id();\n      var oldTarget = edge.target().id();\n      var oldPortSource = edge.data(\"portsource\");\n      var oldPortTarget = edge.data(\"porttarget\");\n      var segmentPoints = edge.segmentPoints();\n      var controlPoints = edge.controlPoints();\n      edge.data().source = oldTarget;\n      edge.data().target = oldSource;\n      edge.data().portsource = oldPortTarget;\n      edge.data().porttarget = oldPortSource;\n      edge = edge.move({\n        target: oldSource,\n        source: oldTarget\n      });\n\n      if (Array.isArray(segmentPoints)) {\n        segmentPoints.reverse();\n        edge.data().bendPointPositions = segmentPoints;\n\n        if (Array.isArray(controlPoints)) {\n          controlPoints.reverse();\n          edge.data().controlPointPositions = controlPoints;\n        }\n\n        var edgeEditing = cy.edgeEditing('get');\n        edgeEditing.initAnchorPoints(edge);\n      }\n\n      return edge;\n    };\n  }\n\n  return elementUtilitiesExtender;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jaGlzZS8uL3NyYy91dGlsaXRpZXMvZWxlbWVudC11dGlsaXRpZXMtZXh0ZW5kZXItZmFjdG9yeS5qcz9iYmZhIl0sIm5hbWVzIjpbImxpYnMiLCJyZXF1aXJlIiwialF1ZXJ5IiwiJCIsIm1vZHVsZSIsImV4cG9ydHMiLCJvcHRpb25zIiwic2JnbnZpekluc3RhbmNlIiwiZWxlbWVudFV0aWxpdGllcyIsImN5IiwiZWxlbWVudFV0aWxpdGllc0V4dGVuZGVyIiwicGFyYW0iLCJzYmdudml6SW5zdGFuY2VVdGlsaXRpZXMiLCJnZXRJbnN0YW5jZSIsIm9wdGlvblV0aWxpdGllcyIsImdldE9wdGlvbnMiLCJnZXRDeSIsImV4dGVuZCIsImFkZE5vZGUiLCJ4IiwieSIsIm5vZGVQYXJhbXMiLCJpZCIsInBhcmVudCIsInZpc2liaWxpdHkiLCJzYmduY2xhc3MiLCJsYW5ndWFnZSIsImNzcyIsImRlZmF1bHRXaWR0aCIsImRlZmF1bHRIZWlnaHQiLCJkYXRhIiwiYmJveCIsInciLCJoIiwic3RhdGVzYW5kaW5mb3MiLCJwb3J0cyIsImdlbmVyYXRlTm9kZUlkIiwiZXh0ZW5kTm9kZURhdGFXaXRoQ2xhc3NEZWZhdWx0cyIsImRlZmF1bHRzIiwiZ2V0RGVmYXVsdFByb3BlcnRpZXMiLCJlbGVzIiwiYWRkIiwiZ3JvdXAiLCJwb3NpdGlvbiIsIm5ld05vZGUiLCJsZW5ndGgiLCJvcmRlcmluZyIsInNldFBvcnRzT3JkZXJpbmciLCJjYW5IYXZlTXVsdGlwbGVVbml0T2ZJbmZvcm1hdGlvbiIsInVvaV9vYmoiLCJjbGF6eiIsImxhYmVsIiwidGV4dCIsImFkZFN0YXRlT3JJbmZvQm94IiwiYmdJbWFnZSIsInNhdmVVbml0cyIsIm5vZGUiLCJ0ZW1wRGF0YSIsImluZGV4IiwiZm9yRWFjaCIsImVsZSIsInB1c2giLCJhbmNob3JTaWRlIiwicmVzdG9yZVVuaXRzIiwidW5kZWZpbmVkIiwibW9kaWZ5VW5pdHMiLCJpbnN0YW5jZSIsImNsYXNzZXMiLCJBdXhVbml0TGF5b3V0IiwiYWRkRWRnZSIsInNvdXJjZSIsInRhcmdldCIsImVkZ2VQYXJhbXMiLCJncm91cElEIiwiT2JqZWN0Iiwia2V5cyIsInByb3AiLCJnZW5lcmF0ZUVkZ2VJZCIsImNhbkhhdmVTQkdOQ2FyZGluYWxpdHkiLCJjYXJkaW5hbGl0eSIsInNvdXJjZU5vZGUiLCJnZXRFbGVtZW50QnlJZCIsInRhcmdldE5vZGUiLCJzb3VyY2VIYXNQb3J0cyIsInRhcmdldEhhc1BvcnRzIiwicG9ydHNvdXJjZSIsInBvcnR0YXJnZXQiLCJnZXRJT1BvcnRJZHMiLCJub2RlSW5wdXRQb3J0SWQiLCJub2RlT3V0cHV0UG9ydElkIiwibm9kZVBvcnRzT3JkZXJpbmciLCJnZXRQb3J0c09yZGVyaW5nIiwibm9kZVBvcnRzIiwibGVmdFBvcnRJZCIsInJpZ2h0UG9ydElkIiwidG9wUG9ydElkIiwiYm90dG9tUG9ydElkIiwiaW5wdXRQb3J0SWQiLCJvdXRwdXRQb3J0SWQiLCJzb3VyY2VOb2RlSW5wdXRQb3J0SWQiLCJzb3VyY2VOb2RlT3V0cHV0UG9ydElkIiwidGFyZ2V0Tm9kZUlucHV0UG9ydElkIiwidGFyZ2V0Tm9kZU91dHB1dFBvcnRJZCIsImlvUG9ydHMiLCJpc01vZHVsYXRpb25BcmNDbGFzcyIsImlzQUZBcmNDbGFzcyIsInNyY0NsYXNzIiwidGd0Q2xhc3MiLCJpc1NvdXJjZUxvZ2ljYWxPcCIsImlzVGFyZ2V0TG9naWNhbE9wIiwibmV3RWRnZSIsImFkZFByb2Nlc3NXaXRoQ29udmVuaWVudEVkZ2VzIiwiX3NvdXJjZSIsIl90YXJnZXQiLCJwcm9jZXNzUGFyZW50IiwiY29sbGVjdGlvbiIsImNvbW1vbkFuY2VzdG9ycyIsImZpcnN0IiwicHJvY2VzcyIsInhkaWZmIiwieWRpZmYiLCJNYXRoIiwiYWJzIiwiZWRnZUJ0d1NyYyIsImVkZ2VCdHdUZ3QiLCJjcmVhdGVDb21wb3VuZEZvckdpdmVuTm9kZXMiLCJub2Rlc1RvTWFrZUNvbXBvdW5kIiwiY29tcG91bmRUeXBlIiwib2xkUGFyZW50SWQiLCJpIiwibmV3Q29tcG91bmQiLCJuZXdDb21wb3VuZElkIiwibmV3RWxlcyIsImNoYW5nZVBhcmVudCIsInVuaW9uIiwiY3JlYXRlVHJhbnNsYXRpb25SZWFjdGlvbiIsIm1SbmFOYW1lIiwicHJvdGVpbk5hbWUiLCJwcm9jZXNzUG9zaXRpb24iLCJlZGdlTGVuZ3RoIiwiZGVmYXVsdFByb2Nlc3NQcm9wZXJ0aWVzIiwiZGVmYXVsdFNvdXJjZUFuZFNpbmtQcm9wZXJ0aWVzIiwiZGVmYXVsdE51Y2xlaWNBY2lkRmVhdHVyZVByb3BlcnRpZXMiLCJkZWZhdWx0TWFjcm9tb2xlY3VsZVByb3BlcnRpZXMiLCJtYWNyb21vbGVjdWxlV2lkdGgiLCJ3aWR0aCIsInNvdXJjZUFuZFNpbmtXaWR0aCIsIm51Y2xlaWNBY2lkRmVhdHVyZUhlaWdodCIsImhlaWdodCIsInByb2Nlc3NXaWR0aCIsInByb2Nlc3NIZWlnaHQiLCJjb252ZXJ0VG9Nb2RlbFBvc2l0aW9uIiwic3RhcnRCYXRjaCIsImdldE1hcFR5cGUiLCJzZXRNYXBUeXBlIiwicHJvY2Vzc05vZGUiLCJ4UG9zT2ZTb3VyY2VBbmRTaW5rTm9kZSIsInlQb3NPZlNvdXJjZUFuZFNpbmtOb2RlIiwic291cmNlQW5kU2lua05vZGUiLCJjb25zdW1wdGlvbkVkZ2UiLCJ4UG9zT2ZtUm5hTm9kZSIsInlQb3NPZm1SbmFOb2RlIiwibVJuYU5vZGUiLCJpbmZvYm94T2JqZWN0T2ZHZW5lIiwibmVjZXNzYXJ5U3RpbXVsYXRpb25FZGdlIiwieFBvc09mUHJvdGVpbk5vZGUiLCJ5UG9zdE9mUHJvdGVpbk5vZGUiLCJwcm90ZWluTm9kZSIsInByb2R1Y3Rpb25FZGdlIiwiZW5kQmF0Y2giLCJlbGVtZW50cyIsInJlbW92ZURhdGEiLCJ1bnNlbGVjdCIsInNlbGVjdCIsImNyZWF0ZVRyYW5zY3JpcHRpb25SZWFjdGlvbiIsImdlbmVOYW1lIiwibnVjbGVpY0FjaWRGZWF0dXJlV2lkdGgiLCJ4UG9zT2ZHZW5lTm9kZSIsInlQb3NPZkdlbmVOb2RlIiwiZ2VuZU5vZGUiLCJ5UG9zdE9mbVJuYU5vZGUiLCJpbmZvYm94T2JqZWN0T2ZtUm5hIiwicm90YXRlOTAiLCJwb2ludCIsImNlbnRlciIsInJlbGF0aXZlWCIsInJlbGF0aXZlWSIsInJlbGF0aXZlUm90YXRlZFgiLCJyZWxhdGl2ZVJvdGF0ZWRZIiwicmVzdWx0WCIsInJlc3VsdFkiLCJjcmVhdGVUcmFuc2xhdGlvbiIsInJlZ3VsYXRvckxhYmVsIiwib3V0cHV0TGFiZWwiLCJvcmllbnRhdGlvbiIsImRlZmF1bHRNYWNyb21vbGVjdWxlUHJvcGV0aWVzIiwidmVydGljYWwiLCJwcm9jZXNzUG9ydHNPcmRlcmluZyIsIm1pbkluZm9ib3hEaW1lbnNpb24iLCJ3aWR0aFBlckNoYXIiLCJyZWd1bGF0b3JJbmZvYm94TGFiZWwiLCJ4UG9zT2ZJbnB1dCIsInhQb3NPZk91dHB1dCIsInlQb3NPZklucHV0IiwieVBvc09mT3V0cHV0Iiwibm9kZVBvc2l0aW9uIiwiaW5wdXROb2RlIiwiaW5wdXRFZGdlIiwib3V0cHV0Tm9kZSIsIm91dHB1dEVkZ2UiLCJ4UG9zT2ZSZWd1bGF0b3IiLCJkaW1lbnNpb24iLCJ5UG9zT2ZSZWd1bGF0b3IiLCJyZWd1bGF0b3JOb2RlIiwiaW5mb2JveE9iamVjdCIsIm1heCIsInJlZ3VsYXRvckVkZ2UiLCJjcmVhdGVUcmFuc2NyaXB0aW9uIiwib3V0cHV0SW5mb2JveExhYmVsIiwiY3JlYXRlRGVncmFkYXRpb24iLCJtYWNyb21vbGVjdWxlIiwibWFjcm9tb2xlY3VsZU5hbWUiLCJuYW1lIiwiY3JlYXRlQ29tcGxleFByb3RlaW5Gb3JtYXRpb24iLCJwcm90ZWluTGFiZWxzIiwiY29tcGxleExhYmVsIiwicmVndWxhdG9yIiwicmV2ZXJzZSIsImhhc1JlZ3VsYXRvciIsImRlZmF1bHRSZWd1bGF0b3JQcm9wZXJ0aWVzIiwidHlwZSIsIm1hY3JvbW9sZWN1bGVIZWlnaHQiLCJyZWd1bGF0b3JIZWlnaHQiLCJ0aWxpbmdQYWRkaW5nVmVydGljYWwiLCJ0aWxpbmdQYWRkaW5nSG9yaXpvbnRhbCIsIm11bHRpbWVyT2Zmc2V0Iiwib2Zmc2V0WCIsInhQb3NPZlByb3RlaW4iLCJwcm90ZWluQ291bnQiLCJtYWNyb21vbGVjdWxlRGltZW5zaW9uIiwic3RlcE9mZnNldCIsIm9mZnNldFkiLCJob3Jpem9udGFsT2Zmc2V0WCIsInlQb3NPZlByb3RlaW4iLCJlZGdlQ2xhc3MiLCJlZGdlIiwiY29tcGxleFBvcyIsImNvbXBsZXgiLCJjb21wbGV4RWRnZSIsInJlZ3VsYXRvck5hbWUiLCJyZWd1bGF0b3JUeXBlIiwicmVndWxhdG9yRWRnZVR5cGUiLCJlZGdlVHlwZSIsInJlZ3VsYXRvck11bHRpbWVyIiwibXVsdGltZXIiLCJlbmFibGVkIiwic2V0TXVsdGltZXJTdGF0dXMiLCJpbmZvYm94TGFiZWwiLCJjcmVhdGVNdWx0aW1lcml6YXRpb24iLCJtYWNyb21vbGVjdWxlTXVsdGltZXJDYXJkaW5hbGl0eSIsImNyZWF0ZUNvbnZlcnNpb24iLCJpbnB1dEluZm9ib3hMYWJlbHMiLCJvdXRwdXRJbmZvYm94TGFiZWxzIiwibWFjcm9tb2xlY3VsZUlzTXVsdGltZXIiLCJpbnB1dEluZm9ib3hXaWR0aCIsInN0eWxlIiwib3V0cHV0SW5mb2JveFdpZHRoIiwiY2FsY3VsYXRlTWluV2lkdGgiLCJyZXNpemVOb2RlcyIsIm5ld0lucHV0WFBvcyIsIm5ld091dHB1dFhQb3MiLCJuZXdJbnB1dFlQb3MiLCJuZXdPdXRwdXRZUG9zIiwiY3JlYXRlTWV0YWJvbGljUmVhY3Rpb24iLCJpbnB1dHMiLCJvdXRwdXRzIiwicmV2ZXJzaWJsZSIsImRlZmF1bHRTaW1wbGVDaGVtaWNhbFByb3BlcnRpZXMiLCJzaW1wbGVDaGVtaWNhbEhlaWdodCIsInNpbXBsZUNoZW1pY2FsV2lkdGgiLCJwcm9jZXNzTGVmdFNpZGVFZGdlVHlwZSIsInByb2Nlc3NSaWdodFNpZGVFZGdlVHlwZSIsIm51bU9mSW5wdXROb2RlcyIsIm51bU9mT3V0cHV0Tm9kZXMiLCJub2RlTmFtZSIsIm5vZGVUeXBlIiwiY2VpbCIsInRvTG93ZXJDYXNlIiwiY3JlYXRlTWV0YWJvbGljQ2F0YWx5dGljQWN0aXZpdHkiLCJpbnB1dE5vZGVMaXN0Iiwib3V0cHV0Tm9kZUxpc3QiLCJjYXRhbHlzdE5hbWUiLCJjYXRhbHlzdFR5cGUiLCJkZWZhdWx0TWFjcm9tb2xlY3VsUHJvcGVydGllcyIsImRlZmF1bHRDYXRhbHlzdFR5cGVQcm9wZXJ0aWVzIiwiY2F0YWx5c3RIZWlnaHQiLCJ4UG9zT2ZDYXRhbHlzdCIsInlQb3NPZkNhdGFseXN0IiwiY2F0YWx5c3ROb2RlIiwiY2F0YWx5c3RFZGdlIiwiY3JlYXRlQWN0aXZhdGlvblJlYWN0aW9uIiwieVBvc2l0aW9uIiwiaW5wdXRTaWRlRWRnZSIsIm91dHB1dFNpZGVFZGdlIiwiY3JlYXRlVGVtcGxhdGVSZWFjdGlvbiIsInRlbXBsYXRlVHlwZSIsIm5vZGVMaXN0IiwiY29tcGxleE5hbWUiLCJsYXlvdXRQYXJhbSIsIm51bU9mTW9sZWN1bGVzIiwieFBvc2l0aW9uT2ZGcmVlTWFjcm9tb2xlY3VsZXMiLCJ4UG9zaXRpb25PZklucHV0TWFjcm9tb2xlY3VsZXMiLCJlZGdlT2ZDb21wbGV4IiwibnVtT2ZJbnB1dE1hY3JvbW9sZWN1bGVzIiwibGF5b3V0Tm9kZXMiLCJub2RlcyIsImxheW91dCIsInJhbmRvbWl6ZSIsImZpdCIsImFuaW1hdGUiLCJzdG9wIiwic3VwcG9zZWRYUG9zaXRpb24iLCJzdXBwb3NlZFlQb3NpdGlvbiIsIm91dGVyV2lkdGgiLCJwb3NpdGlvbkRpZmZYIiwicG9zaXRpb25EaWZmWSIsIm1vdmVOb2RlcyIsInJ1biIsIm5ld1BhcmVudCIsInBvc0RpZmZYIiwicG9zRGlmZlkiLCJuZXdQYXJlbnRJZCIsIm1vdmVkRWxlcyIsIm1vdmUiLCJtYWludGFpblBvaW50ZXIiLCJ1cGRhdGVJbmZvYm94U3R5bGUiLCJuZXdQcm9wcyIsImluZm9ib3hPYmoiLCJ1cGRhdGUiLCJ1cGRhdGVJbmZvYm94T2JqIiwidXNlQXNwZWN0UmF0aW8iLCJwcmVzZXJ2ZVJlbGF0aXZlUG9zIiwicmF0aW8iLCJlbGVNdXN0QmVTcXVhcmUiLCJtdXN0QmVTcXVhcmUiLCJvbGRXaWR0aCIsIm9sZEhlaWdodCIsImlzUGFyZW50IiwiZm9udEZhbWlsaXkiLCJmb250U2l6ZSIsImxhYmVsVGV4dCIsImxhYmVsV2lkdGgiLCJnZXRXaWR0aEJ5Q29udGVudCIsInVuaXRHYXAiLCJ0b3BJZGVhbFdpZHRoIiwiYm90dG9tSWRlYWxXaWR0aCIsInJpZ2h0TWF4V2lkdGgiLCJsZWZ0TWF4V2lkdGgiLCJib3giLCJtaWRkbGVXaWR0aCIsImNvbXBvdW5kV2lkdGgiLCJjaGlsZHJlbiIsImJvdW5kaW5nQm94IiwiY2FsY3VsYXRlTWluSGVpZ2h0IiwibWFyZ2luIiwibGVmdEluZm9Cb3hlcyIsImZpbHRlciIsImxlZnRIZWlnaHQiLCJyaWdodEluZm9Cb3hlcyIsInJpZ2h0SGVpZ2h0Iiwic3BsaXQiLCJwYXJzZUZsb2F0Iiwic3Vic3RyaW5nIiwidG90YWxIZWlnaHQiLCJjb21wb3VuZEhlaWdodCIsImlzUmVzaXplZFRvQ29udGVudCIsImlzTm9kZSIsIm1pblciLCJtaW5IIiwicmVsb2NhdGVTdGF0ZUFuZEluZm9zIiwic3RhdGVBbmRJbmZvcyIsImNoYW5nZVN0YXRlT3JJbmZvQm94IiwidmFsdWUiLCJyZXN1bHQiLCJvbGRMZW5ndGgiLCJuZXdMZW5ndGgiLCJjb250ZW50Iiwic3RhdGUiLCJtaW4iLCJmb250RmFtaWx5IiwiYm9yZGVyV2lkdGgiLCJvcHRzIiwicHJldmlvdXNXaWR0aCIsInVuaXRMYXlvdXQiLCJ1bml0cyIsInNoaWZ0QW1vdW50Iiwib2JqIiwibG9jYXRpb25PYmoiLCJkZWZhdWx0UHJvcHMiLCJpbmZvYm94UHJvcHMiLCJnZXREZWZhdWx0SW5mb2JveFN0eWxlIiwiVW5pdE9mSW5mb3JtYXRpb24iLCJjcmVhdGUiLCJsb2NhdGlvbiIsIlN0YXRlVmFyaWFibGUiLCJ2YXJpYWJsZSIsInJlbW92ZVN0YXRlT3JJbmZvQm94IiwidW5pdCIsInVuaXRDbGFzcyIsImdldEF1eFVuaXRDbGFzcyIsInJlbW92ZSIsImZpdFVuaXRzIiwibG9jYXRpb25zIiwiY2hlY2tGaXQiLCJzdGF0dXMiLCJpc011bHRpbWVyIiwiZW5kc1dpdGgiLCJyZXBsYWNlIiwiY2hhbmdlRm9udFByb3BlcnRpZXMiLCJ2YWxpZGF0ZUFycm93RW5kcyIsImlzUmVwbGFjZW1lbnQiLCJlZGdlY2xhc3MiLCJzb3VyY2VjbGFzcyIsInRhcmdldGNsYXNzIiwibWFwVHlwZSIsImVkZ2VDb25zdHJhaW50cyIsImNvbm5lY3Rpdml0eUNvbnN0cmFpbnRzIiwic3RhcnRzV2l0aCIsImhhc1Rvb01hbnlFZGdlcyIsInNvdXJjZU9yVGFyZ2V0Iiwibm9kZWNsYXNzIiwidG90YWxUb29NYW55IiwiZWRnZVRvb01hbnkiLCJzYW1lRWRnZUNvdW50T3V0Iiwib3V0Z29lcnMiLCJzaXplIiwidG90YWxFZGdlQ291bnRPdXQiLCJtYXhUb3RhbCIsImFzU291cmNlIiwibWF4RWRnZSIsImNvbXBhcmVTdHJpY3QiLCJ3aXRoaW5MaW1pdHMiLCJzYW1lRWRnZUNvdW50SW4iLCJpbmNvbWVycyIsInRvdGFsRWRnZUNvdW50SW4iLCJhc1RhcmdldCIsImlzSW5Db21wbGV4IiwicGFyZW50Q2xhc3MiLCJpc0FsbG93ZWQiLCJkZWxldGVBbmRQZXJmb3JtTGF5b3V0IiwibGF5b3V0cGFyYW0iLCJoaWRlQW5kUGVyZm9ybUxheW91dCIsInZpZXdVdGlsaXRpZXMiLCJoaWRlIiwic2hvd0FuZFBlcmZvcm1MYXlvdXQiLCJzaG93IiwiY2hhbmdlQ3NzIiwidmFsdWVNYXAiLCJjaGFuZ2VEYXRhIiwidXBkYXRlU2V0RmllbGQiLCJmaWVsZE5hbWUiLCJ0b0RlbGV0ZSIsInRvQWRkIiwiY2FsbGJhY2siLCJzZXQiLCJ1cGRhdGVzIiwiZGVsZXRlZCIsImFkZGVkIiwiZ2V0Tm9kZXNBdCIsInJlbmRlcmVkUG9zIiwicmVzdWx0Tm9kZXMiLCJyZW5kZXJlZEJib3giLCJyZW5kZXJlZEJvdW5kaW5nQm94IiwiaW5jbHVkZU5vZGVzIiwiaW5jbHVkZUVkZ2VzIiwiaW5jbHVkZUxhYmVscyIsImluY2x1ZGVTaGFkb3dzIiwieDEiLCJ4MiIsInkxIiwieTIiLCJkZW11bHRpbWVyaXplQ2xhc3MiLCJyZXNldE1hcFR5cGUiLCJlbWl0Iiwic2lkZSIsInBhcmVudE5vZGUiLCJhbnlIYXNCYWNrZ3JvdW5kSW1hZ2UiLCJnZXRCYWNrZ3JvdW5kSW1hZ2VPYmpzIiwia2V5IiwiaXNFbXB0eU9iamVjdCIsImhhc0JhY2tncm91bmRJbWFnZSIsImJnIiwiQXJyYXkiLCJpc0FycmF5IiwiY2xvbmVJbWciLCJvbmx5SGFzQ2xvbmVNYXJrZXJBc0JnSW1hZ2UiLCJpbmRleE9mIiwiZ2V0QmFja2dyb3VuZEltYWdlVVJMIiwiY29tbW9uVVJMIiwidXJsIiwicG9wIiwibGlzdCIsImdldEJnT2JqIiwiZ2V0QmFja2dyb3VuZEZpdE9wdGlvbnMiLCJjb21tb25GaXQiLCJnZXRGaXRPcHRpb24iLCJzZWFyY2hLZXkiLCJzdWJzdHIiLCJmIiwidXBkYXRlQmFja2dyb3VuZEltYWdlIiwiYmdPYmoiLCJpbWdzIiwieFBvcyIsInlQb3MiLCJ3aWR0aHMiLCJoZWlnaHRzIiwiZml0cyIsIm9wYWNpdGllcyIsInRtcCIsImpvaW4iLCJjaGFuZ2VCYWNrZ3JvdW5kSW1hZ2UiLCJvbGRJbWciLCJuZXdJbWciLCJmaXJzdFRpbWUiLCJ1cGRhdGVJbmZvIiwicHJvbXB0SW52YWxpZEltYWdlIiwidmFsaWRhdGVVUkwiLCJyZW1vdmVCYWNrZ3JvdW5kSW1hZ2UiLCJhZGRCYWNrZ3JvdW5kSW1hZ2UiLCJsb2FkQmFja2dyb3VuZFRoZW5BcHBseSIsImFwcGx5QmFja2dyb3VuZCIsImNoZWNrR2l2ZW5VUkwiLCJyZWFkZXIiLCJGaWxlUmVhZGVyIiwiaW1nRmlsZSIsInJlYWRBc0RhdGFVUkwiLCJvbmxvYWQiLCJlIiwiaW1nIiwiZXh0ZW5zaW9uIiwidmFsaWRFeHRlbnNpb25zIiwiaW5jbHVkZXMiLCJhamF4Iiwic3VjY2VzcyIsInhociIsImVycm9yIiwiaW5kZXhUb0luc2VydCIsImhhc0Nsb25lTWFya2VyIiwic3BsaWNlIiwicmV2ZXJzZUVkZ2UiLCJvbGRTb3VyY2UiLCJvbGRUYXJnZXQiLCJvbGRQb3J0U291cmNlIiwib2xkUG9ydFRhcmdldCIsInNlZ21lbnRQb2ludHMiLCJjb250cm9sUG9pbnRzIiwiYmVuZFBvaW50UG9zaXRpb25zIiwiY29udHJvbFBvaW50UG9zaXRpb25zIiwiZWRnZUVkaXRpbmciLCJpbml0QW5jaG9yUG9pbnRzIl0sIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0EsSUFBSUEsSUFBSSxHQUFHQyxzRkFBQSxFQUFYOztBQUNBLElBQUlDLE1BQU0sR0FBR0MsQ0FBQyxHQUFHSCxJQUFJLENBQUNFLE1BQXRCOztBQUVBRSxNQUFNLENBQUNDLE9BQVAsR0FBaUIsWUFBWTtBQUMzQixNQUFJQyxPQUFKLEVBQWFDLGVBQWIsRUFBOEJDLGdCQUE5QixFQUFnREMsRUFBaEQ7O0FBRUEsV0FBU0Msd0JBQVQsQ0FBbUNDLEtBQW5DLEVBQTBDO0FBQ3hDSixtQkFBZSxHQUFHSSxLQUFLLENBQUNDLHdCQUFOLENBQStCQyxXQUEvQixFQUFsQjtBQUNBUCxXQUFPLEdBQUdLLEtBQUssQ0FBQ0csZUFBTixDQUFzQkMsVUFBdEIsRUFBVjtBQUNBUCxvQkFBZ0IsR0FBR0QsZUFBZSxDQUFDQyxnQkFBbkM7QUFDQUMsTUFBRSxHQUFHRSxLQUFLLENBQUNDLHdCQUFOLENBQStCSSxLQUEvQixFQUFMO0FBRUFDLFVBQU0sR0FOa0MsQ0FReEM7O0FBQ0EsV0FBT1QsZ0JBQVA7QUFDRCxHQWIwQixDQWUzQjs7O0FBQ0EsV0FBU1MsTUFBVCxHQUFtQjtBQUNqQjtBQUNBO0FBRUFULG9CQUFnQixDQUFDVSxPQUFqQixHQUEyQixVQUFVQyxDQUFWLEVBQWFDLENBQWIsRUFBZ0JDLFVBQWhCLEVBQTRCQyxFQUE1QixFQUFnQ0MsTUFBaEMsRUFBd0NDLFVBQXhDLEVBQW9EO0FBQzdFLFVBQUksUUFBT0gsVUFBUCxLQUFxQixRQUF6QixFQUFrQztBQUNoQyxZQUFJSSxTQUFTLEdBQUdKLFVBQWhCO0FBQ0QsT0FGRCxN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Q0FwVCxVQUFJLENBQUN2TixJQUFMLEdBQVl3RCxVQUFaLEdBQXlCa2QsYUFBekI7QUFDQ25ULFVBQUksR0FBR0EsSUFBSSxDQUFDd0YsSUFBTCxDQUFVO0FBQ2Z0USxjQUFNLEVBQUUrZCxTQURPO0FBRWZoZSxjQUFNLEVBQUdpZTtBQUZNLE9BQVYsQ0FBUDs7QUFLRCxVQUFHM0QsS0FBSyxDQUFDQyxPQUFOLENBQWM2RCxhQUFkLENBQUgsRUFBZ0M7QUFDOUJBLHFCQUFhLENBQUN2VSxPQUFkO0FBQ0FrQixZQUFJLENBQUN2TixJQUFMLEdBQVk4Z0Isa0JBQVosR0FBaUNGLGFBQWpDOztBQUNBLFlBQUc5RCxLQUFLLENBQUNDLE9BQU4sQ0FBYzhELGFBQWQsQ0FBSCxFQUFpQztBQUMvQkEsdUJBQWEsQ0FBQ3hVLE9BQWQ7QUFDQWtCLGNBQUksQ0FBQ3ZOLElBQUwsR0FBWStnQixxQkFBWixHQUFvQ0YsYUFBcEM7QUFDRDs7QUFDRCxZQUFJRyxXQUFXLEdBQUdyaUIsRUFBRSxDQUFDcWlCLFdBQUgsQ0FBZSxLQUFmLENBQWxCO0FBQ0FBLG1CQUFXLENBQUNDLGdCQUFaLENBQTZCMVQsSUFBN0I7QUFDRDs7QUFHRCxhQUFPQSxJQUFQO0FBQ0QsS0E5QkQ7QUFnQ0Q7O0FBRUQsU0FBTzNPLHdCQUFQO0FBQ0QsQ0FwbUdEIiwiZmlsZSI6Ii4vc3JjL3V0aWxpdGllcy9lbGVtZW50LXV0aWxpdGllcy1leHRlbmRlci1mYWN0b3J5LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gRXh0ZW5kcyBzYmdudml6LmVsZW1lbnRVdGlsaXRpZXNcbnZhciBsaWJzID0gcmVxdWlyZSgnLi9saWItdXRpbGl0aWVzJykuZ2V0TGlicygpO1xudmFyIGpRdWVyeSA9ICQgPSBsaWJzLmpRdWVyeTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBvcHRpb25zLCBzYmdudml6SW5zdGFuY2UsIGVsZW1lbnRVdGlsaXRpZXMsIGN5O1xuXG4gIGZ1bmN0aW9uIGVsZW1lbnRVdGlsaXRpZXNFeHRlbmRlciAocGFyYW0pIHtcbiAgICBzYmdudml6SW5zdGFuY2UgPSBwYXJhbS5zYmdudml6SW5zdGFuY2VVdGlsaXRpZXMuZ2V0SW5zdGFuY2UoKTtcbiAgICBvcHRpb25zID0gcGFyYW0ub3B0aW9uVXRpbGl0aWVzLmdldE9wdGlvbnMoKTtcbiAgICBlbGVtZW50VXRpbGl0aWVzID0gc2JnbnZpekluc3RhbmNlLmVsZW1lbnRVdGlsaXRpZXM7XG4gICAgY3kgPSBwYXJhbS5zYmdudml6SW5zdGFuY2VVdGlsaXRpZXMuZ2V0Q3koKTtcblxuICAgIGV4dGVuZCgpO1xuXG4gICAgLy8gUmV0dXJuIHRoZSBleHRlbmRlZCBlbGVtZW50VXRpbGl0aWVzXG4gICAgcmV0dXJuIGVsZW1lbnRVdGlsaXRpZXM7XG4gIH1cblxuICAvLyBFeHRlbmRzIGVsZW1lbnRVdGlsaXRpZXMgd2l0aCBjaGlzZSBzcGVjaWZpYyBmYWNpbGl0aWVzXG4gIGZ1bmN0aW9uIGV4dGVuZCAoKSB7XG4gICAgLy8gU2VjdGlvbiBTdGFydFxuICAgIC8vIEFkZCByZW1vdmUgdXRpbGl0aWVzXG5cbiAgICBlbGVtZW50VXRpbGl0aWVzLmFkZE5vZGUgPSBmdW5jdGlvbiAoeCwgeSwgbm9kZVBhcmFtcywgaWQsIHBhcmVudCwgdmlzaWJpbGl0eSkge1xuICAgICAgaWYgKHR5cGVvZiBub2RlUGFyYW1zICE9ICdvYmplY3QnKXtcbiAgICAgICAgdmFyIHNiZ25jbGFzcyA9IG5vZGVQYXJhbXM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBzYmduY2xhc3MgPSBub2RlUGFyYW1zLmNsYXNzO1xuICAgICAgICAgIHZhciBsYW5ndWFnZSA9IG5vZGVQYXJhbXMubGFuZ3VhZ2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBjc3MgPSB7fTtcbiAgICAgIC8vIGlmIHRoZXJlIGlzIG5vIHNwZWNpZmljIGRlZmF1bHQgd2lkdGggb3IgaGVpZ2h0IGZvclxuICAgICAgLy8gc2JnbmNsYXNzIHRoZXNlIHNpemVzIGFyZSB1c2VkXG4gICAgICB2YXIgZGVmYXVsdFdpZHRoID0gNTA7XG4gICAgICB2YXIgZGVmYXVsdEhlaWdodCA9IDUwO1xuXG4gICAgICBpZiAodmlzaWJpbGl0eSkge1xuICAgICAgICBjc3MudmlzaWJpbGl0eSA9IHZpc2liaWxpdHk7XG4gICAgICB9XG5cbiAgICAgIHZhciBkYXRhID0ge1xuICAgICAgICBjbGFzczogc2JnbmNsYXNzLFxuICAgIFx0ICBsYW5ndWFnZTogbGFuZ3VhZ2UsXG4gICAgICAgIGJib3g6IHtcbiAgICAgICAgICB3OiBkZWZhdWx0V2lkdGgsXG4gICAgICAgICAgaDogZGVmYXVsdEhlaWdodCxcbiAgICAgICAgICB4OiB4LFxuICAgICAgICAgIHk6IHlcbiAgICAgICAgfSxcbiAgICAgICAgc3RhdGVzYW5kaW5mb3M6IFtdLFxuICAgICAgICBwb3J0czogW11cbiAgICAgIH07XG5cbiAgICAgIGlmKGlkKSB7XG4gICAgICAgIGRhdGEuaWQgPSBpZDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBkYXRhLmlkID0gZWxlbWVudFV0aWxpdGllcy5nZW5lcmF0ZU5vZGVJZCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIGRhdGEucGFyZW50ID0gcGFyZW50O1xuICAgICAgfVxuXG4gICAgICB0aGlzLmV4dGVuZE5vZGVEYXRhV2l0aENsYXNzRGVmYXVsdHMoIGRhdGEsIHNiZ25jbGFzcyApO1xuXG4gICAgICAvLyBzb21lIGRlZmF1bHRzIGFyZSBub3Qgc2V0IGJ5IGV4dGVuZE5vZGVEYXRhV2l0aENsYXNzRGVmYXVsdHMoKVxuICAgICAgdmFyIGRlZmF1bHRzID0gdGhpcy5nZXREZWZhdWx0UHJvcGVydGllcyggc2JnbmNsYXNzICk7XG5cbiAgICAgIGlmICggZGVmYXVsdHNbICdtdWx0aW1lcicgXSApIHtcbiAgICAgICAgZGF0YS5jbGFzcyArPSAnIG11bHRpbWVyJztcbiAgICAgIH1cblxuICAgICAgaWYgKCBkZWZhdWx0c1sgJ2Nsb25lbWFya2VyJyBdICkge1xuICAgICAgICBkYXRhWyAnY2xvbmVtYXJrZXInIF0gPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBkYXRhLmJib3hbICd3JyBdID0gZGVmYXVsdHNbICd3aWR0aCcgXTtcbiAgICAgIGRhdGEuYmJveFsgJ2gnIF0gPSBkZWZhdWx0c1sgJ2hlaWdodCcgXTtcblxuICAgICAgdmFyIGVsZXMgPSBjeS5hZGQoe1xuICAgICAgICBncm91cDogXCJub2Rlc1wiLFxuICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICBjc3M6IGNzcyxcbiAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICB4OiB4LFxuICAgICAgICAgIHk6IHlcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHZhciBuZXdOb2RlID0gZWxlc1tlbGVzLmxlbmd0aCAtIDFdO1xuICAgICAgLy8gR2V0IHRoZSBkZWZhdWx0IHBvcnRzIG9yZGVyaW5nIGZvciB0aGUgbm9kZXMgd2l0aCBnaXZlbiBzYmduY2xhc3NcbiAgICAgIHZhciBvcmRlcmluZyA9IGRlZmF1bHRzWydwb3J0cy1vcmRlcmluZyddO1xuXG4gICAgICAvLyBJZiB0aGVyZSBpcyBhIGRlZmF1bHQgcG9ydHMgb3JkZXJpbmcgZm9yIHRoZSBub2RlcyB3aXRoIGdpdmVuIHNiZ25jbGFzcyBhbmQgaXQgaXMgZGlmZmVyZW50IHRoYW4gJ25vbmUnIHNldCB0aGUgcG9ydHMgb3JkZXJpbmcgdG8gdGhhdCBvcmRlcmluZ1xuICAgICAgaWYgKG9yZGVyaW5nICYmIG9yZGVyaW5nICE9PSAnbm9uZScpIHtcbiAgICAgICAgdGhpcy5zZXRQb3J0c09yZGVyaW5nKG5ld05vZGUsIG9yZGVyaW5nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGxhbmd1YWdlID09IFwiQUZcIiAmJiAhZWxlbWVudFV0aWxpdGllcy5jYW5IYXZlTXVsdGlwbGVVbml0T2ZJbmZvcm1hdGlvbihuZXdOb2RlKSl7XG4gICAgICAgIGlmIChzYmduY2xhc3MgIT0gXCJCQSBwbGFpblwiKSB7IC8vIGlmIEFGIG5vZGUgY2FuIGhhdmUgbGFiZWwgaS5lOiBub3QgcGxhaW4gYmlvbG9naWNhbCBhY3Rpdml0eVxuICAgICAgICAgIHZhciB1b2lfb2JqID0ge1xuICAgICAgICAgICAgY2xheno6IFwidW5pdCBvZiBpbmZvcm1hdGlvblwiXG4gICAgICAgICAgfTtcbiAgICAgICAgICB1b2lfb2JqLmxhYmVsID0ge1xuICAgICAgICAgICAgdGV4dDogXCJcIlxuICAgICAgICAgIH07XG5cbiAgICAgICAgICB1b2lfb2JqLmJib3ggPSB7XG4gICAgICAgICAgICAgdzogMTIsXG4gICAgICAgICAgICAgaDogMTJcbiAgICAgICAgICB9O1xuICAgICAgICAgIGVsZW1lbnRVdGlsaXRpZXMuYWRkU3RhdGVPckluZm9Cb3gobmV3Tm9kZSwgdW9pX29iaik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gbm9kZSBiZyBpbWFnZSB3YXMgdW5leHBlY3RlZGx5IG5vdCByZW5kZXJlZCB1bnRpbCBpdCBpcyBjbGlja2VkXG4gICAgICAvLyB1c2UgdGhpcyBkaXJ0eSBoYWNrIHVudGlsIGZpbmRpbmcgYSBzb2x1dGlvbiB0byB0aGUgcHJvYmxlbVxuICAgICAgdmFyIGJnSW1hZ2UgPSBuZXdOb2RlLmRhdGEoJ2JhY2tncm91bmQtaW1hZ2UnKTtcbiAgICAgIGlmICggYmdJbWFnZSApIHtcbiAgICAgICAgbmV3Tm9kZS5kYXRhKCAnYmFja2dyb3VuZC1pbWFnZScsIGJnSW1hZ2UgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ld05vZGU7XG4gICAgfTtcblxuICAgIC8vU2F2ZXMgb2xkIGF1eCB1bml0cyBvZiBnaXZlbiBub2RlXG4gICAgZWxlbWVudFV0aWxpdGllcy5zYXZlVW5pdHMgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgdGVtcERhdGEgPSBbXTtcbiAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICBub2RlLmRhdGEoJ3N0YXRlc2FuZGluZm9zJykuZm9yRWFjaCggZnVuY3Rpb24oZWxlKSB7XG4gICAgICAgIHRlbXBEYXRhLnB1c2goe1xuICAgICAgICAgIHg6IGVsZS5iYm94LngsXG4gICAgICAgICAgeTogZWxlLmJib3gueSxcbiAgICAgICAgICBhbmNob3JTaWRlOiBlbGUuYW5jaG9yU2lkZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGluZGV4Kys7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0ZW1wRGF0YTtcbiAgICB9O1xuXG4gICAgLy9SZXN0b3JlcyBmcm9tIGdpdmVuIGRhdGFcbiAgICBlbGVtZW50VXRpbGl0aWVzLnJlc3RvcmVVbml0cyA9IGZ1bmN0aW9uKG5vZGUsIGRhdGEpIHtcbiAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICBub2RlLmRhdGEoJ3N0YXRlc2FuZGluZm9zJykuZm9yRWFjaCggZnVuY3Rpb24oZWxlKSB7XG4gICAgICAgIGlmIChkYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBlbGUuYmJveC54ID0gZGF0YVtpbmRleF0ueDtcbiAgICAgICAgICBlbGUuYmJveC55ID0gZGF0YVtpbmRleF0ueVxuICAgICAgICAgIHZhciBhbmNob3JTaWRlID0gZWxlLmFuY2hvclNpZGU7XG4gICAgICAgICAgZWxlLmFuY2hvclNpZGUgPSBkYXRhW2luZGV4XS5hbmNob3JTaWRlO1xuICAgICAgICAgIGVsZW1lbnRVdGlsaXRpZXMubW9kaWZ5VW5pdHMobm9kZSwgZWxlLCBhbmNob3JTaWRlKTtcbiAgICAgICAgICBpbmRleCsrO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy9Nb2RpZnkgYXV4IHVuaXQgbGF5b3V0c1xuICAgIGVsZW1lbnRVdGlsaXRpZXMubW9kaWZ5VW5pdHMgPSBmdW5jdGlvbiAobm9kZSwgZWxlLCBhbmNob3JTaWRlKSB7XG4gICAgICBpbnN0YW5jZS5jbGFzc2VzLkF1eFVuaXRMYXlvdXQubW9kaWZ5VW5pdHMobm9kZSwgZWxlLCBhbmNob3JTaWRlLCBjeSk7XG4gICAgfTtcblxuXG4gICAgLy9Gb3IgcmV2ZXJzaWJsZSByZWFjdGlvbnMgYm90aCBzaWRlIG9mIHRoZSBwcm9jZXNzIGNhbiBiZSBpbnB1dC9vdXRwdXRcbiAgICAvL0dyb3VwIElEIGlkZW50aWZpZXMgdG8gd2hpY2ggZ3JvdXAgb2Ygbm9kZXMgdGhlIGVkZ2UgaXMgZ29pbmcgdG8gYmUgY29ubmVjdGVkIGZvciByZXZlcnNpYmxlIHJlYWN0aW9ucygwOiBncm91cCAxIElEIGFuZCAxOmdyb3VwIDIgSUQpXG4gICAgZWxlbWVudFV0aWxpdGllcy5hZGRFZGdlID0gZnVuY3Rpb24gKHNvdXJjZSwgdGFyZ2V0LCBlZGdlUGFyYW1zLCBpZCwgdmlzaWJpbGl0eSwgZ3JvdXBJRCApIHtcbiAgICAgIGlmICh0eXBlb2YgZWRnZVBhcmFtcyAhPSAnb2JqZWN0Jyl7XG4gICAgICAgIHZhciBzYmduY2xhc3MgPSBlZGdlUGFyYW1zO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgc2JnbmNsYXNzID0gZWRnZVBhcmFtcy5jbGFzcztcbiAgICAgICAgICB2YXIgbGFuZ3VhZ2UgPSBlZGdlUGFyYW1zLmxhbmd1YWdlO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3NzID0ge307XG5cbiAgICAgIGlmICh2aXNpYmlsaXR5KSB7XG4gICAgICAgIGNzcy52aXNpYmlsaXR5ID0gdmlzaWJpbGl0eTtcbiAgICAgIH1cblxuICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICAgICAgY2xhc3M6IHNiZ25jbGFzcyxcbiAgICAgICAgICBsYW5ndWFnZTogbGFuZ3VhZ2UsXG4gICAgICB9O1xuXG4gICAgICB2YXIgZGVmYXVsdHMgPSBlbGVtZW50VXRpbGl0aWVzLmdldERlZmF1bHRQcm9wZXJ0aWVzKCBzYmduY2xhc3MgKTtcblxuICAgICAgLy8gZXh0ZW5kIHRoZSBkYXRhIHdpdGggZGVmYXVsdCBwcm9wZXJ0aWVzIG9mIGVkZ2Ugc3R5bGVcbiAgICAgIE9iamVjdC5rZXlzKCBkZWZhdWx0cyApLmZvckVhY2goIGZ1bmN0aW9uKCBwcm9wICkge1xuICAgICAgICBkYXRhWyBwcm9wIF0gPSBkZWZhdWx0c1sgcHJvcCBdO1xuICAgICAgfSApO1xuXG4gICAgICBpZihpZCkge1xuICAgICAgICBkYXRhLmlkID0gaWQ7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZGF0YS5pZCA9IGVsZW1lbnRVdGlsaXRpZXMuZ2VuZXJhdGVFZGdlSWQoKTtcbiAgICAgIH1cblxuICAgICAgaWYoZWxlbWVudFV0aWxpdGllcy5jYW5IYXZlU0JHTkNhcmRpbmFsaXR5KHNiZ25jbGFzcykpe1xuICAgICAgICBkYXRhLmNhcmRpbmFsaXR5ID0gMDtcbiAgICAgIH1cblxuICAgICAgdmFyIHNvdXJjZU5vZGUgPSBjeS5nZXRFbGVtZW50QnlJZChzb3VyY2UpOyAvLyBUaGUgb3JpZ2luYWwgc291cmNlIG5vZGVcbiAgICAgIHZhciB0YXJnZXROb2RlID0gY3kuZ2V0RWxlbWVudEJ5SWQodGFyZ2V0KTsgLy8gVGhlIG9yaWdpbmFsIHRhcmdldCBub2RlXG4gICAgICB2YXIgc291cmNlSGFzUG9ydHMgPSBzb3VyY2VOb2RlLmRhdGEoJ3BvcnRzJykubGVuZ3RoID09PSAyO1xuICAgICAgdmFyIHRhcmdldEhhc1BvcnRzID0gdGFyZ2V0Tm9kZS5kYXRhKCdwb3J0cycpLmxlbmd0aCA9PT0gMjtcbiAgICAgIC8vIFRoZSBwb3J0c291cmNlIGFuZCBwb3J0dGFyZ2V0IHZhcmlhYmxlc1xuICAgICAgdmFyIHBvcnRzb3VyY2U7XG4gICAgICB2YXIgcG9ydHRhcmdldDtcblxuICAgICAgLypcbiAgICAgICAqIEdldCBpbnB1dC9vdXRwdXQgcG9ydCBpZCdzIG9mIGEgbm9kZSB3aXRoIHRoZSBhc3N1bXB0aW9uIHRoYXQgdGhlIG5vZGUgaGFzIHZhbGlkIHBvcnRzLlxuICAgICAgICovXG4gICAgICB2YXIgZ2V0SU9Qb3J0SWRzID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIG5vZGVJbnB1dFBvcnRJZCwgbm9kZU91dHB1dFBvcnRJZDtcbiAgICAgICAgdmFyIG5vZGVQb3J0c09yZGVyaW5nID0gc2JnbnZpekluc3RhbmNlLmVsZW1lbnRVdGlsaXRpZXMuZ2V0UG9ydHNPcmRlcmluZyhub2RlKTtcbiAgICAgICAgdmFyIG5vZGVQb3J0cyA9IG5vZGUuZGF0YSgncG9ydHMnKTtcbiAgICAgICAgaWYgKCBub2RlUG9ydHNPcmRlcmluZyA9PT0gJ0wtdG8tUicgfHwgbm9kZVBvcnRzT3JkZXJpbmcgPT09ICdSLXRvLUwnICkge1xuICAgICAgICAgIHZhciBsZWZ0UG9ydElkID0gbm9kZVBvcnRzWzBdLnggPCAwID8gbm9kZVBvcnRzWzBdLmlkIDogbm9kZVBvcnRzWzFdLmlkOyAvLyBUaGUgeCB2YWx1ZSBvZiBsZWZ0IHBvcnQgaXMgc3VwcG9zZWQgdG8gYmUgbmVnYXRpdmVcbiAgICAgICAgICB2YXIgcmlnaHRQb3J0SWQgPSBub2RlUG9ydHNbMF0ueCA+IDAgPyBub2RlUG9ydHNbMF0uaWQgOiBub2RlUG9ydHNbMV0uaWQ7IC8vIFRoZSB4IHZhbHVlIG9mIHJpZ2h0IHBvcnQgaXMgc3VwcG9zZWQgdG8gYmUgcG9zaXRpdmVcbiAgICAgICAgICAvKlxuICAgICAgICAgICAqIElmIHRoZSBwb3J0IG9yZGVyaW5nIGlzIGxlZnQgdG8gcmlnaHQgdGhlbiB0aGUgaW5wdXQgcG9ydCBpcyB0aGUgbGVmdCBwb3J0IGFuZCB0aGUgb3V0cHV0IHBvcnQgaXMgdGhlIHJpZ2h0IHBvcnQuXG4gICAgICAgICAgICogRWxzZSBpZiBpdCBpcyByaWdodCB0byBsZWZ0IGl0IGlzIHZpY2UgdmVyc2FcbiAgICAgICAgICAgKi9cbiAgICAgICAgICBub2RlSW5wdXRQb3J0SWQgPSBub2RlUG9ydHNPcmRlcmluZyA9PT0gJ0wtdG8tUicgPyBsZWZ0UG9ydElkIDogcmlnaHRQb3J0SWQ7XG4gICAgICAgICAgbm9kZU91dHB1dFBvcnRJZCA9IG5vZGVQb3J0c09yZGVyaW5nID09PSAnUi10by1MJyA/IGxlZnRQb3J0SWQgOiByaWdodFBvcnRJZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICggbm9kZVBvcnRzT3JkZXJpbmcgPT09ICdULXRvLUInIHx8IG5vZGVQb3J0c09yZGVyaW5nID09PSAnQi10by1UJyApe1xuICAgICAgICAgIHZhciB0b3BQb3J0SWQgPSBub2RlUG9ydHNbMF0ueSA8IDAgPyBub2RlUG9ydHNbMF0uaWQgOiBub2RlUG9ydHNbMV0uaWQ7IC8vIFRoZSB5IHZhbHVlIG9mIHRvcCBwb3J0IGlzIHN1cHBvc2VkIHRvIGJlIG5lZ2F0aXZlXG4gICAgICAgICAgdmFyIGJvdHRvbVBvcnRJZCA9IG5vZGVQb3J0c1swXS55ID4gMCA/IG5vZGVQb3J0c1swXS5pZCA6IG5vZGVQb3J0c1sxXS5pZDsgLy8gVGhlIHkgdmFsdWUgb2YgYm90dG9tIHBvcnQgaXMgc3VwcG9zZWQgdG8gYmUgcG9zaXRpdmVcbiAgICAgICAgICAvKlxuICAgICAgICAgICAqIElmIHRoZSBwb3J0IG9yZGVyaW5nIGlzIHRvcCB0byBib3R0b20gdGhlbiB0aGUgaW5wdXQgcG9ydCBpcyB0aGUgdG9wIHBvcnQgYW5kIHRoZSBvdXRwdXQgcG9ydCBpcyB0aGUgYm90dG9tIHBvcnQuXG4gICAgICAgICAgICogRWxzZSBpZiBpdCBpcyByaWdodCB0byBsZWZ0IGl0IGlzIHZpY2UgdmVyc2FcbiAgICAgICAgICAgKi9cbiAgICAgICAgICBub2RlSW5wdXRQb3J0SWQgPSBub2RlUG9ydHNPcmRlcmluZyA9PT0gJ1QtdG8tQicgPyB0b3BQb3J0SWQgOiBib3R0b21Qb3J0SWQ7XG4gICAgICAgICAgbm9kZU91dHB1dFBvcnRJZCA9IG5vZGVQb3J0c09yZGVyaW5nID09PSAnQi10by1UJyA/IHRvcFBvcnRJZCA6IGJvdHRvbVBvcnRJZDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJldHVybiBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgSU8gcG9ydHMgb2YgdGhlIG5vZGVcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpbnB1dFBvcnRJZDogbm9kZUlucHV0UG9ydElkLFxuICAgICAgICAgIG91dHB1dFBvcnRJZDogbm9kZU91dHB1dFBvcnRJZFxuICAgICAgICB9O1xuICAgICAgfTtcblxuICAgICAgLy8gSWYgYXQgbGVhc3Qgb25lIGVuZCBvZiB0aGUgZWRnZSBoYXMgcG9ydHMgdGhlbiB3ZSBzaG91bGQgZGV0ZXJtaW5lIHRoZSBwb3J0cyB3aGVyZSB0aGUgZWRnZSBzaG91bGQgYmUgY29ubmVjdGVkLlxuICAgICAgaWYgKHNvdXJjZUhhc1BvcnRzIHx8IHRhcmdldEhhc1BvcnRzKSB7XG4gICAgICAgIHZhciBzb3VyY2VOb2RlSW5wdXRQb3J0SWQsIHNvdXJjZU5vZGVPdXRwdXRQb3J0SWQsIHRhcmdldE5vZGVJbnB1dFBvcnRJZCwgdGFyZ2V0Tm9kZU91dHB1dFBvcnRJZDtcblxuICAgICAgICAvLyBJZiBzb3VyY2Ugbm9kZSBoYXMgcG9ydHMgc2V0IHRoZSB2YXJpYWJsZXMgZGVkaWNhdGVkIGZvciBpdHMgSU8gcG9ydHNcbiAgICAgICAgaWYgKCBzb3VyY2VIYXNQb3J0cyApIHtcbiAgICAgICAgICB2YXIgaW9Qb3J0cyA9IGdldElPUG9ydElkcyhzb3VyY2VOb2RlKTtcbiAgICAgICAgICBzb3VyY2VOb2RlSW5wdXRQb3J0SWQgPSBpb1BvcnRzLmlucHV0UG9ydElkO1xuICAgICAgICAgIHNvdXJjZU5vZGVPdXRwdXRQb3J0SWQgPSBpb1BvcnRzLm91dHB1dFBvcnRJZDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRhcmdldCBub2RlIGhhcyBwb3J0cyBzZXQgdGhlIHZhcmlhYmxlcyBkZWRpY2F0ZWQgZm9yIGl0cyBJTyBwb3J0c1xuICAgICAgICBpZiAoIHRhcmdldEhhc1BvcnRzICkge1xuICAgICAgICAgIHZhciBpb1BvcnRzID0gZ2V0SU9Qb3J0SWRzKHRhcmdldE5vZGUpO1xuICAgICAgICAgIHRhcmdldE5vZGVJbnB1dFBvcnRJZCA9IGlvUG9ydHMuaW5wdXRQb3J0SWQ7XG4gICAgICAgICAgdGFyZ2V0Tm9kZU91dHB1dFBvcnRJZCA9IGlvUG9ydHMub3V0cHV0UG9ydElkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNiZ25jbGFzcyA9PT0gJ2NvbnN1bXB0aW9uJykge1xuICAgICAgICAgIC8vIEEgY29uc3VtcHRpb24gZWRnZSBzaG91bGQgYmUgY29ubmVjdGVkIHRvIHRoZSBpbnB1dCBwb3J0IG9mIHRoZSB0YXJnZXQgbm9kZSB3aGljaCBpcyBzdXBwb3NlZCB0byBiZSBhIHByb2Nlc3MgKGFueSBraW5kIG9mKVxuICAgICAgICAgIHBvcnRzb3VyY2UgPSBzb3VyY2VOb2RlT3V0cHV0UG9ydElkO1xuICAgICAgICAgIHBvcnR0YXJnZXQgPSB0YXJnZXROb2RlSW5wdXRQb3J0SWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2JnbmNsYXNzID09PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAvLyBBIHByb2R1Y3Rpb24gZWRnZSBzaG91bGQgYmUgY29ubmVjdGVkIHRvIHRoZSBvdXRwdXQgcG9ydCBvZiB0aGUgc291cmNlIG5vZGUgd2hpY2ggaXMgc3VwcG9zZWQgdG8gYmUgYSBwcm9jZXNzIChhbnkga2luZCBvZilcbiAgICAgICAgICAvLyBBIG1vZHVsYXRpb24gZWRnZSBtYXkgaGF2ZSBhIGxvZ2ljYWwgb3BlcmF0b3IgYXMgc291cmNlIG5vZGUgaW4gdGhpcyBjYXNlIHRoZSBlZGdlIHNob3VsZCBiZSBjb25uZWN0ZWQgdG8gdGhlIG91dHB1dCBwb3J0IG9mIGl0XG4gICAgICAgICAgLy8gVGhlIGJlbG93IGFzc2lnbm1lbnQgc2F0aXNmeSBhbGwgb2YgdGhlc2UgY29uZGl0aW9uXG4gICAgICAgICAgaWYoZ3JvdXBJRCA9PSAwIHx8IGdyb3VwSUQgPT0gdW5kZWZpbmVkKSB7IC8vIGdyb3VwSUQgMCBmb3IgcmV2ZXJzaWJsZSByZWFjdGlvbnMgZ3JvdXAgMFxuICAgICAgICAgICAgcG9ydHNvdXJjZSA9IHNvdXJjZU5vZGVPdXRwdXRQb3J0SWQ7XG4gICAgICAgICAgICBwb3J0dGFyZ2V0ID0gdGFyZ2V0Tm9kZUlucHV0UG9ydElkO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHsgLy9pZiByZWFjdGlvbiBpcyByZXZlcnNpYmxlIGFuZCBlZGdlIGJlbG9uZ3MgdG8gZ3JvdXAgMVxuICAgICAgICAgICAgcG9ydHNvdXJjZSA9IHNvdXJjZU5vZGVJbnB1dFBvcnRJZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZihlbGVtZW50VXRpbGl0aWVzLmlzTW9kdWxhdGlvbkFyY0NsYXNzKHNiZ25jbGFzcykgfHwgZWxlbWVudFV0aWxpdGllcy5pc0FGQXJjQ2xhc3Moc2JnbmNsYXNzKSl7XG4gICAgICAgICAgcG9ydHNvdXJjZSA9IHNvdXJjZU5vZGVPdXRwdXRQb3J0SWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2JnbmNsYXNzID09PSAnbG9naWMgYXJjJykge1xuICAgICAgICAgIHZhciBzcmNDbGFzcyA9IHNvdXJjZU5vZGUuZGF0YSgnY2xhc3MnKTtcbiAgICAgICAgICB2YXIgdGd0Q2xhc3MgPSB0YXJnZXROb2RlLmRhdGEoJ2NsYXNzJyk7XG4gICAgICAgICAgdmFyIGlzU291cmNlTG9naWNhbE9wID0gc3JjQ2xhc3MgPT09ICdhbmQnIHx8IHNyY0NsYXNzID09PSAnb3InIHx8IHNyY0NsYXNzID09PSAnbm90JztcbiAgICAgICAgICB2YXIgaXNUYXJnZXRMb2dpY2FsT3AgPSB0Z3RDbGFzcyA9PT0gJ2FuZCcgfHwgdGd0Q2xhc3MgPT09ICdvcicgfHwgdGd0Q2xhc3MgPT09ICdub3QnO1xuXG4gICAgICAgICAgaWYgKGlzU291cmNlTG9naWNhbE9wICYmIGlzVGFyZ2V0TG9naWNhbE9wKSB7XG4gICAgICAgICAgICAvLyBJZiBib3RoIGVuZCBhcmUgbG9naWNhbCBvcGVyYXRvcnMgdGhlbiB0aGUgZWRnZSBzaG91bGQgYmUgY29ubmVjdGVkIHRvIHRoZSBpbnB1dCBwb3J0IG9mIHRoZSB0YXJnZXQgYW5kIHRoZSBvdXRwdXQgcG9ydCBvZiB0aGUgaW5wdXRcbiAgICAgICAgICAgIHBvcnR0YXJnZXQgPSB0YXJnZXROb2RlSW5wdXRQb3J0SWQ7XG4gICAgICAgICAgICBwb3J0c291cmNlID0gc291cmNlTm9kZU91dHB1dFBvcnRJZDtcbiAgICAgICAgICB9Ly8gSWYganVzdCBvbmUgZW5kIG9mIGxvZ2ljYWwgb3BlcmF0b3IgdGhlbiB0aGUgZWRnZSBzaG91bGQgYmUgY29ubmVjdGVkIHRvIHRoZSBpbnB1dCBwb3J0IG9mIHRoZSBsb2dpY2FsIG9wZXJhdG9yXG4gICAgICAgICAgZWxzZSBpZiAoaXNTb3VyY2VMb2dpY2FsT3ApIHtcbiAgICAgICAgICAgIHBvcnRzb3VyY2UgPSBzb3VyY2VOb2RlSW5wdXRQb3J0SWQ7XG4gICAgICAgICAgICBwb3J0dGFyZ2V0ID0gdGFyZ2V0Tm9kZU91dHB1dFBvcnRJZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoaXNUYXJnZXRMb2dpY2FsT3ApIHtcbiAgICAgICAgICAgIHBvcnRzb3VyY2UgPSBzb3VyY2VOb2RlT3V0cHV0UG9ydElkO1xuICAgICAgICAgICAgcG9ydHRhcmdldCA9IHRhcmdldE5vZGVJbnB1dFBvcnRJZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGRlZmF1bHQgcG9ydHNvdXJjZS9wb3J0dGFyZ2V0IGFyZSB0aGUgc291cmNlL3RhcmdldCB0aGVtc2VsdmVzLiBJZiB0aGV5IGFyZSBub3Qgc2V0IHVzZSB0aGVzZSBkZWZhdWx0cy5cbiAgICAgIC8vIFRoZSBwb3J0c291cmNlIGFuZCBwb3J0dGFyZ2V0IGFyZSBkZXRlcm1pbmVkIHNldCB0aGVtIGluIGRhdGEgb2JqZWN0LlxuICAgICAgZGF0YS5wb3J0c291cmNlID0gcG9ydHNvdXJjZSB8fCBzb3VyY2U7XG4gICAgICBkYXRhLnBvcnR0YXJnZXQgPSBwb3J0dGFyZ2V0IHx8IHRhcmdldDtcblxuICAgICAgdmFyIGVsZXMgPSBjeS5hZGQoe1xuICAgICAgICBncm91cDogXCJlZGdlc1wiLFxuICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICBjc3M6IGNzc1xuICAgICAgfSk7XG5cbiAgICAgIHZhciBuZXdFZGdlID0gZWxlc1tlbGVzLmxlbmd0aCAtIDFdO1xuXG4gICAgICByZXR1cm4gbmV3RWRnZTtcbiAgICB9O1xuXG4gICAgZWxlbWVudFV0aWxpdGllcy5hZGRQcm9jZXNzV2l0aENvbnZlbmllbnRFZGdlcyA9IGZ1bmN0aW9uKF9zb3VyY2UsIF90YXJnZXQsIG5vZGVQYXJhbXMpIHtcbiAgICAgIC8vIElmIHNvdXJjZSBhbmQgdGFyZ2V0IElEcyBhcmUgZ2l2ZW4gZ2V0IHRoZSBlbGVtZW50cyBieSBJRHNcbiAgICAgIHZhciBzb3VyY2UgPSB0eXBlb2YgX3NvdXJjZSA9PT0gJ3N0cmluZycgPyBjeS5nZXRFbGVtZW50QnlJZChfc291cmNlKSA6IF9zb3VyY2U7XG4gICAgICB2YXIgdGFyZ2V0ID0gdHlwZW9mIF90YXJnZXQgPT09ICdzdHJpbmcnID8gY3kuZ2V0RWxlbWVudEJ5SWQoX3RhcmdldCkgOiBfdGFyZ2V0O1xuXG4gICAgICAvLyBQcm9jZXNzIHBhcmVudCBzaG91bGQgYmUgdGhlIGNsb3Nlc3QgY29tbW9uIGFuY2VzdG9yIG9mIHRoZSBzb3VyY2UgYW5kIHRhcmdldCBub2Rlc1xuICAgICAgdmFyIHByb2Nlc3NQYXJlbnQgPSBjeS5jb2xsZWN0aW9uKFtzb3VyY2VbMF0sIHRhcmdldFswXV0pLmNvbW1vbkFuY2VzdG9ycygpLmZpcnN0KCk7XG5cbiAgICAgIC8vIFByb2Nlc3Mgc2hvdWxkIGJlIGF0IHRoZSBtaWRkbGUgb2YgdGhlIHNvdXJjZSBhbmQgdGFyZ2V0IG5vZGVzXG4gICAgICB2YXIgeCA9ICggc291cmNlLnBvc2l0aW9uKCd4JykgKyB0YXJnZXQucG9zaXRpb24oJ3gnKSApIC8gMjtcbiAgICAgIHZhciB5ID0gKCBzb3VyY2UucG9zaXRpb24oJ3knKSArIHRhcmdldC5wb3NpdGlvbigneScpICkgLyAyO1xuXG4gICAgICAvLyBDcmVhdGUgdGhlIHByb2Nlc3Mgd2l0aCBnaXZlbi9jYWxjdWxhdGVkIHZhcmlhYmxlc1xuICAgICAgdmFyIHByb2Nlc3MgPSBlbGVtZW50VXRpbGl0aWVzLmFkZE5vZGUoeCwgeSwgbm9kZVBhcmFtcywgdW5kZWZpbmVkLCBwcm9jZXNzUGFyZW50LmlkKCkpO1xuICAgICAgICB2YXIgeGRpZmYgPSBzb3VyY2UucG9zaXRpb24oJ3gnKSAtIHRhcmdldC5wb3NpdGlvbigneCcpO1xuICAgICAgICB2YXIgeWRpZmYgPSBzb3VyY2UucG9zaXRpb24oJ3knKSAtIHRhcmdldC5wb3NpdGlvbigneScpXG4gICAgICAgIGlmIChNYXRoLmFicyh4ZGlmZikgPj0gTWF0aC5hYnMoeWRpZmYpKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoeGRpZmYgPCAwKVxuICAgICAgICAgICAgICAgIGVsZW1lbnRVdGlsaXRpZXMuc2V0UG9ydHNPcmRlcmluZyhwcm9jZXNzLCAnTC10by1SJyk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZWxlbWVudFV0aWxpdGllcy5zZXRQb3J0c09yZGVyaW5nKHByb2Nlc3MsICdSLXRvLUwnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh5ZGlmZiA8IDApXG4gICAgICAgICAgICAgICAgZWxlbWVudFV0aWxpdGllcy5zZXRQb3J0c09yZGVyaW5nKHByb2Nlc3MsICdULXRvLUInKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBlbGVtZW50VXRpbGl0aWVzLnNldFBvcnRzT3JkZXJpbmcocHJvY2VzcywgJ0ItdG8tVCcpO1xuICAgICAgICB9XG5cblxuICAgICAgLy8gQ3JlYXRlIHRoZSBlZGdlcyBvbmUgaXMgYmV0d2VlbiB0aGUgcHJvY2VzcyBhbmQgdGhlIHNvdXJjZSBub2RlICh3aGljaCBzaG91bGQgYmUgYSBjb25zdW1wdGlvbiksXG4gICAgICAvLyB0aGUgb3RoZXIgb25lIGlzIGJldHdlZW4gdGhlIHByb2Nlc3MgYW5kIHRoZSB0YXJnZXQgbm9kZSAod2hpY2ggc2hvdWxkIGJlIGEgcHJvZHVjdGlvbikuXG4gICAgICAvLyBGb3IgbW9yZSBpbmZvcm1hdGlvbiBwbGVhc2UgcmVmZXIgdG8gU0JHTi1QRCByZWZlcmVuY2UgY2FyZC5cbiAgICAgIHZhciBlZGdlQnR3U3JjID0gZWxlbWVudFV0aWxpdGllcy5hZGRFZGdlKHNvdXJjZS5pZCgpLCBwcm9jZXNzLmlkKCksIHtjbGFzcyA6ICdjb25zdW1wdGlvbicsIGxhbmd1YWdlIDogbm9kZVBhcmFtcy5sYW5ndWFnZX0pO1xuICAgICAgdmFyIGVkZ2VCdHdUZ3QgPSBlbGVtZW50VXRpbGl0aWVzLmFkZEVkZ2UocHJvY2Vzcy5pZCgpLCB0YXJnZXQuaWQoKSwge2NsYXNzIDogJ3Byb2R1Y3Rpb24nLCBsYW5ndWFnZSA6IG5vZGVQYXJhbXMubGFuZ3VhZ2V9KTtcblxuICAgICAgLy8gQ3JlYXRlIGEgY29sbGVjdGlvbiBpbmNsdWRpbmcgdGhlIGVsZW1lbnRzIGFuZCB0byBiZSByZXR1cm5lZFxuICAgICAgdmFyIGNvbGxlY3Rpb24gPSBjeS5jb2xsZWN0aW9uKFtwcm9jZXNzWzBdLCBlZGdlQnR3U3JjWzBdLCBlZGdlQnR3VGd0WzBdXSk7XG4gICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICB9O1xuXG4gICAgLypcbiAgICAgKiBUaGlzIG1ldGhvZCBhc3N1bWVzIHRoYXQgcGFyYW0ubm9kZXNUb01ha2VDb21wb3VuZCBjb250YWlucyBhdCBsZWFzdCBvbmUgbm9kZVxuICAgICAqIGFuZCBhbGwgb2YgdGhlIG5vZGVzIGluY2x1ZGluZyBpbiBpdCBoYXZlIHRoZSBzYW1lIHBhcmVudC4gSXQgY3JlYXRlcyBhIGNvbXBvdW5kIGZvdCB0aGUgZ2l2ZW4gbm9kZXMgYW4gaGF2aW5nIHRoZSBnaXZlbiB0eXBlLlxuICAgICAqL1xuICAgIGVsZW1lbnRVdGlsaXRpZXMuY3JlYXRlQ29tcG91bmRGb3JHaXZlbk5vZGVzID0gZnVuY3Rpb24gKG5vZGVzVG9NYWtlQ29tcG91bmQsIGNvbXBvdW5kVHlwZSkge1xuICAgICAgdmFyIG9sZFBhcmVudElkID0gbm9kZXNUb01ha2VDb21wb3VuZFswXS5kYXRhKFwicGFyZW50XCIpO1xuICAgICAgdmFyIGxhbmd1YWdlID0gbm9kZXNUb01ha2VDb21wb3VuZFswXS5kYXRhKFwibGFuZ3VhZ2VcIik7XG4gICAgICAvLyBpZiBub2Rlc1RvTWFrZUNvbXBvdW5kIGNvbnRhaW4gYm90aCBQRCBhbmQgQUYgbm9kZXMsIHRoZW4gc2V0IGxhbmd1YWdlIG9mIGNvbXBvdW5kIGFzIFVua25vd25cbiAgICAgIGZvciggdmFyIGk9MTsgaTxub2Rlc1RvTWFrZUNvbXBvdW5kLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgaWYobm9kZXNUb01ha2VDb21wb3VuZFtpXSAhPSBsYW5ndWFnZSl7XG4gICAgICAgICAgbGFuZ3VhZ2UgPSBcIlVua25vd25cIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gVGhlIHBhcmVudCBvZiBuZXcgY29tcG91bmQgd2lsbCBiZSB0aGUgb2xkIHBhcmVudCBvZiB0aGUgbm9kZXMgdG8gbWFrZSBjb21wb3VuZC4geCwgeSBhbmQgaWQgcGFyYW1ldGVycyBhcmUgbm90IHNldC5cbiAgICAgIHZhciBuZXdDb21wb3VuZCA9IGVsZW1lbnRVdGlsaXRpZXMuYWRkTm9kZSh1bmRlZmluZWQsIHVuZGVmaW5lZCwge2NsYXNzIDogY29tcG91bmRUeXBlLCBsYW5ndWFnZSA6IGxhbmd1YWdlfSwgdW5kZWZpbmVkLCBvbGRQYXJlbnRJZCk7XG4gICAgICB2YXIgbmV3Q29tcG91bmRJZCA9IG5ld0NvbXBvdW5kLmlkKCk7XG4gICAgICB2YXIgbmV3RWxlcyA9IGVsZW1lbnRVdGlsaXRpZXMuY2hhbmdlUGFyZW50KG5vZGVzVG9NYWtlQ29tcG91bmQsIG5ld0NvbXBvdW5kSWQpO1xuICAgICAgbmV3RWxlcyA9IG5ld0VsZXMudW5pb24obmV3Q29tcG91bmQpO1xuICAgICAgcmV0dXJuIG5ld0VsZXM7XG4gICAgfTtcblxuICAgIGVsZW1lbnRVdGlsaXRpZXMuY3JlYXRlVHJhbnNsYXRpb25SZWFjdGlvbiA9IGZ1bmN0aW9uKG1SbmFOYW1lLCBwcm90ZWluTmFtZSwgcHJvY2Vzc1Bvc2l0aW9uLCBlZGdlTGVuZ3RoKSB7XG4gICAgICBjb25zdCBkZWZhdWx0UHJvY2Vzc1Byb3BlcnRpZXMgPSBlbGVtZW50VXRpbGl0aWVzLmdldERlZmF1bHRQcm9wZXJ0aWVzKFwidHJhbnNsYXRpb25cIik7XG4gICAgICBjb25zdCBkZWZhdWx0U291cmNlQW5kU2lua1Byb3BlcnRpZXMgPSBlbGVtZW50VXRpbGl0aWVzLmdldERlZmF1bHRQcm9wZXJ0aWVzKFwiZW1wdHkgc2V0XCIpO1xuICAgICAgY29uc3QgZGVmYXVsdE51Y2xlaWNBY2lkRmVhdHVyZVByb3BlcnRpZXMgPSBlbGVtZW50VXRpbGl0aWVzLmdldERlZmF1bHRQcm9wZXJ0aWVzKFwibnVjbGVpYyBhY2lkIGZlYXR1cmVcIik7XG4gICAgICBjb25zdCBkZWZhdWx0TWFjcm9tb2xlY3VsZVByb3BlcnRpZXMgPSBlbGVtZW50VXRpbGl0aWVzLmdldERlZmF1bHRQcm9wZXJ0aWVzKFwibWFjcm9tb2xlY3VsZVwiKTtcbiAgICAgIGNvbnN0IG1hY3JvbW9sZWN1bGVXaWR0aCA9IGRlZmF1bHRNYWNyb21vbGVjdWxlUHJvcGVydGllcy53aWR0aCB8fCA1MDtcbiAgICAgIGNvbnN0IHNvdXJjZUFuZFNpbmtXaWR0aCA9IGRlZmF1bHRTb3VyY2VBbmRTaW5rUHJvcGVydGllcy53aWR0aCAgfHwgNTA7XG4gICAgICBjb25zdCBudWNsZWljQWNpZEZlYXR1cmVIZWlnaHQgPSBkZWZhdWx0TnVjbGVpY0FjaWRGZWF0dXJlUHJvcGVydGllcy5oZWlnaHQgfHwgNTA7XG4gICAgICBjb25zdCBwcm9jZXNzV2lkdGggPSBkZWZhdWx0UHJvY2Vzc1Byb3BlcnRpZXMud2lkdGggfHwgNTA7XG4gICAgICBjb25zdCBwcm9jZXNzSGVpZ2h0ID0gZGVmYXVsdFByb2Nlc3NQcm9wZXJ0aWVzLmhlaWdodCB8fCA1MDtcbiAgICAgIHZhciBwcm9jZXNzUG9zaXRpb24gPSBwcm9jZXNzUG9zaXRpb24gfHwgZWxlbWVudFV0aWxpdGllcy5jb252ZXJ0VG9Nb2RlbFBvc2l0aW9uKHt4OiBjeS53aWR0aCgpIC8gMiwgeTogY3kuaGVpZ2h0KCkgLyAyfSk7XG4gICAgICB2YXIgZWRnZUxlbmd0aCA9IGVkZ2VMZW5ndGggfHwgNjA7XG5cbiAgICAgIGN5LnN0YXJ0QmF0Y2goKTtcbiAgICAgIGlmICghZWxlbWVudFV0aWxpdGllcy5nZXRNYXBUeXBlKCkpIHtcbiAgICAgICAgZWxlbWVudFV0aWxpdGllcy5zZXRNYXBUeXBlKFwiUERcIik7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcm9jZXNzTm9kZSA9IGVsZW1lbnRVdGlsaXRpZXMuYWRkTm9kZShwcm9jZXNzUG9zaXRpb24ueCwgcHJvY2Vzc1Bvc2l0aW9uLnksIHtjbGFzczogXCJwcm9jZXNzXCIsIGxhbmd1YWdlOiBcIlBEXCJ9KTtcbiAgICAgIGVsZW1lbnRVdGlsaXRpZXMuc2V0UG9ydHNPcmRlcmluZyhwcm9jZXNzTm9kZSwgXCJMLXRvLVJcIik7XG4gICAgICBwcm9jZXNzTm9kZS5kYXRhKCdqdXN0QWRkZWQnLCB0cnVlKTtcblxuICAgICAgY29uc3QgeFBvc09mU291cmNlQW5kU2lua05vZGUgPSBwcm9jZXNzUG9zaXRpb24ueCAtIGVkZ2VMZW5ndGggLSBwcm9jZXNzV2lkdGggLyAyIC0gc291cmNlQW5kU2lua1dpZHRoIC8gMjtcbiAgICAgIGNvbnN0IHlQb3NPZlNvdXJjZUFuZFNpbmtOb2RlID0gcHJvY2Vzc1Bvc2l0aW9uLnk7XG4gICAgICB2YXIgc291cmNlQW5kU2lua05vZGUgPSBlbGVtZW50VXRpbGl0aWVzLmFkZE5vZGUoeFBvc09mU291cmNlQW5kU2lua05vZGUsIHlQb3NPZlNvdXJjZUFuZFNpbmtOb2RlLCB7Y2xhc3M6ICdlbXB0eSBzZXQnLCBsYW5ndWFnZTogJ1BEJ30pO1xuICAgICAgc291cmNlQW5kU2lua05vZGUuZGF0YSgnanVzdEFkZGVkJywgdHJ1ZSk7XG5cbiAgICAgIHZhciBjb25zdW1wdGlvbkVkZ2UgPSBlbGVtZW50VXRpbGl0aWVzLmFkZEVkZ2Uoc291cmNlQW5kU2lua05vZGUuaWQoKSwgcHJvY2Vzc05vZGUuaWQoKSwge2NsYXNzOiAnY29uc3VtcHRpb24nLCBsYW5ndWFnZTogJ1BEJ30pO1xuICAgICAgY29uc3VtcHRpb25FZGdlLmRhdGEoJ2p1c3RBZGRlZCcsIHRydWUpO1xuXG4gICAgICBjb25zdCB4UG9zT2ZtUm5hTm9kZSA9IHByb2Nlc3NQb3NpdGlvbi54O1xuICAgICAgY29uc3QgeVBvc09mbVJuYU5vZGUgPSBwcm9jZXNzUG9zaXRpb24ueSAtIGVkZ2VMZW5ndGggLSBwcm9jZXNzSGVpZ2h0IC8gMiAtIG51Y2xlaWNBY2lkRmVhdHVyZUhlaWdodCAvIDI7XG4gICAgICB2YXIgbVJuYU5vZGUgPSBlbGVtZW50VXRpbGl0aWVzLmFkZE5vZGUoeFBvc09mbVJuYU5vZGUsIHlQb3NPZm1SbmFOb2RlLCB7Y2xhc3M6ICdudWNsZWljIGFjaWQgZmVhdHVyZScsIGxhbmd1YWdlOiAnUEQnfSk7XG4gICAgICBtUm5hTm9kZS5kYXRhKCdqdXN0QWRkZWQnLCB0cnVlKTtcbiAgICAgIG1SbmFOb2RlLmRhdGEoJ2xhYmVsJywgbVJuYU5hbWUpO1xuICAgICAgY29uc3QgaW5mb2JveE9iamVjdE9mR2VuZSA9IHtcbiAgICAgICAgY2xheno6IFwidW5pdCBvZiBpbmZvcm1hdGlvblwiLFxuICAgICAgICBsYWJlbDoge1xuICAgICAgICAgIHRleHQ6ICdjdDptUk5BJ1xuICAgICAgICB9LFxuICAgICAgICBiYm94OiB7XG4gICAgICAgICAgdzogNDUsXG4gICAgICAgICAgaDogMTVcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGVsZW1lbnRVdGlsaXRpZXMuYWRkU3RhdGVPckluZm9Cb3gobVJuYU5vZGUsIGluZm9ib3hPYmplY3RPZkdlbmUpO1xuXG4gICAgICB2YXIgbmVjZXNzYXJ5U3RpbXVsYXRpb25FZGdlID0gZWxlbWVudFV0aWxpdGllcy5hZGRFZGdlKG1SbmFOb2RlLmlkKCksIHByb2Nlc3NOb2RlLmlkKCksIHtjbGFzczogJ25lY2Vzc2FyeSBzdGltdWxhdGlvbicsIGxhbmd1YWdlOiAnUEQnfSk7XG4gICAgICBuZWNlc3NhcnlTdGltdWxhdGlvbkVkZ2UuZGF0YSgnanVzdEFkZGVkJywgdHJ1ZSk7XG5cbiAgICAgIGNvbnN0IHhQb3NPZlByb3RlaW5Ob2RlID0gcHJvY2Vzc1Bvc2l0aW9uLnggKyBlZGdlTGVuZ3RoICsgcHJvY2Vzc1dpZHRoIC8gMiArIG1hY3JvbW9sZWN1bGVXaWR0aCAvIDI7XG4gICAgICBjb25zdCB5UG9zdE9mUHJvdGVpbk5vZGUgPSBwcm9jZXNzUG9zaXRpb24ueTtcbiAgICAgIHZhciBwcm90ZWluTm9kZSA9IGVsZW1lbnRVdGlsaXRpZXMuYWRkTm9kZSh4UG9zT2ZQcm90ZWluTm9kZSwgeVBvc3RPZlByb3RlaW5Ob2RlLCB7Y2xhc3M6ICdtYWNyb21vbGVjdWxlJywgbGFuZ3VhZ2U6ICdQRCd9KTtcbiAgICAgIHByb3RlaW5Ob2RlLmRhdGEoJ2p1c3RBZGRlZCcsIHRydWUpO1xuICAgICAgcHJvdGVpbk5vZGUuZGF0YSgnbGFiZWwnLCBwcm90ZWluTmFtZSk7XG4gIFxuICAgICAgdmFyIHByb2R1Y3Rpb25FZGdlID0gZWxlbWVudFV0aWxpdGllcy5hZGRFZGdlKHByb2Nlc3NOb2RlLmlkKCksIHByb3RlaW5Ob2RlLmlkKCksIHtjbGFzczogJ3Byb2R1Y3Rpb24nLCBsYW5ndWFnZTogJ1BEJ30pO1xuICAgICAgcHJvZHVjdGlvbkVkZ2UuZGF0YSgnanVzdEFkZGVkJywgdHJ1ZSk7XG5cbiAgICAgIGN5LmVuZEJhdGNoKCk7XG5cbiAgICAgIC8vZmlsdGVyIHRoZSBqdXN0IGFkZGVkIGVsZW1lbXRzIHRvIHJldHVybiB0aGVtIGFuZCByZW1vdmUganVzdCBhZGRlZCBtYXJrXG4gICAgICB2YXIgZWxlcyA9IGN5LmVsZW1lbnRzKCdbanVzdEFkZGVkXScpO1xuICAgICAgZWxlcy5yZW1vdmVEYXRhKCdqdXN0QWRkZWQnKTtcblxuICAgICAgY3kuZWxlbWVudHMoKS51bnNlbGVjdCgpO1xuICAgICAgZWxlcy5zZWxlY3QoKTtcblxuICAgICAgcmV0dXJuIGVsZXM7IC8vIFJldHVybiB0aGUganVzdCBhZGRlZCBlbGVtZW50c1xuICAgIH07XG5cbiAgICBlbGVtZW50VXRpbGl0aWVzLmNyZWF0ZVRyYW5zY3JpcHRpb25SZWFjdGlvbiA9IGZ1bmN0aW9uKGdlbmVOYW1lLCBtUm5hTmFtZSwgcHJvY2Vzc1Bvc2l0aW9uLCBlZGdlTGVuZ3RoKSB7XG4gICAgICBjb25zdCBkZWZhdWx0UHJvY2Vzc1Byb3BlcnRpZXMgPSBlbGVtZW50VXRpbGl0aWVzLmdldERlZmF1bHRQcm9wZXJ0aWVzKFwidHJhbnNjcmlwdGlvblwiKTtcbiAgICAgIGNvbnN0IGRlZmF1bHRTb3VyY2VBbmRTaW5rUHJvcGVydGllcyA9IGVsZW1lbnRVdGlsaXRpZXMuZ2V0RGVmYXVsdFByb3BlcnRpZXMoXCJlbXB0eSBzZXRcIik7XG4gICAgICBjb25zdCBkZWZhdWx0TnVjbGVpY0FjaWRGZWF0dXJlUHJvcGVydGllcyA9IGVsZW1lbnRVdGlsaXRpZXMuZ2V0RGVmYXVsdFByb3BlcnRpZXMoXCJudWNsZWljIGFjaWQgZmVhdHVyZVwiKTtcbiAgICAgIGNvbnN0IHNvdXJjZUFuZFNpbmtXaWR0aCA9IGRlZmF1bHRTb3VyY2VBbmRTaW5rUHJvcGVydGllcy53aWR0aCAgfHwgNTA7XG4gICAgICBjb25zdCBudWNsZWljQWNpZEZlYXR1cmVIZWlnaHQgPSBkZWZhdWx0TnVjbGVpY0FjaWRGZWF0dXJlUHJvcGVydGllcy5oZWlnaHQgfHwgNTA7XG4gICAgICBjb25zdCBudWNsZWljQWNpZEZlYXR1cmVXaWR0aCA9IGRlZmF1bHROdWNsZWljQWNpZEZlYXR1cmVQcm9wZXJ0aWVzLndpZHRoIHx8IDUwO1xuICAgICAgY29uc3QgcHJvY2Vzc1dpZHRoID0gZGVmYXVsdFByb2Nlc3NQcm9wZXJ0aWVzLndpZHRoIHx8IDUwO1xuICAgICAgY29uc3QgcHJvY2Vzc0hlaWdodCA9IGRlZmF1bHRQcm9jZXNzUHJvcGVydGllcy5oZWlnaHQgfHwgNTA7XG4gICAgICB2YXIgcHJvY2Vzc1Bvc2l0aW9uID0gcHJvY2Vzc1Bvc2l0aW9uIHx8IGVsZW1lbnRVdGlsaXRpZXMuY29udmVydFRvTW9kZWxQb3NpdGlvbih7eDogY3kud2lkdGgoKSAvIDIsIHk6IGN5LmhlaWdodCgpIC8gMn0pO1xuICAgICAgdmFyIGVkZ2VMZW5ndGggPSBlZGdlTGVuZ3RoIHx8IDYwO1xuXG4gICAgICBjeS5zdGFydEJhdGNoKCk7XG4gICAgICBpZiAoIWVsZW1lbnRVdGlsaXRpZXMuZ2V0TWFwVHlwZSgpKSB7XG4gICAgICAgIGVsZW1lbnRVdGlsaXRpZXMuc2V0TWFwVHlwZShcIlBEXCIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHJvY2Vzc05vZGUgPSBlbGVtZW50VXRpbGl0aWVzLmFkZE5vZGUocHJvY2Vzc1Bvc2l0aW9uLngsIHByb2Nlc3NQb3NpdGlvbi55LCB7Y2xhc3M6IFwicHJvY2Vzc1wiLCBsYW5ndWFnZTogXCJQRFwifSk7XG4gICAgICBlbGVtZW50VXRpbGl0aWVzLnNldFBvcnRzT3JkZXJpbmcocHJvY2Vzc05vZGUsIFwiTC10by1SXCIpO1xuICAgICAgcHJvY2Vzc05vZGUuZGF0YSgnanVzdEFkZGVkJywgdHJ1ZSk7XG5cbiAgICAgIGNvbnN0IHhQb3NPZlNvdXJjZUFuZFNpbmtOb2RlID0gcHJvY2Vzc1Bvc2l0aW9uLnggLSBlZGdlTGVuZ3RoIC0gcHJvY2Vzc1dpZHRoIC8gMiAtIHNvdXJjZUFuZFNpbmtXaWR0aCAvIDI7XG4gICAgICBjb25zdCB5UG9zT2ZTb3VyY2VBbmRTaW5rTm9kZSA9IHByb2Nlc3NQb3NpdGlvbi55O1xuICAgICAgdmFyIHNvdXJjZUFuZFNpbmtOb2RlID0gZWxlbWVudFV0aWxpdGllcy5hZGROb2RlKHhQb3NPZlNvdXJjZUFuZFNpbmtOb2RlLCB5UG9zT2ZTb3VyY2VBbmRTaW5rTm9kZSwge2NsYXNzOiAnZW1wdHkgc2V0JywgbGFuZ3VhZ2U6ICdQRCd9KTtcbiAgICAgIHNvdXJjZUFuZFNpbmtOb2RlLmRhdGEoJ2p1c3RBZGRlZCcsIHRydWUpO1xuXG4gICAgICB2YXIgY29uc3VtcHRpb25FZGdlID0gZWxlbWVudFV0aWxpdGllcy5hZGRFZGdlKHNvdXJjZUFuZFNpbmtOb2RlLmlkKCksIHByb2Nlc3NOb2RlLmlkKCksIHtjbGFzczogJ2NvbnN1bXB0aW9uJywgbGFuZ3VhZ2U6ICdQRCd9KTtcbiAgICAgIGNvbnN1bXB0aW9uRWRnZS5kYXRhKCdqdXN0QWRkZWQnLCB0cnVlKTtcblxuICAgICAgY29uc3QgeFBvc09mR2VuZU5vZGUgPSBwcm9jZXNzUG9zaXRpb24ueDtcbiAgICAgIGNvbnN0IHlQb3NPZkdlbmVOb2RlID0gcHJvY2Vzc1Bvc2l0aW9uLnkgLSBlZGdlTGVuZ3RoIC0gcHJvY2Vzc0hlaWdodCAvIDIgLSBudWNsZWljQWNpZEZlYXR1cmVIZWlnaHQgLyAyO1xuICAgICAgdmFyIGdlbmVOb2RlID0gZWxlbWVudFV0aWxpdGllcy5hZGROb2RlKHhQb3NPZkdlbmVOb2RlLCB5UG9zT2ZHZW5lTm9kZSwge2NsYXNzOiAnbnVjbGVpYyBhY2lkIGZlYXR1cmUnLCBsYW5ndWFnZTogJ1BEJ30pO1xuICAgICAgZ2VuZU5vZGUuZGF0YSgnanVzdEFkZGVkJywgdHJ1ZSk7XG4gICAgICBnZW5lTm9kZS5kYXRhKCdsYWJlbCcsIGdlbmVOYW1lKTtcbiAgICAgIGNvbnN0IGluZm9ib3hPYmplY3RPZkdlbmUgPSB7XG4gICAgICAgIGNsYXp6OiBcInVuaXQgb2YgaW5mb3JtYXRpb25cIixcbiAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICB0ZXh0OiAnY3Q6Z2VuZSdcbiAgICAgICAgfSxcbiAgICAgICAgYmJveDoge1xuICAgICAgICAgIHc6IDM2LFxuICAgICAgICAgIGg6IDE1XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBlbGVtZW50VXRpbGl0aWVzLmFkZFN0YXRlT3JJbmZvQm94KGdlbmVOb2RlLCBpbmZvYm94T2JqZWN0T2ZHZW5lKTtcblxuICAgICAgdmFyIG5lY2Vzc2FyeVN0aW11bGF0aW9uRWRnZSA9IGVsZW1lbnRVdGlsaXRpZXMuYWRkRWRnZShnZW5lTm9kZS5pZCgpLCBwcm9jZXNzTm9kZS5pZCgpLCB7Y2xhc3M6ICduZWNlc3Nhcnkgc3RpbXVsYXRpb24nLCBsYW5ndWFnZTogJ1BEJ30pO1xuICAgICAgbmVjZXNzYXJ5U3RpbXVsYXRpb25FZGdlLmRhdGEoJ2p1c3RBZGRlZCcsIHRydWUpO1xuXG4gICAgICBjb25zdCB4UG9zT2ZtUm5hTm9kZSA9IHByb2Nlc3NQb3NpdGlvbi54ICsgZWRnZUxlbmd0aCArIHByb2Nlc3NXaWR0aCAvIDIgKyBudWNsZWljQWNpZEZlYXR1cmVXaWR0aCAvIDI7XG4gICAgICBjb25zdCB5UG9zdE9mbVJuYU5vZGUgPSBwcm9jZXNzUG9zaXRpb24ueTtcbiAgICAgIHZhciBtUm5hTm9kZSA9IGVsZW1lbnRVdGlsaXRpZXMuYWRkTm9kZSh4UG9zT2ZtUm5hTm9kZSwgeVBvc3RPZm1SbmFOb2RlLCB7Y2xhc3M6ICdudWNsZWljIGFjaWQgZmVhdHVyZScsIGxhbmd1YWdlOiAnUEQnfSk7XG4gICAgICBtUm5hTm9kZS5kYXRhKCdqdXN0QWRkZWQnLCB0cnVlKTtcbiAgICAgIG1SbmFOb2RlLmRhdGEoJ2xhYmVsJywgbVJuYU5hbWUpO1xuICAgICAgY29uc3QgaW5mb2JveE9iamVjdE9mbVJuYSA9IHtcbiAgICAgICAgY2xheno6IFwidW5pdCBvZiBpbmZvcm1hdGlvblwiLFxuICAgICAgICBsYWJlbDoge1xuICAgICAgICAgIHRleHQ6ICdjdDptUk5BJ1xuICAgICAgICB9LFxuICAgICAgICBiYm94OiB7XG4gICAgICAgICAgdzogNDUsXG4gICAgICAgICAgaDogMTVcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGVsZW1lbnRVdGlsaXRpZXMuYWRkU3RhdGVPckluZm9Cb3gobVJuYU5vZGUsIGluZm9ib3hPYmplY3RPZm1SbmEpO1xuXG4gICAgICB2YXIgcHJvZHVjdGlvbkVkZ2UgPSBlbGVtZW50VXRpbGl0aWVzLmFkZEVkZ2UocHJvY2Vzc05vZGUuaWQoKSwgbVJuYU5vZGUuaWQoKSwge2NsYXNzOiAncHJvZHVjdGlvbicsIGxhbmd1YWdlOiAnUEQnfSk7XG4gICAgICBwcm9kdWN0aW9uRWRnZS5kYXRhKCdqdXN0QWRkZWQnLCB0cnVlKTtcblxuICAgICAgY3kuZW5kQmF0Y2goKTtcblxuICAgICAgLy9maWx0ZXIgdGhlIGp1c3QgYWRkZWQgZWxlbWVtdHMgdG8gcmV0dXJuIHRoZW0gYW5kIHJlbW92ZSBqdXN0IGFkZGVkIG1hcmtcbiAgICAgIHZhciBlbGVzID0gY3kuZWxlbWVudHMoJ1tqdXN0QWRkZWRdJyk7XG4gICAgICBlbGVzLnJlbW92ZURhdGEoJ2p1c3RBZGRlZCcpO1xuXG4gICAgICBjeS5lbGVtZW50cygpLnVuc2VsZWN0KCk7XG4gICAgICBlbGVzLnNlbGVjdCgpO1xuXG4gICAgICByZXR1cm4gZWxlczsgLy8gUmV0dXJuIHRoZSBqdXN0IGFkZGVkIGVsZW1lbnRzXG4gICAgfTtcblxuICAgIGVsZW1lbnRVdGlsaXRpZXMucm90YXRlOTAgPSBmdW5jdGlvbihwb2ludCwgY2VudGVyKSB7XG4gICAgICBjb25zdCByZWxhdGl2ZVggPSBjZW50ZXIueCAtIHBvaW50Lng7XG4gICAgICBjb25zdCByZWxhdGl2ZVkgPSBjZW50ZXIueSAtIHBvaW50Lnk7XG5cbiAgICAgIGNvbnN0IHJlbGF0aXZlUm90YXRlZFggPSByZWxhdGl2ZVk7XG4gICAgICBjb25zdCByZWxhdGl2ZVJvdGF0ZWRZID0gLTEgKiByZWxhdGl2ZVg7XG5cbiAgICAgIGNvbnN0IHJlc3VsdFggPSByZWxhdGl2ZVJvdGF0ZWRYICsgY2VudGVyLng7XG4gICAgICBjb25zdCByZXN1bHRZID0gcmVsYXRpdmVSb3RhdGVkWSArIGNlbnRlci55O1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiByZXN1bHRYLFxuICAgICAgICB5OiByZXN1bHRZXG4gICAgICB9XG4gICAgfVxuXG4gICAgZWxlbWVudFV0aWxpdGllcy5jcmVhdGVUcmFuc2xhdGlvbiA9IGZ1bmN0aW9uKHJlZ3VsYXRvckxhYmVsLCBvdXRwdXRMYWJlbCwgb3JpZW50YXRpb24pIHtcbiAgICAgIGNvbnN0IGRlZmF1bHRTb3VyY2VBbmRTaW5rUHJvcGVydGllcyA9IGVsZW1lbnRVdGlsaXRpZXMuZ2V0RGVmYXVsdFByb3BlcnRpZXMoXCJlbXB0eSBzZXRcIik7XG4gICAgICBjb25zdCBkZWZhdWx0TnVjbGVpY0FjaWRGZWF0dXJlUHJvcGVydGllcyA9IGVsZW1lbnRVdGlsaXRpZXMuZ2V0RGVmYXVsdFByb3BlcnRpZXMoXCJudWNsZWljIGFjaWQgZmVhdHVyZVwiKTtcbiAgICAgIGNvbnN0IGRlZmF1bHRNYWNyb21vbGVjdWxlUHJvcGV0aWVzID0gZWxlbWVudFV0aWxpdGllcy5nZXREZWZhdWx0UHJvcGVydGllcyhcIm1hY3JvbW9sZWN1bGVcIilcbiAgICAgIGNvbnN0IGRlZmF1bHRQcm9jZXNzUHJvcGVydGllcyA9IGVsZW1lbnRVdGlsaXRpZXMuZ2V0RGVmYXVsdFByb3BlcnRpZXMoXCJwcm9jZXNzXCIpO1xuICAgICAgY29uc3Qgc291cmNlQW5kU2lua1dpZHRoID0gZGVmYXVsdFNvdXJjZUFuZFNpbmtQcm9wZXJ0aWVzLndpZHRoIHx8IDUwO1xuICAgICAgY29uc3QgbnVjbGVpY0FjaWRGZWF0dXJlV2lkdGggPSBkZWZhdWx0TnVjbGVpY0FjaWRGZWF0dXJlUHJvcGVydGllcy53aWR0aCB8fCA1MDtcbiAgICAgIGNvbnN0IG51Y2xlaWNBY2lkRmVhdHVyZUhlaWdodCA9IGRlZmF1bHROdWNsZWljQWNpZEZlYXR1cmVQcm9wZXJ0aWVzLmhlaWdodCB8fCA1MDtcbiAgICAgIGNvbnN0IG1hY3JvbW9sZWN1bGVXaWR0aCA9IGRlZmF1bHRNYWNyb21vbGVjdWxlUHJvcGV0aWVzLndpZHRoIHx8IDUwO1xuICAgICAgY29uc3QgcHJvY2Vzc1dpZHRoID0gZGVmYXVsdFByb2Nlc3NQcm9wZXJ0aWVzLndpZHRoIHx8IDUwO1xuICAgICAgY29uc3QgcHJvY2Vzc0hlaWdodCA9IGRlZmF1bHRQcm9jZXNzUHJvcGVydGllcy5oZWlnaHQgfHwgNTA7XG4gICAgICBjb25zdCBwcm9jZXNzUG9zaXRpb24gPSBlbGVtZW50VXRpbGl0aWVzLmNvbnZlcnRUb01vZGVsUG9zaXRpb24oe3g6IGN5LndpZHRoKCkgLyAyLCB5OiBjeS5oZWlnaHQoKSAvIDJ9KTtcbiAgICAgIGNvbnN0IGVkZ2VMZW5ndGggPSAzMDtcbiAgICAgIGNvbnN0IHZlcnRpY2FsID0gb3JpZW50YXRpb24gPT09IFwidmVydGljYWxcIjtcbiAgICAgIGNvbnN0IHByb2Nlc3NQb3J0c09yZGVyaW5nID0gdmVydGljYWwgPyBcIlQtdG8tQlwiIDogXCJMLXRvLVJcIjtcbiAgICAgIGNvbnN0IG1pbkluZm9ib3hEaW1lbnNpb24gPSAxNTtcbiAgICAgIGNvbnN0IHdpZHRoUGVyQ2hhciA9IDY7XG4gICAgICBjb25zdCByZWd1bGF0b3JJbmZvYm94TGFiZWwgPSBcImN0Om1STkFcIjtcblxuICAgICAgY3kuc3RhcnRCYXRjaCgpO1xuXG4gICAgICBpZiAoIWVsZW1lbnRVdGlsaXRpZXMuZ2V0TWFwVHlwZSgpKSB7XG4gICAgICAgIGVsZW1lbnRVdGlsaXRpZXMuc2V0TWFwVHlwZShcIlBEXCIpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwcm9jZXNzTm9kZSA9IGVsZW1lbnRVdGlsaXRpZXMuYWRkTm9kZShwcm9jZXNzUG9zaXRpb24ueCwgcHJvY2Vzc1Bvc2l0aW9uLnksIHtjbGFzczogXCJwcm9jZXNzXCIsIGxhbmd1YWdlOiBcIlBEXCJ9KTtcbiAgICAgIGVsZW1lbnRVdGlsaXRpZXMuc2V0UG9ydHNPcmRlcmluZyhwcm9jZXNzTm9kZSwgcHJvY2Vzc1BvcnRzT3JkZXJpbmcpO1xuICAgICAgcHJvY2Vzc05vZGUuZGF0YSgnanVzdEFkZGVkJywgdHJ1ZSk7XG5cbiAgICAgIGxldCB4UG9zT2ZJbnB1dCA9IHByb2Nlc3NQb3NpdGlvbi54IC0gZWRnZUxlbmd0aCAtIHByb2Nlc3NXaWR0aCAvIDIgLSBzb3VyY2VBbmRTaW5rV2lkdGggLyAyO1xuICAgICAgbGV0IHhQb3NPZk91dHB1dCA9IHByb2Nlc3NQb3NpdGlvbi54ICsgZWRnZUxlbmd0aCArIHByb2Nlc3NXaWR0aCAvIDIgKyBtYWNyb21vbGVjdWxlV2lkdGggLyAyO1xuICAgICAgbGV0IHlQb3NPZklucHV0ID0gcHJvY2Vzc1Bvc2l0aW9uLnk7XG4gICAgICBsZXQgeVBvc09mT3V0cHV0ID0gcHJvY2Vzc1Bvc2l0aW9uLnk7XG5cbiAgICAgIGxldCBub2RlUG9zaXRpb24gPSB7XG4gICAgICAgIHg6IHhQb3NPZklucHV0LFxuICAgICAgICB5OiB5UG9zT2ZJbnB1dFxuICAgICAgfVxuICAgICAgaWYgKHZlcnRpY2FsKSB7XG4gICAgICAgIG5vZGVQb3NpdGlvbiA9IGVsZW1lbnRVdGlsaXRpZXMucm90YXRlOTAobm9kZVBvc2l0aW9uLCBwcm9jZXNzUG9zaXRpb24pO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBpbnB1dE5vZGUgPSBlbGVtZW50VXRpbGl0aWVzLmFkZE5vZGUobm9kZVBvc2l0aW9uLngsIG5vZGVQb3NpdGlvbi55LCB7Y2xhc3M6ICdlbXB0eSBzZXQnLCBsYW5ndWFnZTogJ1BEJ30pO1xuICAgICAgaW5wdXROb2RlLmRhdGEoXCJqdXN0QWRkZWRcIiwgdHJ1ZSk7XG4gICAgICBpbnB1dE5vZGUuZGF0YShcImxhYmVsXCIsIGxhYmVsKTtcblxuICAgICAgY29uc3QgaW5wdXRFZGdlID0gZWxlbWVudFV0aWxpdGllcy5hZGRFZGdlKGlucHV0Tm9kZS5pZCgpLCBwcm9jZXNzTm9kZS5pZCgpLCB7Y2xhc3M6ICdjb25zdW1wdGlvbicsIGxhbmd1YWdlOiAnUEQnfSlcbiAgICAgIGlucHV0RWRnZS5kYXRhKFwianVzdEFkZGVkXCIsIHRydWUpO1xuXG4gICAgICBub2RlUG9zaXRpb24gPSB7XG4gICAgICAgIHg6IHhQb3NPZk91dHB1dCxcbiAgICAgICAgeTogeVBvc09mT3V0cHV0XG4gICAgICB9XG5cbiAgICAgIGlmICh2ZXJ0aWNhbCkge1xuICAgICAgICBub2RlUG9zaXRpb24gPSBlbGVtZW50VXRpbGl0aWVzLnJvdGF0ZTkwKG5vZGVQb3NpdGlvbiwgcHJvY2Vzc1Bvc2l0aW9uKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgb3V0cHV0Tm9kZSA9IGVsZW1lbnRVdGlsaXRpZXMuYWRkTm9kZShub2RlUG9zaXRpb24ueCwgbm9kZVBvc2l0aW9uLnksIHtjbGFzczogXCJtYWNyb21vbGVjdWxlXCIsIGxhbmd1YWdlOiAnUEQnfSk7XG4gICAgICBvdXRwdXROb2RlLmRhdGEoXCJqdXN0QWRkZWRcIiwgdHJ1ZSk7XG4gICAgICBvdXRwdXROb2RlLmRhdGEoXCJsYWJlbFwiLCBvdXRwdXRMYWJlbCk7XG5cbiAgICAgIGNvbnN0IG91dHB1dEVkZ2UgPSBlbGVtZW50VXRpbGl0aWVzLmFkZEVkZ2UocHJvY2Vzc05vZGUuaWQoKSwgb3V0cHV0Tm9kZS5pZCgpLCB7Y2xhc3M6ICdwcm9kdWN0aW9uJywgbGFuZ3VhZ2U6ICdQRCd9KVxuICAgICAgb3V0cHV0RWRnZS5kYXRhKFwianVzdEFkZGVkXCIsIHRydWUpO1xuXG4gICAgICBsZXQgeFBvc09mUmVndWxhdG9yID0gcHJvY2Vzc1Bvc2l0aW9uLng7XG4gICAgICBjb25zdCBkaW1lbnNpb24gPSB2ZXJ0aWNhbCA/IG51Y2xlaWNBY2lkRmVhdHVyZVdpZHRoIDogbnVjbGVpY0FjaWRGZWF0dXJlSGVpZ2h0O1xuICAgICAgbGV0IHlQb3NPZlJlZ3VsYXRvciA9IHByb2Nlc3NQb3NpdGlvbi55IC0gKChwcm9jZXNzSGVpZ2h0IC8gMikgKyAoZGltZW5zaW9uIC8gMikgKyBlZGdlTGVuZ3RoKTsgXG5cbiAgICAgIG5vZGVQb3NpdGlvbiA9IHtcbiAgICAgICAgeDogeFBvc09mUmVndWxhdG9yLFxuICAgICAgICB5OiB5UG9zT2ZSZWd1bGF0b3JcbiAgICAgIH1cbiAgICAgIGlmICh2ZXJ0aWNhbCkge1xuICAgICAgICBub2RlUG9zaXRpb24gPSBlbGVtZW50VXRpbGl0aWVzLnJvdGF0ZTkwKG5vZGVQb3NpdGlvbiwgcHJvY2Vzc1Bvc2l0aW9uKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVndWxhdG9yTm9kZSA9IGVsZW1lbnRVdGlsaXRpZXMuYWRkTm9kZShub2RlUG9zaXRpb24ueCwgbm9kZVBvc2l0aW9uLnksIHtjbGFzczogXCJudWNsZWljIGFjaWQgZmVhdHVyZVwiLCBsYW5ndWFnZTogJ1BEJ30pO1xuICAgICAgcmVndWxhdG9yTm9kZS5kYXRhKCdqdXN0QWRkZWQnLCB0cnVlKTtcbiAgICAgIHJlZ3VsYXRvck5vZGUuZGF0YSgnbGFiZWwnLCByZWd1bGF0b3JMYWJlbCk7XG4gICAgICBpbmZvYm94T2JqZWN0ID0ge1xuICAgICAgICBjbGF6ejogXCJ1bml0IG9mIGluZm9ybWF0aW9uXCIsXG4gICAgICAgIGxhYmVsOiB7XG4gICAgICAgICAgdGV4dDogcmVndWxhdG9ySW5mb2JveExhYmVsXG4gICAgICAgIH0sXG4gICAgICAgIGJib3g6IHtcbiAgICAgICAgICB3OiBNYXRoLm1heChyZWd1bGF0b3JJbmZvYm94TGFiZWwubGVuZ3RoICogd2lkdGhQZXJDaGFyLCBtaW5JbmZvYm94RGltZW5zaW9uKSxcbiAgICAgICAgICBoOiBtaW5JbmZvYm94RGltZW5zaW9uXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBlbGVtZW50VXRpbGl0aWVzLmFkZFN0YXRlT3JJbmZvQm94KHJlZ3VsYXRvck5vZGUsIGluZm9ib3hPYmplY3QpO1xuXG4gICAgICBjb25zdCByZWd1bGF0b3JFZGdlID0gZWxlbWVudFV0aWxpdGllcy5hZGRFZGdlKHJlZ3VsYXRvck5vZGUuaWQoKSwgcHJvY2Vzc05vZGUuaWQoKSwge2NsYXNzOiAnbmVjZXNzYXJ5IHN0aW11bGF0aW9uJywgbGFuZ3VhZ2U6ICdQRCd9KTtcbiAgICAgIHJlZ3VsYXRvckVkZ2UuZGF0YSgnanVzdEFkZGVkJywgdHJ1ZSk7XG5cbiAgICAgIGN5LmVuZEJhdGNoKCk7XG5cbiAgICAgIGNvbnN0IGVsZXMgPSBjeS5lbGVtZW50cygnW2p1c3RBZGRlZF0nKTtcbiAgICAgIGVsZXMucmVtb3ZlRGF0YSgnanVzdEFkZGVkJyk7XG5cbiAgICAgIGN5LmVsZW1lbnRzKCkudW5zZWxlY3QoKTtcbiAgICAgIGVsZXMuc2VsZWN0KCk7XG5cbiAgICAgIHJldHVybiBlbGVzO1xuICAgIH1cblxuICAgIGVsZW1lbnRVdGlsaXRpZXMuY3JlYXRlVHJhbnNjcmlwdGlvbiA9IGZ1bmN0aW9uKGxhYmVsLCBvcmllbnRhdGlvbikge1xuICAgICAgY29uc3QgZGVmYXVsdFNvdXJjZUFuZFNpbmtQcm9wZXJ0aWVzID0gZWxlbWVudFV0aWxpdGllcy5nZXREZWZhdWx0UHJvcGVydGllcyhcImVtcHR5IHNldFwiKTtcbiAgICAgIGNvbnN0IGRlZmF1bHROdWNsZWljQWNpZEZlYXR1cmVQcm9wZXJ0aWVzID0gZWxlbWVudFV0aWxpdGllcy5nZXREZWZhdWx0UHJvcGVydGllcyhcIm51Y2xlaWMgYWNpZCBmZWF0dXJlXCIpO1xuICAgICAgY29uc3QgZGVmYXVsdFByb2Nlc3NQcm9wZXJ0aWVzID0gZWxlbWVudFV0aWxpdGllcy5nZXREZWZhdWx0UHJvcGVydGllcyhcInByb2Nlc3NcIilcbiAgICAgIGNvbnN0IHNvdXJjZUFuZFNpbmtXaWR0aCA9IGRlZmF1bHRTb3VyY2VBbmRTaW5rUHJvcGVydGllcy53aWR0aCB8fCA1MDtcbiAgICAgIGNvbnN0IG51Y2xlaWNBY2lkRmVhdHVyZVdpZHRoID0gZGVmYXVsdE51Y2xlaWNBY2lkRmVhdHVyZVByb3BlcnRpZXMud2lkdGggfHwgNTA7XG4gICAgICBjb25zdCBudWNsZWljQWNpZEZlYXR1cmVIZWlnaHQgPSBkZWZhdWx0TnVjbGVpY0FjaWRGZWF0dXJlUHJvcGVydGllcy5oZWlnaHQgfHwgNTA7XG4gICAgICBjb25zdCBwcm9jZXNzV2lkdGggPSBkZWZhdWx0UHJvY2Vzc1Byb3BlcnRpZXMud2lkdGggfHwgNTA7XG4gICAgICBjb25zdCBwcm9jZXNzSGVpZ2h0ID0gZGVmYXVsdFByb2Nlc3NQcm9wZXJ0aWVzLmhlaWdodCB8fCA1MDtcbiAgICAgIGNvbnN0IHByb2Nlc3NQb3NpdGlvbiA9IGVsZW1lbnRVdGlsaXRpZXMuY29udmVydFRvTW9kZWxQb3NpdGlvbih7eDogY3kud2lkdGgoKSAvIDIsIHk6IGN5LmhlaWdodCgpIC8gMn0pO1xuICAgICAgY29uc3QgZWRnZUxlbmd0aCA9IDMwO1xuICAgICAgY29uc3QgdmVydGljYWwgPSBvcmllbnRhdGlvbiA9PT0gXCJ2ZXJ0aWNhbFwiO1xuICAgICAgY29uc3QgcHJvY2Vzc1BvcnRzT3JkZXJpbmcgPSB2ZXJ0aWNhbCA/IFwiVC10by1CXCIgOiBcIkwtdG8tUlwiO1xuICAgICAgY29uc3QgbWluSW5mb2JveERpbWVuc2lvbiA9IDE1O1xuICAgICAgY29uc3Qgd2lkdGhQZXJDaGFyID0gNjtcbiAgICAgIGNvbnN0IG91dHB1dEluZm9ib3hMYWJlbCA9IFwiY3Q6bVJOQVwiO1xuICAgICAgY29uc3QgcmVndWxhdG9ySW5mb2JveExhYmVsID0gXCJjdDpnZW5lXCI7XG5cbiAgICAgIGN5LnN0YXJ0QmF0Y2goKTtcblxuICAgICAgaWYgKCFlbGVtZW50VXRpbGl0aWVzLmdldE1hcFR5cGUoKSkge1xuICAgICAgICBlbGVtZW50VXRpbGl0aWVzLnNldE1hcFR5cGUoXCJQRFwiKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcHJvY2Vzc05vZGUgPSBlbGVtZW50VXRpbGl0aWVzLmFkZE5vZGUocHJvY2Vzc1Bvc2l0aW9uLngsIHByb2Nlc3NQb3NpdGlvbi55LCB7Y2xhc3M6IFwicHJvY2Vzc1wiLCBsYW5ndWFnZTogXCJQRFwifSk7XG4gICAgICBlbGVtZW50VXRpbGl0aWVzLnNldFBvcnRzT3JkZXJpbmcocHJvY2Vzc05vZGUsIHByb2Nlc3NQb3J0c09yZGVyaW5nKTtcbiAgICAgIHByb2Nlc3NOb2RlLmRhdGEoJ2p1c3RBZGRlZCcsIHRydWUpO1xuXG4gICAgICBsZXQgeFBvc09mSW5wdXQgPSBwcm9jZXNzUG9zaXRpb24ueCAtIGVkZ2VMZW5ndGggLSBwcm9jZXNzV2lkdGggLyAyIC0gc291cmNlQW5kU2lua1dpZHRoIC8gMjtcbiAgICAgIGxldCB4UG9zT2ZPdXRwdXQgPSBwcm9jZXNzUG9zaXRpb24ueCArIGVkZ2VMZW5ndGggKyBwcm9jZXNzV2lkdGggLyAyICsgbnVjbGVpY0FjaWRGZWF0dXJlV2lkdGggLyAyO1xuICAgICAgbGV0IHlQb3NPZklucHV0ID0gcHJvY2Vzc1Bvc2l0aW9uLnk7XG4gICAgICBsZXQgeVBvc09mT3V0cHV0ID0gcHJvY2Vzc1Bvc2l0aW9uLnk7XG5cbiAgICAgIGxldCBub2RlUG9zaXRpb24gPSB7XG4gICAgICAgIHg6IHhQb3NPZklucHV0LFxuICAgICAgICB5OiB5UG9zT2ZJbnB1dFxuICAgICAgfVxuICAgICAgaWYgKHZlcnRpY2FsKSB7XG4gICAgICAgIG5vZGVQb3NpdGlvbiA9IGVsZW1lbnRVdGlsaXRpZXMucm90YXRlOTAobm9kZVBvc2l0aW9uLCBwcm9jZXNzUG9zaXRpb24pO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBpbnB1dE5vZGUgPSBlbGVtZW50VXRpbGl0aWVzLmFkZE5vZGUobm9kZVBvc2l0aW9uLngsIG5vZGVQb3NpdGlvbi55LCB7Y2xhc3M6ICdlbXB0eSBzZXQnLCBsYW5ndWFnZTogJ1BEJ30pO1xuICAgICAgaW5wdXROb2RlLmRhdGEoXCJqdXN0QWRkZWRcIiwgdHJ1ZSk7XG5cbiAgICAgIGNvbnN0IGlucHV0RWRnZSA9IGVsZW1lbnRVdGlsaXRpZXMuYWRkRWRnZShpbnB1dE5vZGUuaWQoKSwgcHJvY2Vzc05vZGUuaWQoKSwge2NsYXNzOiAnY29uc3VtcHRpb24nLCBsYW5ndWFnZTogJ1BEJ30pXG4gICAgICBpbnB1dEVkZ2UuZGF0YShcImp1c3RBZGRlZFwiLCB0cnVlKTtcblxuICAgICAgbm9kZVBvc2l0aW9uID0ge1xuICAgICAgICB4OiB4UG9zT2ZPdXRwdXQsXG4gICAgICAgIHk6IHlQb3NPZk91dHB1dFxuICAgICAgfVxuXG4gICAgICBpZiAodmVydGljYWwpIHtcbiAgICAgICAgbm9kZVBvc2l0aW9uID0gZWxlbWVudFV0aWxpdGllcy5yb3RhdGU5MChub2RlUG9zaXRpb24sIHByb2Nlc3NQb3NpdGlvbik7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG91dHB1dE5vZGUgPSBlbGVtZW50VXRpbGl0aWVzLmFkZE5vZGUobm9kZVBvc2l0aW9uLngsIG5vZGVQb3NpdGlvbi55LCB7Y2xhc3M6ICdudWNsZWljIGFjaWQgZmVhdHVyZScsIGxhbmd1YWdlOiAnUEQnfSk7XG4gICAgICBvdXRwdXROb2RlLmRhdGEoXCJqdXN0QWRkZWRcIiwgdHJ1ZSk7XG4gICAgICBvdXRwdXROb2RlLmRhdGEoXCJsYWJlbFwiLCBsYWJlbCk7XG4gICAgICBpbmZvYm94T2JqZWN0ID0ge1xuICAgICAgICBjbGF6ejogXCJ1bml0IG9mIGluZm9ybWF0aW9uXCIsXG4gICAgICAgIGxhYmVsOiB7XG4gICAgICAgICAgdGV4dDogb3V0cHV0SW5mb2JveExhYmVsXG4gICAgICAgIH0sXG4gICAgICAgIGJib3g6IHtcbiAgICAgICAgICB3OiBNYXRoLm1heChvdXRwdXRJbmZvYm94TGFiZWwubGVuZ3RoICogd2lkdGhQZXJDaGFyLCBtaW5JbmZvYm94RGltZW5zaW9uKSxcbiAgICAgICAgICBoOiBtaW5JbmZvYm94RGltZW5zaW9uXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBlbGVtZW50VXRpbGl0aWVzLmFkZFN0YXRlT3JJbmZvQm94KG91dHB1dE5vZGUsIGluZm9ib3hPYmplY3QpO1xuXG4gICAgICBjb25zdCBvdXRwdXRFZGdlID0gZWxlbWVudFV0aWxpdGllcy5hZGRFZGdlKHByb2Nlc3NOb2RlLmlkKCksIG91dHB1dE5vZGUuaWQoKSwge2NsYXNzOiAncHJvZHVjdGlvbicsIGxhbmd1YWdlOiAnUEQnfSlcbiAgICAgIG91dHB1dEVkZ2UuZGF0YShcImp1c3RBZGRlZFwiLCB0cnVlKTtcblxuICAgICAgbGV0IHhQb3NPZlJlZ3VsYXRvciA9IHByb2Nlc3NQb3NpdGlvbi54O1xuICAgICAgY29uc3QgZGltZW5zaW9uID0gdmVydGljYWwgPyBudWNsZWljQWNpZEZlYXR1cmVXaWR0aCA6IG51Y2xlaWNBY2lkRmVhdHVyZUhlaWdodDtcbiAgICAgIGxldCB5UG9zT2ZSZWd1bGF0b3IgPSBwcm9jZXNzUG9zaXRpb24ueSAtICgocHJvY2Vzc0hlaWdodCAvIDIpICsgKGRpbWVuc2lvbiAvIDIpICsgZWRnZUxlbmd0aCk7IFxuXG4gICAgICBub2RlUG9zaXRpb24gPSB7XG4gICAgICAgIHg6IHhQb3NPZlJlZ3VsYXRvcixcbiAgICAgICAgeTogeVBvc09mUmVndWxhdG9yXG4gICAgICB9XG4gICAgICBpZiAodmVydGljYWwpIHtcbiAgICAgICAgbm9kZVBvc2l0aW9uID0gZWxlbWVudFV0aWxpdGllcy5yb3RhdGU5MChub2RlUG9zaXRpb24sIHByb2Nlc3NQb3NpdGlvbik7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlZ3VsYXRvck5vZGUgPSBlbGVtZW50VXRpbGl0aWVzLmFkZE5vZGUobm9kZVBvc2l0aW9uLngsIG5vZGVQb3NpdGlvbi55LCB7Y2xhc3M6IFwibnVjbGVpYyBhY2lkIGZlYXR1cmVcIiwgbGFuZ3VhZ2U6ICdQRCd9KTtcbiAgICAgIHJlZ3VsYXRvck5vZGUuZGF0YSgnanVzdEFkZGVkJywgdHJ1ZSk7XG4gICAgICByZWd1bGF0b3JOb2RlLmRhdGEoJ2xhYmVsJywgbGFiZWwpO1xuICAgICAgaW5mb2JveE9iamVjdCA9IHtcbiAgICAgICAgY2xheno6IFwidW5pdCBvZiBpbmZvcm1hdGlvblwiLFxuICAgICAgICBsYWJlbDoge1xuICAgICAgICAgIHRleHQ6IHJlZ3VsYXRvckluZm9ib3hMYWJlbFxuICAgICAgICB9LFxuICAgICAgICBiYm94OiB7XG4gICAgICAgICAgdzogTWF0aC5tYXgocmVndWxhdG9ySW5mb2JveExhYmVsLmxlbmd0aCAqIHdpZHRoUGVyQ2hhciwgbWluSW5mb2JveERpbWVuc2lvbiksXG4gICAgICAgICAgaDogbWluSW5mb2JveERpbWVuc2lvblxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgZWxlbWVudFV0aWxpdGllcy5hZGRTdGF0ZU9ySW5mb0JveChyZWd1bGF0b3JOb2RlLCBpbmZvYm94T2JqZWN0KTtcblxuICAgICAgY29uc3QgcmVndWxhdG9yRWRnZSA9IGVsZW1lbnRVdGlsaXRpZXMuYWRkRWRnZShyZWd1bGF0b3JOb2RlLmlkKCksIHByb2Nlc3NOb2RlLmlkKCksIHtjbGFzczogJ25lY2Vzc2FyeSBzdGltdWxhdGlvbicsIGxhbmd1YWdlOiAnUEQnfSk7XG4gICAgICByZWd1bGF0b3JFZGdlLmRhdGEoJ2p1c3RBZGRlZCcsIHRydWUpO1xuXG4gICAgICBjeS5lbmRCYXRjaCgpO1xuXG4gICAgICBjb25zdCBlbGVzID0gY3kuZWxlbWVudHMoJ1tqdXN0QWRkZWRdJyk7XG4gICAgICBlbGVzLnJlbW92ZURhdGEoJ2p1c3RBZGRlZCcpO1xuXG4gICAgICBjeS5lbGVtZW50cygpLnVuc2VsZWN0KCk7XG4gICAgICBlbGVzLnNlbGVjdCgpO1xuXG4gICAgICByZXR1cm4gZWxlcztcbiAgICB9XG5cbiAgICBlbGVtZW50VXRpbGl0aWVzLmNyZWF0ZURlZ3JhZGF0aW9uID0gZnVuY3Rpb24obWFjcm9tb2xlY3VsZSwgb3JpZW50YXRpb24pIHtcbiAgICAgIGNvbnN0IG1hY3JvbW9sZWN1bGVOYW1lID0gbWFjcm9tb2xlY3VsZS5uYW1lO1xuICAgICAgY29uc3QgZGVmYXVsdE1hY3JvbW9sZWN1bGVQcm9wZXJ0aWVzID0gZWxlbWVudFV0aWxpdGllcy5nZXREZWZhdWx0UHJvcGVydGllcyhcIm1hY3JvbW9sZWN1bGVcIik7XG4gICAgICBjb25zdCBtYWNyb21vbGVjdWxlV2lkdGggPSBkZWZhdWx0TWFjcm9tb2xlY3VsZVByb3BlcnRpZXMud2lkdGggfHwgNTA7XG4gICAgICBjb25zdCBkZWZhdWx0UHJvY2Vzc1Byb3BlcnRpZXMgPSBlbGVtZW50VXRpbGl0aWVzLmdldERlZmF1bHRQcm9wZXJ0aWVzKFwiY2F0YWx5dGljXCIpO1xuICAgICAgY29uc3QgcHJvY2Vzc1dpZHRoID0gZGVmYXVsdFByb2Nlc3NQcm9wZXJ0aWVzLndpZHRoIHx8IDUwO1xuICAgICAgY29uc3QgcHJvY2Vzc1Bvc2l0aW9uID0gZWxlbWVudFV0aWxpdGllcy5jb252ZXJ0VG9Nb2RlbFBvc2l0aW9uKHt4OiBjeS53aWR0aCgpIC8gMiwgeTogY3kuaGVpZ2h0KCkgLyAyfSk7XG4gICAgICBjb25zdCBlZGdlTGVuZ3RoID0gMzA7XG4gICAgICBjb25zdCB2ZXJ0aWNhbCA9IG9yaWVudGF0aW9uID09PSBcInZlcnRpY2FsXCI7XG4gICAgICBjb25zdCBwcm9jZXNzUG9ydHNPcmRlcmluZyA9IHZlcnRpY2FsID8gXCJULXRvLUJcIiA6IFwiTC10by1SXCI7XG5cbiAgICAgIGN5LnN0YXJ0QmF0Y2goKTtcblxuICAgICAgaWYgKCFlbGVtZW50VXRpbGl0aWVzLmdldE1hcFR5cGUoKSkge1xuICAgICAgICBlbGVtZW50VXRpbGl0aWVzLnNldE1hcFR5cGUoXCJQRFwiKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcHJvY2Vzc05vZGUgPSBlbGVtZW50VXRpbGl0aWVzLmFkZE5vZGUocHJvY2Vzc1Bvc2l0aW9uLngsIHByb2Nlc3NQb3NpdGlvbi55LCB7Y2xhc3M6IFwicHJvY2Vzc1wiLCBsYW5ndWFnZTogXCJQRFwifSk7XG4gICAgICBlbGVtZW50VXRpbGl0aWVzLnNldFBvcnRzT3JkZXJpbmcocHJvY2Vzc05vZGUsIHByb2Nlc3NQb3J0c09yZGVyaW5nKTtcbiAgICAgIHByb2Nlc3NOb2RlLmRhdGEoJ2p1c3RBZGRlZCcsIHRydWUpO1xuXG4gICAgICBsZXQgeFBvc09mSW5wdXQgPSBwcm9jZXNzUG9zaXRpb24ueCAtIGVkZ2VMZW5ndGggLSBwcm9jZXNzV2lkdGggLyAyIC0gbWFjcm9tb2xlY3VsZVdpZHRoIC8gMjtcbiAgICAgIGxldCB4UG9zT2ZPdXRwdXQgPSBwcm9jZXNzUG9zaXRpb24ueCArIGVkZ2VMZW5ndGggKyBwcm9jZXNzV2lkdGggLyAyICsgbWFjcm9tb2xlY3VsZVdpZHRoIC8gMjtcbiAgICAgIGxldCB5UG9zT2ZJbnB1dCA9IHByb2Nlc3NQb3NpdGlvbi55O1xuICAgICAgbGV0IHlQb3NPZk91dHB1dCA9IHByb2Nlc3NQb3NpdGlvbi55O1xuXG4gICAgICBsZXQgbm9kZVBvc2l0aW9uID0ge1xuICAgICAgICB4OiB4UG9zT2ZJbnB1dCxcbiAgICAgICAgeTogeVBvc09mSW5wdXRcbiAgICAgIH1cbiAgICAgIGlmICh2ZXJ0aWNhbCkge1xuICAgICAgICBub2RlUG9zaXRpb24gPSBlbGVtZW50VXRpbGl0aWVzLnJvdGF0ZTkwKG5vZGVQb3NpdGlvbiwgcHJvY2Vzc1Bvc2l0aW9uKTtcbiAgICAgIH1cblxuICAgICAgbGV0IGlucHV0Tm9kZSA9IGVsZW1lbnRVdGlsaXRpZXMuYWRkTm9kZShub2RlUG9zaXRpb24ueCwgbm9kZVBvc2l0aW9uLnksIHtjbGFzczogJ21hY3JvbW9sZWN1bGUnLCBsYW5ndWFnZTogJ1BEJ30pO1xuICAgICAgaW5wdXROb2RlLmRhdGEoXCJqdXN0QWRkZWRcIiwgdHJ1ZSk7XG4gICAgICBpbnB1dE5vZGUuZGF0YShcImxhYmVsXCIsIG1hY3JvbW9sZWN1bGVOYW1lKTtcblxuICAgICAgbGV0IGlucHV0RWRnZSA9IGVsZW1lbnRVdGlsaXRpZXMuYWRkRWRnZShpbnB1dE5vZGUuaWQoKSwgcHJvY2Vzc05vZGUuaWQoKSwge2NsYXNzOiAnY29uc3VtcHRpb24nLCBsYW5ndWFnZTogJ1BEJ30pXG4gICAgICBpbnB1dEVkZ2UuZGF0YShcImp1c3RBZGRlZFwiLCB0cnVlKTtcblxuICAgICAgbm9kZVBvc2l0aW9uID0ge1xuICAgICAgICB4OiB4UG9zT2ZPdXRwdXQsXG4gICAgICAgIHk6IHlQb3NPZk91dHB1dFxuICAgICAgfVxuXG4gICAgICBpZiAodmVydGljYWwpIHtcbiAgICAgICAgbm9kZVBvc2l0aW9uID0gZWxlbWVudFV0aWxpdGllcy5yb3RhdGU5MChub2RlUG9zaXRpb24sIHByb2Nlc3NQb3NpdGlvbik7XG4gICAgICB9XG5cbiAgICAgIGxldCBvdXRwdXROb2RlID0gZWxlbWVudFV0aWxpdGllcy5hZGROb2RlKG5vZGVQb3NpdGlvbi54LCBub2RlUG9zaXRpb24ueSwge2NsYXNzOiAnZW1wdHkgc2V0JywgbGFuZ3VhZ2U6ICdQRCd9KTtcbiAgICAgIG91dHB1dE5vZGUuZGF0YShcImp1c3RBZGRlZFwiLCB0cnVlKTtcblxuICAgICAgbGV0IG91dHB1dEVkZ2UgPSBlbGVtZW50VXRpbGl0aWVzLmFkZEVkZ2UocHJvY2Vzc05vZGUuaWQoKSwgb3V0cHV0Tm9kZS5pZCgpLCB7Y2xhc3M6ICdwcm9kdWN0aW9uJywgbGFuZ3VhZ2U6ICdQRCd9KVxuICAgICAgb3V0cHV0RWRnZS5kYXRhKFwianVzdEFkZGVkXCIsIHRydWUpO1xuXG4gICAgICBjeS5lbmRCYXRjaCgpO1xuXG4gICAgICBjb25zdCBlbGVzID0gY3kuZWxlbWVudHMoJ1tqdXN0QWRkZWRdJyk7XG4gICAgICBlbGVzLnJlbW92ZURhdGEoJ2p1c3RBZGRlZCcpO1xuXG4gICAgICBjeS5lbGVtZW50cygpLnVuc2VsZWN0KCk7XG4gICAgICBlbGVzLnNlbGVjdCgpO1xuXG4gICAgICByZXR1cm4gZWxlcztcbiAgICB9XG5cbiAgICBlbGVtZW50VXRpbGl0aWVzLmNyZWF0ZUNvbXBsZXhQcm90ZWluRm9ybWF0aW9uID0gZnVuY3Rpb24ocHJvdGVpbkxhYmVscywgY29tcGxleExhYmVsLCByZWd1bGF0b3IsIG9yaWVudGF0aW9uLCByZXZlcnNlKSB7XG4gICAgICBjb25zdCBoYXNSZWd1bGF0b3IgPSByZWd1bGF0b3IubmFtZSAhPT0gdW5kZWZpbmVkO1xuICAgICAgY29uc3QgZGVmYXVsdE1hY3JvbW9sZWN1bGVQcm9wZXJ0aWVzID0gZWxlbWVudFV0aWxpdGllcy5nZXREZWZhdWx0UHJvcGVydGllcyhcIm1hY3JvbW9sZWN1bGVcIik7XG4gICAgICBjb25zdCBkZWZhdWx0UmVndWxhdG9yUHJvcGVydGllcyA9IGhhc1JlZ3VsYXRvciA/IGVsZW1lbnRVdGlsaXRpZXMuZ2V0RGVmYXVsdFByb3BlcnRpZXMocmVndWxhdG9yLnR5cGUpIDoge307XG4gICAgICBjb25zdCBkZWZhdWx0UHJvY2Vzc1Byb3BlcnRpZXMgPSBlbGVtZW50VXRpbGl0aWVzLmdldERlZmF1bHRQcm9wZXJ0aWVzKFwiY2F0YWx5dGljXCIpO1xuICAgICAgY29uc3QgcHJvY2Vzc1dpZHRoID0gZGVmYXVsdFByb2Nlc3NQcm9wZXJ0aWVzLndpZHRoIHx8IDUwO1xuICAgICAgY29uc3QgbWFjcm9tb2xlY3VsZVdpZHRoID0gZGVmYXVsdE1hY3JvbW9sZWN1bGVQcm9wZXJ0aWVzLndpZHRoIHx8IDUwO1xuICAgICAgY29uc3QgbWFjcm9tb2xlY3VsZUhlaWdodCA9IGRlZmF1bHRNYWNyb21vbGVjdWxlUHJvcGVydGllcy5oZWlnaHQgfHwgNTA7IFxuICAgICAgY29uc3QgcHJvY2Vzc0hlaWdodCA9IGRlZmF1bHRQcm9jZXNzUHJvcGVydGllcy5oZWlnaHQgfHwgNTA7XG4gICAgICBjb25zdCByZWd1bGF0b3JIZWlnaHQgPSBkZWZhdWx0UmVndWxhdG9yUHJvcGVydGllcy5oZWlnaHQgfHwgNTA7XG4gICAgICBjb25zdCBwcm9jZXNzUG9zaXRpb24gPSBlbGVtZW50VXRpbGl0aWVzLmNvbnZlcnRUb01vZGVsUG9zaXRpb24oe3g6IGN5LndpZHRoKCkgLyAyLCB5OiBjeS5oZWlnaHQoKSAvIDJ9KTtcbiAgICAgIGNvbnN0IGVkZ2VMZW5ndGggPSAzMDtcbiAgICAgIGNvbnN0IHByb2Nlc3NQb3J0c09yZGVyaW5nID0gb3JpZW50YXRpb24gPT09IFwidmVydGljYWxcIiA/IFwiVC10by1CXCIgOiBcIkwtdG8tUlwiO1xuICAgICAgY29uc3QgbWluSW5mb2JveERpbWVuc2lvbiA9IDIwO1xuICAgICAgY29uc3Qgd2lkdGhQZXJDaGFyID0gNjtcbiAgICAgIGNvbnN0IHRpbGluZ1BhZGRpbmdWZXJ0aWNhbCA9IDE1O1xuICAgICAgY29uc3QgdGlsaW5nUGFkZGluZ0hvcml6b250YWwgPSAxNTtcbiAgICAgIGNvbnN0IG11bHRpbWVyT2Zmc2V0ID0gNjtcblxuICAgICAgY3kuc3RhcnRCYXRjaCgpO1xuXG4gICAgICBpZiAoIWVsZW1lbnRVdGlsaXRpZXMuZ2V0TWFwVHlwZSgpKSB7XG4gICAgICAgIGVsZW1lbnRVdGlsaXRpZXMuc2V0TWFwVHlwZShcIlBEXCIpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwcm9jZXNzTm9kZSA9IGVsZW1lbnRVdGlsaXRpZXMuYWRkTm9kZShwcm9jZXNzUG9zaXRpb24ueCwgcHJvY2Vzc1Bvc2l0aW9uLnksIHtjbGFzczogXCJwcm9jZXNzXCIsIGxhbmd1YWdlOiBcIlBEXCJ9KTtcbiAgICAgIGVsZW1lbnRVdGlsaXRpZXMuc2V0UG9ydHNPcmRlcmluZyhwcm9jZXNzTm9kZSwgcHJvY2Vzc1BvcnRzT3JkZXJpbmcpO1xuICAgICAgcHJvY2Vzc05vZGUuZGF0YSgnanVzdEFkZGVkJywgdHJ1ZSk7XG5cbiAgICAgIGNvbnN0IG9mZnNldFggPSBwcm9jZXNzV2lkdGggLyAyICsgZWRnZUxlbmd0aCArIG1hY3JvbW9sZWN1bGVXaWR0aCAvIDI7XG4gICAgICBsZXQgeFBvc09mUHJvdGVpbiA9IHJldmVyc2UgPyBwcm9jZXNzUG9zaXRpb24ueCArIG9mZnNldFhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBwcm9jZXNzUG9zaXRpb24ueCAtIG9mZnNldFg7XG5cbiAgICAgIGNvbnN0IHByb3RlaW5Db3VudCA9IHByb3RlaW5MYWJlbHMubGVuZ3RoO1xuXG4gICAgICBjb25zdCBtYWNyb21vbGVjdWxlRGltZW5zaW9uID0gb3JpZW50YXRpb24gPT09IFwidmVydGljYWxcIiA/IG1hY3JvbW9sZWN1bGVXaWR0aCA6IG1hY3JvbW9sZWN1bGVIZWlnaHQ7XG4gICAgICBjb25zdCBzdGVwT2Zmc2V0ID0gbWFjcm9tb2xlY3VsZURpbWVuc2lvbiArIHRpbGluZ1BhZGRpbmdWZXJ0aWNhbDtcbiAgICAgIGNvbnN0IG9mZnNldFkgPSAocHJvdGVpbkNvdW50IC0gMSkgLyAyICogKG1hY3JvbW9sZWN1bGVEaW1lbnNpb24gKyB0aWxpbmdQYWRkaW5nVmVydGljYWwpO1xuICAgICAgY29uc3QgaG9yaXpvbnRhbE9mZnNldFggPSAocHJvdGVpbkNvdW50IC0gMSkgLyAyICogKG1hY3JvbW9sZWN1bGVEaW1lbnNpb24gKyB0aWxpbmdQYWRkaW5nSG9yaXpvbnRhbCk7XG4gICAgICBcbiAgICAgIGxldCB5UG9zT2ZQcm90ZWluID0gcHJvY2Vzc1Bvc2l0aW9uLnkgLSBvZmZzZXRZO1xuXG4gICAgICBwcm90ZWluTGFiZWxzLmZvckVhY2goZnVuY3Rpb24obGFiZWwpIHtcbiAgICAgICAgbGV0IG5vZGVQb3NpdGlvbiA9IHtcbiAgICAgICAgICB4OiB4UG9zT2ZQcm90ZWluLFxuICAgICAgICAgIHk6IHlQb3NPZlByb3RlaW5cbiAgICAgICAgfVxuICAgICAgICBpZiAob3JpZW50YXRpb24gPT09IFwidmVydGljYWxcIikge1xuICAgICAgICAgIG5vZGVQb3NpdGlvbiA9IGVsZW1lbnRVdGlsaXRpZXMucm90YXRlOTAobm9kZVBvc2l0aW9uLCBwcm9jZXNzUG9zaXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgbm9kZSA9IGVsZW1lbnRVdGlsaXRpZXMuYWRkTm9kZShub2RlUG9zaXRpb24ueCwgbm9kZVBvc2l0aW9uLnksIHtjbGFzczogXCJtYWNyb21vbGVjdWxlXCIsIGxhbmd1YWdlOiBcIlBEXCJ9KTtcbiAgICAgICAgbm9kZS5kYXRhKFwibGFiZWxcIiwgbGFiZWwpO1xuICAgICAgICBub2RlLmRhdGEoXCJqdXN0QWRkZWRcIiwgdHJ1ZSk7XG4gICAgICAgIHlQb3NPZlByb3RlaW4gKz0gc3RlcE9mZnNldDtcblxuICAgICAgICBjb25zdCBzb3VyY2UgPSByZXZlcnNlID8gcHJvY2Vzc05vZGUuaWQoKSA6IG5vZGUuaWQoKTtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gcmV2ZXJzZSA/IG5vZGUuaWQoKSA6IHByb2Nlc3NOb2RlLmlkKCk7XG4gICAgICAgIGNvbnN0IGVkZ2VDbGFzcyA9IHJldmVyc2UgPyBcInByb2R1Y3Rpb25cIiA6IFwiY29uc3VtcHRpb25cIjtcbiAgICAgICAgY29uc3QgZWRnZSA9IGVsZW1lbnRVdGlsaXRpZXMuYWRkRWRnZShzb3VyY2UsIHRhcmdldCwge2NsYXNzOiBlZGdlQ2xhc3MsIGxhbmd1YWdlOiBcIlBEXCJ9KTtcbiAgICAgICAgZWRnZS5kYXRhKFwianVzdEFkZGVkXCIsIHRydWUpO1xuICAgICAgfSk7XG5cbiAgICAgIGxldCBjb21wbGV4UG9zID0ge1xuICAgICAgICB4OiBwcm9jZXNzUG9zaXRpb24ueCArIChyZXZlcnNlID8gLTEgOiAxKSAqIG9mZnNldFgsXG4gICAgICAgIHk6IHByb2Nlc3NQb3NpdGlvbi55XG4gICAgICB9XG5cbiAgICAgIGlmIChvcmllbnRhdGlvbiA9PT0gXCJ2ZXJ0aWNhbFwiKSB7XG4gICAgICAgIGNvbXBsZXhQb3MgPSBlbGVtZW50VXRpbGl0aWVzLnJvdGF0ZTkwKGNvbXBsZXhQb3MsIHByb2Nlc3NQb3NpdGlvbik7IFxuICAgICAgfVxuXG4gICAgICBjb25zdCBjb21wbGV4ID0gZWxlbWVudFV0aWxpdGllcy5hZGROb2RlKGNvbXBsZXhQb3MueCwgY29tcGxleFBvcy55LCB7Y2xhc3M6IFwiY29tcGxleFwiLCBsYW5ndWFnZTogXCJQRFwifSk7XG4gICAgICBjb21wbGV4LmRhdGEoXCJsYWJlbFwiLCBjb21wbGV4TGFiZWwpO1xuICAgICAgY29tcGxleC5kYXRhKFwianVzdEFkZGVkXCIsIHRydWUpO1xuXG4gICAgICBjb25zdCBzb3VyY2UgPSByZXZlcnNlID8gY29tcGxleC5pZCgpIDogcHJvY2Vzc05vZGUuaWQoKTtcbiAgICAgIGNvbnN0IHRhcmdldCA9IHJldmVyc2UgPyBwcm9jZXNzTm9kZS5pZCgpIDogY29tcGxleC5pZCgpO1xuICAgICAgY29uc3QgZWRnZUNsYXNzID0gcmV2ZXJzZSA/IFwiY29uc3VtcHRpb25cIiA6IFwicHJvZHVjdGlvblwiO1xuICAgICAgY29uc3QgY29tcGxleEVkZ2UgPSBlbGVtZW50VXRpbGl0aWVzLmFkZEVkZ2Uoc291cmNlLCB0YXJnZXQsIHtjbGFzczogZWRnZUNsYXNzLCBsYW5ndWFnZTogXCJQRFwifSk7XG4gICAgICBjb21wbGV4RWRnZS5kYXRhKFwianVzdEFkZGVkXCIsIHRydWUpO1xuXG4gICAgICBcbiAgICAgIGlmIChvcmllbnRhdGlvbiA9PT0gXCJ2ZXJ0aWNhbFwiKSB7XG4gICAgICAgIHhQb3NPZlByb3RlaW4gPSBjb21wbGV4LnBvc2l0aW9uKFwieFwiKSAtIGhvcml6b250YWxPZmZzZXRYO1xuICAgICAgICB5UG9zT2ZQcm90ZWluID0gY29tcGxleC5wb3NpdGlvbihcInlcIik7ICAgXG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgeFBvc09mUHJvdGVpbiA9IGNvbXBsZXgucG9zaXRpb24oXCJ4XCIpO1xuICAgICAgICB5UG9zT2ZQcm90ZWluID0gY29tcGxleC5wb3NpdGlvbihcInlcIikgLSBvZmZzZXRZO1xuICAgICAgfVxuXG4gICAgICBwcm90ZWluTGFiZWxzLmZvckVhY2goZnVuY3Rpb24obGFiZWwpIHtcblxuICAgICAgICBsZXQgbm9kZVBvc2l0aW9uID0ge1xuICAgICAgICAgIHg6IHhQb3NPZlByb3RlaW4sXG4gICAgICAgICAgeTogeVBvc09mUHJvdGVpblxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjb25zdCBub2RlID0gZWxlbWVudFV0aWxpdGllcy5hZGROb2RlKG5vZGVQb3NpdGlvbi54LCBub2RlUG9zaXRpb24ueSwge2NsYXNzOiBcIm1hY3JvbW9sZWN1bGVcIiwgbGFuZ3VhZ2U6IFwiUERcIn0sIHVuZGVmaW5lZCwgY29tcGxleC5pZCgpKTtcbiAgICAgICAgbm9kZS5kYXRhKFwibGFiZWxcIiwgbGFiZWwpO1xuICAgICAgICBub2RlLmRhdGEoXCJqdXN0QWRkZWRcIiwgdHJ1ZSk7XG4gICAgICAgIFxuICAgICAgICBpZiAob3JpZW50YXRpb24gPT09IFwidmVydGljYWxcIikge1xuICAgICAgICAgIHhQb3NPZlByb3RlaW4gKz0gc3RlcE9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB5UG9zT2ZQcm90ZWluICs9IHN0ZXBPZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoaGFzUmVndWxhdG9yKSB7XG4gICAgICAgIGNvbnN0IHJlZ3VsYXRvck5hbWUgPSByZWd1bGF0b3IubmFtZTtcbiAgICAgICAgY29uc3QgcmVndWxhdG9yVHlwZSA9IHJlZ3VsYXRvci50eXBlO1xuICAgICAgICBjb25zdCByZWd1bGF0b3JFZGdlVHlwZSA9IHJlZ3VsYXRvci5lZGdlVHlwZTtcbiAgICAgICAgY29uc3QgcmVndWxhdG9yTXVsdGltZXIgPSByZWd1bGF0b3IubXVsdGltZXI7XG5cbiAgICAgICAgbGV0IHhQb3NPZlJlZ3VsYXRvciA9IHByb2Nlc3NQb3NpdGlvbi54O1xuICAgICAgICBpZiAocmVndWxhdG9yTXVsdGltZXIuZW5hYmxlZCAmJiBvcmllbnRhdGlvbiA9PT0gXCJob3Jpem9udGFsXCIpIHtcbiAgICAgICAgICB4UG9zT2ZSZWd1bGF0b3IgLT0gbXVsdGltZXJPZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHlQb3NPZlJlZ3VsYXRvciA9IHByb2Nlc3NQb3NpdGlvbi55IC0gKChwcm9jZXNzSGVpZ2h0IC8gMikgKyAocmVndWxhdG9ySGVpZ2h0IC8gMikgKyBlZGdlTGVuZ3RoKTsgXG5cbiAgICAgICAgbm9kZVBvc2l0aW9uID0ge1xuICAgICAgICAgIHg6IHhQb3NPZlJlZ3VsYXRvcixcbiAgICAgICAgICB5OiB5UG9zT2ZSZWd1bGF0b3JcbiAgICAgICAgfVxuICAgICAgICBpZiAob3JpZW50YXRpb24gPT09IFwidmVydGljYWxcIikge1xuICAgICAgICAgIG5vZGVQb3NpdGlvbiA9IGVsZW1lbnRVdGlsaXRpZXMucm90YXRlOTAobm9kZVBvc2l0aW9uLCBwcm9jZXNzUG9zaXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHJlZ3VsYXRvck5vZGUgPSBlbGVtZW50VXRpbGl0aWVzLmFkZE5vZGUobm9kZVBvc2l0aW9uLngsIG5vZGVQb3NpdGlvbi55LCB7Y2xhc3M6IHJlZ3VsYXRvclR5cGUsIGxhbmd1YWdlOiAnUEQnfSk7XG4gICAgICAgIHJlZ3VsYXRvck5vZGUuZGF0YSgnanVzdEFkZGVkJywgdHJ1ZSk7XG4gICAgICAgIHJlZ3VsYXRvck5vZGUuZGF0YSgnbGFiZWwnLCByZWd1bGF0b3JOYW1lKTtcblxuICAgICAgICBpZiAocmVndWxhdG9yTXVsdGltZXIuZW5hYmxlZCkge1xuICAgICAgICAgIGVsZW1lbnRVdGlsaXRpZXMuc2V0TXVsdGltZXJTdGF0dXMocmVndWxhdG9yTm9kZSwgdHJ1ZSk7XG5cbiAgICAgICAgICBjb25zdCBjYXJkaW5hbGl0eSA9IHJlZ3VsYXRvck11bHRpbWVyLmNhcmRpbmFsaXR5O1xuICAgICAgICAgIGlmIChjYXJkaW5hbGl0eSAhPSAnJykge1xuICAgICAgICAgICAgY29uc3QgaW5mb2JveExhYmVsID0gXCJOOlwiICsgY2FyZGluYWxpdHk7XG4gICAgICAgICAgICBpbmZvYm94T2JqZWN0ID0ge1xuICAgICAgICAgICAgICBjbGF6ejogXCJ1bml0IG9mIGluZm9ybWF0aW9uXCIsXG4gICAgICAgICAgICAgIGxhYmVsOiB7XG4gICAgICAgICAgICAgICAgdGV4dDogaW5mb2JveExhYmVsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGJib3g6IHtcbiAgICAgICAgICAgICAgICB3OiBpbmZvYm94TGFiZWwubGVuZ3RoICogd2lkdGhQZXJDaGFyLFxuICAgICAgICAgICAgICAgIGg6IG1pbkluZm9ib3hEaW1lbnNpb25cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGVsZW1lbnRVdGlsaXRpZXMuYWRkU3RhdGVPckluZm9Cb3gocmVndWxhdG9yTm9kZSwgaW5mb2JveE9iamVjdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHJlZ3VsYXRvckVkZ2UgPSBlbGVtZW50VXRpbGl0aWVzLmFkZEVkZ2UocmVndWxhdG9yTm9kZS5pZCgpLCBwcm9jZXNzTm9kZS5pZCgpLCB7Y2xhc3M6IHJlZ3VsYXRvckVkZ2VUeXBlLCBsYW5ndWFnZTogJ1BEJ30pO1xuICAgICAgICByZWd1bGF0b3JFZGdlLmRhdGEoJ2p1c3RBZGRlZCcsIHRydWUpO1xuICAgICAgfVxuXG4gICAgICBjeS5lbmRCYXRjaCgpO1xuXG4gICAgICBjb25zdCBlbGVzID0gY3kuZWxlbWVudHMoJ1tqdXN0QWRkZWRdJyk7XG4gICAgICBlbGVzLnJlbW92ZURhdGEoJ2p1c3RBZGRlZCcpO1xuXG4gICAgICBjeS5lbGVtZW50cygpLnVuc2VsZWN0KCk7XG4gICAgICBlbGVzLnNlbGVjdCgpO1xuXG4gICAgICByZXR1cm4gZWxlcztcblxuICAgIH1cblxuICAgIGVsZW1lbnRVdGlsaXRpZXMuY3JlYXRlTXVsdGltZXJpemF0aW9uID0gZnVuY3Rpb24gKG1hY3JvbW9sZWN1bGUsIHJlZ3VsYXRvciwgcmVndWxhdG9yTXVsdGltZXIsIG9yaWVudGF0aW9uKSB7XG4gICAgICBjb25zdCBoYXNSZWd1bGF0b3IgPSByZWd1bGF0b3IubmFtZSAhPT0gdW5kZWZpbmVkO1xuICAgICAgY29uc3QgbWFjcm9tb2xlY3VsZU5hbWUgPSBtYWNyb21vbGVjdWxlLm5hbWU7XG4gICAgICBjb25zdCBtYWNyb21vbGVjdWxlTXVsdGltZXJDYXJkaW5hbGl0eSA9IG1hY3JvbW9sZWN1bGUuY2FyZGluYWxpdHk7XG4gICAgICBjb25zdCBkZWZhdWx0TWFjcm9tb2xlY3VsZVByb3BlcnRpZXMgPSBlbGVtZW50VXRpbGl0aWVzLmdldERlZmF1bHRQcm9wZXJ0aWVzKFwibWFjcm9tb2xlY3VsZVwiKTtcbiAgICAgIGNvbnN0IGRlZmF1bHRSZWd1bGF0b3JQcm9wZXJ0aWVzID0gaGFzUmVndWxhdG9yID8gZWxlbWVudFV0aWxpdGllcy5nZXREZWZhdWx0UHJvcGVydGllcyhyZWd1bGF0b3IudHlwZSkgOiB7fTtcbiAgICAgIGNvbnN0IGRlZmF1bHRQcm9jZXNzUHJvcGVydGllcyA9IGVsZW1lbnRVdGlsaXRpZXMuZ2V0RGVmYXVsdFByb3BlcnRpZXMoXCJjYXRhbHl0aWNcIik7XG4gICAgICBjb25zdCBwcm9jZXNzV2lkdGggPSBkZWZhdWx0UHJvY2Vzc1Byb3BlcnRpZXMud2lkdGggfHwgNTA7XG4gICAgICBjb25zdCBtYWNyb21vbGVjdWxlV2lkdGggPSBkZWZhdWx0TWFjcm9tb2xlY3VsZVByb3BlcnRpZXMud2lkdGggfHwgNTA7XG4gICAgICBjb25zdCBtYWNyb21vbGVjdWxlSGVpZ2h0ID0gZGVmYXVsdE1hY3JvbW9sZWN1bGVQcm9wZXJ0aWVzLmhlaWdodCB8fCA1MDsgXG4gICAgICBjb25zdCBwcm9jZXNzSGVpZ2h0ID0gZGVmYXVsdFByb2Nlc3NQcm9wZXJ0aWVzLmhlaWdodCB8fCA1MDtcbiAgICAgIGNvbnN0IHJlZ3VsYXRvckhlaWdodCA9IGRlZmF1bHRSZWd1bGF0b3JQcm9wZXJ0aWVzLmhlaWdodCB8fCA1MDtcbiAgICAgIGNvbnN0IHByb2Nlc3NQb3NpdGlvbiA9IGVsZW1lbnRVdGlsaXRpZXMuY29udmVydFRvTW9kZWxQb3NpdGlvbih7eDogY3kud2lkdGgoKSAvIDIsIHk6IGN5LmhlaWdodCgpIC8gMn0pO1xuICAgICAgY29uc3QgZWRnZUxlbmd0aCA9IDMwO1xuICAgICAgY29uc3QgcHJvY2Vzc1BvcnRzT3JkZXJpbmcgPSBvcmllbnRhdGlvbiA9PT0gXCJ2ZXJ0aWNhbFwiID8gXCJULXRvLUJcIiA6IFwiTC10by1SXCI7XG4gICAgICBjb25zdCBtaW5JbmZvYm94RGltZW5zaW9uID0gMjA7XG4gICAgICBjb25zdCB3aWR0aFBlckNoYXIgPSA2O1xuICAgICAgY29uc3QgbXVsdGltZXJPZmZzZXQgPSA2O1xuXG4gICAgICBjeS5zdGFydEJhdGNoKCk7XG5cbiAgICAgIGlmICghZWxlbWVudFV0aWxpdGllcy5nZXRNYXBUeXBlKCkpIHtcbiAgICAgICAgZWxlbWVudFV0aWxpdGllcy5zZXRNYXBUeXBlKFwiUERcIik7XG4gICAgICB9XG5cbiAgICAgIGxldCB4UG9zT2ZJbnB1dCA9IHByb2Nlc3NQb3NpdGlvbi54IC0gZWRnZUxlbmd0aCAtIHByb2Nlc3NXaWR0aCAvIDIgLSBtYWNyb21vbGVjdWxlV2lkdGggLyAyO1xuICAgICAgbGV0IHhQb3NPZk91dHB1dCA9IHByb2Nlc3NQb3NpdGlvbi54ICsgZWRnZUxlbmd0aCArIHByb2Nlc3NXaWR0aCAvIDIgKyBtYWNyb21vbGVjdWxlV2lkdGggLyAyO1xuICAgICAgbGV0IHlQb3NPZklucHV0ID0gcHJvY2Vzc1Bvc2l0aW9uLnk7XG4gICAgICBsZXQgeVBvc09mT3V0cHV0ID0gcHJvY2Vzc1Bvc2l0aW9uLnk7XG5cbiAgICAgIGxldCBwcm9jZXNzTm9kZSA9IGVsZW1lbnRVdGlsaXRpZXMuYWRkTm9kZShwcm9jZXNzUG9zaXRpb24ueCwgcHJvY2Vzc1Bvc2l0aW9uLnksIHtjbGFzczogXCJwcm9jZXNzXCIsIGxhbmd1YWdlOiBcIlBEXCJ9KTtcbiAgICAgIGVsZW1lbnRVdGlsaXRpZXMuc2V0UG9ydHNPcmRlcmluZyhwcm9jZXNzTm9kZSwgcHJvY2Vzc1BvcnRzT3JkZXJpbmcpO1xuICAgICAgcHJvY2Vzc05vZGUuZGF0YSgnanVzdEFkZGVkJywgdHJ1ZSk7XG5cbiAgICAgIGxldCBub2RlUG9zaXRpb24gPSB7XG4gICAgICAgIHg6IHhQb3NPZklucHV0LFxuICAgICAgICB5OiB5UG9zT2ZJbnB1dFxuICAgICAgfVxuICAgICAgaWYgKG9yaWVudGF0aW9uID09PSBcInZlcnRpY2FsXCIpIHtcbiAgICAgICAgbm9kZVBvc2l0aW9uID0gZWxlbWVudFV0aWxpdGllcy5yb3RhdGU5MChub2RlUG9zaXRpb24sIHByb2Nlc3NQb3NpdGlvbik7XG4gICAgICB9XG5cbiAgICAgIGxldCBpbnB1dE5vZGUgPSBlbGVtZW50VXRpbGl0aWVzLmFkZE5vZGUobm9kZVBvc2l0aW9uLngsIG5vZGVQb3NpdGlvbi55LCB7Y2xhc3M6ICdtYWNyb21vbGVjdWxlJywgbGFuZ3VhZ2U6ICdQRCd9KTtcbiAgICAgIGlucHV0Tm9kZS5kYXRhKFwianVzdEFkZGVkXCIsIHRydWUpO1xuICAgICAgaW5wdXROb2RlLmRhdGEoXCJsYWJlbFwiLCBtYWNyb21vbGVjdWxlTmFtZSk7XG5cbiAgICAgIGxldCBpbnB1dEVkZ2UgPSBlbGVtZW50VXRpbGl0aWVzLmFkZEVkZ2UoaW5wdXROb2RlLmlkKCksIHByb2Nlc3NOb2RlLmlkKCksIHtjbGFzczogJ2NvbnN1bXB0aW9uJywgbGFuZ3VhZ2U6ICdQRCd9KVxuICAgICAgaW5wdXRFZGdlLmRhdGEoXCJqdXN0QWRkZWRcIiwgdHJ1ZSk7XG5cbiAgICAgIGxldCBjYXJkaW5hbGl0eSA9IG1hY3JvbW9sZWN1bGVNdWx0aW1lckNhcmRpbmFsaXR5O1xuICAgICAgaWYgKGNhcmRpbmFsaXR5ICE9PSAnJykge1xuICAgICAgICBpbnB1dEVkZ2UuZGF0YShcImNhcmRpbmFsaXR5XCIsIGNhcmRpbmFsaXR5KTtcbiAgICAgIH1cblxuICAgICAgbm9kZVBvc2l0aW9uID0ge1xuICAgICAgICB4OiB4UG9zT2ZPdXRwdXQsXG4gICAgICAgIHk6IHlQb3NPZk91dHB1dFxuICAgICAgfVxuXG4gICAgICBpZiAob3JpZW50YXRpb24gPT09IFwidmVydGljYWxcIikge1xuICAgICAgICBub2RlUG9zaXRpb24gPSBlbGVtZW50VXRpbGl0aWVzLnJvdGF0ZTkwKG5vZGVQb3NpdGlvbiwgcHJvY2Vzc1Bvc2l0aW9uKTtcbiAgICAgIH1cblxuICAgICAgbGV0IG91dHB1dE5vZGUgPSBlbGVtZW50VXRpbGl0aWVzLmFkZE5vZGUobm9kZVBvc2l0aW9uLngsIG5vZGVQb3NpdGlvbi55LCB7Y2xhc3M6ICdtYWNyb21vbGVjdWxlJywgbGFuZ3VhZ2U6ICdQRCd9KTtcbiAgICAgIG91dHB1dE5vZGUuZGF0YShcImp1c3RBZGRlZFwiLCB0cnVlKTtcbiAgICAgIG91dHB1dE5vZGUuZGF0YShcImxhYmVsXCIsIG1hY3JvbW9sZWN1bGVOYW1lKTtcbiAgICAgIGVsZW1lbnRVdGlsaXRpZXMuc2V0TXVsdGltZXJTdGF0dXMob3V0cHV0Tm9kZSwgdHJ1ZSk7XG5cbiAgICAgIGlmIChjYXJkaW5hbGl0eSAhPT0gJycpIHtcbiAgICAgICAgY29uc3QgaW5mb2JveExhYmVsID0gXCJOOlwiICsgY2FyZGluYWxpdHk7XG4gICAgICAgIGluZm9ib3hPYmplY3QgPSB7XG4gICAgICAgICAgY2xheno6IFwidW5pdCBvZiBpbmZvcm1hdGlvblwiLFxuICAgICAgICAgIGxhYmVsOiB7XG4gICAgICAgICAgICB0ZXh0OiBpbmZvYm94TGFiZWxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGJib3g6IHtcbiAgICAgICAgICAgIHc6IGluZm9ib3hMYWJlbC5sZW5ndGggKiB3aWR0aFBlckNoYXIsXG4gICAgICAgICAgICBoOiBtaW5JbmZvYm94RGltZW5zaW9uXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBlbGVtZW50VXRpbGl0aWVzLmFkZFN0YXRlT3JJbmZvQm94KG91dHB1dE5vZGUsIGluZm9ib3hPYmplY3QpO1xuICAgICAgfVxuXG4gICAgICBsZXQgb3V0cHV0RWRnZSA9IGVsZW1lbnRVdGlsaXRpZXMuYWRkRWRnZShwcm9jZXNzTm9kZS5pZCgpLCBvdXRwdXROb2RlLmlkKCksIHtjbGFzczogJ3Byb2R1Y3Rpb24nLCBsYW5ndWFnZTogJ1BEJ30pXG4gICAgICBvdXRwdXRFZGdlLmRhdGEoXCJqdXN0QWRkZWRcIiwgdHJ1ZSk7XG5cbiAgICAgIGlmIChoYXNSZWd1bGF0b3IpIHtcbiAgICAgICAgY29uc3QgcmVndWxhdG9yTmFtZSA9IHJlZ3VsYXRvci5uYW1lO1xuICAgICAgICBjb25zdCByZWd1bGF0b3JUeXBlID0gcmVndWxhdG9yLnR5cGU7XG4gICAgICAgIGNvbnN0IHJlZ3VsYXRvckVkZ2VUeXBlID0gcmVndWxhdG9yLmVkZ2VUeXBlO1xuXG4gICAgICAgIGxldCB4UG9zT2ZSZWd1bGF0b3IgPSBwcm9jZXNzUG9zaXRpb24ueDtcbiAgICAgICAgaWYgKHJlZ3VsYXRvck11bHRpbWVyLmVuYWJsZWQgJiYgb3JpZW50YXRpb24gPT09IFwiaG9yaXpvbnRhbFwiKSB7XG4gICAgICAgICAgeFBvc09mUmVndWxhdG9yIC09IG11bHRpbWVyT2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIGxldCB5UG9zT2ZSZWd1bGF0b3IgPSBwcm9jZXNzUG9zaXRpb24ueSAtICgocHJvY2Vzc0hlaWdodCAvIDIpICsgKHJlZ3VsYXRvckhlaWdodCAvIDIpICsgZWRnZUxlbmd0aCk7IFxuXG4gICAgICAgIG5vZGVQb3NpdGlvbiA9IHtcbiAgICAgICAgICB4OiB4UG9zT2ZSZWd1bGF0b3IsXG4gICAgICAgICAgeTogeVBvc09mUmVndWxhdG9yXG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9yaWVudGF0aW9uID09PSBcInZlcnRpY2FsXCIpIHtcbiAgICAgICAgICBub2RlUG9zaXRpb24gPSBlbGVtZW50VXRpbGl0aWVzLnJvdGF0ZTkwKG5vZGVQb3NpdGlvbiwgcHJvY2Vzc1Bvc2l0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCByZWd1bGF0b3JOb2RlID0gZWxlbWVudFV0aWxpdGllcy5hZGROb2RlKG5vZGVQb3NpdGlvbi54LCBub2RlUG9zaXRpb24ueSwge2NsYXNzOiByZWd1bGF0b3JUeXBlLCBsYW5ndWFnZTogJ1BEJ30pO1xuICAgICAgICByZWd1bGF0b3JOb2RlLmRhdGEoJ2p1c3RBZGRlZCcsIHRydWUpO1xuICAgICAgICByZWd1bGF0b3JOb2RlLmRhdGEoJ2xhYmVsJywgcmVndWxhdG9yTmFtZSk7XG5cbiAgICAgICAgaWYgKHJlZ3VsYXRvck11bHRpbWVyLmVuYWJsZWQpIHtcbiAgICAgICAgICBlbGVtZW50VXRpbGl0aWVzLnNldE11bHRpbWVyU3RhdHVzKHJlZ3VsYXRvck5vZGUsIHRydWUpO1xuXG4gICAgICAgICAgY29uc3QgY2FyZGluYWxpdHkgPSByZWd1bGF0b3JNdWx0aW1lci5jYXJkaW5hbGl0eTtcbiAgICAgICAgICBpZiAoY2FyZGluYWxpdHkgIT0gJycpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZm9ib3hMYWJlbCA9IFwiTjpcIiArIGNhcmRpbmFsaXR5O1xuICAgICAgICAgICAgaW5mb2JveE9iamVjdCA9IHtcbiAgICAgICAgICAgICAgY2xheno6IFwidW5pdCBvZiBpbmZvcm1hdGlvblwiLFxuICAgICAgICAgICAgICBsYWJlbDoge1xuICAgICAgICAgICAgICAgIHRleHQ6IGluZm9ib3hMYWJlbFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBiYm94OiB7XG4gICAgICAgICAgICAgICAgdzogaW5mb2JveExhYmVsLmxlbmd0aCAqIHdpZHRoUGVyQ2hhcixcbiAgICAgICAgICAgICAgICBoOiBtaW5JbmZvYm94RGltZW5zaW9uXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBlbGVtZW50VXRpbGl0aWVzLmFkZFN0YXRlT3JJbmZvQm94KHJlZ3VsYXRvck5vZGUsIGluZm9ib3hPYmplY3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCByZWd1bGF0b3JFZGdlID0gZWxlbWVudFV0aWxpdGllcy5hZGRFZGdlKHJlZ3VsYXRvck5vZGUuaWQoKSwgcHJvY2Vzc05vZGUuaWQoKSwge2NsYXNzOiByZWd1bGF0b3JFZGdlVHlwZSwgbGFuZ3VhZ2U6ICdQRCd9KTtcbiAgICAgICAgcmVndWxhdG9yRWRnZS5kYXRhKCdqdXN0QWRkZWQnLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgY3kuZW5kQmF0Y2goKTtcblxuICAgICAgY29uc3QgZWxlcyA9IGN5LmVsZW1lbnRzKCdbanVzdEFkZGVkXScpO1xuICAgICAgZWxlcy5yZW1vdmVEYXRhKCdqdXN0QWRkZWQnKTtcblxuICAgICAgY3kuZWxlbWVudHMoKS51bnNlbGVjdCgpO1xuICAgICAgZWxlcy5zZWxlY3QoKTtcblxuICAgICAgcmV0dXJuIGVsZXM7XG4gICAgfTtcblxuICAgIGVsZW1lbnRVdGlsaXRpZXMuY3JlYXRlQ29udmVyc2lvbiA9IGZ1bmN0aW9uIChtYWNyb21vbGVjdWxlLCByZWd1bGF0b3IsIHJlZ3VsYXRvck11bHRpbWVyLCBvcmllbnRhdGlvbiwgaW5wdXRJbmZvYm94TGFiZWxzLCBvdXRwdXRJbmZvYm94TGFiZWxzKSB7XG4gICAgICBjb25zdCBoYXNSZWd1bGF0b3IgPSByZWd1bGF0b3IubmFtZSAhPT0gdW5kZWZpbmVkO1xuICAgICAgY29uc3QgbWFjcm9tb2xlY3VsZU5hbWUgPSBtYWNyb21vbGVjdWxlLm5hbWU7XG4gICAgICBjb25zdCBtYWNyb21vbGVjdWxlSXNNdWx0aW1lciA9IG1hY3JvbW9sZWN1bGUubXVsdGltZXIuZW5hYmxlZDtcbiAgICAgIGNvbnN0IG1hY3JvbW9sZWN1bGVNdWx0aW1lckNhcmRpbmFsaXR5ID0gbWFjcm9tb2xlY3VsZS5tdWx0aW1lci5jYXJkaW5hbGl0eTtcbiAgICAgIGNvbnN0IGRlZmF1bHRNYWNyb21vbGVjdWxlUHJvcGVydGllcyA9IGVsZW1lbnRVdGlsaXRpZXMuZ2V0RGVmYXVsdFByb3BlcnRpZXMoXCJtYWNyb21vbGVjdWxlXCIpO1xuICAgICAgY29uc3QgZGVmYXVsdFJlZ3VsYXRvclByb3BlcnRpZXMgPSBoYXNSZWd1bGF0b3IgPyBlbGVtZW50VXRpbGl0aWVzLmdldERlZmF1bHRQcm9wZXJ0aWVzKHJlZ3VsYXRvci50eXBlKSA6IHt9O1xuICAgICAgY29uc3QgZGVmYXVsdFByb2Nlc3NQcm9wZXJ0aWVzID0gZWxlbWVudFV0aWxpdGllcy5nZXREZWZhdWx0UHJvcGVydGllcyhcImNhdGFseXRpY1wiKTtcbiAgICAgIGNvbnN0IHByb2Nlc3NXaWR0aCA9IGRlZmF1bHRQcm9jZXNzUHJvcGVydGllcy53aWR0aCB8fCA1MDtcbiAgICAgIGNvbnN0IG1hY3JvbW9sZWN1bGVXaWR0aCA9IGRlZmF1bHRNYWNyb21vbGVjdWxlUHJvcGVydGllcy53aWR0aCB8fCA1MDtcbiAgICAgIGNvbnN0IG1hY3JvbW9sZWN1bGVIZWlnaHQgPSBkZWZhdWx0TWFjcm9tb2xlY3VsZVByb3BlcnRpZXMuaGVpZ2h0IHx8IDUwOyBcbiAgICAgIGNvbnN0IHByb2Nlc3NIZWlnaHQgPSBkZWZhdWx0UHJvY2Vzc1Byb3BlcnRpZXMuaGVpZ2h0IHx8IDUwO1xuICAgICAgY29uc3QgcmVndWxhdG9ySGVpZ2h0ID0gZGVmYXVsdFJlZ3VsYXRvclByb3BlcnRpZXMuaGVpZ2h0IHx8IDUwO1xuICAgICAgY29uc3QgcHJvY2Vzc1Bvc2l0aW9uID0gZWxlbWVudFV0aWxpdGllcy5jb252ZXJ0VG9Nb2RlbFBvc2l0aW9uKHt4OiBjeS53aWR0aCgpIC8gMiwgeTogY3kuaGVpZ2h0KCkgLyAyfSk7XG4gICAgICBjb25zdCBlZGdlTGVuZ3RoID0gMzA7XG4gICAgICBjb25zdCBwcm9jZXNzUG9ydHNPcmRlcmluZyA9IG9yaWVudGF0aW9uID09PSBcInZlcnRpY2FsXCIgPyBcIlQtdG8tQlwiIDogXCJMLXRvLVJcIjtcbiAgICAgIGNvbnN0IG1pbkluZm9ib3hEaW1lbnNpb24gPSAyMDtcbiAgICAgIGNvbnN0IHdpZHRoUGVyQ2hhciA9IDY7XG4gICAgICBjb25zdCBtdWx0aW1lck9mZnNldCA9IDY7XG5cbiAgICAgIGN5LnN0YXJ0QmF0Y2goKTtcblxuICAgICAgaWYgKCFlbGVtZW50VXRpbGl0aWVzLmdldE1hcFR5cGUoKSkge1xuICAgICAgICBlbGVtZW50VXRpbGl0aWVzLnNldE1hcFR5cGUoXCJQRFwiKTtcbiAgICAgIH1cblxuICAgICAgbGV0IHhQb3NPZklucHV0ID0gcHJvY2Vzc1Bvc2l0aW9uLnggLSBlZGdlTGVuZ3RoIC0gcHJvY2Vzc1dpZHRoIC8gMiAtIG1hY3JvbW9sZWN1bGVXaWR0aCAvIDI7XG4gICAgICBsZXQgeFBvc09mT3V0cHV0ID0gcHJvY2Vzc1Bvc2l0aW9uLnggKyBlZGdlTGVuZ3RoICsgcHJvY2Vzc1dpZHRoIC8gMiArIG1hY3JvbW9sZWN1bGVXaWR0aCAvIDI7XG4gICAgICBsZXQgeVBvc09mSW5wdXQgPSBwcm9jZXNzUG9zaXRpb24ueTtcbiAgICAgIGxldCB5UG9zT2ZPdXRwdXQgPSBwcm9jZXNzUG9zaXRpb24ueTtcblxuICAgICAgbGV0IHByb2Nlc3NOb2RlID0gZWxlbWVudFV0aWxpdGllcy5hZGROb2RlKHByb2Nlc3NQb3NpdGlvbi54LCBwcm9jZXNzUG9zaXRpb24ueSwge2NsYXNzOiBcInByb2Nlc3NcIiwgbGFuZ3VhZ2U6IFwiUERcIn0pO1xuICAgICAgZWxlbWVudFV0aWxpdGllcy5zZXRQb3J0c09yZGVyaW5nKHByb2Nlc3NOb2RlLCBwcm9jZXNzUG9ydHNPcmRlcmluZyk7XG4gICAgICBwcm9jZXNzTm9kZS5kYXRhKCdqdXN0QWRkZWQnLCB0cnVlKTtcblxuICAgICAgbGV0IG5vZGVQb3NpdGlvbiA9IHtcbiAgICAgICAgeDogeFBvc09mSW5wdXQsXG4gICAgICAgIHk6IHlQb3NPZklucHV0XG4gICAgICB9XG4gICAgICBpZiAob3JpZW50YXRpb24gPT09IFwidmVydGljYWxcIikge1xuICAgICAgICBub2RlUG9zaXRpb24gPSBlbGVtZW50VXRpbGl0aWVzLnJvdGF0ZTkwKG5vZGVQb3NpdGlvbiwgcHJvY2Vzc1Bvc2l0aW9uKTtcbiAgICAgIH1cblxuICAgICAgbGV0IGlucHV0Tm9kZSA9IGVsZW1lbnRVdGlsaXRpZXMuYWRkTm9kZShub2RlUG9zaXRpb24ueCwgbm9kZVBvc2l0aW9uLnksIHtjbGFzczogJ21hY3JvbW9sZWN1bGUnLCBsYW5ndWFnZTogJ1BEJ30pO1xuICAgICAgaW5wdXROb2RlLmRhdGEoXCJqdXN0QWRkZWRcIiwgdHJ1ZSk7XG4gICAgICBpbnB1dE5vZGUuZGF0YShcImxhYmVsXCIsIG1hY3JvbW9sZWN1bGVOYW1lKTtcbiAgICAgIGlmIChtYWNyb21vbGVjdWxlSXNNdWx0aW1lcikge1xuICAgICAgICBcbiAgICAgICAgZWxlbWVudFV0aWxpdGllcy5zZXRNdWx0aW1lclN0YXR1cyhpbnB1dE5vZGUsIHRydWUpO1xuXG4gICAgICAgIGNvbnN0IGNhcmRpbmFsaXR5ID0gbWFjcm9tb2xlY3VsZU11bHRpbWVyQ2FyZGluYWxpdHk7XG4gICAgICAgIGlmIChjYXJkaW5hbGl0eSAhPSAnJykge1xuICAgICAgICAgIGNvbnN0IGluZm9ib3hMYWJlbCA9IFwiTjpcIiArIGNhcmRpbmFsaXR5O1xuICAgICAgICAgIGluZm9ib3hPYmplY3QgPSB7XG4gICAgICAgICAgICBjbGF6ejogXCJ1bml0IG9mIGluZm9ybWF0aW9uXCIsXG4gICAgICAgICAgICBsYWJlbDoge1xuICAgICAgICAgICAgICB0ZXh0OiBpbmZvYm94TGFiZWxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBiYm94OiB7XG4gICAgICAgICAgICAgIHc6IGluZm9ib3hMYWJlbC5sZW5ndGggKiB3aWR0aFBlckNoYXIsXG4gICAgICAgICAgICAgIGg6IG1pbkluZm9ib3hEaW1lbnNpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIGVsZW1lbnRVdGlsaXRpZXMuYWRkU3RhdGVPckluZm9Cb3goaW5wdXROb2RlLCBpbmZvYm94T2JqZWN0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpbnB1dEluZm9ib3hMYWJlbHMuZm9yRWFjaChmdW5jdGlvbihsYWJlbCkge1xuICAgICAgICBjb25zdCBpbnB1dEluZm9ib3hXaWR0aCA9IGxhYmVsLmxlbmd0aCA+IDAgPyBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5tYXgod2lkdGhQZXJDaGFyICogbGFiZWwubGVuZ3RoLCBtaW5JbmZvYm94RGltZW5zaW9uKSA6IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5JbmZvYm94RGltZW5zaW9uOyBcbiAgICAgICAgbGV0IGluZm9ib3hPYmplY3QgPSB7XG4gICAgICAgICAgY2xheno6IFwidW5pdCBvZiBpbmZvcm1hdGlvblwiLFxuICAgICAgICAgIGxhYmVsOiB7XG4gICAgICAgICAgICB0ZXh0OiBsYWJlbFxuICAgICAgICAgIH0sXG4gICAgICAgICAgYmJveDoge1xuICAgICAgICAgICAgdzogaW5wdXRJbmZvYm94V2lkdGgsXG4gICAgICAgICAgICBoOiBtaW5JbmZvYm94RGltZW5zaW9uXG4gICAgICAgICAgfSxcbiAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgXCJzaGFwZS1uYW1lXCI6IFwiZWxsaXBzZVwiXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBlbGVtZW50VXRpbGl0aWVzLmFkZFN0YXRlT3JJbmZvQm94KGlucHV0Tm9kZSwgaW5mb2JveE9iamVjdCk7XG4gICAgICB9KTtcblxuICAgICAgbGV0IGlucHV0RWRnZSA9IGVsZW1lbnRVdGlsaXRpZXMuYWRkRWRnZShpbnB1dE5vZGUuaWQoKSwgcHJvY2Vzc05vZGUuaWQoKSwge2NsYXNzOiAnY29uc3VtcHRpb24nLCBsYW5ndWFnZTogJ1BEJ30pXG4gICAgICBpbnB1dEVkZ2UuZGF0YShcImp1c3RBZGRlZFwiLCB0cnVlKTtcblxuICAgICAgbm9kZVBvc2l0aW9uID0ge1xuICAgICAgICB4OiB4UG9zT2ZPdXRwdXQsXG4gICAgICAgIHk6IHlQb3NPZk91dHB1dFxuICAgICAgfVxuXG4gICAgICBpZiAob3JpZW50YXRpb24gPT09IFwidmVydGljYWxcIikge1xuICAgICAgICBub2RlUG9zaXRpb24gPSBlbGVtZW50VXRpbGl0aWVzLnJvdGF0ZTkwKG5vZGVQb3NpdGlvbiwgcHJvY2Vzc1Bvc2l0aW9uKTtcbiAgICAgIH1cblxuICAgICAgbGV0IG91dHB1dE5vZGUgPSBlbGVtZW50VXRpbGl0aWVzLmFkZE5vZGUobm9kZVBvc2l0aW9uLngsIG5vZGVQb3NpdGlvbi55LCB7Y2xhc3M6ICdtYWNyb21vbGVjdWxlJywgbGFuZ3VhZ2U6ICdQRCd9KTtcbiAgICAgIG91dHB1dE5vZGUuZGF0YShcImp1c3RBZGRlZFwiLCB0cnVlKTtcbiAgICAgIG91dHB1dE5vZGUuZGF0YShcImxhYmVsXCIsIG1hY3JvbW9sZWN1bGVOYW1lKTtcbiAgICAgIGlmIChtYWNyb21vbGVjdWxlSXNNdWx0aW1lcikge1xuICAgICAgICBcbiAgICAgICAgZWxlbWVudFV0aWxpdGllcy5zZXRNdWx0aW1lclN0YXR1cyhvdXRwdXROb2RlLCB0cnVlKTtcblxuICAgICAgICBjb25zdCBjYXJkaW5hbGl0eSA9IG1hY3JvbW9sZWN1bGVNdWx0aW1lckNhcmRpbmFsaXR5O1xuICAgICAgICBpZiAoY2FyZGluYWxpdHkgIT0gJycpIHtcbiAgICAgICAgICBjb25zdCBpbmZvYm94TGFiZWwgPSBcIk46XCIgKyBjYXJkaW5hbGl0eTtcbiAgICAgICAgICBpbmZvYm94T2JqZWN0ID0ge1xuICAgICAgICAgICAgY2xheno6IFwidW5pdCBvZiBpbmZvcm1hdGlvblwiLFxuICAgICAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICAgICAgdGV4dDogaW5mb2JveExhYmVsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYmJveDoge1xuICAgICAgICAgICAgICB3OiBpbmZvYm94TGFiZWwubGVuZ3RoICogd2lkdGhQZXJDaGFyLFxuICAgICAgICAgICAgICBoOiBtaW5JbmZvYm94RGltZW5zaW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICBlbGVtZW50VXRpbGl0aWVzLmFkZFN0YXRlT3JJbmZvQm94KG91dHB1dE5vZGUsIGluZm9ib3hPYmplY3QpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG91dHB1dEluZm9ib3hMYWJlbHMuZm9yRWFjaChmdW5jdGlvbihsYWJlbCkge1xuICAgICAgICBjb25zdCBvdXRwdXRJbmZvYm94V2lkdGggPSBsYWJlbC5sZW5ndGggPiAwID8gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgubWF4KHdpZHRoUGVyQ2hhciAqIGxhYmVsLmxlbmd0aCwgbWluSW5mb2JveERpbWVuc2lvbikgOiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluSW5mb2JveERpbWVuc2lvbjtcbiAgICAgICAgaW5mb2JveE9iamVjdCA9IHtcbiAgICAgICAgICBjbGF6ejogXCJ1bml0IG9mIGluZm9ybWF0aW9uXCIsXG4gICAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICAgIHRleHQ6IGxhYmVsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBiYm94OiB7XG4gICAgICAgICAgICB3OiBvdXRwdXRJbmZvYm94V2lkdGgsXG4gICAgICAgICAgICBoOiBtaW5JbmZvYm94RGltZW5zaW9uXG4gICAgICAgICAgfSxcbiAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgXCJzaGFwZS1uYW1lXCI6IFwiZWxsaXBzZVwiXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBlbGVtZW50VXRpbGl0aWVzLmFkZFN0YXRlT3JJbmZvQm94KG91dHB1dE5vZGUsIGluZm9ib3hPYmplY3QpO1xuICAgICAgfSk7XG5cbiAgICAgIFxuICAgICAgW2lucHV0Tm9kZSwgb3V0cHV0Tm9kZV0uZm9yRWFjaChmdW5jdGlvbihub2RlKXtcbiAgICAgICAgY29uc3Qgd2lkdGggPSBlbGVtZW50VXRpbGl0aWVzLmNhbGN1bGF0ZU1pbldpZHRoKG5vZGUpO1xuICAgICAgICBcbiAgICAgICAgZWxlbWVudFV0aWxpdGllcy5yZXNpemVOb2Rlcyhub2RlLCB3aWR0aCwgbWFjcm9tb2xlY3VsZUhlaWdodCwgZmFsc2UsIHRydWUpO1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGlmIChvcmllbnRhdGlvbiA9PT0gXCJob3Jpem9udGFsXCIpIHtcbiAgICAgICAgbGV0IG5ld0lucHV0WFBvcyA9IHByb2Nlc3NQb3NpdGlvbi54IC0gZWRnZUxlbmd0aCAtIHByb2Nlc3NXaWR0aCAvIDIgLSBpbnB1dE5vZGUuZGF0YSgnYmJveCcpLncgLyAyO1xuICAgICAgICBpbnB1dE5vZGUucG9zaXRpb24oJ3gnLCBuZXdJbnB1dFhQb3MpO1xuICAgICAgXG4gICAgICAgIGxldCBuZXdPdXRwdXRYUG9zID0gcHJvY2Vzc1Bvc2l0aW9uLnggKyBlZGdlTGVuZ3RoICsgcHJvY2Vzc1dpZHRoIC8gMiArIG91dHB1dE5vZGUuZGF0YSgnYmJveCcpLncgLyAyO1xuICAgICAgICBvdXRwdXROb2RlLnBvc2l0aW9uKCd4JywgbmV3T3V0cHV0WFBvcyk7XG4gICAgICB9IFxuICAgICAgZWxzZSB7XG4gICAgICAgIGxldCBuZXdJbnB1dFlQb3MgPSBwcm9jZXNzUG9zaXRpb24ueSAtIGVkZ2VMZW5ndGggLSBwcm9jZXNzV2lkdGggLyAyIC0gaW5wdXROb2RlLmRhdGEoJ2Jib3gnKS5oIC8gMjtcbiAgICAgICAgaW5wdXROb2RlLnBvc2l0aW9uKCd5JywgbmV3SW5wdXRZUG9zKTtcbiAgICAgIFxuICAgICAgICBsZXQgbmV3T3V0cHV0WVBvcyA9IHByb2Nlc3NQb3NpdGlvbi55ICsgZWRnZUxlbmd0aCArIHByb2Nlc3NXaWR0aCAvIDIgKyBvdXRwdXROb2RlLmRhdGEoJ2Jib3gnKS5oIC8gMjtcbiAgICAgICAgb3V0cHV0Tm9kZS5wb3NpdGlvbigneScsIG5ld091dHB1dFlQb3MpO1xuICAgICAgfVxuXG4gICAgICBsZXQgb3V0cHV0RWRnZSA9IGVsZW1lbnRVdGlsaXRpZXMuYWRkRWRnZShwcm9jZXNzTm9kZS5pZCgpLCBvdXRwdXROb2RlLmlkKCksIHtjbGFzczogJ3Byb2R1Y3Rpb24nLCBsYW5ndWFnZTogJ1BEJ30pXG4gICAgICBvdXRwdXRFZGdlLmRhdGEoXCJqdXN0QWRkZWRcIiwgdHJ1ZSk7XG5cbiAgICAgIGlmIChoYXNSZWd1bGF0b3IpIHtcbiAgICAgICAgY29uc3QgcmVndWxhdG9yTmFtZSA9IHJlZ3VsYXRvci5uYW1lO1xuICAgICAgICBjb25zdCByZWd1bGF0b3JUeXBlID0gcmVndWxhdG9yLnR5cGU7XG4gICAgICAgIGxldCB4UG9zT2ZSZWd1bGF0b3IgPSBwcm9jZXNzUG9zaXRpb24ueDtcbiAgICAgICAgaWYgKHJlZ3VsYXRvck11bHRpbWVyLmVuYWJsZWQgJiYgb3JpZW50YXRpb24gPT09IFwiaG9yaXpvbnRhbFwiKSB7XG4gICAgICAgICAgeFBvc09mUmVndWxhdG9yIC09IG11bHRpbWVyT2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIGxldCB5UG9zT2ZSZWd1bGF0b3IgPSBwcm9jZXNzUG9zaXRpb24ueSAtICgocHJvY2Vzc0hlaWdodCAvIDIpICsgKHJlZ3VsYXRvckhlaWdodCAvIDIpICsgZWRnZUxlbmd0aCk7IFxuXG4gICAgICAgIG5vZGVQb3NpdGlvbiA9IHtcbiAgICAgICAgICB4OiB4UG9zT2ZSZWd1bGF0b3IsXG4gICAgICAgICAgeTogeVBvc09mUmVndWxhdG9yXG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9yaWVudGF0aW9uID09PSBcInZlcnRpY2FsXCIpIHtcbiAgICAgICAgICBub2RlUG9zaXRpb24gPSBlbGVtZW50VXRpbGl0aWVzLnJvdGF0ZTkwKG5vZGVQb3NpdGlvbiwgcHJvY2Vzc1Bvc2l0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCByZWd1bGF0b3JOb2RlID0gZWxlbWVudFV0aWxpdGllcy5hZGROb2RlKG5vZGVQb3NpdGlvbi54LCBub2RlUG9zaXRpb24ueSwge2NsYXNzOiByZWd1bGF0b3JUeXBlLCBsYW5ndWFnZTogJ1BEJ30pO1xuICAgICAgICByZWd1bGF0b3JOb2RlLmRhdGEoJ2p1c3RBZGRlZCcsIHRydWUpO1xuICAgICAgICByZWd1bGF0b3JOb2RlLmRhdGEoJ2xhYmVsJywgcmVndWxhdG9yTmFtZSk7XG5cbiAgICAgICAgaWYgKHJlZ3VsYXRvck11bHRpbWVyLmVuYWJsZWQpIHtcbiAgICAgICAgICBlbGVtZW50VXRpbGl0aWVzLnNldE11bHRpbWVyU3RhdHVzKHJlZ3VsYXRvck5vZGUsIHRydWUpO1xuXG4gICAgICAgICAgY29uc3QgY2FyZGluYWxpdHkgPSByZWd1bGF0b3JNdWx0aW1lci5jYXJkaW5hbGl0eTtcbiAgICAgICAgICBpZiAoY2FyZGluYWxpdHkgIT0gJycpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZm9ib3hMYWJlbCA9IFwiTjpcIiArIGNhcmRpbmFsaXR5O1xuICAgICAgICAgICAgaW5mb2JveE9iamVjdCA9IHtcbiAgICAgICAgICAgICAgY2xheno6IFwidW5pdCBvZiBpbmZvcm1hdGlvblwiLFxuICAgICAgICAgICAgICBsYWJlbDoge1xuICAgICAgICAgICAgICAgIHRleHQ6IGluZm9ib3hMYWJlbFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBiYm94OiB7XG4gICAgICAgICAgICAgICAgdzogaW5mb2JveExhYmVsLmxlbmd0aCAqIHdpZHRoUGVyQ2hhcixcbiAgICAgICAgICAgICAgICBoOiBtaW5JbmZvYm94RGltZW5zaW9uXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBlbGVtZW50VXRpbGl0aWVzLmFkZFN0YXRlT3JJbmZvQm94KHJlZ3VsYXRvck5vZGUsIGluZm9ib3hPYmplY3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCByZWd1bGF0b3JFZGdlID0gZWxlbWVudFV0aWxpdGllcy5hZGRFZGdlKHJlZ3VsYXRvck5vZGUuaWQoKSwgcHJvY2Vzc05vZGUuaWQoKSwge2NsYXNzOiAnY2F0YWx5c2lzJywgbGFuZ3VhZ2U6ICdQRCd9KTtcbiAgICAgICAgcmVndWxhdG9yRWRnZS5kYXRhKCdqdXN0QWRkZWQnLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgY3kuZW5kQmF0Y2goKTtcblxuICAgICAgY29uc3QgZWxlcyA9IGN5LmVsZW1lbnRzKCdbanVzdEFkZGVkXScpO1xuICAgICAgZWxlcy5yZW1vdmVEYXRhKCdqdXN0QWRkZWQnKTtcblxuICAgICAgY3kuZWxlbWVudHMoKS51bnNlbGVjdCgpO1xuICAgICAgZWxlcy5zZWxlY3QoKTtcblxuICAgICAgcmV0dXJuIGVsZXM7XG4gICAgfTtcblxuICAgIGVsZW1lbnRVdGlsaXRpZXMuY3JlYXRlTWV0YWJvbGljUmVhY3Rpb24gPSBmdW5jdGlvbiAoaW5wdXRzLCBvdXRwdXRzLCByZXZlcnNpYmxlLCByZWd1bGF0b3IsIHJlZ3VsYXRvck11bHRpbWVyLCBvcmllbnRhdGlvbikge1xuICAgICAgbGV0IHJvdGF0ZTkwID0gZnVuY3Rpb24ocG9pbnQsIGNlbnRlcikge1xuICAgICAgICBjb25zdCByZWxhdGl2ZVggPSBjZW50ZXIueCAtIHBvaW50Lng7XG4gICAgICAgIGNvbnN0IHJlbGF0aXZlWSA9IGNlbnRlci55IC0gcG9pbnQueTtcblxuICAgICAgICBjb25zdCByZWxhdGl2ZVJvdGF0ZWRYID0gcmVsYXRpdmVZO1xuICAgICAgICBjb25zdCByZWxhdGl2ZVJvdGF0ZWRZID0gLTEgKiByZWxhdGl2ZVg7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0WCA9IHJlbGF0aXZlUm90YXRlZFggKyBjZW50ZXIueDtcbiAgICAgICAgY29uc3QgcmVzdWx0WSA9IHJlbGF0aXZlUm90YXRlZFkgKyBjZW50ZXIueTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IHJlc3VsdFgsXG4gICAgICAgICAgeTogcmVzdWx0WVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgaGFzUmVndWxhdG9yID0gcmVndWxhdG9yLm5hbWUgIT09IHVuZGVmaW5lZDtcbiAgICAgIGNvbnN0IGRlZmF1bHRTaW1wbGVDaGVtaWNhbFByb3BlcnRpZXMgPSBlbGVtZW50VXRpbGl0aWVzLmdldERlZmF1bHRQcm9wZXJ0aWVzKCBcInNpbXBsZSBjaGVtaWNhbFwiICk7XG4gICAgICBjb25zdCBkZWZhdWx0UmVndWxhdG9yUHJvcGVydGllcyA9IGhhc1JlZ3VsYXRvciA/IGVsZW1lbnRVdGlsaXRpZXMuZ2V0RGVmYXVsdFByb3BlcnRpZXMocmVndWxhdG9yLnR5cGUpIDoge307XG4gICAgICBjb25zdCBkZWZhdWx0UHJvY2Vzc1Byb3BlcnRpZXMgPSBlbGVtZW50VXRpbGl0aWVzLmdldERlZmF1bHRQcm9wZXJ0aWVzKFwiY2F0YWx5dGljXCIpO1xuICAgICAgY29uc3QgcHJvY2Vzc1dpZHRoID0gZGVmYXVsdFByb2Nlc3NQcm9wZXJ0aWVzLndpZHRoIHx8IDUwO1xuICAgICAgY29uc3QgcHJvY2Vzc0hlaWdodCA9IGRlZmF1bHRQcm9jZXNzUHJvcGVydGllcy5oZWlnaHQgfHwgNTA7XG4gICAgICBjb25zdCBzaW1wbGVDaGVtaWNhbEhlaWdodCA9IGRlZmF1bHRTaW1wbGVDaGVtaWNhbFByb3BlcnRpZXMuaGVpZ2h0IHx8IDM1O1xuICAgICAgY29uc3Qgc2ltcGxlQ2hlbWljYWxXaWR0aCA9IGRlZmF1bHRTaW1wbGVDaGVtaWNhbFByb3BlcnRpZXMud2lkdGggfHwgMzU7XG4gICAgICBjb25zdCByZWd1bGF0b3JIZWlnaHQgPSBkZWZhdWx0UmVndWxhdG9yUHJvcGVydGllcy5oZWlnaHQgfHwgNTA7XG4gICAgICBjb25zdCBwcm9jZXNzUG9zaXRpb24gPSBlbGVtZW50VXRpbGl0aWVzLmNvbnZlcnRUb01vZGVsUG9zaXRpb24oe3g6IGN5LndpZHRoKCkgLyAyLCB5OiBjeS5oZWlnaHQoKSAvIDJ9KTtcbiAgICAgIGNvbnN0IHRpbGluZ1BhZGRpbmdWZXJ0aWNhbCA9IDE1O1xuICAgICAgY29uc3QgZWRnZUxlbmd0aCA9IDMwO1xuICAgICAgY29uc3QgcHJvY2Vzc0xlZnRTaWRlRWRnZVR5cGUgPSByZXZlcnNpYmxlID8gXCJwcm9kdWN0aW9uXCIgOiBcImNvbnN1bXB0aW9uXCI7XG4gICAgICBjb25zdCBwcm9jZXNzUmlnaHRTaWRlRWRnZVR5cGUgPSBcInByb2R1Y3Rpb25cIjtcbiAgICAgIGNvbnN0IHByb2Nlc3NQb3J0c09yZGVyaW5nID0gb3JpZW50YXRpb24gPT09IFwidmVydGljYWxcIiA/IFwiVC10by1CXCIgOiBcIkwtdG8tUlwiO1xuICAgICAgY29uc3QgbXVsdGltZXJPZmZzZXQgPSA2O1xuXG4gICAgICBjeS5zdGFydEJhdGNoKCk7XG4gICAgICBpZiAoIWVsZW1lbnRVdGlsaXRpZXMuZ2V0TWFwVHlwZSgpKSB7XG4gICAgICAgIGVsZW1lbnRVdGlsaXRpZXMuc2V0TWFwVHlwZShcIlBEXCIpO1xuICAgICAgfVxuXG4gICAgICBsZXQgeFBvc09mSW5wdXQgPSBwcm9jZXNzUG9zaXRpb24ueCAtIGVkZ2VMZW5ndGggLSBwcm9jZXNzV2lkdGggLyAyIC0gc2ltcGxlQ2hlbWljYWxXaWR0aCAvIDI7XG4gICAgICBsZXQgeFBvc09mT3V0cHV0ID0gcHJvY2Vzc1Bvc2l0aW9uLnggKyBlZGdlTGVuZ3RoICsgcHJvY2Vzc1dpZHRoIC8gMiArIHNpbXBsZUNoZW1pY2FsV2lkdGggLyAyO1xuXG5cbiAgICAgIGxldCBwcm9jZXNzTm9kZSA9IGVsZW1lbnRVdGlsaXRpZXMuYWRkTm9kZShwcm9jZXNzUG9zaXRpb24ueCwgcHJvY2Vzc1Bvc2l0aW9uLnksIHtjbGFzczogXCJwcm9jZXNzXCIsIGxhbmd1YWdlOiBcIlBEXCJ9KTtcbiAgICAgIGVsZW1lbnRVdGlsaXRpZXMuc2V0UG9ydHNPcmRlcmluZyhwcm9jZXNzTm9kZSwgcHJvY2Vzc1BvcnRzT3JkZXJpbmcpO1xuICAgICAgcHJvY2Vzc05vZGUuZGF0YSgnanVzdEFkZGVkJywgdHJ1ZSk7XG5cbiAgICAgIGNvbnN0IG51bU9mSW5wdXROb2RlcyA9IGlucHV0cy5sZW5ndGg7XG4gICAgICBjb25zdCBudW1PZk91dHB1dE5vZGVzID0gb3V0cHV0cy5sZW5ndGg7XG5cbiAgICAgIGxldCB5UG9zT2ZJbnB1dCA9IHByb2Nlc3NQb3NpdGlvbi55IC0gKChudW1PZklucHV0Tm9kZXMgLSAxKSAvIDIpICogKHNpbXBsZUNoZW1pY2FsSGVpZ2h0ICsgdGlsaW5nUGFkZGluZ1ZlcnRpY2FsKTtcblxuICAgICAgaW5wdXRzLmZvckVhY2goZnVuY3Rpb24oZGF0YSwgaW5kZXgpIHtcbiAgICAgICAgY29uc3Qgbm9kZU5hbWUgPSBkYXRhLm5hbWU7XG4gICAgICAgIGNvbnN0IG5vZGVUeXBlID0gZGF0YS50eXBlO1xuXG4gICAgICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICAgIHlQb3NPZklucHV0ID0gcHJvY2Vzc1Bvc2l0aW9uLnk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW5kZXggJSAyID09PSAxKSB7XG4gICAgICAgICAgeVBvc09mSW5wdXQgPSBwcm9jZXNzUG9zaXRpb24ueSAtICgoc2ltcGxlQ2hlbWljYWxIZWlnaHQgKyB0aWxpbmdQYWRkaW5nVmVydGljYWwpICogTWF0aC5jZWlsKGluZGV4IC8gMikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHlQb3NPZklucHV0ID0gcHJvY2Vzc1Bvc2l0aW9uLnkgKyAoKHNpbXBsZUNoZW1pY2FsSGVpZ2h0ICsgdGlsaW5nUGFkZGluZ1ZlcnRpY2FsKSAqIChpbmRleCAvIDIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBub2RlUG9zaXRpb24gPSB7XG4gICAgICAgICAgeDogeFBvc09mSW5wdXQsXG4gICAgICAgICAgeTogeVBvc09mSW5wdXRcbiAgICAgICAgfVxuICAgICAgICBpZiAob3JpZW50YXRpb24gPT09IFwidmVydGljYWxcIikge1xuICAgICAgICAgIG5vZGVQb3NpdGlvbiA9IHJvdGF0ZTkwKG5vZGVQb3NpdGlvbiwgcHJvY2Vzc1Bvc2l0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBuZXdOb2RlID0gZWxlbWVudFV0aWxpdGllcy5hZGROb2RlKG5vZGVQb3NpdGlvbi54LCBub2RlUG9zaXRpb24ueSwge2NsYXNzOiBub2RlVHlwZS50b0xvd2VyQ2FzZSgpLCBsYW5ndWFnZTogXCJQRFwifSk7XG4gICAgICAgIG5ld05vZGUuZGF0YShcImp1c3RBZGRlZFwiLCB0cnVlKTtcbiAgICAgICAgbmV3Tm9kZS5kYXRhKFwibGFiZWxcIiwgbm9kZU5hbWUpO1xuXG4gICAgICAgIGxldCBuZXdFZGdlO1xuICAgICAgICBpZiAocmV2ZXJzaWJsZSkge1xuICAgICAgICAgIG5ld0VkZ2UgPSBlbGVtZW50VXRpbGl0aWVzLmFkZEVkZ2UocHJvY2Vzc05vZGUuaWQoKSwgbmV3Tm9kZS5pZCgpLCB7Y2xhc3M6IHByb2Nlc3NMZWZ0U2lkZUVkZ2VUeXBlLCBsYW5ndWFnZTogXCJQRFwifSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIG5ld0VkZ2UgPSBlbGVtZW50VXRpbGl0aWVzLmFkZEVkZ2UobmV3Tm9kZS5pZCgpLCBwcm9jZXNzTm9kZS5pZCgpLCB7Y2xhc3M6IHByb2Nlc3NMZWZ0U2lkZUVkZ2VUeXBlLCBsYW5ndWFnZTogXCJQRFwifSk7XG4gICAgICAgIH1cbiAgICAgICAgbmV3RWRnZS5kYXRhKFwianVzdEFkZGVkXCIsIHRydWUpO1xuICAgICAgfSk7XG5cbiAgICAgIGxldCB5UG9zT2ZPdXRwdXQgPSBwcm9jZXNzUG9zaXRpb24ueSAtICgobnVtT2ZPdXRwdXROb2RlcyAtIDEpIC8gMikgKiAoc2ltcGxlQ2hlbWljYWxIZWlnaHQgKyB0aWxpbmdQYWRkaW5nVmVydGljYWwpO1xuXG4gICAgICBvdXRwdXRzLmZvckVhY2goZnVuY3Rpb24oZGF0YSwgaW5kZXgpIHtcbiAgICAgICAgY29uc3Qgbm9kZU5hbWUgPSBkYXRhLm5hbWU7XG4gICAgICAgIGNvbnN0IG5vZGVUeXBlID0gZGF0YS50eXBlO1xuXG4gICAgICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICAgIHlQb3NPZk91dHB1dCA9IHByb2Nlc3NQb3NpdGlvbi55O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGluZGV4ICUgMiA9PT0gMSkge1xuICAgICAgICAgIHlQb3NPZk91dHB1dCA9IHByb2Nlc3NQb3NpdGlvbi55IC0gKChzaW1wbGVDaGVtaWNhbEhlaWdodCArIHRpbGluZ1BhZGRpbmdWZXJ0aWNhbCkgKiBNYXRoLmNlaWwoaW5kZXggLyAyKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgeVBvc09mT3V0cHV0ID0gcHJvY2Vzc1Bvc2l0aW9uLnkgKyAoKHNpbXBsZUNoZW1pY2FsSGVpZ2h0ICsgdGlsaW5nUGFkZGluZ1ZlcnRpY2FsKSAqIChpbmRleCAvIDIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBub2RlUG9zaXRpb24gPSB7XG4gICAgICAgICAgeDogeFBvc09mT3V0cHV0LFxuICAgICAgICAgIHk6IHlQb3NPZk91dHB1dFxuICAgICAgICB9XG4gICAgICAgIGlmIChvcmllbnRhdGlvbiA9PT0gXCJ2ZXJ0aWNhbFwiKSB7XG4gICAgICAgICAgbm9kZVBvc2l0aW9uID0gcm90YXRlOTAobm9kZVBvc2l0aW9uLCBwcm9jZXNzUG9zaXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG5ld05vZGUgPSBlbGVtZW50VXRpbGl0aWVzLmFkZE5vZGUobm9kZVBvc2l0aW9uLngsIG5vZGVQb3NpdGlvbi55LCB7Y2xhc3M6IG5vZGVUeXBlLnRvTG93ZXJDYXNlKCksIGxhbmd1YWdlOiBcIlBEXCJ9KTtcbiAgICAgICAgbmV3Tm9kZS5kYXRhKFwianVzdEFkZGVkXCIsIHRydWUpO1xuICAgICAgICBuZXdOb2RlLmRhdGEoXCJsYWJlbFwiLCBub2RlTmFtZSk7XG5cbiAgICAgICAgbGV0IG5ld0VkZ2UgPSBlbGVtZW50VXRpbGl0aWVzLmFkZEVkZ2UocHJvY2Vzc05vZGUuaWQoKSwgbmV3Tm9kZS5pZCgpLCB7Y2xhc3M6IHByb2Nlc3NSaWdodFNpZGVFZGdlVHlwZSwgbGFuZ3VhZ2U6IFwiUERcIn0sIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCAwKTtcbiAgICAgICAgbmV3RWRnZS5kYXRhKFwianVzdEFkZGVkXCIsIHRydWUpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIGFkZCByZWd1bGF0b3Igbm9kZVxuICAgICAgaWYgKGhhc1JlZ3VsYXRvcikge1xuICAgICAgICBjb25zdCByZWd1bGF0b3JOYW1lID0gcmVndWxhdG9yLm5hbWU7XG4gICAgICAgIGNvbnN0IHJlZ3VsYXRvclR5cGUgPSByZWd1bGF0b3IudHlwZTtcbiAgICAgICAgbGV0IHhQb3NPZlJlZ3VsYXRvciA9IHByb2Nlc3NQb3NpdGlvbi54O1xuICAgICAgICBpZiAocmVndWxhdG9yTXVsdGltZXIuZW5hYmxlZCAmJiBvcmllbnRhdGlvbiA9PT0gXCJob3Jpem9udGFsXCIpIHtcbiAgICAgICAgICB4UG9zT2ZSZWd1bGF0b3IgLT0gbXVsdGltZXJPZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHlQb3NPZlJlZ3VsYXRvciA9IHByb2Nlc3NQb3NpdGlvbi55IC0gKChwcm9jZXNzSGVpZ2h0IC8gMikgKyAocmVndWxhdG9ySGVpZ2h0IC8gMikgKyBlZGdlTGVuZ3RoKTsgXG5cbiAgICAgICAgbGV0IG5vZGVQb3NpdGlvbiA9IHtcbiAgICAgICAgICB4OiB4UG9zT2ZSZWd1bGF0b3IsXG4gICAgICAgICAgeTogeVBvc09mUmVndWxhdG9yXG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9yaWVudGF0aW9uID09PSBcInZlcnRpY2FsXCIpIHtcbiAgICAgICAgICBub2RlUG9zaXRpb24gPSByb3RhdGU5MChub2RlUG9zaXRpb24sIHByb2Nlc3NQb3NpdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcmVndWxhdG9yTm9kZSA9IGVsZW1lbnRVdGlsaXRpZXMuYWRkTm9kZShub2RlUG9zaXRpb24ueCwgbm9kZVBvc2l0aW9uLnksIHtjbGFzczogcmVndWxhdG9yVHlwZSwgbGFuZ3VhZ2U6ICdQRCd9KTtcbiAgICAgICAgcmVndWxhdG9yTm9kZS5kYXRhKCdqdXN0QWRkZWQnLCB0cnVlKTtcbiAgICAgICAgcmVndWxhdG9yTm9kZS5kYXRhKCdsYWJlbCcsIHJlZ3VsYXRvck5hbWUpO1xuXG4gICAgICAgIGlmIChyZWd1bGF0b3JNdWx0aW1lci5lbmFibGVkKSB7XG4gICAgICAgICAgZWxlbWVudFV0aWxpdGllcy5zZXRNdWx0aW1lclN0YXR1cyhyZWd1bGF0b3JOb2RlLCB0cnVlKTtcblxuICAgICAgICAgIGNvbnN0IGNhcmRpbmFsaXR5ID0gcmVndWxhdG9yTXVsdGltZXIuY2FyZGluYWxpdHk7XG4gICAgICAgICAgaWYgKGNhcmRpbmFsaXR5ICE9ICcnKSB7XG4gICAgICAgICAgICBjb25zdCBpbmZvYm94TGFiZWwgPSBcIk46XCIgKyBjYXJkaW5hbGl0eTtcbiAgICAgICAgICAgIGluZm9ib3hPYmplY3QgPSB7XG4gICAgICAgICAgICAgIGNsYXp6OiBcInVuaXQgb2YgaW5mb3JtYXRpb25cIixcbiAgICAgICAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBpbmZvYm94TGFiZWxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgYmJveDoge1xuICAgICAgICAgICAgICAgIHc6IGluZm9ib3hMYWJlbC5sZW5ndGggKiA2LFxuICAgICAgICAgICAgICAgIGg6IDE1XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGVsZW1lbnRVdGlsaXRpZXMuYWRkU3RhdGVPckluZm9Cb3gocmVndWxhdG9yTm9kZSwgaW5mb2JveE9iamVjdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHJlZ3VsYXRvckVkZ2UgPSBlbGVtZW50VXRpbGl0aWVzLmFkZEVkZ2UocmVndWxhdG9yTm9kZS5pZCgpLCBwcm9jZXNzTm9kZS5pZCgpLCB7Y2xhc3M6ICdjYXRhbHlzaXMnLCBsYW5ndWFnZTogJ1BEJ30pO1xuICAgICAgICByZWd1bGF0b3JFZGdlLmRhdGEoJ2p1c3RBZGRlZCcsIHRydWUpO1xuICAgICAgfVxuXG4gICAgICBjeS5lbmRCYXRjaCgpO1xuXG4gICAgICBjb25zdCBlbGVzID0gY3kuZWxlbWVudHMoJ1tqdXN0QWRkZWRdJyk7XG4gICAgICBlbGVzLnJlbW92ZURhdGEoJ2p1c3RBZGRlZCcpO1xuXG4gICAgICBjeS5lbGVtZW50cygpLnVuc2VsZWN0KCk7XG4gICAgICBlbGVzLnNlbGVjdCgpO1xuXG4gICAgICByZXR1cm4gZWxlcztcbiAgICB9O1xuXG4gICAgZWxlbWVudFV0aWxpdGllcy5jcmVhdGVNZXRhYm9saWNDYXRhbHl0aWNBY3Rpdml0eSA9IGZ1bmN0aW9uKGlucHV0Tm9kZUxpc3QsIG91dHB1dE5vZGVMaXN0LCBjYXRhbHlzdE5hbWUsIGNhdGFseXN0VHlwZSwgcHJvY2Vzc1Bvc2l0aW9uLCB0aWxpbmdQYWRkaW5nVmVydGljYWwsIHRpbGluZ1BhZGRpbmdIb3Jpem9udGFsLCBlZGdlTGVuZ3RoKSB7XG4gICAgICB2YXIgZGVmYXVsdE1hY3JvbW9sZWN1bFByb3BlcnRpZXMgPSBlbGVtZW50VXRpbGl0aWVzLmdldERlZmF1bHRQcm9wZXJ0aWVzKCBcIm1hY3JvbW9sZWN1bGVcIiApO1xuICAgICAgdmFyIGRlZmF1bHRTaW1wbGVDaGVtaWNhbFByb3BlcnRpZXMgPSBlbGVtZW50VXRpbGl0aWVzLmdldERlZmF1bHRQcm9wZXJ0aWVzKCBcInNpbXBsZSBjaGVtaWNhbFwiICk7XG4gICAgICB2YXIgZGVmYXVsdENhdGFseXN0VHlwZVByb3BlcnRpZXMgPSBlbGVtZW50VXRpbGl0aWVzLmdldERlZmF1bHRQcm9wZXJ0aWVzKGNhdGFseXN0VHlwZSk7XG4gICAgICB2YXIgZGVmYXVsdFByb2Nlc3NQcm9wZXJ0aWVzID0gZWxlbWVudFV0aWxpdGllcy5nZXREZWZhdWx0UHJvcGVydGllcyhcImNhdGFseXRpY1wiKTtcbiAgICAgIHZhciBwcm9jZXNzV2lkdGggPSBkZWZhdWx0UHJvY2Vzc1Byb3BlcnRpZXMud2lkdGggfHwgNTA7XG4gICAgICB2YXIgcHJvY2Vzc0hlaWdodCA9IGRlZmF1bHRQcm9jZXNzUHJvcGVydGllcy5oZWlnaHQgfHwgNTA7XG4gICAgICB2YXIgc2ltcGxlQ2hlbWljYWxIZWlnaHQgPSBkZWZhdWx0U2ltcGxlQ2hlbWljYWxQcm9wZXJ0aWVzLmhlaWdodCB8fCAzNTtcbiAgICAgIHZhciBtYWNyb21vbGVjdWxlV2lkdGggPSBkZWZhdWx0TWFjcm9tb2xlY3VsUHJvcGVydGllcy53aWR0aCB8fCA1MDtcbiAgICAgIHZhciBtYWNyb21vbGVjdWxlSGVpZ2h0ID0gZGVmYXVsdE1hY3JvbW9sZWN1bFByb3BlcnRpZXMuaGVpZ2h0IHx8IDUwO1xuICAgICAgdmFyIGNhdGFseXN0SGVpZ2h0ID0gZGVmYXVsdENhdGFseXN0VHlwZVByb3BlcnRpZXMuaGVpZ2h0IHx8IDUwO1xuICAgICAgdmFyIHByb2Nlc3NQb3NpdGlvbiA9IHByb2Nlc3NQb3NpdGlvbiB8fCBlbGVtZW50VXRpbGl0aWVzLmNvbnZlcnRUb01vZGVsUG9zaXRpb24oe3g6IGN5LndpZHRoKCkgLyAyLCB5OiBjeS5oZWlnaHQoKSAvIDJ9KTtcbiAgICAgIHZhciB0aWxpbmdQYWRkaW5nVmVydGljYWwgPSB0aWxpbmdQYWRkaW5nVmVydGljYWwgfHwgMTU7XG4gICAgICB2YXIgdGlsaW5nUGFkZGluZ0hvcml6b250YWwgPSB0aWxpbmdQYWRkaW5nSG9yaXpvbnRhbCB8fCAxNTtcbiAgICAgIHZhciBlZGdlTGVuZ3RoID0gZWRnZUxlbmd0aCB8fCA2MDtcblxuICAgICAgY3kuc3RhcnRCYXRjaCgpO1xuICAgICAgaWYgKCFlbGVtZW50VXRpbGl0aWVzLmdldE1hcFR5cGUoKSkge1xuICAgICAgICBlbGVtZW50VXRpbGl0aWVzLnNldE1hcFR5cGUoXCJQRFwiKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHhQb3NPZklucHV0ID0gcHJvY2Vzc1Bvc2l0aW9uLnggLSBlZGdlTGVuZ3RoIC0gcHJvY2Vzc1dpZHRoIC8gMiAtIG1hY3JvbW9sZWN1bGVXaWR0aCAvIDI7XG4gICAgICB2YXIgeFBvc09mT3V0cHV0ID0gcHJvY2Vzc1Bvc2l0aW9uLnggKyBlZGdlTGVuZ3RoICsgcHJvY2Vzc1dpZHRoIC8gMiArIG1hY3JvbW9sZWN1bGVXaWR0aCAvIDI7XG5cbiAgICAgIHZhciBwcm9jZXNzTm9kZSA9IGVsZW1lbnRVdGlsaXRpZXMuYWRkTm9kZShwcm9jZXNzUG9zaXRpb24ueCwgcHJvY2Vzc1Bvc2l0aW9uLnksIHtjbGFzczogXCJwcm9jZXNzXCIsIGxhbmd1YWdlOiBcIlBEXCJ9KTtcbiAgICAgIGVsZW1lbnRVdGlsaXRpZXMuc2V0UG9ydHNPcmRlcmluZyhwcm9jZXNzTm9kZSwgXCJMLXRvLVJcIik7XG4gICAgICBwcm9jZXNzTm9kZS5kYXRhKCdqdXN0QWRkZWQnLCB0cnVlKTtcblxuICAgICAgY29uc3QgbnVtT2ZJbnB1dE5vZGVzID0gaW5wdXROb2RlTGlzdC5sZW5ndGg7XG4gICAgICBjb25zdCBudW1PZk91dHB1dE5vZGVzID0gb3V0cHV0Tm9kZUxpc3QubGVuZ3RoO1xuICAgICAgdmFyIHlQb3NPZklucHV0ID0gcHJvY2Vzc1Bvc2l0aW9uLnkgLSAoKG51bU9mSW5wdXROb2RlcyAtIDEpIC8gMikgKiAobWFjcm9tb2xlY3VsZUhlaWdodCArIHRpbGluZ1BhZGRpbmdWZXJ0aWNhbCk7XG5cbiAgICAgIC8vIGFkZCBpbnB1dCBzaWRlIG5vZGVzXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bU9mSW5wdXROb2RlczsgaSsrKSB7XG4gICAgICAgIGlmKGlucHV0Tm9kZUxpc3RbaV0udHlwZSA9PSBcIlNpbXBsZSBDaGVtaWNhbFwiKXtcbiAgICAgICAgICB2YXIgbmV3Tm9kZSA9IGVsZW1lbnRVdGlsaXRpZXMuYWRkTm9kZSh4UG9zT2ZJbnB1dCwgeVBvc09mSW5wdXQsIHtjbGFzcyA6ICdzaW1wbGUgY2hlbWljYWwnLCBsYW5ndWFnZSA6ICdQRCd9KTtcbiAgICAgICAgICB5UG9zT2ZJbnB1dCArPSBzaW1wbGVDaGVtaWNhbEhlaWdodCArIHRpbGluZ1BhZGRpbmdWZXJ0aWNhbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNle1xuICAgICAgICAgIHZhciBuZXdOb2RlID0gZWxlbWVudFV0aWxpdGllcy5hZGROb2RlKHhQb3NPZklucHV0LCB5UG9zT2ZJbnB1dCwge2NsYXNzIDogJ21hY3JvbW9sZWN1bGUnLCBsYW5ndWFnZSA6ICdQRCd9KTtcbiAgICAgICAgICAvL3VwZGF0ZSB0aGUgeSBwb3NpdGlvblxuICAgICAgICAgIHlQb3NPZklucHV0ICs9IG1hY3JvbW9sZWN1bGVIZWlnaHQgKyB0aWxpbmdQYWRkaW5nVmVydGljYWw7XG4gICAgICAgIH1cbiAgICAgICAgbmV3Tm9kZS5kYXRhKCdqdXN0QWRkZWQnLCB0cnVlKTtcbiAgICAgICAgbmV3Tm9kZS5kYXRhKCdsYWJlbCcsIGlucHV0Tm9kZUxpc3RbaV0ubmFtZSk7XG5cbiAgICAgICAgdmFyIG5ld0VkZ2UgPSBlbGVtZW50VXRpbGl0aWVzLmFkZEVkZ2UobmV3Tm9kZS5pZCgpLCBwcm9jZXNzTm9kZS5pZCgpLCB7Y2xhc3MgOiAnY29uc3VtcHRpb24nLCBsYW5ndWFnZSA6ICdQRCd9KTtcbiAgICAgICAgbmV3RWRnZS5kYXRhKCdqdXN0QWRkZWQnLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdmFyIHlQb3NPZk91dHB1dCA9IHByb2Nlc3NQb3NpdGlvbi55IC0gKChudW1PZk91dHB1dE5vZGVzIC0gMSkgLyAyKSAqIChtYWNyb21vbGVjdWxlSGVpZ2h0ICsgdGlsaW5nUGFkZGluZ1ZlcnRpY2FsKTtcblxuICAgICAgLy8gYWRkIG91dHB1dCBzaWRlIG5vZGVzXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bU9mT3V0cHV0Tm9kZXM7IGkrKykge1xuICAgICAgICBpZihvdXRwdXROb2RlTGlzdFtpXS50eXBlID09IFwiU2ltcGxlIENoZW1pY2FsXCIpe1xuICAgICAgICAgIHZhciBuZXdOb2RlID0gZWxlbWVudFV0aWxpdGllcy5hZGROb2RlKHhQb3NPZk91dHB1dCwgeVBvc09mT3V0cHV0LCB7Y2xhc3MgOiAnc2ltcGxlIGNoZW1pY2FsJywgbGFuZ3VhZ2UgOiAnUEQnfSk7XG4gICAgICAgICAgeVBvc09mT3V0cHV0ICs9IHNpbXBsZUNoZW1pY2FsSGVpZ2h0ICsgdGlsaW5nUGFkZGluZ1ZlcnRpY2FsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2V7XG4gICAgICAgICAgdmFyIG5ld05vZGUgPSBlbGVtZW50VXRpbGl0aWVzLmFkZE5vZGUoeFBvc09mT3V0cHV0LCB5UG9zT2ZPdXRwdXQsIHtjbGFzcyA6ICdtYWNyb21vbGVjdWxlJywgbGFuZ3VhZ2UgOiAnUEQnfSk7XG4gICAgICAgICAgLy91cGRhdGUgdGhlIHkgcG9zaXRpb25cbiAgICAgICAgICB5UG9zT2ZPdXRwdXQgKz0gbWFjcm9tb2xlY3VsZUhlaWdodCArIHRpbGluZ1BhZGRpbmdWZXJ0aWNhbDtcbiAgICAgICAgfVxuICAgICAgICBuZXdOb2RlLmRhdGEoJ2p1c3RBZGRlZCcsIHRydWUpO1xuICAgICAgICBuZXdOb2RlLmRhdGEoJ2xhYmVsJywgb3V0cHV0Tm9kZUxpc3RbaV0ubmFtZSk7XG5cbiAgICAgICAgdmFyIG5ld0VkZ2UgPSBlbGVtZW50VXRpbGl0aWVzLmFkZEVkZ2UocHJvY2Vzc05vZGUuaWQoKSwgbmV3Tm9kZS5pZCgpLCB7Y2xhc3MgOiAncHJvZHVjdGlvbicsIGxhbmd1YWdlIDogJ1BEJ30pO1xuICAgICAgICBuZXdFZGdlLmRhdGEoJ2p1c3RBZGRlZCcsIHRydWUpO1xuICAgICAgfVxuXG4gICAgICAvLyBhZGQgY2F0YWx5c3Qgbm9kZVxuICAgICAgdmFyIHhQb3NPZkNhdGFseXN0ID0gcHJvY2Vzc1Bvc2l0aW9uLng7XG4gICAgICB2YXIgeVBvc09mQ2F0YWx5c3QgPSBwcm9jZXNzUG9zaXRpb24ueSAtIChwcm9jZXNzSGVpZ2h0ICsgY2F0YWx5c3RIZWlnaHQgKyB0aWxpbmdQYWRkaW5nVmVydGljYWwpOyBcbiAgICAgIHZhciBjYXRhbHlzdE5vZGUgPSBlbGVtZW50VXRpbGl0aWVzLmFkZE5vZGUoeFBvc09mQ2F0YWx5c3QsIHlQb3NPZkNhdGFseXN0LCB7Y2xhc3M6IGNhdGFseXN0VHlwZSwgbGFuZ3VhZ2U6ICdQRCd9KTtcbiAgICAgIGNhdGFseXN0Tm9kZS5kYXRhKCdqdXN0QWRkZWQnLCB0cnVlKTtcbiAgICAgIGNhdGFseXN0Tm9kZS5kYXRhKCdsYWJlbCcsIGNhdGFseXN0TmFtZSk7XG5cbiAgICAgIHZhciBjYXRhbHlzdEVkZ2UgPSBlbGVtZW50VXRpbGl0aWVzLmFkZEVkZ2UoY2F0YWx5c3ROb2RlLmlkKCksIHByb2Nlc3NOb2RlLmlkKCksIHtjbGFzczogJ2NhdGFseXNpcycsIGxhbmd1YWdlOiAnUEQnfSk7XG4gICAgICBjYXRhbHlzdEVkZ2UuZGF0YSgnanVzdEFkZGVkJywgdHJ1ZSk7XG5cbiAgICAgIGN5LmVuZEJhdGNoKCk7XG5cbiAgICAgIC8vZmlsdGVyIHRoZSBqdXN0IGFkZGVkIGVsZW1lbXRzIHRvIHJldHVybiB0aGVtIGFuZCByZW1vdmUganVzdCBhZGRlZCBtYXJrXG4gICAgICB2YXIgZWxlcyA9IGN5LmVsZW1lbnRzKCdbanVzdEFkZGVkXScpO1xuICAgICAgZWxlcy5yZW1vdmVEYXRhKCdqdXN0QWRkZWQnKTtcblxuICAgICAgY3kuZWxlbWVudHMoKS51bnNlbGVjdCgpO1xuICAgICAgZWxlcy5zZWxlY3QoKTtcblxuICAgICAgcmV0dXJuIGVsZXM7IC8vIFJldHVybiB0aGUganVzdCBhZGRlZCBlbGVtZW50c1xuICAgIH1cblxuICAgIGVsZW1lbnRVdGlsaXRpZXMuY3JlYXRlQWN0aXZhdGlvblJlYWN0aW9uID0gZnVuY3Rpb24gKHByb3RlaW5OYW1lLCBwcm9jZXNzUG9zaXRpb24sIGVkZ2VMZW5ndGgsIHJldmVyc2UpIHtcbiAgICAgIHZhciBkZWZhdWx0TWFjcm9tb2xlY3VsUHJvcGVydGllcyA9IGVsZW1lbnRVdGlsaXRpZXMuZ2V0RGVmYXVsdFByb3BlcnRpZXMoIFwibWFjcm9tb2xlY3VsZVwiICk7XG4gICAgICB2YXIgZGVmYXVsdFByb2Nlc3NQcm9wZXJ0aWVzID0gZWxlbWVudFV0aWxpdGllcy5nZXREZWZhdWx0UHJvcGVydGllcyhcImFjdGl2YXRpb25cIik7XG4gICAgICB2YXIgcHJvY2Vzc1dpZHRoID0gZGVmYXVsdFByb2Nlc3NQcm9wZXJ0aWVzLndpZHRoIHx8IDUwO1xuICAgICAgdmFyIG1hY3JvbW9sZWN1bGVXaWR0aCA9IGRlZmF1bHRNYWNyb21vbGVjdWxQcm9wZXJ0aWVzLndpZHRoIHx8IDUwO1xuICAgICAgdmFyIHByb2Nlc3NQb3NpdGlvbiA9IHByb2Nlc3NQb3NpdGlvbiB8fCBlbGVtZW50VXRpbGl0aWVzLmNvbnZlcnRUb01vZGVsUG9zaXRpb24oe3g6IGN5LndpZHRoKCkgLyAyLCB5OiBjeS5oZWlnaHQoKSAvIDJ9KTtcbiAgICAgIHZhciBlZGdlTGVuZ3RoID0gZWRnZUxlbmd0aCB8fCA2MDtcblxuICAgICAgY3kuc3RhcnRCYXRjaCgpO1xuICAgICAgaWYgKCFlbGVtZW50VXRpbGl0aWVzLmdldE1hcFR5cGUoKSkge1xuICAgICAgICBlbGVtZW50VXRpbGl0aWVzLnNldE1hcFR5cGUoXCJQRFwiKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHhQb3NPZklucHV0ID0gcHJvY2Vzc1Bvc2l0aW9uLnggLSBlZGdlTGVuZ3RoIC0gcHJvY2Vzc1dpZHRoIC8gMiAtIG1hY3JvbW9sZWN1bGVXaWR0aCAvIDI7XG4gICAgICB2YXIgeFBvc09mT3V0cHV0ID0gcHJvY2Vzc1Bvc2l0aW9uLnggKyBlZGdlTGVuZ3RoICsgcHJvY2Vzc1dpZHRoIC8gMiArIG1hY3JvbW9sZWN1bGVXaWR0aCAvIDI7XG5cbiAgICAgIHZhciBwcm9jZXNzTm9kZSA9IGVsZW1lbnRVdGlsaXRpZXMuYWRkTm9kZShwcm9jZXNzUG9zaXRpb24ueCwgcHJvY2Vzc1Bvc2l0aW9uLnksIHtjbGFzczogXCJwcm9jZXNzXCIsIGxhbmd1YWdlOiBcIlBEXCJ9KTtcbiAgICAgIGVsZW1lbnRVdGlsaXRpZXMuc2V0UG9ydHNPcmRlcmluZyhwcm9jZXNzTm9kZSwgXCJMLXRvLVJcIik7XG4gICAgICBwcm9jZXNzTm9kZS5kYXRhKCdqdXN0QWRkZWQnLCB0cnVlKTtcblxuICAgICAgdmFyIHlQb3NpdGlvbiA9IHByb2Nlc3NQb3NpdGlvbi55O1xuXG4gICAgICB2YXIgaW5wdXROb2RlID0gZWxlbWVudFV0aWxpdGllcy5hZGROb2RlKHhQb3NPZklucHV0LCB5UG9zaXRpb24sIHtjbGFzczogXCJtYWNyb21vbGVjdWxlXCIsIGxhbmd1YWdlOiBcIlBEXCJ9KTtcbiAgICAgIGlucHV0Tm9kZS5kYXRhKFwianVzdEFkZGVkXCIsIHRydWUpO1xuICAgICAgaW5wdXROb2RlLmRhdGEoXCJsYWJlbFwiLCBwcm90ZWluTmFtZSk7XG4gICAgICB2YXIgaW5mb2JveE9iamVjdCA9IHtcbiAgICAgICAgY2xheno6IFwidW5pdCBvZiBpbmZvcm1hdGlvblwiLFxuICAgICAgICBsYWJlbDoge1xuICAgICAgICAgIHRleHQ6IHJldmVyc2UgPyBcImFjdGl2ZVwiIDogXCJpbmFjdGl2ZVwiXG4gICAgICAgIH0sXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgXCJzaGFwZS1uYW1lXCI6IFwiZWxsaXBzZVwiXG4gICAgICAgIH0sXG4gICAgICAgIGJib3g6IHtcbiAgICAgICAgICB3OiAzNixcbiAgICAgICAgICBoOiAxNVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgZWxlbWVudFV0aWxpdGllcy5hZGRTdGF0ZU9ySW5mb0JveChpbnB1dE5vZGUsIGluZm9ib3hPYmplY3QpO1xuXG4gICAgICB2YXIgb3V0cHV0Tm9kZSA9IGVsZW1lbnRVdGlsaXRpZXMuYWRkTm9kZSh4UG9zT2ZPdXRwdXQsIHlQb3NpdGlvbiwge2NsYXNzOiBcIm1hY3JvbW9sZWN1bGVcIiwgbGFuZ3VhZ2U6IFwiUERcIn0pO1xuICAgICAgb3V0cHV0Tm9kZS5kYXRhKFwianVzdEFkZGVkXCIsIHRydWUpO1xuICAgICAgb3V0cHV0Tm9kZS5kYXRhKFwibGFiZWxcIiwgcHJvdGVpbk5hbWUpO1xuICAgICAgaW5mb2JveE9iamVjdCA9IHtcbiAgICAgICAgY2xheno6IFwidW5pdCBvZiBpbmZvcm1hdGlvblwiLFxuICAgICAgICBsYWJlbDoge1xuICAgICAgICAgIHRleHQ6IHJldmVyc2UgPyBcImluYWN0aXZlXCIgOiBcImFjdGl2ZVwiXG4gICAgICAgIH0sXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgXCJzaGFwZS1uYW1lXCI6IFwiZWxsaXBzZVwiXG4gICAgICAgIH0sXG4gICAgICAgIGJib3g6IHtcbiAgICAgICAgICB3OiAzNixcbiAgICAgICAgICBoOiAxNVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbGVtZW50VXRpbGl0aWVzLmFkZFN0YXRlT3JJbmZvQm94KG91dHB1dE5vZGUsIGluZm9ib3hPYmplY3QpO1xuXG4gICAgICB2YXIgaW5wdXRTaWRlRWRnZSA9IGVsZW1lbnRVdGlsaXRpZXMuYWRkRWRnZShpbnB1dE5vZGUuaWQoKSwgcHJvY2Vzc05vZGUuaWQoKSwge2NsYXNzOiBcImNvbnN1bXB0aW9uXCIsIGxhbmd1YWdlOiBcIlBEXCJ9KTtcbiAgICAgIGlucHV0U2lkZUVkZ2UuZGF0YShcImp1c3RBZGRlZFwiLCB0cnVlKTtcbiAgICAgIHZhciBvdXRwdXRTaWRlRWRnZSA9IGVsZW1lbnRVdGlsaXRpZXMuYWRkRWRnZShwcm9jZXNzTm9kZS5pZCgpLCBvdXRwdXROb2RlLmlkKCksIHtjbGFzczogXCJwcm9kdWN0aW9uXCIsIGxhbmd1YWdlOiBcIlBEXCJ9KTtcbiAgICAgIG91dHB1dFNpZGVFZGdlLmRhdGEoXCJqdXN0QWRkZWRcIiwgdHJ1ZSk7XG4gICAgICBjeS5lbmRCYXRjaCgpO1xuXG4gICAgICAvL2ZpbHRlciB0aGUganVzdCBhZGRlZCBlbGVtZW10cyB0byByZXR1cm4gdGhlbSBhbmQgcmVtb3ZlIGp1c3QgYWRkZWQgbWFya1xuICAgICAgdmFyIGVsZXMgPSBjeS5lbGVtZW50cygnW2p1c3RBZGRlZF0nKTtcbiAgICAgIGVsZXMucmVtb3ZlRGF0YSgnanVzdEFkZGVkJyk7XG5cbiAgICAgIGN5LmVsZW1lbnRzKCkudW5zZWxlY3QoKTtcbiAgICAgIGVsZXMuc2VsZWN0KCk7XG5cbiAgICAgIHJldHVybiBlbGVzOyAvLyBSZXR1cm4gdGhlIGp1c3QgYWRkZWQgZWxlbWVudHNcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIENyZWF0ZXMgYSB0ZW1wbGF0ZSByZWFjdGlvbiB3aXRoIGdpdmVuIHBhcmFtZXRlcnMuIFJlcXVpcmVzIGNvc2UtYmlsa2VudCBsYXlvdXQgdG8gdGlsZSB0aGUgZnJlZSBtYWNyb21vbGVjdWxlcyBpbmNsdWRlZFxuICAgICAqIGluIHRoZSBjb21wbGV4LiBQYXJhbWV0ZXJzIGFyZSBleHBsYWluZWQgYmVsb3cuXG4gICAgICogdGVtcGxhdGVUeXBlOiBUaGUgdHlwZSBvZiB0aGUgdGVtcGxhdGUgcmVhY3Rpb24uIEl0IG1heSBiZSAnYXNzb2NpYXRpb24nLCAnZGlzc29jaWF0aW9uJywgJ3JldmVyc2libGUnIG9yICdpcnJldmVyc2libGUnLlxuICAgICAqIG5vZGVMaXN0OiBUaGUgbGlzdCBvZiB0aGUgbmFtZXMgYW5kIHR5cGVzIG9mIG1vbGVjdWxlcyB3aGljaCB3aWxsIGludm9sdmUgaW4gdGhlIHJlYWN0aW9uLlxuICAgICAqIGNvbXBsZXhOYW1lOiBUaGUgbmFtZSBvZiB0aGUgY29tcGxleCBpbiB0aGUgcmVhY3Rpb24uXG4gICAgICogcHJvY2Vzc1Bvc2l0aW9uOiBUaGUgbW9kYWwgcG9zaXRpb24gb2YgdGhlIHByb2Nlc3MgaW4gdGhlIHJlYWN0aW9uLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0aGUgY2VudGVyIG9mIHRoZSBjYW52YXMuXG4gICAgICogdGlsaW5nUGFkZGluZ1ZlcnRpY2FsOiBUaGlzIG9wdGlvbiB3aWxsIGJlIHBhc3NlZCB0byB0aGUgY29zZS1iaWxrZW50IGxheW91dCB3aXRoIHRoZSBzYW1lIG5hbWUuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIDE1LlxuICAgICAqIHRpbGluZ1BhZGRpbmdIb3Jpem9udGFsOiBUaGlzIG9wdGlvbiB3aWxsIGJlIHBhc3NlZCB0byB0aGUgY29zZS1iaWxrZW50IGxheW91dCB3aXRoIHRoZSBzYW1lIG5hbWUuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIDE1LlxuICAgICAqIGVkZ2VMZW5ndGg6IFRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBwcm9jZXNzIGFuZCB0aGUgbWFjcm9tb2xlY3VsZXMgYXQgdGhlIGJvdGggc2lkZXMuXG4gICAgICovXG4gICAgZWxlbWVudFV0aWxpdGllcy5jcmVhdGVUZW1wbGF0ZVJlYWN0aW9uID0gZnVuY3Rpb24gKHRlbXBsYXRlVHlwZSwgbm9kZUxpc3QsIGNvbXBsZXhOYW1lLCBwcm9jZXNzUG9zaXRpb24sIHRpbGluZ1BhZGRpbmdWZXJ0aWNhbCwgdGlsaW5nUGFkZGluZ0hvcml6b250YWwsIGVkZ2VMZW5ndGgsIGxheW91dFBhcmFtKSB7XG5cbiAgICAgIHZhciBkZWZhdWx0TWFjcm9tb2xlY3VsUHJvcGVydGllcyA9IGVsZW1lbnRVdGlsaXRpZXMuZ2V0RGVmYXVsdFByb3BlcnRpZXMoIFwibWFjcm9tb2xlY3VsZVwiICk7XG4gICAgICB2YXIgZGVmYXVsdFNpbXBsZUNoZW1pY2FsUHJvcGVydGllcyA9IGVsZW1lbnRVdGlsaXRpZXMuZ2V0RGVmYXVsdFByb3BlcnRpZXMoIFwic2ltcGxlIGNoZW1pY2FsXCIgKTtcbiAgICAgIHZhciBkZWZhdWx0UHJvY2Vzc1Byb3BlcnRpZXMgPSBlbGVtZW50VXRpbGl0aWVzLmdldERlZmF1bHRQcm9wZXJ0aWVzKCB0ZW1wbGF0ZVR5cGUgKTtcbiAgICAgIHZhciBwcm9jZXNzV2lkdGggPSBkZWZhdWx0UHJvY2Vzc1Byb3BlcnRpZXMud2lkdGggfHwgNTA7XG4gICAgICB2YXIgbWFjcm9tb2xlY3VsZVdpZHRoID0gZGVmYXVsdE1hY3JvbW9sZWN1bFByb3BlcnRpZXMud2lkdGggfHwgNTA7XG4gICAgICB2YXIgbWFjcm9tb2xlY3VsZUhlaWdodCA9IGRlZmF1bHRNYWNyb21vbGVjdWxQcm9wZXJ0aWVzLmhlaWdodCB8fCA1MDtcbiAgICAgIHZhciBzaW1wbGVDaGVtaWNhbFdpZHRoID0gZGVmYXVsdFNpbXBsZUNoZW1pY2FsUHJvcGVydGllcy53aWR0aCB8fCAzNTtcbiAgICAgIHZhciBzaW1wbGVDaGVtaWNhbEhlaWdodCA9IGRlZmF1bHRTaW1wbGVDaGVtaWNhbFByb3BlcnRpZXMuaGVpZ2h0IHx8IDM1O1xuICAgICAgdmFyIHByb2Nlc3NQb3NpdGlvbiA9IHByb2Nlc3NQb3NpdGlvbiB8fCBlbGVtZW50VXRpbGl0aWVzLmNvbnZlcnRUb01vZGVsUG9zaXRpb24oe3g6IGN5LndpZHRoKCkgLyAyLCB5OiBjeS5oZWlnaHQoKSAvIDJ9KTtcbiAgICAgIHZhciBub2RlTGlzdCA9IG5vZGVMaXN0O1xuICAgICAgdmFyIGNvbXBsZXhOYW1lID0gY29tcGxleE5hbWU7XG4gICAgICB2YXIgbnVtT2ZNb2xlY3VsZXMgPSBub2RlTGlzdC5sZW5ndGg7XG4gICAgICB2YXIgdGlsaW5nUGFkZGluZ1ZlcnRpY2FsID0gdGlsaW5nUGFkZGluZ1ZlcnRpY2FsIHx8IDE1O1xuICAgICAgdmFyIHRpbGluZ1BhZGRpbmdIb3Jpem9udGFsID0gdGlsaW5nUGFkZGluZ0hvcml6b250YWwgfHwgMTU7XG4gICAgICB2YXIgZWRnZUxlbmd0aCA9IGVkZ2VMZW5ndGggfHwgNjA7XG5cbiAgICAgIGN5LnN0YXJ0QmF0Y2goKTtcblxuICAgICAgXG4gICAgICBpZiAoIWVsZW1lbnRVdGlsaXRpZXMuZ2V0TWFwVHlwZSgpKSB7XG4gICAgICAgIGVsZW1lbnRVdGlsaXRpZXMuc2V0TWFwVHlwZShcIlBEXCIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgeFBvc2l0aW9uT2ZGcmVlTWFjcm9tb2xlY3VsZXM7XG4gICAgICB2YXIgeFBvc2l0aW9uT2ZJbnB1dE1hY3JvbW9sZWN1bGVzO1xuICAgICAgaWYgKHRlbXBsYXRlVHlwZSA9PT0gJ2Fzc29jaWF0aW9uJykge1xuICAgICAgICB4UG9zaXRpb25PZkZyZWVNYWNyb21vbGVjdWxlcyA9IHByb2Nlc3NQb3NpdGlvbi54IC0gZWRnZUxlbmd0aCAtIHByb2Nlc3NXaWR0aCAvIDIgLSBtYWNyb21vbGVjdWxlV2lkdGggLyAyO1xuICAgICAgIFxuICAgICAgfVxuICAgICAgZWxzZSBpZih0ZW1wbGF0ZVR5cGUgPT09ICdkaXNzb2NpYXRpb24nKXtcbiAgICAgICAgeFBvc2l0aW9uT2ZGcmVlTWFjcm9tb2xlY3VsZXMgPSBwcm9jZXNzUG9zaXRpb24ueCArIGVkZ2VMZW5ndGggKyBwcm9jZXNzV2lkdGggLyAyICsgbWFjcm9tb2xlY3VsZVdpZHRoIC8gMjtcbiAgICAgICBcbiAgICAgIH1cbiAgICAgIGVsc2V7XG4gICAgICAgIFxuICAgICAgICB4UG9zaXRpb25PZkZyZWVNYWNyb21vbGVjdWxlcyA9IHByb2Nlc3NQb3NpdGlvbi54IC0gZWRnZUxlbmd0aCAtIHByb2Nlc3NXaWR0aCAvIDIgLSBtYWNyb21vbGVjdWxlV2lkdGggLyAyO1xuICAgICAgICB4UG9zaXRpb25PZklucHV0TWFjcm9tb2xlY3VsZXMgPSBwcm9jZXNzUG9zaXRpb24ueCArIGVkZ2VMZW5ndGggKyBwcm9jZXNzV2lkdGggLyAyICsgbWFjcm9tb2xlY3VsZVdpZHRoIC8gMjtcbiAgICAgIH1cblxuICAgICAgLy9DcmVhdGUgdGhlIHByb2Nlc3MgaW4gdGVtcGxhdGUgdHlwZVxuICAgICAgdmFyIHByb2Nlc3M7XG4gICAgICBpZiAodGVtcGxhdGVUeXBlID09PSAncmV2ZXJzaWJsZScgfHwgdGVtcGxhdGVUeXBlID09PSAnaXJyZXZlcnNpYmxlJykge1xuICAgICAgICBwcm9jZXNzID0gZWxlbWVudFV0aWxpdGllcy5hZGROb2RlKHByb2Nlc3NQb3NpdGlvbi54LCBwcm9jZXNzUG9zaXRpb24ueSwge2NsYXNzIDogJ3Byb2Nlc3MnLCBsYW5ndWFnZSA6ICdQRCd9KTtcbiAgICAgICAgZWxlbWVudFV0aWxpdGllcy5zZXRQb3J0c09yZGVyaW5nKHByb2Nlc3MsICdMLXRvLVInKTtcbiAgICAgIH1cbiAgICAgIGVsc2V7XG4gICAgICAgIHByb2Nlc3MgPSBlbGVtZW50VXRpbGl0aWVzLmFkZE5vZGUocHJvY2Vzc1Bvc2l0aW9uLngsIHByb2Nlc3NQb3NpdGlvbi55LCB7Y2xhc3MgOiB0ZW1wbGF0ZVR5cGUsIGxhbmd1YWdlIDogJ1BEJ30pO1xuICAgICAgICBlbGVtZW50VXRpbGl0aWVzLnNldFBvcnRzT3JkZXJpbmcocHJvY2VzcywgJ0wtdG8tUicpO1xuICAgICAgfVxuICAgICAgcHJvY2Vzcy5kYXRhKCdqdXN0QWRkZWQnLCB0cnVlKTtcblxuICAgICAgLy9EZWZpbmUgdGhlIHN0YXJ0aW5nIHkgcG9zaXRpb25cbiAgICAgIHZhciB5UG9zaXRpb24gPSBwcm9jZXNzUG9zaXRpb24ueSAtICgobnVtT2ZNb2xlY3VsZXMgLSAxKSAvIDIpICogKG1hY3JvbW9sZWN1bGVIZWlnaHQgKyB0aWxpbmdQYWRkaW5nVmVydGljYWwpO1xuXG4gICAgICAvL0NyZWF0ZSB0aGUgZnJlZSBtb2xlY3VsZXNcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtT2ZNb2xlY3VsZXM7IGkrKykge1xuICAgICAgICAvLyBub2RlIGFkZGl0aW9uIG9wZXJhdGlvbiBpcyBkZXRlcm1pbmVkIGJ5IG1vbGVjdWxlIHR5cGVcbiAgICAgICAgaWYobm9kZUxpc3RbaV0udHlwZSA9PSBcIlNpbXBsZSBDaGVtaWNhbFwiKXtcbiAgICAgICAgICB2YXIgbmV3Tm9kZSA9IGVsZW1lbnRVdGlsaXRpZXMuYWRkTm9kZSh4UG9zaXRpb25PZkZyZWVNYWNyb21vbGVjdWxlcywgeVBvc2l0aW9uLCB7Y2xhc3MgOiAnc2ltcGxlIGNoZW1pY2FsJywgbGFuZ3VhZ2UgOiAnUEQnfSk7XG4gICAgICAgICAgLy91cGRhdGUgdGhlIHkgcG9zaXRpb25cbiAgICAgICAgICB5UG9zaXRpb24gKz0gc2ltcGxlQ2hlbWljYWxIZWlnaHQgKyB0aWxpbmdQYWRkaW5nVmVydGljYWw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZXtcbiAgICAgICAgICB2YXIgbmV3Tm9kZSA9IGVsZW1lbnRVdGlsaXRpZXMuYWRkTm9kZSh4UG9zaXRpb25PZkZyZWVNYWNyb21vbGVjdWxlcywgeVBvc2l0aW9uLCB7Y2xhc3MgOiAnbWFjcm9tb2xlY3VsZScsIGxhbmd1YWdlIDogJ1BEJ30pO1xuICAgICAgICAgIC8vdXBkYXRlIHRoZSB5IHBvc2l0aW9uXG4gICAgICAgICAgeVBvc2l0aW9uICs9IG1hY3JvbW9sZWN1bGVIZWlnaHQgKyB0aWxpbmdQYWRkaW5nVmVydGljYWw7XG4gICAgICAgIH1cbiAgICAgICAgbmV3Tm9kZS5kYXRhKCdqdXN0QWRkZWQnLCB0cnVlKTtcbiAgICAgICAgbmV3Tm9kZS5kYXRhKCdsYWJlbCcsIG5vZGVMaXN0W2ldLm5hbWUpO1xuXG4gICAgICAgIC8vY3JlYXRlIHRoZSBlZGdlIGNvbm5lY3RlZCB0byB0aGUgbmV3IG1vbGVjdWxlXG4gICAgICAgIHZhciBuZXdFZGdlO1xuICAgICAgICBpZiAodGVtcGxhdGVUeXBlID09PSAnYXNzb2NpYXRpb24nKSB7XG4gICAgICAgICAgbmV3RWRnZSA9IGVsZW1lbnRVdGlsaXRpZXMuYWRkRWRnZShuZXdOb2RlLmlkKCksIHByb2Nlc3MuaWQoKSwge2NsYXNzIDogJ2NvbnN1bXB0aW9uJywgbGFuZ3VhZ2UgOiAnUEQnfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZih0ZW1wbGF0ZVR5cGUgPT09ICdkaXNzb2NpYXRpb24nKXtcbiAgICAgICAgICBuZXdFZGdlID0gZWxlbWVudFV0aWxpdGllcy5hZGRFZGdlKHByb2Nlc3MuaWQoKSwgbmV3Tm9kZS5pZCgpLCB7Y2xhc3MgOiAncHJvZHVjdGlvbicsIGxhbmd1YWdlIDogJ1BEJ30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2V7XG4gICAgICAgICAgLy9Hcm91cCByaWdodCBvciB0b3AgZWxlbWVudHMgaW4gZ3JvdXAgaWQgMVxuICAgICAgICAgIGlmICh0ZW1wbGF0ZVR5cGUgPT09IFwiaXJyZXZlcnNpYmxlXCIpIHtcbiAgICAgICAgICAgIG5ld0VkZ2UgPSBlbGVtZW50VXRpbGl0aWVzLmFkZEVkZ2UobmV3Tm9kZS5pZCgpLCBwcm9jZXNzLmlkKCksIHtjbGFzczogXCJjb25zdW1wdGlvblwiLCBsYW5ndWFnZTogJ1BEJ30pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5ld0VkZ2UgPSBlbGVtZW50VXRpbGl0aWVzLmFkZEVkZ2UocHJvY2Vzcy5pZCgpLCBuZXdOb2RlLmlkKCksIHtjbGFzcyA6IFwicHJvZHVjdGlvblwiLCBsYW5ndWFnZSA6ICdQRCd9LCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbmV3RWRnZS5kYXRhKCdqdXN0QWRkZWQnLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgaWYodGVtcGxhdGVUeXBlID09PSAnYXNzb2NpYXRpb24nIHx8IHRlbXBsYXRlVHlwZSA9PSAnZGlzc29jaWF0aW9uJyl7XG4gICAgICAgIC8vQ3JlYXRlIHRoZSBjb21wbGV4IGluY2x1ZGluZyBtYWNyb21vbGVjdWxlcyBpbnNpZGUgb2YgaXRcbiAgICAgICAgLy9UZW1wcm9yYXJpbHkgYWRkIGl0IHRvIHRoZSBwcm9jZXNzIHBvc2l0aW9uIHdlIHdpbGwgbW92ZSBpdCBhY2NvcmRpbmcgdG8gdGhlIGxhc3Qgc2l6ZSBvZiBpdFxuICAgICAgICB2YXIgY29tcGxleCA9IGVsZW1lbnRVdGlsaXRpZXMuYWRkTm9kZShwcm9jZXNzUG9zaXRpb24ueCwgcHJvY2Vzc1Bvc2l0aW9uLnksIHtjbGFzcyA6ICdjb21wbGV4JywgbGFuZ3VhZ2UgOiAnUEQnfSk7XG4gICAgICAgIGNvbXBsZXguZGF0YSgnanVzdEFkZGVkJywgdHJ1ZSk7XG4gICAgICAgIGNvbXBsZXguZGF0YSgnanVzdEFkZGVkTGF5b3V0Tm9kZScsIHRydWUpO1xuXG4gICAgICAgIC8vSWYgYSBuYW1lIGlzIHNwZWNpZmllZCBmb3IgdGhlIGNvbXBsZXggc2V0IGl0cyBsYWJlbCBhY2NvcmRpbmdseVxuICAgICAgICBpZiAoY29tcGxleE5hbWUpIHtcbiAgICAgICAgICBjb21wbGV4LmRhdGEoJ2xhYmVsJywgY29tcGxleE5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9jcmVhdGUgdGhlIGVkZ2UgY29ubm5lY3RlZCB0byB0aGUgY29tcGxleFxuICAgICAgICB2YXIgZWRnZU9mQ29tcGxleDtcblxuICAgICAgICBpZiAodGVtcGxhdGVUeXBlID09PSAnYXNzb2NpYXRpb24nKSB7XG4gICAgICAgICAgZWRnZU9mQ29tcGxleCA9IGVsZW1lbnRVdGlsaXRpZXMuYWRkRWRnZShwcm9jZXNzLmlkKCksIGNvbXBsZXguaWQoKSwge2NsYXNzIDogJ3Byb2R1Y3Rpb24nLCBsYW5ndWFnZSA6ICdQRCd9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBlZGdlT2ZDb21wbGV4ID0gZWxlbWVudFV0aWxpdGllcy5hZGRFZGdlKGNvbXBsZXguaWQoKSwgcHJvY2Vzcy5pZCgpLCB7Y2xhc3MgOiAnY29uc3VtcHRpb24nLCBsYW5ndWFnZSA6ICdQRCd9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVkZ2VPZkNvbXBsZXguZGF0YSgnanVzdEFkZGVkJywgdHJ1ZSk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1PZk1vbGVjdWxlczsgaSsrKSB7XG5cbiAgICAgICAgICAvLyBBZGQgYSBtb2xlY3VsZShkZXBlbmRlbnQgb24gaXQncyB0eXBlKSBub3QgaGF2aW5nIGEgcHJldmlvdXNseSBkZWZpbmVkIGlkIGFuZCBoYXZpbmcgdGhlIGNvbXBsZXggY3JlYXRlZCBpbiB0aGlzIHJlYWN0aW9uIGFzIHBhcmVudFxuICAgICAgICAgIGlmKG5vZGVMaXN0W2ldLnR5cGUgPT0gJ1NpbXBsZSBDaGVtaWNhbCcpe1xuICAgICAgICAgICAgdmFyIG5ld05vZGUgPSBlbGVtZW50VXRpbGl0aWVzLmFkZE5vZGUoY29tcGxleC5wb3NpdGlvbigneCcpLCBjb21wbGV4LnBvc2l0aW9uKCd5JyksIHtjbGFzcyA6ICdzaW1wbGUgY2hlbWljYWwnLCBsYW5ndWFnZSA6ICdQRCd9LCB1bmRlZmluZWQsIGNvbXBsZXguaWQoKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICB2YXIgbmV3Tm9kZSA9IGVsZW1lbnRVdGlsaXRpZXMuYWRkTm9kZShjb21wbGV4LnBvc2l0aW9uKCd4JyksIGNvbXBsZXgucG9zaXRpb24oJ3knKSwge2NsYXNzIDogJ21hY3JvbW9sZWN1bGUnLCBsYW5ndWFnZSA6ICdQRCd9LCB1bmRlZmluZWQsIGNvbXBsZXguaWQoKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV3Tm9kZS5kYXRhKCdqdXN0QWRkZWQnLCB0cnVlKTtcbiAgICAgICAgICBuZXdOb2RlLmRhdGEoJ2xhYmVsJywgbm9kZUxpc3RbaV0ubmFtZSk7XG4gICAgICAgICAgbmV3Tm9kZS5kYXRhKCdqdXN0QWRkZWRMYXlvdXROb2RlJywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2V7XG5cbiAgICAgICAgLy9DcmVhdGUgdGhlIGlucHV0IG1hY3JvbW9sZWN1bGVzXG4gICAgICAgIHZhciBudW1PZklucHV0TWFjcm9tb2xlY3VsZXMgPSBjb21wbGV4TmFtZS5sZW5ndGg7XG4gICAgICAgIHlQb3NpdGlvbiA9IHByb2Nlc3NQb3NpdGlvbi55IC0gKChudW1PZklucHV0TWFjcm9tb2xlY3VsZXMgLSAxKSAvIDIpICogKG1hY3JvbW9sZWN1bGVIZWlnaHQgKyB0aWxpbmdQYWRkaW5nVmVydGljYWwpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtT2ZJbnB1dE1hY3JvbW9sZWN1bGVzOyBpKyspIHtcblxuICAgICAgICAgIGlmKGNvbXBsZXhOYW1lW2ldLnR5cGUgPT0gJ1NpbXBsZSBDaGVtaWNhbCcpe1xuICAgICAgICAgICAgdmFyIG5ld05vZGUgPSBlbGVtZW50VXRpbGl0aWVzLmFkZE5vZGUoeFBvc2l0aW9uT2ZJbnB1dE1hY3JvbW9sZWN1bGVzLCB5UG9zaXRpb24sIHtjbGFzcyA6ICdzaW1wbGUgY2hlbWljYWwnLCBsYW5ndWFnZSA6ICdQRCd9KTtcbiAgICAgICAgICAgIHlQb3NpdGlvbiArPSBzaW1wbGVDaGVtaWNhbEhlaWdodCArIHRpbGluZ1BhZGRpbmdWZXJ0aWNhbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgIHZhciBuZXdOb2RlID0gZWxlbWVudFV0aWxpdGllcy5hZGROb2RlKHhQb3NpdGlvbk9mSW5wdXRNYWNyb21vbGVjdWxlcywgeVBvc2l0aW9uLCB7Y2xhc3MgOiAnbWFjcm9tb2xlY3VsZScsIGxhbmd1YWdlIDogJ1BEJ30pO1xuICAgICAgICAgICAgeVBvc2l0aW9uICs9IG1hY3JvbW9sZWN1bGVIZWlnaHQgKyB0aWxpbmdQYWRkaW5nVmVydGljYWw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV3Tm9kZS5kYXRhKCdqdXN0QWRkZWQnLCB0cnVlKTtcbiAgICAgICAgICBuZXdOb2RlLmRhdGEoJ2xhYmVsJywgY29tcGxleE5hbWVbaV0ubmFtZSk7XG5cbiAgICAgICAgICAvL2NyZWF0ZSB0aGUgZWRnZSBjb25uZWN0ZWQgdG8gdGhlIG5ldyBtYWNyb21vbGVjdWxlXG4gICAgICAgICAgdmFyIG5ld0VkZ2U7XG5cbiAgICAgICAgICAvL0dyb3VwIHRoZSBsZWZ0IG9yIGJvdHRvbSBlbGVtZW50cyBpbiBncm91cCBpZCAwIGlmIHJldmVyc2libGVcbiAgICAgICAgICBpZiAodGVtcGxhdGVUeXBlID09PSBcImlycmV2ZXJzaWJsZVwiKSB7XG4gICAgICAgICAgICBuZXdFZGdlID0gZWxlbWVudFV0aWxpdGllcy5hZGRFZGdlKHByb2Nlc3MuaWQoKSwgbmV3Tm9kZS5pZCgpLCB7Y2xhc3M6IFwicHJvZHVjdGlvblwiLCBsYW5ndWFnZTogJ1BEJ30pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5ld0VkZ2UgPSBlbGVtZW50VXRpbGl0aWVzLmFkZEVkZ2UocHJvY2Vzcy5pZCgpLCBuZXdOb2RlLmlkKCksIHtjbGFzcyA6IFwicHJvZHVjdGlvblwiLCBsYW5ndWFnZSA6ICdQRCd9LCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgMCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5ld0VkZ2UuZGF0YSgnanVzdEFkZGVkJywgdHJ1ZSk7XG5cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjeS5lbmRCYXRjaCgpO1xuXG4gICAgICB2YXIgbGF5b3V0Tm9kZXMgPSBjeS5ub2RlcygnW2p1c3RBZGRlZExheW91dE5vZGVdJyk7XG4gICAgICBsYXlvdXROb2Rlcy5yZW1vdmVEYXRhKCdqdXN0QWRkZWRMYXlvdXROb2RlJyk7XG4gICAgICB2YXIgbGF5b3V0ID0gbGF5b3V0Tm9kZXMubGF5b3V0KHtcbiAgICAgICAgbmFtZTogbGF5b3V0UGFyYW0ubmFtZSxcbiAgICAgICAgcmFuZG9taXplOiBmYWxzZSxcbiAgICAgICAgZml0OiBmYWxzZSxcbiAgICAgICAgYW5pbWF0ZTogZmFsc2UsXG4gICAgICAgIHRpbGluZ1BhZGRpbmdWZXJ0aWNhbDogdGlsaW5nUGFkZGluZ1ZlcnRpY2FsLFxuICAgICAgICB0aWxpbmdQYWRkaW5nSG9yaXpvbnRhbDogdGlsaW5nUGFkZGluZ0hvcml6b250YWwsXG4gICAgICAgIHN0b3A6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvL0lmIGl0IGlzIGEgcmV2ZXJzaWJsZSByZWFjdGlvbiBubyBuZWVkIHRvIHJlLXBvc2l0aW9uIGNvbXBsZXhlc1xuICAgICAgICAgIGlmKHRlbXBsYXRlVHlwZSA9PT0gJ3JldmVyc2libGUnKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIC8vcmUtcG9zaXRpb24gdGhlIG5vZGVzIGluc2lkZSB0aGUgY29tcGxleFxuICAgICAgICAgIHZhciBzdXBwb3NlZFhQb3NpdGlvbjtcbiAgICAgICAgICB2YXIgc3VwcG9zZWRZUG9zaXRpb24gPSBwcm9jZXNzUG9zaXRpb24ueTtcblxuICAgICAgICAgIGlmICh0ZW1wbGF0ZVR5cGUgPT09ICdhc3NvY2lhdGlvbicpIHtcbiAgICAgICAgICAgIHN1cHBvc2VkWFBvc2l0aW9uID0gcHJvY2Vzc1Bvc2l0aW9uLnggKyBlZGdlTGVuZ3RoICsgcHJvY2Vzc1dpZHRoIC8gMiArIGNvbXBsZXgub3V0ZXJXaWR0aCgpIC8gMjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdXBwb3NlZFhQb3NpdGlvbiA9IHByb2Nlc3NQb3NpdGlvbi54IC0gZWRnZUxlbmd0aCAtIHByb2Nlc3NXaWR0aCAvIDIgLSBjb21wbGV4Lm91dGVyV2lkdGgoKSAvIDI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHBvc2l0aW9uRGlmZlggPSAoc3VwcG9zZWRYUG9zaXRpb24gLSBjb21wbGV4LnBvc2l0aW9uKCd4JykpIC8gMjtcbiAgICAgICAgICB2YXIgcG9zaXRpb25EaWZmWSA9IChzdXBwb3NlZFlQb3NpdGlvbiAtIGNvbXBsZXgucG9zaXRpb24oJ3knKSkgLyAyO1xuICAgICAgICAgIGVsZW1lbnRVdGlsaXRpZXMubW92ZU5vZGVzKHt4OiBwb3NpdGlvbkRpZmZYLCB5OiBwb3NpdGlvbkRpZmZZfSwgY29tcGxleCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBEbyB0aGlzIGNoZWNrIGZvciBjeXRvc2NhcGUuanMgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICAgICAgaWYgKGxheW91dCAmJiBsYXlvdXQucnVuICYmIHRlbXBsYXRlVHlwZSAhPT0gJ3JldmVyc2libGUnICYmIHRlbXBsYXRlVHlwZSAhPT0gJ2lycmV2ZXJzaWJsZScpIHtcbiAgICAgICAgbGF5b3V0LnJ1bigpO1xuICAgICAgfVxuXG4gICAgICAvL2ZpbHRlciB0aGUganVzdCBhZGRlZCBlbGVtZW10cyB0byByZXR1cm4gdGhlbSBhbmQgcmVtb3ZlIGp1c3QgYWRkZWQgbWFya1xuICAgICAgdmFyIGVsZXMgPSBjeS5lbGVtZW50cygnW2p1c3RBZGRlZF0nKTtcbiAgICAgIGVsZXMucmVtb3ZlRGF0YSgnanVzdEFkZGVkJyk7XG5cbiAgICAgIGN5LmVsZW1lbnRzKCkudW5zZWxlY3QoKTtcbiAgICAgIGVsZXMuc2VsZWN0KCk7XG5cbiAgICAgIHJldHVybiBlbGVzOyAvLyBSZXR1cm4gdGhlIGp1c3QgYWRkZWQgZWxlbWVudHNcbiAgICB9O1xuXG4gICAgLypcbiAgICAgKiBNb3ZlIHRoZSBub2RlcyB0byBhIG5ldyBwYXJlbnQgYW5kIGNoYW5nZSB0aGVpciBwb3NpdGlvbiBpZiBwb3NzRGlmZiBwYXJhbXMgYXJlIHNldC5cbiAgICAgKi9cbiAgICBlbGVtZW50VXRpbGl0aWVzLmNoYW5nZVBhcmVudCA9IGZ1bmN0aW9uKG5vZGVzLCBuZXdQYXJlbnQsIHBvc0RpZmZYLCBwb3NEaWZmWSkge1xuICAgICAgdmFyIG5ld1BhcmVudElkID0gbmV3UGFyZW50ID09IHVuZGVmaW5lZCB8fCB0eXBlb2YgbmV3UGFyZW50ID09PSAnc3RyaW5nJyA/IG5ld1BhcmVudCA6IG5ld1BhcmVudC5pZCgpO1xuICAgICAgdmFyIG1vdmVkRWxlcyA9IG5vZGVzLm1vdmUoe1wicGFyZW50XCI6IG5ld1BhcmVudElkfSk7XG4gICAgICBpZih0eXBlb2YgcG9zRGlmZlggIT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIHBvc0RpZmZZICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGVsZW1lbnRVdGlsaXRpZXMubW92ZU5vZGVzKHt4OiBwb3NEaWZmWCwgeTogcG9zRGlmZll9LCBub2Rlcyk7XG4gICAgICB9XG4gICAgICBlbGVtZW50VXRpbGl0aWVzLm1haW50YWluUG9pbnRlcihtb3ZlZEVsZXMpO1xuICAgICAgcmV0dXJuIG1vdmVkRWxlcztcbiAgICB9O1xuXG4gICAgZWxlbWVudFV0aWxpdGllcy51cGRhdGVJbmZvYm94U3R5bGUgPSBmdW5jdGlvbiggbm9kZSwgaW5kZXgsIG5ld1Byb3BzICkge1xuICAgICAgdmFyIGluZm9ib3hPYmogPSBub2RlLmRhdGEoJ3N0YXRlc2FuZGluZm9zJylbaW5kZXhdO1xuICAgICAgJC5leHRlbmQoIGluZm9ib3hPYmouc3R5bGUsIG5ld1Byb3BzICk7XG4gICAgICBjeS5zdHlsZSgpLnVwZGF0ZSgpO1xuICAgIH07XG5cbiAgICBlbGVtZW50VXRpbGl0aWVzLnVwZGF0ZUluZm9ib3hPYmogPSBmdW5jdGlvbiggbm9kZSwgaW5kZXgsIG5ld1Byb3BzICkge1xuICAgICAgdmFyIGluZm9ib3hPYmogPSBub2RlLmRhdGEoJ3N0YXRlc2FuZGluZm9zJylbaW5kZXhdO1xuICAgICAgJC5leHRlbmQoIGluZm9ib3hPYmosIG5ld1Byb3BzICk7XG4gICAgfTtcblxuICAgIC8vIFJlc2l6ZSBnaXZlbiBub2RlcyBpZiB1c2VBc3BlY3RSYXRpbyBpcyB0cnV0aHkgb25lIG9mIHdpZHRoIG9yIGhlaWdodCBzaG91bGQgbm90IGJlIHNldC5cbiAgICBlbGVtZW50VXRpbGl0aWVzLnJlc2l6ZU5vZGVzID0gZnVuY3Rpb24gKG5vZGVzLCB3aWR0aCwgaGVpZ2h0LCB1c2VBc3BlY3RSYXRpbywgcHJlc2VydmVSZWxhdGl2ZVBvcykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuXG4gICAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIHZhciByYXRpbyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIGVsZU11c3RCZVNxdWFyZSA9IGVsZW1lbnRVdGlsaXRpZXMubXVzdEJlU3F1YXJlKG5vZGUuZGF0YSgnY2xhc3MnKSk7XG5cbiAgICAgICAgaWYgKHByZXNlcnZlUmVsYXRpdmVQb3MgPT09IHRydWUpIHtcbiAgICAgICAgICB2YXIgb2xkV2lkdGggPSBub2RlLmRhdGEoXCJiYm94XCIpLnc7XG4gICAgICAgICAgdmFyIG9sZEhlaWdodCA9IG5vZGUuZGF0YShcImJib3hcIikuaDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5vdGUgdGhhdCBib3RoIHdpZHRoIGFuZCBoZWlnaHQgc2hvdWxkIG5vdCBiZSBzZXQgaWYgdXNlQXNwZWN0UmF0aW8gaXMgdHJ1dGh5XG4gICAgICAgIGlmKCFub2RlLmlzUGFyZW50KCkpe1xuICAgICAgICAgIGlmICh3aWR0aCkge1xuICAgICAgICAgICAgaWYgKHVzZUFzcGVjdFJhdGlvIHx8IGVsZU11c3RCZVNxdWFyZSkge1xuICAgICAgICAgICAgICByYXRpbyA9IHdpZHRoIC8gbm9kZS53aWR0aCgpO1xuICAgICAgICAgICAgfVxuICBcbiAgICAgICAgICAgIG5vZGUuZGF0YShcImJib3hcIikudyA9IHdpZHRoO1xuICAgICAgICAgIH1cbiAgXG4gICAgICAgICAgaWYgKGhlaWdodCkge1xuICAgICAgICAgICAgaWYgKHVzZUFzcGVjdFJhdGlvIHx8IGVsZU11c3RCZVNxdWFyZSkge1xuICAgICAgICAgICAgICByYXRpbyA9IGhlaWdodCAvIG5vZGUuaGVpZ2h0KCk7XG4gICAgICAgICAgICB9XG4gIFxuICAgICAgICAgICAgbm9kZS5kYXRhKFwiYmJveFwiKS5oID0gaGVpZ2h0O1xuICAgICAgICAgIH1cbiAgXG4gICAgICAgICAgaWYgKHJhdGlvICYmICFoZWlnaHQpIHtcbiAgICAgICAgICAgIG5vZGUuZGF0YShcImJib3hcIikuaCA9IG5vZGUuaGVpZ2h0KCkgKiByYXRpbztcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAocmF0aW8gJiYgIXdpZHRoKSB7XG4gICAgICAgICAgICBub2RlLmRhdGEoXCJiYm94XCIpLncgPSBub2RlLndpZHRoKCkgKiByYXRpbztcbiAgICAgICAgICB9XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgIG5vZGUuZGF0YShcIm1pbkhlaWdodFwiICwgXCJcIisgaGVpZ2h0KTtcbiAgICAgICAgICBub2RlLmRhdGEoXCJtaW5XaWR0aFwiICwgXCJcIisgd2lkdGgpO1xuICAgICAgICAgIG5vZGUuZGF0YShcIm1pbldpZHRoQmlhc0xlZnRcIiwgXCI1MCVcIik7XG4gICAgICAgICAgbm9kZS5kYXRhKFwibWluV2lkdGhCaWFzUmlnaHRcIiwgXCI1MCVcIik7XG4gICAgICAgICAgbm9kZS5kYXRhKFwibWluSGVpZ2h0Qmlhc1RvcFwiLCBcIjUwJVwiICk7XG4gICAgICAgICAgbm9kZS5kYXRhKFwibWluSGVpZ2h0Qmlhc0JvdHRvbVwiLCBcIjUwJVwiKTtcbiAgICAgICAgfVxuICAgICAgICBcblxuICAgICAvKiAgICBpZiAocHJlc2VydmVSZWxhdGl2ZVBvcyA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHZhciBzdGF0ZXNhbmRpbmZvcyA9IG5vZGUuZGF0YSgnc3RhdGVzYW5kaW5mb3MnKTtcbiAgICAgICAgICB2YXIgdG9wQm90dG9tID0gc3RhdGVzYW5kaW5mb3MuZmlsdGVyKGJveCA9PiAoYm94LmFuY2hvclNpZGUgPT09IFwidG9wXCIgfHwgYm94LmFuY2hvclNpZGUgPT09IFwiYm90dG9tXCIpKTtcbiAgICAgICAgICB2YXIgcmlnaHRMZWZ0ID0gc3RhdGVzYW5kaW5mb3MuZmlsdGVyKGJveCA9PiAoYm94LmFuY2hvclNpZGUgPT09IFwicmlnaHRcIiB8fCBib3guYW5jaG9yU2lkZSA9PT0gXCJsZWZ0XCIpKTtcblxuICAgICAgICAgIHRvcEJvdHRvbS5mb3JFYWNoKGZ1bmN0aW9uKGJveCl7XG4gICAgICAgICAgICBpZiAoYm94LmJib3gueCA8IDApIHtcbiAgICAgICAgICAgICAgYm94LmJib3gueCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChib3guYmJveC54ID4gb2xkV2lkdGgpIHtcbiAgICAgICAgICAgICAgYm94LmJib3gueCA9IG9sZFdpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYm94LmJib3gueCA9IG5vZGUuZGF0YShcImJib3hcIikudyAqIGJveC5iYm94LnggLyBvbGRXaWR0aDtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHJpZ2h0TGVmdC5mb3JFYWNoKGZ1bmN0aW9uKGJveCl7XG4gICAgICAgICAgICBpZiAoYm94LmJib3gueSA8IDApIHtcbiAgICAgICAgICAgICAgYm94LmJib3gueSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChib3guYmJveC55ID4gb2xkSGVpZ2h0KSB7XG4gICAgICAgICAgICAgIGJveC5iYm94LnkgPSBvbGRIZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBib3guYmJveC55ID0gbm9kZS5kYXRhKFwiYmJveFwiKS5oICogYm94LmJib3gueSAvIG9sZEhlaWdodDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSAqL1xuICAgICAgfVxuICAgIH07XG5cbiAgICBlbGVtZW50VXRpbGl0aWVzLmNhbGN1bGF0ZU1pbldpZHRoID0gZnVuY3Rpb24obm9kZSkge1xuXG4gICAgICAgIHZhciBkZWZhdWx0V2lkdGggPSB0aGlzLmdldERlZmF1bHRQcm9wZXJ0aWVzKG5vZGUuZGF0YSgnY2xhc3MnKSkud2lkdGg7XG5cbiAgICAgICAgLy8gTGFiZWwgd2lkdGggY2FsY3VsYXRpb25cbiAgICAgICAgdmFyIHN0eWxlID0gbm9kZS5zdHlsZSgpO1xuXG4gICAgICAgIHZhciBmb250RmFtaWxpeSA9IHN0eWxlWydmb250LWZhbWlseSddO1xuICAgICAgICB2YXIgZm9udFNpemUgPSBzdHlsZVsnZm9udC1zaXplJ107XG4gICAgICAgIHZhciBsYWJlbFRleHQgPSBzdHlsZVsnbGFiZWwnXTtcblxuICAgICAgICBpZiAobGFiZWxUZXh0ID09PSBcIlwiICYmIG5vZGUuZGF0YSgnbGFiZWwnKSAmJiBub2RlLmRhdGEoJ2xhYmVsJykgIT09IFwiXCIpIHtcbiAgICAgICAgICBsYWJlbFRleHQgPSBub2RlLmRhdGEoJ2xhYmVsJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGFiZWxXaWR0aCA9IGVsZW1lbnRVdGlsaXRpZXMuZ2V0V2lkdGhCeUNvbnRlbnQoIGxhYmVsVGV4dCwgZm9udEZhbWlsaXksIGZvbnRTaXplICk7XG5cbiAgICAgICAgdmFyIHN0YXRlc2FuZGluZm9zID0gbm9kZS5kYXRhKCdzdGF0ZXNhbmRpbmZvcycpO1xuICAgICAgICAvL1RvcCBhbmQgYm90dG9tIGluZm9Cb3hlc1xuICAgICAgICAvL3ZhciB0b3BJbmZvQm94ZXMgPSBzdGF0ZXNhbmRpbmZvcy5maWx0ZXIoYm94ID0+IChib3guYW5jaG9yU2lkZSA9PT0gXCJ0b3BcIiB8fCAoKGJveC5hbmNob3JTaWRlID09PSBcInJpZ2h0XCIgfHwgYm94LmFuY2hvclNpZGUgPT09IFwibGVmdFwiKSAmJiAoYm94LmJib3gueSA8PSAxMikpKSk7XG4gICAgICAgIC8vdmFyIGJvdHRvbUluZm9Cb3hlcyA9IHN0YXRlc2FuZGluZm9zLmZpbHRlcihib3ggPT4gKGJveC5hbmNob3JTaWRlID09PSBcImJvdHRvbVwiIHx8ICgoYm94LmFuY2hvclNpZGUgPT09IFwicmlnaHRcIiB8fCBib3guYW5jaG9yU2lkZSA9PT0gXCJsZWZ0XCIpICYmIChib3guYmJveC55ID49IG5vZGUuZGF0YSgnYmJveCcpLmggLSAxMikpKSk7XG4gICAgICAgIHZhciB1bml0R2FwID0gNTtcbiAgICAgICAgdmFyIHRvcElkZWFsV2lkdGggPSB1bml0R2FwO1xuICAgICAgICB2YXIgYm90dG9tSWRlYWxXaWR0aCA9IHVuaXRHYXA7ICAgICAgICBcbiAgICAgICAgdmFyIHJpZ2h0TWF4V2lkdGggPSAwO1xuICAgICAgICB2YXIgbGVmdE1heFdpZHRoID0wO1xuICAgICAgICBzdGF0ZXNhbmRpbmZvcy5mb3JFYWNoKGZ1bmN0aW9uKGJveCl7XG4gICAgICAgICAgaWYoYm94LmFuY2hvclNpZGUgPT09IFwidG9wXCIpe1xuICAgICAgICAgICAgdG9wSWRlYWxXaWR0aCArPSBib3guYmJveC53ICsgdW5pdEdhcDtcblxuICAgICAgICAgIH1lbHNlIGlmKGJveC5hbmNob3JTaWRlID09PSBcImJvdHRvbVwiKXtcbiAgICAgICAgICAgIGJvdHRvbUlkZWFsV2lkdGggKz0gYm94LmJib3gudyArIHVuaXRHYXA7XG5cbiAgICAgICAgICB9ZWxzZSBpZihib3guYW5jaG9yU2lkZSA9PT0gXCJyaWdodFwiKVxuICAgICAgICAgIHsgICAgICAgICAgIFxuICAgICAgICAgICAgcmlnaHRNYXhXaWR0aCA9IChib3guYmJveC53ID4gcmlnaHRNYXhXaWR0aCkgPyBib3guYmJveC53IDogcmlnaHRNYXhXaWR0aDtcbiAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgbGVmdE1heFdpZHRoID0gKGJveC5iYm94LncgPiBsZWZ0TWF4V2lkdGgpID8gYm94LmJib3gudyA6IGxlZnRNYXhXaWR0aDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pOyAgICAgIFxuXG4gICAgICAgIHZhciBtaWRkbGVXaWR0aCA9IGxhYmVsV2lkdGggKyAyICogTWF0aC5tYXgocmlnaHRNYXhXaWR0aC8yLCBsZWZ0TWF4V2lkdGgvMik7XG5cbiAgICAgICAgdmFyIGNvbXBvdW5kV2lkdGggPSAwO1xuICAgICAgICBpZihub2RlLmlzUGFyZW50KCkpe1xuICAgICAgICAgIGNvbXBvdW5kV2lkdGggPSBub2RlLmNoaWxkcmVuKCkuYm91bmRpbmdCb3goKS53O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBNYXRoLm1heChtaWRkbGVXaWR0aCwgZGVmYXVsdFdpZHRoLzIsIHRvcElkZWFsV2lkdGgsIGJvdHRvbUlkZWFsV2lkdGgsIGNvbXBvdW5kV2lkdGgpO1xuICAgIH1cblxuICAgIGVsZW1lbnRVdGlsaXRpZXMuY2FsY3VsYXRlTWluSGVpZ2h0ID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgICB2YXIgc3RhdGVzYW5kaW5mb3MgPSBub2RlLmRhdGEoJ3N0YXRlc2FuZGluZm9zJyk7XG4gICAgICAgIHZhciBtYXJnaW4gPSA3O1xuICAgICAgICB2YXIgdW5pdEdhcCA9IDU7XG4gICAgICAgIHZhciBkZWZhdWx0SGVpZ2h0ID0gdGhpcy5nZXREZWZhdWx0UHJvcGVydGllcyhub2RlLmRhdGEoJ2NsYXNzJykpLmhlaWdodDtcbiAgICAgICAgdmFyIGxlZnRJbmZvQm94ZXMgPSBzdGF0ZXNhbmRpbmZvcy5maWx0ZXIoYm94ID0+IGJveC5hbmNob3JTaWRlID09PSBcImxlZnRcIik7ICAgICAgICBcbiAgICAgICAgdmFyIGxlZnRIZWlnaHQgPSB1bml0R2FwOyBcbiAgICAgICAgbGVmdEluZm9Cb3hlcy5mb3JFYWNoKGZ1bmN0aW9uKGJveCl7XG4gICAgICAgICAgICBsZWZ0SGVpZ2h0ICs9IGJveC5iYm94LmggKyB1bml0R2FwO1xuICAgICAgICAgICBcbiAgICAgICAgfSk7ICAgICAgXG4gICAgICAgIHZhciByaWdodEluZm9Cb3hlcyA9IHN0YXRlc2FuZGluZm9zLmZpbHRlcihib3ggPT4gYm94LmFuY2hvclNpZGUgPT09IFwicmlnaHRcIik7XG4gICAgICAgIHZhciByaWdodEhlaWdodCA9IHVuaXRHYXA7ICAgICAgICBcbiAgICAgICAgcmlnaHRJbmZvQm94ZXMuZm9yRWFjaChmdW5jdGlvbihib3gpe1xuICAgICAgICAgICAgcmlnaHRIZWlnaHQgKz0gYm94LmJib3guaCArIHVuaXRHYXA7ICAgICAgICAgICBcbiAgICAgICAgfSk7ICAgICAgIFxuICAgICAgICB2YXIgc3R5bGUgPSBub2RlLnN0eWxlKCk7XG4gICAgICAgIHZhciBsYWJlbFRleHQgPSAoKHN0eWxlWydsYWJlbCddKS5zcGxpdChcIlxcblwiKSkuZmlsdGVyKCB0ZXh0ID0+IHRleHQgIT09ICcnKTtcbiAgICAgICAgdmFyIGZvbnRTaXplID0gcGFyc2VGbG9hdChzdHlsZVsnZm9udC1zaXplJ10uc3Vic3RyaW5nKDAsIHN0eWxlWydmb250LXNpemUnXS5sZW5ndGggLSAyKSk7XG4gICAgICAgIHZhciB0b3RhbEhlaWdodCA9IGxhYmVsVGV4dC5sZW5ndGggKiBmb250U2l6ZSArIDIgKiBtYXJnaW47XG5cbiAgICAgICAgXG5cbiAgICAgICAgdmFyIGNvbXBvdW5kSGVpZ2h0ID0gMDtcbiAgICAgICAgaWYobm9kZS5pc1BhcmVudCgpKXtcbiAgICAgICAgICBjb21wb3VuZEhlaWdodCA9IG5vZGUuY2hpbGRyZW4oKS5ib3VuZGluZ0JveCgpLmg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KHRvdGFsSGVpZ2h0LCBkZWZhdWx0SGVpZ2h0LzIsIGxlZnRIZWlnaHQsIHJpZ2h0SGVpZ2h0LCBjb21wb3VuZEhlaWdodCk7XG4gICAgfVxuXG4gICAgZWxlbWVudFV0aWxpdGllcy5pc1Jlc2l6ZWRUb0NvbnRlbnQgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgaWYoIW5vZGUgfHwgIW5vZGUuaXNOb2RlKCkgfHwgIW5vZGUuZGF0YSgnYmJveCcpKXtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvL3ZhciB3ID0gbm9kZS5kYXRhKCdiYm94JykudztcbiAgICAgIC8vdmFyIGggPSBub2RlLmRhdGEoJ2Jib3gnKS5oO1xuICAgICAgdmFyIHcgPSBub2RlLndpZHRoKCk7XG4gICAgICB2YXIgaCA9IG5vZGUuaGVpZ2h0KCk7XG5cbiAgICAgIHZhciBtaW5XID0gZWxlbWVudFV0aWxpdGllcy5jYWxjdWxhdGVNaW5XaWR0aChub2RlKTtcbiAgICAgIHZhciBtaW5IID0gZWxlbWVudFV0aWxpdGllcy5jYWxjdWxhdGVNaW5IZWlnaHQobm9kZSk7XG5cbiAgICAgIGlmKHcgPT09IG1pblcgJiYgaCA9PT0gbWluSClcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBTZWN0aW9uIEVuZFxuICAgIC8vIEFkZCByZW1vdmUgdXRpbGl0aWVzXG5cbiAgICAvLyBSZWxvY2F0ZXMgc3RhdGUgYW5kIGluZm8gYm94ZXMuIFRoaXMgZnVuY3Rpb24gaXMgZXhwZWN0ZWQgdG8gYmUgY2FsbGVkIGFmdGVyIGFkZC9yZW1vdmUgc3RhdGUgYW5kIGluZm8gYm94ZXNcbiAgICBlbGVtZW50VXRpbGl0aWVzLnJlbG9jYXRlU3RhdGVBbmRJbmZvcyA9IGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgIHZhciBzdGF0ZUFuZEluZm9zID0gKGVsZS5pc05vZGUgJiYgZWxlLmlzTm9kZSgpKSA/IGVsZS5kYXRhKCdzdGF0ZXNhbmRpbmZvcycpIDogZWxlO1xuICAgICAgdmFyIGxlbmd0aCA9IHN0YXRlQW5kSW5mb3MubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCA9PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGxlbmd0aCA9PSAxKSB7XG4gICAgICAgIHN0YXRlQW5kSW5mb3NbMF0uYmJveC54ID0gMDtcbiAgICAgICAgc3RhdGVBbmRJbmZvc1swXS5iYm94LnkgPSAtNTA7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChsZW5ndGggPT0gMikge1xuICAgICAgICBzdGF0ZUFuZEluZm9zWzBdLmJib3gueCA9IDA7XG4gICAgICAgIHN0YXRlQW5kSW5mb3NbMF0uYmJveC55ID0gLTUwO1xuXG4gICAgICAgIHN0YXRlQW5kSW5mb3NbMV0uYmJveC54ID0gMDtcbiAgICAgICAgc3RhdGVBbmRJbmZvc1sxXS5iYm94LnkgPSA1MDtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGxlbmd0aCA9PSAzKSB7XG4gICAgICAgIHN0YXRlQW5kSW5mb3NbMF0uYmJveC54ID0gLTI1O1xuICAgICAgICBzdGF0ZUFuZEluZm9zWzBdLmJib3gueSA9IC01MDtcblxuICAgICAgICBzdGF0ZUFuZEluZm9zWzFdLmJib3gueCA9IDI1O1xuICAgICAgICBzdGF0ZUFuZEluZm9zWzFdLmJib3gueSA9IC01MDtcblxuICAgICAgICBzdGF0ZUFuZEluZm9zWzJdLmJib3gueCA9IDA7XG4gICAgICAgIHN0YXRlQW5kSW5mb3NbMl0uYmJveC55ID0gNTA7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgc3RhdGVBbmRJbmZvc1swXS5iYm94LnggPSAtMjU7XG4gICAgICAgIHN0YXRlQW5kSW5mb3NbMF0uYmJveC55ID0gLTUwO1xuXG4gICAgICAgIHN0YXRlQW5kSW5mb3NbMV0uYmJveC54ID0gMjU7XG4gICAgICAgIHN0YXRlQW5kSW5mb3NbMV0uYmJveC55ID0gLTUwO1xuXG4gICAgICAgIHN0YXRlQW5kSW5mb3NbMl0uYmJveC54ID0gLTI1O1xuICAgICAgICBzdGF0ZUFuZEluZm9zWzJdLmJib3gueSA9IDUwO1xuXG4gICAgICAgIHN0YXRlQW5kSW5mb3NbM10uYmJveC54ID0gMjU7XG4gICAgICAgIHN0YXRlQW5kSW5mb3NbM10uYmJveC55ID0gNTA7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIENoYW5nZSBzdGF0ZSB2YWx1ZSBvciB1bml0IG9mIGluZm9ybWF0aW9uIGJveCBvZiBnaXZlbiBub2RlcyB3aXRoIGdpdmVuIGluZGV4LlxuICAgIC8vIFR5cGUgcGFyYW1ldGVyIGluZGljYXRlcyB3aGV0aGVyIHRvIGNoYW5nZSB2YWx1ZSBvciB2YXJpYWJsZSwgaXQgaXMgdmFsaWQgaWYgdGhlIGJveCBhdCB0aGUgZ2l2ZW4gaW5kZXggaXMgYSBzdGF0ZSB2YXJpYWJsZS5cbiAgICAvLyBWYWx1ZSBwYXJhbWV0ZXIgaXMgdGhlIG5ldyB2YWx1ZSB0byBzZXQuXG4gICAgLy8gVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgb2xkIHZhbHVlIG9mIHRoZSBjaGFuZ2VkIGRhdGEgKFdlIGFzc3VtZSB0aGF0IHRoZSBvbGQgdmFsdWUgb2YgdGhlIGNoYW5nZWQgZGF0YSB3YXMgdGhlIHNhbWUgZm9yIGFsbCBub2RlcykuXG4gICAgLy8gRWFjaCBjaGFyYWN0ZXIgYXNzdW1lZCB0byBvY2N1cHkgOCB1bml0XG4gICAgLy8gRWFjaCBpbmZvYm94IGNhbiBoYXZlIGF0IG1vc3QgMzIgdW5pdHMgb2Ygd2lkdGhcbiAgICBlbGVtZW50VXRpbGl0aWVzLmNoYW5nZVN0YXRlT3JJbmZvQm94ID0gZnVuY3Rpb24gKG5vZGVzLCBpbmRleCwgdmFsdWUsIHR5cGUpIHtcbiAgICAgIHZhciByZXN1bHQ7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIHZhciBzYmduY2xhc3MgPSBub2RlLmRhdGEoJ2NsYXNzJyk7XG4gICAgICAgIHZhciBzdGF0ZUFuZEluZm9zID0gbm9kZS5kYXRhKCdzdGF0ZXNhbmRpbmZvcycpO1xuICAgICAgICB2YXIgYm94ID0gc3RhdGVBbmRJbmZvc1tpbmRleF07XG4gICAgICAgIHZhciBvbGRMZW5ndGggPSBib3guYmJveC53O1xuICAgICAgICB2YXIgbmV3TGVuZ3RoID0gMDtcblxuICAgICAgICB2YXIgY29udGVudCA9ICcnO1xuICAgICAgICBpZiAoYm94LmNsYXp6ID09IFwic3RhdGUgdmFyaWFibGVcIikge1xuICAgICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICByZXN1bHQgPSBib3guc3RhdGVbdHlwZV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYm94LnN0YXRlW3R5cGVdID0gdmFsdWU7XG4gICAgICAgICAgaWYgKGJveC5zdGF0ZVtcInZhbHVlXCJdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnRlbnQgKz0gYm94LnN0YXRlW1widmFsdWVcIl07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChib3guc3RhdGVbXCJ2YXJpYWJsZVwiXSAhPT0gdW5kZWZpbmVkICYmIGJveC5zdGF0ZVtcInZhcmlhYmxlXCJdLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnRlbnQgKz0gYm94LnN0YXRlW1widmFyaWFibGVcIl0gKyBcIkBcIjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChib3guY2xhenogPT0gXCJ1bml0IG9mIGluZm9ybWF0aW9uXCIpIHtcbiAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gYm94LmxhYmVsLnRleHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRlbnQgKz0gdmFsdWU7XG4gICAgICAgICAgYm94LmxhYmVsLnRleHQgPSB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtaW4gPSAoIHNiZ25jbGFzcyA9PT0gJ1NJRiBtYWNyb21vbGVjdWxlJyB8fCBzYmduY2xhc3MgPT09ICdTSUYgc2ltcGxlIGNoZW1pY2FsJyApID8gMTUgOiAxMjtcbiAgICAgICAgdmFyIGZvbnRGYW1pbHkgPSBib3guc3R5bGVbICdmb250LWZhbWlseScgXTtcbiAgICAgICAgdmFyIGZvbnRTaXplID0gYm94LnN0eWxlWyAnZm9udC1zaXplJyBdO1xuICAgICAgICB2YXIgYm9yZGVyV2lkdGggPSBib3guc3R5bGVbICdib3JkZXItd2lkdGgnIF07XG4gICAgICAgIHZhciBvcHRzID0ge1xuICAgICAgICAgIG1pbixcbiAgICAgICAgICBtYXg6IDQ4LFxuICAgICAgICAgIG1hcmdpbjogYm9yZGVyV2lkdGggLyAyICsgMC41XG4gICAgICAgIH07XG4gICAgICAgIHZhciBwcmV2aW91c1dpZHRoID0gYm94LmJib3gudztcbiAgICAgICAgYm94LmJib3gudyA9IGVsZW1lbnRVdGlsaXRpZXMuZ2V0V2lkdGhCeUNvbnRlbnQoIGNvbnRlbnQsIGZvbnRGYW1pbHksIGZvbnRTaXplLCBvcHRzICk7XG5cbiAgICAgICAgaWYoYm94LmFuY2hvclNpZGUgPT0gXCJ0b3BcIiB8fCBib3guYW5jaG9yU2lkZSA9PSBcImJvdHRvbVwiKXtcbiAgICAgICAgICB2YXIgdW5pdExheW91dCA9IG5vZGUuZGF0YSgpW1wiYXV4dW5pdGxheW91dHNcIl1bYm94LmFuY2hvclNpZGVdO1xuICAgICAgICAgIGlmKHVuaXRMYXlvdXQudW5pdHNbdW5pdExheW91dC51bml0cy5sZW5ndGgtMV0uaWQgPT0gYm94LmlkKXtcbiAgICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBib3JkZXJXaWR0aCA9IG5vZGUuZGF0YSgpWydib3JkZXItd2lkdGgnXTtcbiAgICAgICAgICAgIHZhciBzaGlmdEFtb3VudCA9ICgoKGJveC5iYm94LncgLSBwcmV2aW91c1dpZHRoKSAvIDIpICogMTAwICkvIChub2RlLm91dGVyV2lkdGgoKSAtIGJvcmRlcldpZHRoKTtcbiAgICAgICAgICAgXG4gICAgICAgICAgICBpZihzaGlmdEFtb3VudCA+PSAwKXtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICBpZihib3guYmJveC54ICsgc2hpZnRBbW91bnQgPD0gMTAwKXtcbiAgICAgICAgICAgICAgICBib3guYmJveC54ID0gYm94LmJib3gueCArIHNoaWZ0QW1vdW50O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgIC8qICBlbHNle1xuICAgICAgICAgICAgICB2YXIgcHJldmlvdXNJbmZvQmJveCA9IHt4IDogMCwgdzowfTtcbiAgICAgICAgICAgICAgaWYodW5pdExheW91dC51bml0cy5sZW5ndGggPiAxKXtcbiAgICAgICAgICAgICAgICBwcmV2aW91c0luZm9CYm94PSB1bml0TGF5b3V0LnVuaXRzW3VuaXRMYXlvdXQudW5pdHMubGVuZ3RoLTJdLmJib3g7ICAgICAgXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIHNiZ252aXpJbnN0YW5jZS5jbGFzc2VzLkF1eFVuaXRMYXlvdXQuc2V0SWRlYWxHYXAobm9kZSwgYm94LmFuY2hvclNpZGUpO1xuICAgICAgICAgICAgICB2YXIgaWRlYWxHYXAgPSBzYmdudml6SW5zdGFuY2UuY2xhc3Nlcy5BdXhVbml0TGF5b3V0LmdldEN1cnJlbnRHYXAoYm94LmFuY2hvclNpZGUpO1xuICAgICAgICAgICAgICB2YXIgbmV3UG9zaXRpb24gPSBwcmV2aW91c0luZm9CYm94LnggKyAocHJldmlvdXNJbmZvQmJveC53LzIgKyBpZGVhbEdhcCArIGJveC5iYm94LncvMikqMTAwIC8gKG5vZGUub3V0ZXJXaWR0aCgpIC0gYm9yZGVyV2lkdGgpO1xuICAgICAgICAgICAgICBib3guYmJveC54ID0gbmV3UG9zaXRpb247XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgfSAqL1xuICAgICAgICAgICBcbiAgICAgICAgICAgXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgLyogaWYgKGJveC5hbmNob3JTaWRlID09PSBcInRvcFwiIHx8IGJveC5hbmNob3JTaWRlID09PSBcImJvdHRvbVwiKSB7XG4gICAgICAgICAgYm94LmJib3gueCArPSAoYm94LmJib3gudyAtIG9sZExlbmd0aCkgLyAyO1xuICAgICAgICAgIHZhciB1bml0cyA9IChub2RlLmRhdGEoJ2F1eHVuaXRsYXlvdXRzJylbYm94LmFuY2hvclNpZGVdKS51bml0cztcbiAgICAgICAgICB2YXIgc2hpZnRJbmRleCA9IDA7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1bml0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYodW5pdHNbaV0gPT09IGJveCl7XG4gICAgICAgICAgICAgIHNoaWZ0SW5kZXggPSBpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yICh2YXIgaiA9IHNoaWZ0SW5kZXgrMTsgaiA8IHVuaXRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgIHVuaXRzW2pdLmJib3gueCArPSAoYm94LmJib3gudyAtIG9sZExlbmd0aCk7XG4gICAgICAgICAgfVxuICAgICAgICB9ICovXG5cbiAgICAgIH1cblxuICAgICAgLy9UT0RPIGZpbmQgYSB3YXkgdG8gZWxpbWF0ZSB0aGlzIHJlZHVuZGFuY3kgdG8gdXBkYXRlIGluZm8tYm94IHBvc2l0aW9uc1xuICAgICAgbm9kZS5kYXRhKCdib3JkZXItd2lkdGgnLCBub2RlLmRhdGEoJ2JvcmRlci13aWR0aCcpKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgLy8gQWRkIGEgbmV3IHN0YXRlIG9yIGluZm8gYm94IHRvIGdpdmVuIG5vZGVzLlxuICAgIC8vIFRoZSBib3ggaXMgcmVwcmVzZW50ZWQgYnkgdGhlIHBhcmFtZXRlciBvYmouXG4gICAgLy8gVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGp1c3QgYWRkZWQgYm94LlxuICAgIGVsZW1lbnRVdGlsaXRpZXMuYWRkU3RhdGVPckluZm9Cb3ggPSBmdW5jdGlvbiAobm9kZXMsIG9iaikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICB2YXIgbG9jYXRpb25PYmo7XG5cbiAgICAgICAgdmFyIGRlZmF1bHRQcm9wcyA9IGVsZW1lbnRVdGlsaXRpZXMuZ2V0RGVmYXVsdFByb3BlcnRpZXMoIG5vZGUuZGF0YSgnY2xhc3MnKSApO1xuICAgICAgICB2YXIgaW5mb2JveFByb3BzID0gZGVmYXVsdFByb3BzWyBvYmouY2xhenogXTtcbiAgICAgICAgdmFyIGJib3ggPSBvYmouYmJveCB8fCB7IHc6IGluZm9ib3hQcm9wcy53aWR0aCwgaDogaW5mb2JveFByb3BzLmhlaWdodCB9OyAgICAgICAgXG4gICAgICAgIHZhciBzdHlsZSA9IGVsZW1lbnRVdGlsaXRpZXMuZ2V0RGVmYXVsdEluZm9ib3hTdHlsZSggbm9kZS5kYXRhKCdjbGFzcycpLCBvYmouY2xhenogKTtcbiAgICAgICAgaWYob2JqLnN0eWxlKXtcbiAgICAgICAgICAkLmV4dGVuZCggc3R5bGUsIG9iai5zdHlsZSApO1xuICAgICAgICB9XG4gICAgICAgXG4gICAgICAgIGlmKG9iai5jbGF6eiA9PSBcInVuaXQgb2YgaW5mb3JtYXRpb25cIikge1xuICAgICAgICAgIGxvY2F0aW9uT2JqID0gc2JnbnZpekluc3RhbmNlLmNsYXNzZXMuVW5pdE9mSW5mb3JtYXRpb24uY3JlYXRlKG5vZGUsIGN5LCBvYmoubGFiZWwudGV4dCwgYmJveCwgb2JqLmxvY2F0aW9uLCBvYmoucG9zaXRpb24sIHN0eWxlLCBvYmouaW5kZXgsIG9iai5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob2JqLmNsYXp6ID09IFwic3RhdGUgdmFyaWFibGVcIikge1xuICAgICAgICAgIGxvY2F0aW9uT2JqID0gc2JnbnZpekluc3RhbmNlLmNsYXNzZXMuU3RhdGVWYXJpYWJsZS5jcmVhdGUobm9kZSwgY3ksIG9iai5zdGF0ZS52YWx1ZSwgb2JqLnN0YXRlLnZhcmlhYmxlLCBiYm94LCBvYmoubG9jYXRpb24sIG9iai5wb3NpdGlvbiwgc3R5bGUsIG9iai5pbmRleCwgb2JqLmlkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGxvY2F0aW9uT2JqO1xuICAgIH07XG5cbiAgICAvLyBSZW1vdmUgdGhlIHN0YXRlIG9yIGluZm8gYm94ZXMgb2YgdGhlIGdpdmVuIG5vZGVzIGF0IGdpdmVuIGluZGV4LlxuICAgIC8vIFJldHVybnMgdGhlIHJlbW92ZWQgYm94LlxuICAgIGVsZW1lbnRVdGlsaXRpZXMucmVtb3ZlU3RhdGVPckluZm9Cb3ggPSBmdW5jdGlvbiAobm9kZXMsIGxvY2F0aW9uT2JqKSB7XG4gICAgICB2YXIgb2JqO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICB2YXIgc3RhdGVBbmRJbmZvcyA9IG5vZGUuZGF0YSgnc3RhdGVzYW5kaW5mb3MnKTtcbiAgICAgICAgdmFyIHVuaXQgPSBzdGF0ZUFuZEluZm9zW2xvY2F0aW9uT2JqLmluZGV4XTtcblxuICAgICAgICB2YXIgdW5pdENsYXNzID0gc2JnbnZpekluc3RhbmNlLmNsYXNzZXMuZ2V0QXV4VW5pdENsYXNzKHVuaXQpO1xuXG4gICAgICAgIG9iaiA9IHVuaXRDbGFzcy5yZW1vdmUodW5pdCwgY3kpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2JqO1xuICAgIH07XG5cblxuICAgIC8vVGlsZXMgaW5mb3JtYXRpb25zIGJveGVzIGZvciBnaXZlbiBhbmNob3JTaWRlc1xuICAgIGVsZW1lbnRVdGlsaXRpZXMuZml0VW5pdHMgPSBmdW5jdGlvbiAobm9kZSwgbG9jYXRpb25zKSB7XG4gICAgICB2YXIgb2JqID0gW107XG4gICAgICBub2RlLmRhdGEoJ3N0YXRlc2FuZGluZm9zJykuZm9yRWFjaCggZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICBvYmoucHVzaCh7XG4gICAgICAgICAgeDogZWxlLmJib3gueCxcbiAgICAgICAgICB5OiBlbGUuYmJveC55LFxuICAgICAgICAgIGFuY2hvclNpZGU6IGVsZS5hbmNob3JTaWRlXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBzYmdudml6SW5zdGFuY2UuY2xhc3Nlcy5BdXhVbml0TGF5b3V0LmZpdFVuaXRzKG5vZGUsIGN5LCBsb2NhdGlvbnMpO1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xuXG4gICAgLy9DaGVjayB3aGljaCBhbmNob3JzaWRlcyBmaXRzXG4gICAgZWxlbWVudFV0aWxpdGllcy5jaGVja0ZpdCA9IGZ1bmN0aW9uIChub2RlLCBsb2NhdGlvbikgeyAvL2lmIG5vIGxvY2F0aW9uIGdpdmVuLCBpdCBjaGVja3MgYWxsIHBvc3NpYmxlIGxvY2F0aW9uc1xuICAgICAgcmV0dXJuIHNiZ252aXpJbnN0YW5jZS5jbGFzc2VzLkF1eFVuaXRMYXlvdXQuY2hlY2tGaXQobm9kZSwgY3ksIGxvY2F0aW9uKTtcbiAgICB9O1xuXG4gICAgLy9Nb2RpZnkgYXJyYXkgb2YgYXV4IGxheW91dCB1bml0c1xuICAgIGVsZW1lbnRVdGlsaXRpZXMubW9kaWZ5VW5pdHMgPSBmdW5jdGlvbiAobm9kZSwgdW5pdCwgYW5jaG9yU2lkZSkge1xuICAgICAgc2JnbnZpekluc3RhbmNlLmNsYXNzZXMuQXV4VW5pdExheW91dC5tb2RpZnlVbml0cyhub2RlLCB1bml0LCBhbmNob3JTaWRlLCBjeSk7XG4gICAgfTtcblxuICAgIC8vIFNldCBtdWx0aW1lciBzdGF0dXMgb2YgdGhlIGdpdmVuIG5vZGVzIHRvIHRoZSBnaXZlbiBzdGF0dXMuXG4gICAgZWxlbWVudFV0aWxpdGllcy5zZXRNdWx0aW1lclN0YXR1cyA9IGZ1bmN0aW9uIChub2Rlcywgc3RhdHVzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIHZhciBzYmduY2xhc3MgPSBub2RlLmRhdGEoJ2NsYXNzJyk7XG4gICAgICAgIHZhciBpc011bHRpbWVyID0gbm9kZS5kYXRhKCdjbGFzcycpLmVuZHNXaXRoKCcgbXVsdGltZXInKTtcblxuICAgICAgICBpZiAoc3RhdHVzKSB7IC8vIE1ha2UgbXVsdGltZXIgc3RhdHVzIHRydWVcbiAgICAgICAgICBpZiAoIWlzTXVsdGltZXIpIHtcbiAgICAgICAgICAgIG5vZGUuZGF0YSgnY2xhc3MnLCBzYmduY2xhc3MgKyAnIG11bHRpbWVyJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvLyBNYWtlIG11bHRpbWVyIHN0YXR1cyBmYWxzZVxuICAgICAgICAgIGlmIChpc011bHRpbWVyKSB7XG4gICAgICAgICAgICBub2RlLmRhdGEoJ2NsYXNzJywgc2JnbmNsYXNzLnJlcGxhY2UoJyBtdWx0aW1lcicsICcnKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIENoYW5nZSBmb250IHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIGVsZW1lbnRzIHdpdGggZ2l2ZW4gZm9udCBkYXRhXG4gICAgZWxlbWVudFV0aWxpdGllcy5jaGFuZ2VGb250UHJvcGVydGllcyA9IGZ1bmN0aW9uIChlbGVzLCBkYXRhKSB7XG4gICAgICBmb3IgKHZhciBwcm9wIGluIGRhdGEpIHtcbiAgICAgICAgZWxlcy5kYXRhKHByb3AsIGRhdGFbcHJvcF0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGdldHMgYW4gZWRnZSwgYW5kIGVuZHMgb2YgdGhhdCBlZGdlIChPcHRpb25hbGx5IGl0IG1heSB0YWtlIGp1c3QgdGhlIGNsYXNzZXMgb2YgdGhlIGVkZ2UgYXMgd2VsbCkgYXMgcGFyYW1ldGVycy5cbiAgICAvLyBJdCBtYXkgcmV0dXJuICd2YWxpZCcgKHRoYXQgZW5kcyBpcyB2YWxpZCBmb3IgdGhhdCBlZGdlKSwgJ3JldmVyc2UnICh0aGF0IGVuZHMgaXMgbm90IHZhbGlkIGZvciB0aGF0IGVkZ2UgYnV0IHRoZXkgd291bGQgYmUgdmFsaWRcbiAgICAvLyBpZiB5b3UgcmV2ZXJzZSB0aGUgc291cmNlIGFuZCB0YXJnZXQpLCAnaW52YWxpZCcgKHRoYXQgZW5kcyBhcmUgdG90YWxseSBpbnZhbGlkIGZvciB0aGF0IGVkZ2UpLlxuICAgIGVsZW1lbnRVdGlsaXRpZXMudmFsaWRhdGVBcnJvd0VuZHMgPSBmdW5jdGlvbiAoZWRnZSwgc291cmNlLCB0YXJnZXQsIGlzUmVwbGFjZW1lbnQpIHtcbiAgICAgIC8vIGlmIG1hcCB0eXBlIGlzIFVua25vd24gLS0gbm8gcnVsZXMgYXBwbGllZFxuICAgICAgaWYgKGVsZW1lbnRVdGlsaXRpZXMuZ2V0TWFwVHlwZSgpID09IFwiSHlicmlkQW55XCIgfHwgZWxlbWVudFV0aWxpdGllcy5nZXRNYXBUeXBlKCkgPT0gXCJIeWJyaWRTYmduXCIgfHwgIWVsZW1lbnRVdGlsaXRpZXMuZ2V0TWFwVHlwZSgpKVxuICAgICAgICByZXR1cm4gXCJ2YWxpZFwiO1xuXG4gICAgICB2YXIgZWRnZWNsYXNzID0gdHlwZW9mIGVkZ2UgPT09ICdzdHJpbmcnID8gZWRnZSA6IGVkZ2UuZGF0YSgnY2xhc3MnKTtcbiAgICAgIHZhciBzb3VyY2VjbGFzcyA9IHNvdXJjZS5kYXRhKCdjbGFzcycpO1xuICAgICAgdmFyIHRhcmdldGNsYXNzID0gdGFyZ2V0LmRhdGEoJ2NsYXNzJyk7XG4gICAgICB2YXIgbWFwVHlwZSA9IGVsZW1lbnRVdGlsaXRpZXMuZ2V0TWFwVHlwZSgpO1xuICAgICAgdmFyIGVkZ2VDb25zdHJhaW50cyA9IGVsZW1lbnRVdGlsaXRpZXNbbWFwVHlwZV0uY29ubmVjdGl2aXR5Q29uc3RyYWludHNbZWRnZWNsYXNzXTtcblxuICAgICAgaWYgKG1hcFR5cGUgPT0gXCJBRlwiKXtcbiAgICAgICAgaWYgKHNvdXJjZWNsYXNzLnN0YXJ0c1dpdGgoXCJCQVwiKSkgLy8gd2UgaGF2ZSBzZXBhcmF0ZSBjbGFzc2VzIGZvciBlYWNoIGJpb2xvZ2ljYWwgYWN0aXZpdHlcbiAgICAgICAgICBzb3VyY2VjbGFzcyA9IFwiYmlvbG9naWNhbCBhY3Rpdml0eVwiOyAvLyBidXQgc2FtZSBydWxlIGFwcGxpZXMgdG8gYWxsIG9mIHRoZW1cblxuICAgICAgICBpZiAodGFyZ2V0Y2xhc3Muc3RhcnRzV2l0aChcIkJBXCIpKSAvLyB3ZSBoYXZlIHNlcGFyYXRlIGNsYXNzZXMgZm9yIGVhY2ggYmlvbG9naWNhbCBhY3Rpdml0eVxuICAgICAgICAgIHRhcmdldGNsYXNzID0gXCJiaW9sb2dpY2FsIGFjdGl2aXR5XCI7IC8vIGJ1dCBzYW1lIHJ1bGUgYXBwbGllcyB0byBhbGwgb2YgdGhlbVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAobWFwVHlwZSA9PSBcIlBEXCIpe1xuICAgICAgICBzb3VyY2VjbGFzcyA9IHNvdXJjZWNsYXNzLnJlcGxhY2UoL1xccyptdWx0aW1lciQvLCAnJyk7XG4gICAgICAgIHRhcmdldGNsYXNzID0gdGFyZ2V0Y2xhc3MucmVwbGFjZSgvXFxzKm11bHRpbWVyJC8sICcnKTtcbiAgICAgIH1cblxuICAgICAgLy8gZ2l2ZW4gYSBub2RlLCBhY3RpbmcgYXMgc291cmNlIG9yIHRhcmdldCwgcmV0dXJucyBib29sZWFuIHdldGhlciBvciBub3QgaXQgaGFzIHRvbyBtYW55IGVkZ2VzIGFscmVhZHlcbiAgICAgIGZ1bmN0aW9uIGhhc1Rvb01hbnlFZGdlcyhub2RlLCBzb3VyY2VPclRhcmdldCkge1xuICAgICAgICB2YXIgbm9kZWNsYXNzID0gbm9kZS5kYXRhKCdjbGFzcycpO1xuICAgICAgICBub2RlY2xhc3MgPSBub2RlY2xhc3MucmVwbGFjZSgvXFxzKm11bHRpbWVyJC8sICcnKTtcbiAgICAgICAgaWYgKG5vZGVjbGFzcy5zdGFydHNXaXRoKFwiQkFcIikpXG4gICAgICAgICAgbm9kZWNsYXNzID0gXCJiaW9sb2dpY2FsIGFjdGl2aXR5XCI7XG5cbiAgICAgICAgLypcbiAgICAgICAgICBPbiB0aGUgbG9naWMgYmVsb3c6XG5cbiAgICAgICAgICBDdXJyZW50IGVkZ2UgY291bnQgKGluY29taW5nIG9yIG91dGdvaW5nKSBvZiBub2RlcyBzaG91bGQgYmUgc3RyaWN0bHkgbGVzcyBcbiAgICAgICAgICB0aGFuIHRoZSBtYXhpbXVtIGFsbG93ZWQgaWYgd2UgYXJlIGFkZGluZyBhbiBlZGdlIHRvIHRoZSBub2RlLiBUaGlzIHdheVxuICAgICAgICAgIGl0IHdpbGwgbmV2ZXIgZXhjZWVkIHRoZSBtYXggY291bnQuXG4gICAgICAgICAgXG4gICAgICAgICAgRWRnZXMgY2FuIGJlIGFkZGVkIGluIHR3byBkaWZmZXJlbnQgd2F5cy4gRWl0aGVyIHRoZXkgYXJlIGFkZGVkIGRpcmVjdGx5IG9yXG4gICAgICAgICAgdGhleSBhcmUgYWRkZWQgYnkgYmVpbmcgcmVwbGFjZWQgZnJvbSBhbm90aGVyIG5vZGUsIGkuZSBkaXNjb25uZWN0ZWQgZnJvbVxuICAgICAgICAgIG9uZSBhbmQgY29ubmVjdGVkIHRvIGFub3RoZXIuXG5cbiAgICAgICAgICBXZSBjYW4gZGV0ZWN0IGlmIHRoZSBlZGdlIGJlaW5nIGFkZGVkIGlzIGFkZGVkIGZyb20gYSByZXBsYWNlbWVudCBieSBjaGVja2luZ1xuICAgICAgICAgIHdoZXRoZXIgdGhlIHNvdXJjZSBzdGF5ZWQgdGhlIHNhbWUgd2hlbiBjaGVja2luZyBlZGdlIGNvdW50cyBvZiB0aGUgc291cmNlIG5vZGUsXG4gICAgICAgICAgYW5kIHdoZXRoZXIgdGhlIHRhcmdldCBzdGF5ZWQgdGhlIHNhbWUgd2hlbiBjaGVja2luZyBlZGdlIGNvdW50cyBvZiB0aGVcbiAgICAgICAgICB0YXJnZXQgbm9kZS5cblxuICAgICAgICAgIEN1cnJlbnQgZWRnZSBjb3VudCBvZiBub2RlcyBjYW4gYmUgYWxsb3dlZCB0byBiZSBlcXVhbCB0byB0aGUgbWF4aW11bSBpbiBcbiAgICAgICAgICBjYXNlcyB3aGVyZSBhIHJlcGxhY2VtZW50IGlzIG1hZGUuIEJ1dCB3ZSBzaG91bGQgYmUgY2FyZWZ1bCB0aGF0IHRoaXNcbiAgICAgICAgICByZXBsYWNlbWVudCBvcGVyYXRpb24gaXMgbm90IGFsc28gYW4gYWRkaXRpb24gb3BlcmF0aW9uIGFzIGRlc2NyaWJlZCBhYm92ZS5cbiAgICAgICAgKi9cblxuICAgICAgICB2YXIgdG90YWxUb29NYW55ID0gdHJ1ZTtcbiAgICAgICAgdmFyIGVkZ2VUb29NYW55ID0gdHJ1ZTtcbiAgICAgICAgaWYgKHNvdXJjZU9yVGFyZ2V0ID09IFwic291cmNlXCIpIHtcbiAgICAgICAgICAgIHZhciBzYW1lRWRnZUNvdW50T3V0ID0gbm9kZS5vdXRnb2VycygnZWRnZVtjbGFzcz1cIicrZWRnZWNsYXNzKydcIl0nKS5zaXplKCk7XG4gICAgICAgICAgICB2YXIgdG90YWxFZGdlQ291bnRPdXQgPSBub2RlLm91dGdvZXJzKCdlZGdlJykuc2l6ZSgpO1xuICAgICAgICAgICAgdmFyIG1heFRvdGFsID0gZWRnZUNvbnN0cmFpbnRzW25vZGVjbGFzc10uYXNTb3VyY2UubWF4VG90YWw7IFxuICAgICAgICAgICAgdmFyIG1heEVkZ2UgPSBlZGdlQ29uc3RyYWludHNbbm9kZWNsYXNzXS5hc1NvdXJjZS5tYXhFZGdlO1xuXG4gICAgICAgICAgICB2YXIgY29tcGFyZVN0cmljdCA9ICEoaXNSZXBsYWNlbWVudCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChlZGdlLnNvdXJjZSgpID09PSBzb3VyY2UpKTtcblxuICAgICAgICAgICAgdmFyIHdpdGhpbkxpbWl0cyA9ICFtYXhUb3RhbCB8fCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjb21wYXJlU3RyaWN0ICYmICh0b3RhbEVkZ2VDb3VudE91dCA8IG1heFRvdGFsKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICghY29tcGFyZVN0cmljdCAmJiAodG90YWxFZGdlQ291bnRPdXQgPD0gbWF4VG90YWwpKTtcblxuICAgICAgICAgICAgaWYgKHdpdGhpbkxpbWl0cykge1xuICAgICAgICAgICAgICAgIHRvdGFsVG9vTWFueSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGhlbiBjaGVjayBsaW1pdHMgZm9yIHRoaXMgc3BlY2lmaWMgZWRnZSBjbGFzc1xuXG4gICAgICAgICAgICB3aXRoaW5MaW1pdHMgPSAhbWF4RWRnZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjb21wYXJlU3RyaWN0ICYmIChzYW1lRWRnZUNvdW50T3V0IDwgbWF4RWRnZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIWNvbXBhcmVTdHJpY3QgJiYgKHNhbWVFZGdlQ291bnRPdXQgPD0gbWF4RWRnZSkpKTsgXG5cbiAgICAgICAgICAgIGlmICh3aXRoaW5MaW1pdHMpIHtcbiAgICAgICAgICAgICAgICBlZGdlVG9vTWFueSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiBvbmx5IG9uZSBvZiB0aGUgbGltaXRzIGlzIHJlYWNoZWQgdGhlbiBlZGdlIGlzIGludmFsaWRcbiAgICAgICAgICAgIHJldHVybiB0b3RhbFRvb01hbnkgfHwgZWRnZVRvb01hbnk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vIG5vZGUgaXMgdXNlZCBhcyB0YXJnZXRcbiAgICAgICAgICAgIHZhciBzYW1lRWRnZUNvdW50SW4gPSBub2RlLmluY29tZXJzKCdlZGdlW2NsYXNzPVwiJytlZGdlY2xhc3MrJ1wiXScpLnNpemUoKTtcbiAgICAgICAgICAgIHZhciB0b3RhbEVkZ2VDb3VudEluID0gbm9kZS5pbmNvbWVycygnZWRnZScpLnNpemUoKTtcbiAgICAgICAgICAgIHZhciBtYXhUb3RhbCA9IGVkZ2VDb25zdHJhaW50c1tub2RlY2xhc3NdLmFzVGFyZ2V0Lm1heFRvdGFsOyBcbiAgICAgICAgICAgIHZhciBtYXhFZGdlID0gZWRnZUNvbnN0cmFpbnRzW25vZGVjbGFzc10uYXNUYXJnZXQubWF4RWRnZTtcblxuICAgICAgICAgICAgdmFyIGNvbXBhcmVTdHJpY3QgPSAhKGlzUmVwbGFjZW1lbnQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGVkZ2UudGFyZ2V0KCkgPT09IHRhcmdldCkpO1xuXG4gICAgICAgICAgICB2YXIgd2l0aGluTGltaXRzID0gIW1heFRvdGFsIHx8IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGNvbXBhcmVTdHJpY3QgJiYgKHRvdGFsRWRnZUNvdW50SW4gPCBtYXhUb3RhbCkpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIWNvbXBhcmVTdHJpY3QgJiYgKHRvdGFsRWRnZUNvdW50SW4gPD0gbWF4VG90YWwpKTtcblxuICAgICAgICAgICAgaWYgKHdpdGhpbkxpbWl0cykge1xuICAgICAgICAgICAgICAgIHRvdGFsVG9vTWFueSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3aXRoaW5MaW1pdHMgPSAhbWF4RWRnZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAoY29tcGFyZVN0cmljdCAmJiAoc2FtZUVkZ2VDb3VudEluIDwgbWF4RWRnZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKCFjb21wYXJlU3RyaWN0ICYmIChzYW1lRWRnZUNvdW50SW4gPD0gbWF4RWRnZSkpKTsgXG5cbiAgICAgICAgICAgIGlmICh3aXRoaW5MaW1pdHMpIHtcbiAgICAgICAgICAgICAgICBlZGdlVG9vTWFueSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRvdGFsVG9vTWFueSB8fCBlZGdlVG9vTWFueTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpc0luQ29tcGxleChub2RlKSB7XG4gICAgICAgIHZhciBwYXJlbnRDbGFzcyA9IG5vZGUucGFyZW50KCkuZGF0YSgnY2xhc3MnKTtcbiAgICAgICAgcmV0dXJuIHBhcmVudENsYXNzICYmIHBhcmVudENsYXNzLnN0YXJ0c1dpdGgoJ2NvbXBsZXgnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzSW5Db21wbGV4KHNvdXJjZSkgfHwgaXNJbkNvbXBsZXgodGFyZ2V0KSkgeyAvLyBzdWJ1bml0cyBvZiBhIGNvbXBsZXggYXJlIG5vIGxvbmdlciBFUE5zLCBubyBjb25uZWN0aW9uIGFsbG93ZWRcbiAgICAgICAgcmV0dXJuICdpbnZhbGlkJztcbiAgICAgIH1cblxuICAgICAgLy8gY2hlY2sgbmF0dXJlIG9mIGNvbm5lY3Rpb25cbiAgICAgIGlmIChlZGdlQ29uc3RyYWludHNbc291cmNlY2xhc3NdLmFzU291cmNlLmlzQWxsb3dlZCAmJiBlZGdlQ29uc3RyYWludHNbdGFyZ2V0Y2xhc3NdLmFzVGFyZ2V0LmlzQWxsb3dlZCkge1xuICAgICAgICAvLyBjaGVjayBhbW91bnQgb2YgY29ubmVjdGlvbnNcbiAgICAgICAgaWYgKCFoYXNUb29NYW55RWRnZXMoc291cmNlLCBcInNvdXJjZVwiKSAmJiAhaGFzVG9vTWFueUVkZ2VzKHRhcmdldCwgXCJ0YXJnZXRcIikgKSB7XG4gICAgICAgICAgcmV0dXJuICd2YWxpZCc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIHRyeSB0byByZXZlcnNlXG4gICAgICBpZiAoZWRnZUNvbnN0cmFpbnRzW3RhcmdldGNsYXNzXS5hc1NvdXJjZS5pc0FsbG93ZWQgJiYgZWRnZUNvbnN0cmFpbnRzW3NvdXJjZWNsYXNzXS5hc1RhcmdldC5pc0FsbG93ZWQpIHtcbiAgICAgICAgaWYgKCFoYXNUb29NYW55RWRnZXModGFyZ2V0LCBcInNvdXJjZVwiKSAmJiAhaGFzVG9vTWFueUVkZ2VzKHNvdXJjZSwgXCJ0YXJnZXRcIikgKSB7XG4gICAgICAgICAgcmV0dXJuICdyZXZlcnNlJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuICdpbnZhbGlkJztcbiAgICB9O1xuXG4gICAgZWxlbWVudFV0aWxpdGllcy5kZWxldGVBbmRQZXJmb3JtTGF5b3V0ID0gZnVuY3Rpb24oZWxlcywgbGF5b3V0cGFyYW0pIHtcbiAgICAgIHZhciByZXN1bHQgPSBlbGVzLnJlbW92ZSgpO1xuICAgICAgaWYgKHR5cGVvZiBsYXlvdXRwYXJhbSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBsYXlvdXRwYXJhbSgpOyAvLyBJZiBsYXlvdXRwYXJhbSBpcyBhIGZ1bmN0aW9uIGV4ZWN1dGUgaXRcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciBsYXlvdXQgPSBjeS5sYXlvdXQobGF5b3V0cGFyYW0pOyAvLyBJZiBsYXlvdXRwYXJhbSBpcyBsYXlvdXQgb3B0aW9ucyBjYWxsIGxheW91dCB3aXRoIHRoYXQgb3B0aW9ucy5cblxuICAgICAgICAgIC8vIERvIHRoaXMgY2hlY2sgZm9yIGN5dG9zY2FwZS5qcyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gICAgICAgICAgaWYgKGxheW91dCAmJiBsYXlvdXQucnVuKSB7XG4gICAgICAgICAgICAgIGxheW91dC5ydW4oKTtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIC8qXG4gICAgICogSGlkZSBnaXZlbiBlbGVzIGFuZCBwZXJmb3JtIGdpdmVuIGxheW91dCBhZnRlcndhcmQuIExheW91dCBwYXJhbWV0ZXIgbWF5IGJlIGxheW91dCBvcHRpb25zXG4gICAgICogb3IgYSBmdW5jdGlvbiB0byBjYWxsLlxuICAgICAqL1xuICAgIGVsZW1lbnRVdGlsaXRpZXMuaGlkZUFuZFBlcmZvcm1MYXlvdXQgPSBmdW5jdGlvbihlbGVzLCBsYXlvdXRwYXJhbSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gY3kudmlld1V0aWxpdGllcygpLmhpZGUoZWxlcyk7IC8vIEhpZGUgZ2l2ZW4gZWxlc1xuICAgICAgICBpZiAodHlwZW9mIGxheW91dHBhcmFtID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBsYXlvdXRwYXJhbSgpOyAvLyBJZiBsYXlvdXRwYXJhbSBpcyBhIGZ1bmN0aW9uIGV4ZWN1dGUgaXRcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBsYXlvdXQgPSBjeS5sYXlvdXQobGF5b3V0cGFyYW0pOyAvLyBJZiBsYXlvdXRwYXJhbSBpcyBsYXlvdXQgb3B0aW9ucyBjYWxsIGxheW91dCB3aXRoIHRoYXQgb3B0aW9ucy5cblxuICAgICAgICAgICAgLy8gRG8gdGhpcyBjaGVjayBmb3IgY3l0b3NjYXBlLmpzIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAgICAgICAgICAgIGlmIChsYXlvdXQgJiYgbGF5b3V0LnJ1bikge1xuICAgICAgICAgICAgICAgIGxheW91dC5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIC8qXG4gICAgICogVW5oaWRlIGdpdmVuIGVsZXMgYW5kIHBlcmZvcm0gZ2l2ZW4gbGF5b3V0IGFmdGVyd2FyZC4gTGF5b3V0IHBhcmFtZXRlciBtYXkgYmUgbGF5b3V0IG9wdGlvbnNcbiAgICAgKiBvciBhIGZ1bmN0aW9uIHRvIGNhbGwuXG4gICAgICovXG4gICAgZWxlbWVudFV0aWxpdGllcy5zaG93QW5kUGVyZm9ybUxheW91dCA9IGZ1bmN0aW9uKGVsZXMsIGxheW91dHBhcmFtKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gY3kudmlld1V0aWxpdGllcygpLnNob3coZWxlcyk7IC8vIFNob3cgZ2l2ZW4gZWxlc1xuICAgICAgaWYgKHR5cGVvZiBsYXlvdXRwYXJhbSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBsYXlvdXRwYXJhbSgpOyAvLyBJZiBsYXlvdXRwYXJhbSBpcyBhIGZ1bmN0aW9uIGV4ZWN1dGUgaXRcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB2YXIgbGF5b3V0ID0gY3kubGF5b3V0KGxheW91dHBhcmFtKTsgLy8gSWYgbGF5b3V0cGFyYW0gaXMgbGF5b3V0IG9wdGlvbnMgY2FsbCBsYXlvdXQgd2l0aCB0aGF0IG9wdGlvbnMuXG5cbiAgICAgICAgLy8gRG8gdGhpcyBjaGVjayBmb3IgY3l0b3NjYXBlLmpzIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAgICAgICAgaWYgKGxheW91dCAmJiBsYXlvdXQucnVuKSB7XG4gICAgICAgICAgbGF5b3V0LnJ1bigpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIC8qXG4gICAgICogQ2hhbmdlIHN0eWxlL2NzcyBvZiBnaXZlbiBlbGVzIGJ5IHNldHRpbmcgZ2V0dGluZyBwcm9wZXJ0eSBuYW1lIHRvIHRoZSBnaXZlbiB2YWx1ZS92YWx1ZXMgKE5vdGUgdGhhdCB2YWx1ZU1hcCBwYXJhbWV0ZXIgbWF5IGJlXG4gICAgICogYSBzaW5nbGUgc3RyaW5nIG9yIGFuIGlkIHRvIHZhbHVlIG1hcCkuXG4gICAgICovXG4gICAgZWxlbWVudFV0aWxpdGllcy5jaGFuZ2VDc3MgPSBmdW5jdGlvbihlbGVzLCBuYW1lLCB2YWx1ZU1hcCkge1xuICAgICAgaWYgKCB0eXBlb2YgdmFsdWVNYXAgPT09ICdvYmplY3QnICkge1xuICAgICAgICBjeS5zdGFydEJhdGNoKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBlbGUgPSBjeS5nZXRFbGVtZW50QnlJZChlbGVzW2ldLmlkKCkpO1xuICAgICAgICAgIGVsZS5jc3MobmFtZSwgdmFsdWVNYXBbZWxlLmlkKCldKTsgLy8gdmFsdWVNYXAgaXMgYW4gaWQgdG8gdmFsdWUgbWFwIHVzZSBpdCBpbiB0aGlzIHdheVxuICAgICAgICB9XG4gICAgICAgIGN5LmVuZEJhdGNoKCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZWxlcy5jc3MobmFtZSwgdmFsdWVNYXApOyAvLyB2YWx1ZU1hcCBpcyBqdXN0IGEgc3RyaW5nIHNldCBjc3MoJ25hbWUnKSBmb3IgYWxsIGVsZXMgdG8gdGhpcyB2YWx1ZVxuICAgICAgfVxuICAgIH07XG5cbiAgICAvKlxuICAgICAqIENoYW5nZSBkYXRhIG9mIGdpdmVuIGVsZXMgYnkgc2V0dGluZyBnZXR0aW5nIHByb3BlcnR5IG5hbWUgdG8gdGhlIGdpdmVuIHZhbHVlL3ZhbHVlcyAoTm90ZSB0aGF0IHZhbHVlTWFwIHBhcmFtZXRlciBtYXkgYmVcbiAgICAgKiBhIHNpbmdsZSBzdHJpbmcgb3IgYW4gaWQgdG8gdmFsdWUgbWFwKS5cbiAgICAgKi9cbiAgICBlbGVtZW50VXRpbGl0aWVzLmNoYW5nZURhdGEgPSBmdW5jdGlvbihlbGVzLCBuYW1lLCB2YWx1ZU1hcCkge1xuICAgICAgaWYgKCB0eXBlb2YgdmFsdWVNYXAgPT09ICdvYmplY3QnICkge1xuICAgICAgICBjeS5zdGFydEJhdGNoKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBlbGUgPSBjeS5nZXRFbGVtZW50QnlJZChlbGVzW2ldLmlkKCkpO1xuICAgICAgICAgIGVsZS5kYXRhKG5hbWUsIHZhbHVlTWFwW2VsZS5pZCgpXSk7IC8vIHZhbHVlTWFwIGlzIGFuIGlkIHRvIHZhbHVlIG1hcCB1c2UgaXQgaW4gdGhpcyB3YXlcbiAgICAgICAgfVxuICAgICAgICBjeS5lbmRCYXRjaCgpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGVsZXMuZGF0YShuYW1lLCB2YWx1ZU1hcCk7IC8vIHZhbHVlTWFwIGlzIGp1c3QgYSBzdHJpbmcgc2V0IGNzcygnbmFtZScpIGZvciBhbGwgZWxlcyB0byB0aGlzIHZhbHVlXG4gICAgICB9XG4gICAgfTtcblxuICAgIGVsZW1lbnRVdGlsaXRpZXMudXBkYXRlU2V0RmllbGQgPSBmdW5jdGlvbihlbGUsIGZpZWxkTmFtZSwgdG9EZWxldGUsIHRvQWRkLCBjYWxsYmFjaykge1xuICAgICAgdmFyIHNldCA9IGVsZS5kYXRhKCBmaWVsZE5hbWUgKTtcbiAgICAgIGlmICggIXNldCApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHVwZGF0ZXMgPSB7fTtcblxuICAgICAgaWYgKCB0b0RlbGV0ZSAhPSBudWxsICYmIHNldFsgdG9EZWxldGUgXSApIHtcbiAgICAgICAgZGVsZXRlIHNldFsgdG9EZWxldGUgXTtcbiAgICAgICAgdXBkYXRlcy5kZWxldGVkID0gdG9EZWxldGU7XG4gICAgICB9XG5cbiAgICAgIGlmICggdG9BZGQgIT0gbnVsbCApIHtcbiAgICAgICAgc2V0WyB0b0FkZCBdID0gdHJ1ZTtcbiAgICAgICAgdXBkYXRlcy5hZGRlZCA9IHRvQWRkO1xuICAgICAgfVxuXG4gICAgICBpZiAoIGNhbGxiYWNrICYmICggdXBkYXRlc1sgJ2RlbGV0ZWQnIF0gIT0gbnVsbCB8fCB1cGRhdGVzWyAnYWRkZWQnIF0gIT0gbnVsbCApICkge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdXBkYXRlcztcbiAgICB9O1xuXG4gICAgLypcbiAgICAgKiBSZXR1cm4gdGhlIHNldCBvZiBhbGwgbm9kZXMgcHJlc2VudCB1bmRlciB0aGUgZ2l2ZW4gcG9zaXRpb25cbiAgICAgKiByZW5kZXJlZFBvcyBtdXN0IGJlIGEgcG9pbnQgZGVmaW5lZCByZWxhdGl2ZWx5IHRvIGN5dG9zY2FwZSBjb250YWluZXJcbiAgICAgKiAobGlrZSByZW5kZXJlZFBvc2l0aW9uIGZpZWxkIG9mIGEgbm9kZSlcbiAgICAgKi9cbiAgICBlbGVtZW50VXRpbGl0aWVzLmdldE5vZGVzQXQgPSBmdW5jdGlvbihyZW5kZXJlZFBvcykge1xuICAgICAgdmFyIG5vZGVzID0gY3kubm9kZXMoKTtcbiAgICAgIHZhciB4ID0gcmVuZGVyZWRQb3MueDtcbiAgICAgIHZhciB5ID0gcmVuZGVyZWRQb3MueTtcbiAgICAgIHZhciByZXN1bHROb2RlcyA9IFtdO1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIHZhciByZW5kZXJlZEJib3ggPSBub2RlLnJlbmRlcmVkQm91bmRpbmdCb3goe1xuICAgICAgICAgIGluY2x1ZGVOb2RlczogdHJ1ZSxcbiAgICAgICAgICBpbmNsdWRlRWRnZXM6IGZhbHNlLFxuICAgICAgICAgIGluY2x1ZGVMYWJlbHM6IGZhbHNlLFxuICAgICAgICAgIGluY2x1ZGVTaGFkb3dzOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHggPj0gcmVuZGVyZWRCYm94LngxICYmIHggPD0gcmVuZGVyZWRCYm94LngyKSB7XG4gICAgICAgICAgaWYgKHkgPj0gcmVuZGVyZWRCYm94LnkxICYmIHkgPD0gcmVuZGVyZWRCYm94LnkyKSB7XG4gICAgICAgICAgICByZXN1bHROb2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdE5vZGVzO1xuICAgIH07XG5cbiAgICBlbGVtZW50VXRpbGl0aWVzLmRlbXVsdGltZXJpemVDbGFzcyA9IGZ1bmN0aW9uKHNiZ25jbGFzcykge1xuICAgICAgcmV0dXJuIHNiZ25jbGFzcy5yZXBsYWNlKFwiIG11bHRpbWVyXCIsIFwiXCIpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbWFwVHlwZSAtIHR5cGUgb2YgdGhlIGN1cnJlbnQgbWFwIChQRCwgQUYgb3IgVW5rbm93bilcbiAgICAgKi9cbiAgICBlbGVtZW50VXRpbGl0aWVzLnNldE1hcFR5cGUgPSBmdW5jdGlvbihtYXBUeXBlKXtcbiAgICAgIGVsZW1lbnRVdGlsaXRpZXMubWFwVHlwZSA9IG1hcFR5cGU7XG4gICAgICByZXR1cm4gbWFwVHlwZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZXR1cm4gLSBtYXAgdHlwZVxuICAgICAqL1xuICAgIGVsZW1lbnRVdGlsaXRpZXMuZ2V0TWFwVHlwZSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiBlbGVtZW50VXRpbGl0aWVzLm1hcFR5cGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2V0cyBtYXAgdHlwZVxuICAgICAqL1xuICAgIGVsZW1lbnRVdGlsaXRpZXMucmVzZXRNYXBUeXBlID0gZnVuY3Rpb24oKXtcbiAgICAgICAgZWxlbWVudFV0aWxpdGllcy5tYXBUeXBlID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEtlZXAgY29uc2lzdGVuY3kgb2YgbGlua3MgdG8gc2VsZiBpbnNpZGUgdGhlIGRhdGEoKSBzdHJ1Y3R1cmUuXG4gICAgICogVGhpcyBpcyBuZWVkZWQgd2hlbmV2ZXIgYSBub2RlIGNoYW5nZXMgcGFyZW50cywgZm9yIGV4YW1wbGUsXG4gICAgICogYXMgaXQgaXMgZGVzdHJveWVkIGFuZCByZWNyZWF0ZWQuIEJ1dCB0aGUgZGF0YSgpIHN0YXlzIGlkZW50aWNhbC5cbiAgICAgKiBUaGlzIGNyZWF0ZXMgaW5jb25zaXN0ZW5jaWVzIGZvciB0aGUgcG9pbnRlcnMgc3RvcmVkIGluIGRhdGEoKSxcbiAgICAgKiBhcyB0aGV5IG5vdyBwb2ludCB0byBhIGRlbGV0ZWQgbm9kZS5cbiAgICAgKi9cbiAgICBlbGVtZW50VXRpbGl0aWVzLm1haW50YWluUG9pbnRlciA9IGZ1bmN0aW9uIChlbGVzKSB7XG4gICAgICBlbGVzLm5vZGVzKCkuZm9yRWFjaChmdW5jdGlvbihlbGUpe1xuICAgICAgICAvLyByZXN0b3JlIGJhY2tncm91bmQgaW1hZ2VzXG4gICAgICAgIGVsZS5lbWl0KCdkYXRhJyk7XG5cbiAgICAgICAgLy8gc2tpcCBub2RlcyB3aXRob3V0IGFueSBhdXhpbGlhcnkgdW5pdHNcbiAgICAgICAgaWYoIWVsZS5kYXRhKCdzdGF0ZXNhbmRpbmZvcycpIHx8IGVsZS5kYXRhKCdzdGF0ZXNhbmRpbmZvcycpLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvcih2YXIgc2lkZSBpbiBlbGUuZGF0YSgnYXV4dW5pdGxheW91dHMnKSkge1xuICAgICAgICAgIGVsZS5kYXRhKCdhdXh1bml0bGF5b3V0cycpW3NpZGVdLnBhcmVudE5vZGUgPSBlbGUuaWQoKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IodmFyIGk9MDsgaSA8IGVsZS5kYXRhKCdzdGF0ZXNhbmRpbmZvcycpLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgZWxlLmRhdGEoJ3N0YXRlc2FuZGluZm9zJylbaV0ucGFyZW50ID0gZWxlLmlkKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGVsZW1lbnRVdGlsaXRpZXMuYW55SGFzQmFja2dyb3VuZEltYWdlID0gZnVuY3Rpb24gKGVsZXMpIHtcbiAgICAgIHZhciBvYmogPSBlbGVtZW50VXRpbGl0aWVzLmdldEJhY2tncm91bmRJbWFnZU9ianMoZWxlcyk7XG4gICAgICBpZihvYmogPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgZWxzZXtcbiAgICAgICAgZm9yKHZhciBrZXkgaW4gb2JqKXtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBvYmpba2V5XTtcbiAgICAgICAgICBpZih2YWx1ZSAmJiAhJC5pc0VtcHR5T2JqZWN0KHZhbHVlKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBlbGVtZW50VXRpbGl0aWVzLmhhc0JhY2tncm91bmRJbWFnZSA9IGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgIGlmICghZWxlLmlzTm9kZSgpIHx8ICFlbGUuZGF0YSgnYmFja2dyb3VuZC1pbWFnZScpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBiZztcbiAgICAgIFxuICAgICAgaWYodHlwZW9mIGVsZS5kYXRhKCdiYWNrZ3JvdW5kLWltYWdlJykgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgYmcgPSBlbGUuZGF0YSgnYmFja2dyb3VuZC1pbWFnZScpLnNwbGl0KFwiIFwiKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYoQXJyYXkuaXNBcnJheShvYmpbJ2JhY2tncm91bmQtaW1hZ2UnXSkpIHtcbiAgICAgICAgYmcgPSBlbGUuZGF0YSgnYmFja2dyb3VuZC1pbWFnZScpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWJnKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIHZhciBjbG9uZUltZyA9ICdkYXRhOmltYWdlL3N2Zyt4bWw7dXRmOCwlM0NzdmclMjB3aWR0aCUzRCUyMjEwMCUyMiUyMGhlaWdodCUzRCUyMjEwMCUyMiUyMHZpZXdCb3glM0QlMjIwJTIwMCUyMDEwMCUyMDEwMCUyMiUyMHN0eWxlJTNEJTIyZmlsbCUzQW5vbmUlM0JzdHJva2UlM0FibGFjayUzQnN0cm9rZS13aWR0aCUzQTAlM0IlMjIlMjB4bWxucyUzRCUyMmh0dHAlM0EvL3d3dy53My5vcmcvMjAwMC9zdmclMjIlMjAlM0UlM0NyZWN0JTIweCUzRCUyMjAlMjIlMjB5JTNEJTIyMCUyMiUyMHdpZHRoJTNEJTIyMTAwJTIyJTIwaGVpZ2h0JTNEJTIyMTAwJTIyJTIwc3R5bGUlM0QlMjJmaWxsJTNBJTIzODM4MzgzJTIyLyUzRSUyMCUzQy9zdmclM0UnO1xuICAgICAgLy8gSWYgY2xvbmVJbWcgaXMgbm90IHRoZSBvbmx5IGltYWdlIG9yIHRoZXJlIGFyZSBtdWx0aXBsZSBpbWFnZXMgdGhlcmUgaXMgYSBiYWNrZ3JvdW5kIGltYWdlXG4gICAgICB2YXIgb25seUhhc0Nsb25lTWFya2VyQXNCZ0ltYWdlID0gKGJnLmxlbmd0aCA9PT0gMSkgJiYgKGJnLmluZGV4T2YoY2xvbmVJbWcpID09PSAwKTtcblxuICAgICAgaWYoYmcubGVuZ3RoID4gMSB8fCAhKG9ubHlIYXNDbG9uZU1hcmtlckFzQmdJbWFnZSkpXG4gICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZWxlbWVudFV0aWxpdGllcy5nZXRCYWNrZ3JvdW5kSW1hZ2VVUkwgPSBmdW5jdGlvbiAoZWxlcykge1xuICAgICAgaWYoIWVsZXMgfHwgZWxlcy5sZW5ndGggPCAxKVxuICAgICAgICByZXR1cm47XG5cbiAgICAgIHZhciBjb21tb25VUkwgPSBcIlwiO1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgZWxlID0gZWxlc1tpXTtcblxuICAgICAgICBpZighZWxlLmlzTm9kZSgpIHx8ICFlbGVtZW50VXRpbGl0aWVzLmhhc0JhY2tncm91bmRJbWFnZShlbGUpKVxuICAgICAgICAgIHJldHVybjtcblxuICAgICAgICB2YXIgdXJsID0gZWxlLmRhdGEoJ2JhY2tncm91bmQtaW1hZ2UnKS5zcGxpdChcIiBcIikucG9wKCk7XG4gICAgICAgIGlmKCF1cmwgfHwgdXJsLmluZGV4T2YoJ2h0dHAnKSAhPT0gMCB8fCAoY29tbW9uVVJMICE9PSBcIlwiICYmIGNvbW1vblVSTCAhPT0gdXJsKSlcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGVsc2UgaWYoY29tbW9uVVJMID09PSBcIlwiKVxuICAgICAgICAgIGNvbW1vblVSTCA9IHVybDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbW1vblVSTDtcbiAgICB9XG5cbiAgICBlbGVtZW50VXRpbGl0aWVzLmdldEJhY2tncm91bmRJbWFnZU9ianMgPSBmdW5jdGlvbiAoZWxlcykge1xuICAgICAgaWYoIWVsZXMgfHwgZWxlcy5sZW5ndGggPCAxKVxuICAgICAgICByZXR1cm47XG5cbiAgICAgIHZhciBsaXN0ID0ge307XG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgICB2YXIgb2JqID0gZ2V0QmdPYmooZWxlKTtcbiAgICAgICAgaWYoT2JqZWN0LmtleXMob2JqKS5sZW5ndGggPCAxKVxuICAgICAgICAgIHJldHVybjtcblxuICAgICAgICBsaXN0W2VsZS5kYXRhKCdpZCcpXSA9IG9iajtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsaXN0O1xuXG4gICAgICBmdW5jdGlvbiBnZXRCZ09iaiAoZWxlKSB7XG4gICAgICAgIGlmKGVsZS5pc05vZGUoKSAmJiBlbGVtZW50VXRpbGl0aWVzLmhhc0JhY2tncm91bmRJbWFnZShlbGUpKXtcbiAgICAgICAgICB2YXIga2V5cyA9IFsnYmFja2dyb3VuZC1pbWFnZScsICdiYWNrZ3JvdW5kLWZpdCcsICdiYWNrZ3JvdW5kLWltYWdlLW9wYWNpdHknLFxuICAgICAgICAgICdiYWNrZ3JvdW5kLXBvc2l0aW9uLXgnLCAnYmFja2dyb3VuZC1wb3NpdGlvbi15JywgJ2JhY2tncm91bmQtaGVpZ2h0JywgJ2JhY2tncm91bmQtd2lkdGgnXTtcblxuICAgICAgICAgIHZhciBvYmogPSB7fTtcbiAgICAgICAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgICAgICBpZiAoZWxlLmRhdGEoa2V5KSAmJiAodHlwZW9mIGVsZS5kYXRhKGtleSkgPT09IFwic3RyaW5nXCIpKSB7XG4gICAgICAgICAgICAgIHZhbHVlID0gZWxlLmRhdGEoa2V5KS5zcGxpdChcIiBcIilbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdmFsdWUgPSBlbGUuZGF0YShrZXkpO1xuICAgICAgICAgICAgfSAgICAgICAgICAgXG4gICAgICAgICAgICBvYmpba2V5XSA9IHZhbHVlO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmKGVsZS5pc05vZGUoKSlcbiAgICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG4gICAgfVxuXG4gICAgZWxlbWVudFV0aWxpdGllcy5nZXRCYWNrZ3JvdW5kRml0T3B0aW9ucyA9IGZ1bmN0aW9uIChlbGVzKSB7XG4gICAgICBpZighZWxlcyB8fCBlbGVzLmxlbmd0aCA8IDEpXG4gICAgICAgIHJldHVybjtcblxuICAgICAgdmFyIGNvbW1vbkZpdCA9IFwiXCI7XG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBub2RlID0gZWxlc1tpXTtcbiAgICAgICAgaWYoIW5vZGUuaXNOb2RlKCkpXG4gICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIHZhciBmaXQgPSBnZXRGaXRPcHRpb24obm9kZSk7XG4gICAgICAgIGlmKCFmaXQgfHwgKGNvbW1vbkZpdCAhPT0gXCJcIiAmJiBmaXQgIT09IGNvbW1vbkZpdCkpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBlbHNlIGlmKGNvbW1vbkZpdCA9PT0gXCJcIilcbiAgICAgICAgICBjb21tb25GaXQgPSBmaXQ7XG4gICAgICB9XG5cbiAgICAgIHZhciBvcHRpb25zID0gJzxvcHRpb24gdmFsdWU9XCJub25lXCI+Tm9uZTwvb3B0aW9uPidcbiAgICAgICAgICAgICAgICAgICsgJzxvcHRpb24gdmFsdWU9XCJmaXRcIj5GaXQ8L29wdGlvbj4nXG4gICAgICAgICAgICAgICAgICArICc8b3B0aW9uIHZhbHVlPVwiY292ZXJcIj5Db3Zlcjwvb3B0aW9uPidcbiAgICAgICAgICAgICAgICAgICsgJzxvcHRpb24gdmFsdWU9XCJjb250YWluXCI+Q29udGFpbjwvb3B0aW9uPic7XG4gICAgICB2YXIgc2VhcmNoS2V5ID0gJ3ZhbHVlPVwiJyArIGNvbW1vbkZpdCArICdcIic7XG4gICAgICB2YXIgaW5kZXggPSBvcHRpb25zLmluZGV4T2Yoc2VhcmNoS2V5KSArIHNlYXJjaEtleS5sZW5ndGg7XG4gICAgICByZXR1cm4gb3B0aW9ucy5zdWJzdHIoMCwgaW5kZXgpICsgJyBzZWxlY3RlZCcgKyBvcHRpb25zLnN1YnN0cihpbmRleCk7XG5cbiAgICAgIGZ1bmN0aW9uIGdldEZpdE9wdGlvbihub2RlKSB7XG4gICAgICAgIGlmKCFlbGVtZW50VXRpbGl0aWVzLmhhc0JhY2tncm91bmRJbWFnZShub2RlKSlcbiAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgdmFyIGYgPSBub2RlLmRhdGEoJ2JhY2tncm91bmQtZml0Jyk7XG4gICAgICAgIHZhciBoID0gbm9kZS5kYXRhKCdiYWNrZ3JvdW5kLWhlaWdodCcpO1xuXG4gICAgICAgIGlmKCFmIHx8ICFoKVxuICAgICAgICAgIHJldHVybjtcblxuICAgICAgICBmID0gZi5zcGxpdChcIiBcIik7XG4gICAgICAgIGggPSBoLnNwbGl0KFwiIFwiKTtcbiAgICAgICAgaWYoZltmLmxlbmd0aC0xXSA9PT0gXCJub25lXCIpXG4gICAgICAgICAgcmV0dXJuIChoW2gubGVuZ3RoLTFdID09PSBcImF1dG9cIiA/IFwibm9uZVwiIDogXCJmaXRcIik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICByZXR1cm4gZltmLmxlbmd0aC0xXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBlbGVtZW50VXRpbGl0aWVzLnVwZGF0ZUJhY2tncm91bmRJbWFnZSA9IGZ1bmN0aW9uIChub2RlcywgYmdPYmopIHtcbiAgICAgIGlmKCFub2RlcyB8fCBub2Rlcy5sZW5ndGggPT0gMCB8fCAhYmdPYmopXG4gICAgICAgIHJldHVybjtcblxuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgdmFyIG9iaiA9IGJnT2JqW25vZGUuZGF0YSgnaWQnKV07XG4gICAgICAgIGlmKCFvYmogfHwgJC5pc0VtcHR5T2JqZWN0KG9iaikpXG4gICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgdmFyIGltZ3MgPSBub2RlLmRhdGEoJ2JhY2tncm91bmQtaW1hZ2UnKSA/IG5vZGUuZGF0YSgnYmFja2dyb3VuZC1pbWFnZScpLnNwbGl0KFwiIFwiKSA6IFtdO1xuICAgICAgICB2YXIgeFBvcyA9IG5vZGUuZGF0YSgnYmFja2dyb3VuZC1wb3NpdGlvbi14JykgPyBub2RlLmRhdGEoJ2JhY2tncm91bmQtcG9zaXRpb24teCcpLnNwbGl0KFwiIFwiKSA6IFtdO1xuICAgICAgICB2YXIgeVBvcyA9IG5vZGUuZGF0YSgnYmFja2dyb3VuZC1wb3NpdGlvbi15JykgPyBub2RlLmRhdGEoJ2JhY2tncm91bmQtcG9zaXRpb24teScpLnNwbGl0KFwiIFwiKSA6IFtdO1xuICAgICAgICB2YXIgd2lkdGhzID0gbm9kZS5kYXRhKCdiYWNrZ3JvdW5kLXdpZHRoJykgPyBub2RlLmRhdGEoJ2JhY2tncm91bmQtd2lkdGgnKS5zcGxpdChcIiBcIikgOiBbXTtcbiAgICAgICAgdmFyIGhlaWdodHMgPSBub2RlLmRhdGEoJ2JhY2tncm91bmQtaGVpZ2h0JykgPyBub2RlLmRhdGEoJ2JhY2tncm91bmQtaGVpZ2h0Jykuc3BsaXQoXCIgXCIpIDogW107XG4gICAgICAgIHZhciBmaXRzID0gbm9kZS5kYXRhKCdiYWNrZ3JvdW5kLWZpdCcpID8gbm9kZS5kYXRhKCdiYWNrZ3JvdW5kLWZpdCcpLnNwbGl0KFwiIFwiKSA6IFtdO1xuICAgICAgICB2YXIgb3BhY2l0aWVzID0gbm9kZS5kYXRhKCdiYWNrZ3JvdW5kLWltYWdlLW9wYWNpdHknKSA/IChcIlwiICsgbm9kZS5kYXRhKCdiYWNrZ3JvdW5kLWltYWdlLW9wYWNpdHknKSkuc3BsaXQoXCIgXCIpIDogW107XG5cbiAgICAgICAgdmFyIGluZGV4ID0gLTE7XG4gICAgICAgIGlmKHR5cGVvZiBvYmpbJ2JhY2tncm91bmQtaW1hZ2UnXSA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICBpbmRleCA9IGltZ3MuaW5kZXhPZihvYmpbJ2JhY2tncm91bmQtaW1hZ2UnXSk7XG4gICAgICAgIGVsc2UgaWYoQXJyYXkuaXNBcnJheShvYmpbJ2JhY2tncm91bmQtaW1hZ2UnXSkpXG4gICAgICAgICAgaW5kZXggPSBpbWdzLmluZGV4T2Yob2JqWydiYWNrZ3JvdW5kLWltYWdlJ11bMF0pO1xuXG4gICAgICAgIGlmKGluZGV4IDwgMClcbiAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICBpZihvYmpbJ2JhY2tncm91bmQtaW1hZ2UnXSAmJiBpbWdzLmxlbmd0aCA+IGluZGV4KXtcbiAgICAgICAgICB2YXIgdG1wID0gaW1nc1tpbmRleF07XG4gICAgICAgICAgaW1nc1tpbmRleF0gPSBvYmpbJ2JhY2tncm91bmQtaW1hZ2UnXTtcbiAgICAgICAgICBvYmpbJ2JhY2tncm91bmQtaW1hZ2UnXSA9IHRtcDtcbiAgICAgICAgfVxuICAgICAgICBpZihvYmpbJ2JhY2tncm91bmQtZml0J10gJiYgZml0cy5sZW5ndGggPiBpbmRleCl7XG4gICAgICAgICAgdmFyIHRtcCA9IGZpdHNbaW5kZXhdO1xuICAgICAgICAgIGZpdHNbaW5kZXhdID0gb2JqWydiYWNrZ3JvdW5kLWZpdCddO1xuICAgICAgICAgIG9ialsnYmFja2dyb3VuZC1maXQnXSA9IHRtcDtcbiAgICAgICAgfVxuICAgICAgICBpZihvYmpbJ2JhY2tncm91bmQtd2lkdGgnXSAmJiB3aWR0aHMubGVuZ3RoID4gaW5kZXgpe1xuICAgICAgICAgIHZhciB0bXAgPSB3aWR0aHNbaW5kZXhdO1xuICAgICAgICAgIHdpZHRoc1tpbmRleF0gPSBvYmpbJ2JhY2tncm91bmQtd2lkdGgnXTtcbiAgICAgICAgICBvYmpbJ2JhY2tncm91bmQtd2lkdGgnXSA9IHRtcDtcbiAgICAgICAgfVxuICAgICAgICBpZihvYmpbJ2JhY2tncm91bmQtaGVpZ2h0J10gJiYgaGVpZ2h0cy5sZW5ndGggPiBpbmRleCl7XG4gICAgICAgICAgdmFyIHRtcCA9IGhlaWdodHNbaW5kZXhdO1xuICAgICAgICAgIGhlaWdodHNbaW5kZXhdID0gb2JqWydiYWNrZ3JvdW5kLWhlaWdodCddO1xuICAgICAgICAgIG9ialsnYmFja2dyb3VuZC1oZWlnaHQnXSA9IHRtcDtcbiAgICAgICAgfVxuICAgICAgICBpZihvYmpbJ2JhY2tncm91bmQtcG9zaXRpb24teCddICYmIHhQb3MubGVuZ3RoID4gaW5kZXgpe1xuICAgICAgICAgIHZhciB0bXAgPSB4UG9zW2luZGV4XTtcbiAgICAgICAgICB4UG9zW2luZGV4XSA9IG9ialsnYmFja2dyb3VuZC1wb3NpdGlvbi14J107XG4gICAgICAgICAgb2JqWydiYWNrZ3JvdW5kLXBvc2l0aW9uLXgnXSA9IHRtcDtcbiAgICAgICAgfVxuICAgICAgICBpZihvYmpbJ2JhY2tncm91bmQtcG9zaXRpb24teSddICYmIHlQb3MubGVuZ3RoID4gaW5kZXgpe1xuICAgICAgICAgIHZhciB0bXAgPSB5UG9zW2luZGV4XTtcbiAgICAgICAgICB5UG9zW2luZGV4XSA9IG9ialsnYmFja2dyb3VuZC1wb3NpdGlvbi15J107XG4gICAgICAgICAgb2JqWydiYWNrZ3JvdW5kLXBvc2l0aW9uLXknXSA9IHRtcDtcbiAgICAgICAgfVxuICAgICAgICBpZihvYmpbJ2JhY2tncm91bmQtaW1hZ2Utb3BhY2l0eSddICYmIG9wYWNpdGllcy5sZW5ndGggPiBpbmRleCl7XG4gICAgICAgICAgdmFyIHRtcCA9IG9wYWNpdGllc1tpbmRleF07XG4gICAgICAgICAgb3BhY2l0aWVzW2luZGV4XSA9IG9ialsnYmFja2dyb3VuZC1pbWFnZS1vcGFjaXR5J107XG4gICAgICAgICAgb2JqWydiYWNrZ3JvdW5kLWltYWdlLW9wYWNpdHknXSA9IHRtcDtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUuZGF0YSgnYmFja2dyb3VuZC1pbWFnZScsIGltZ3Muam9pbihcIiBcIikpO1xuICAgICAgICBub2RlLmRhdGEoJ2JhY2tncm91bmQtcG9zaXRpb24teCcsIHhQb3Muam9pbihcIiBcIikpO1xuICAgICAgICBub2RlLmRhdGEoJ2JhY2tncm91bmQtcG9zaXRpb24teScsIHlQb3Muam9pbihcIiBcIikpO1xuICAgICAgICBub2RlLmRhdGEoJ2JhY2tncm91bmQtd2lkdGgnLCB3aWR0aHMuam9pbihcIiBcIikpO1xuICAgICAgICBub2RlLmRhdGEoJ2JhY2tncm91bmQtaGVpZ2h0JywgaGVpZ2h0cy5qb2luKFwiIFwiKSk7XG4gICAgICAgIG5vZGUuZGF0YSgnYmFja2dyb3VuZC1maXQnLCBmaXRzLmpvaW4oXCIgXCIpKTtcbiAgICAgICAgbm9kZS5kYXRhKCdiYWNrZ3JvdW5kLWltYWdlLW9wYWNpdHknLCBvcGFjaXRpZXMuam9pbihcIiBcIikpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYmdPYmo7XG4gICAgfVxuXG4gICAgZWxlbWVudFV0aWxpdGllcy5jaGFuZ2VCYWNrZ3JvdW5kSW1hZ2UgPSBmdW5jdGlvbiAobm9kZXMsIG9sZEltZywgbmV3SW1nLCBmaXJzdFRpbWUsIHVwZGF0ZUluZm8sIHByb21wdEludmFsaWRJbWFnZSwgdmFsaWRhdGVVUkwpIHtcbiAgICAgIGlmKCFub2RlcyB8fCBub2Rlcy5sZW5ndGggPT0gMCB8fCAhb2xkSW1nIHx8ICFuZXdJbWcpXG4gICAgICAgIHJldHVybjtcblxuICAgICAgZWxlbWVudFV0aWxpdGllcy5yZW1vdmVCYWNrZ3JvdW5kSW1hZ2Uobm9kZXMsIG9sZEltZyk7XG4gICAgICBmb3IodmFyIGtleSBpbiBuZXdJbWcpe1xuICAgICAgICBuZXdJbWdba2V5XVsnZmlyc3RUaW1lJ10gPSBmaXJzdFRpbWU7XG4gICAgICB9XG4gICAgICBlbGVtZW50VXRpbGl0aWVzLmFkZEJhY2tncm91bmRJbWFnZShub2RlcywgbmV3SW1nLCB1cGRhdGVJbmZvLCBwcm9tcHRJbnZhbGlkSW1hZ2UsIHZhbGlkYXRlVVJMKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbm9kZXM6IG5vZGVzLFxuICAgICAgICBvbGRJbWc6IG5ld0ltZyxcbiAgICAgICAgbmV3SW1nOiBvbGRJbWcsXG4gICAgICAgIGZpcnN0VGltZTogZmFsc2UsXG4gICAgICAgIHByb21wdEludmFsaWRJbWFnZTogcHJvbXB0SW52YWxpZEltYWdlLFxuICAgICAgICB2YWxpZGF0ZVVSTDogdmFsaWRhdGVVUkxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gQWRkIGEgYmFja2dyb3VuZCBpbWFnZSB0byBnaXZlbiBub2Rlcy5cbiAgICBlbGVtZW50VXRpbGl0aWVzLmFkZEJhY2tncm91bmRJbWFnZSA9IGZ1bmN0aW9uIChub2RlcywgYmdPYmosIHVwZGF0ZUluZm8sIHByb21wdEludmFsaWRJbWFnZSwgdmFsaWRhdGVVUkwpIHtcbiAgICAgIGlmKCFub2RlcyB8fCBub2Rlcy5sZW5ndGggPT0gMCB8fCAhYmdPYmopXG4gICAgICAgIHJldHVybjtcblxuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgdmFyIG9iaiA9IGJnT2JqW25vZGUuZGF0YSgnaWQnKV07XG4gICAgICAgIGlmKCFvYmogfHwgJC5pc0VtcHR5T2JqZWN0KG9iaikpXG4gICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgLy8gTG9hZCB0aGUgaW1hZ2UgZnJvbSBsb2NhbCwgZWxzZSBqdXN0IHB1dCB0aGUgVVJMXG4gICAgICAgIGlmKG9ialsnZnJvbUZpbGUnXSlcbiAgICAgICAgbG9hZEJhY2tncm91bmRUaGVuQXBwbHkobm9kZSwgb2JqKTtcbiAgICAgICAgLy8gVmFsaWRpdHkgb2YgZ2l2ZW4gVVJMIHNob3VsZCBiZSBjaGVja2VkIGJlZm9yZSBhcHBseWluZyBpdFxuICAgICAgICBlbHNlIGlmKG9ialsnZmlyc3RUaW1lJ10pe1xuICAgICAgICAgIGlmKHR5cGVvZiB2YWxpZGF0ZVVSTCA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHZhbGlkYXRlVVJMKG5vZGUsIG9iaiwgYXBwbHlCYWNrZ3JvdW5kLCBwcm9tcHRJbnZhbGlkSW1hZ2UpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGNoZWNrR2l2ZW5VUkwobm9kZSwgb2JqKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgYXBwbHlCYWNrZ3JvdW5kKG5vZGUsIG9iaik7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGxvYWRCYWNrZ3JvdW5kVGhlbkFwcGx5KG5vZGUsIGJnT2JqKSB7XG4gICAgICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICB2YXIgaW1nRmlsZSA9IGJnT2JqWydiYWNrZ3JvdW5kLWltYWdlJ107XG5cbiAgICAgICAgLy8gQ2hlY2sgd2hldGhlciBnaXZlbiBmaWxlIGlzIGFuIGltYWdlIGZpbGVcbiAgICAgICAgaWYoaW1nRmlsZS50eXBlLmluZGV4T2YoXCJpbWFnZVwiKSAhPT0gMCl7XG4gICAgICAgICAgaWYocHJvbXB0SW52YWxpZEltYWdlKVxuICAgICAgICAgICAgcHJvbXB0SW52YWxpZEltYWdlKFwiSW52YWxpZCBpbWFnZSBmaWxlIGlzIGdpdmVuIVwiKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICByZWFkZXIucmVhZEFzRGF0YVVSTChpbWdGaWxlKTtcblxuICAgICAgICByZWFkZXIub25sb2FkID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICB2YXIgaW1nID0gcmVhZGVyLnJlc3VsdDtcbiAgICAgICAgICBpZihpbWcpe1xuICAgICAgICAgICAgYmdPYmpbJ2JhY2tncm91bmQtaW1hZ2UnXSA9IGltZztcbiAgICAgICAgICAgIGJnT2JqWydmcm9tRmlsZSddID0gZmFsc2U7XG4gICAgICAgICAgICBhcHBseUJhY2tncm91bmQobm9kZSwgYmdPYmopO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgaWYocHJvbXB0SW52YWxpZEltYWdlKVxuICAgICAgICAgICAgICBwcm9tcHRJbnZhbGlkSW1hZ2UoXCJHaXZlbiBmaWxlIGNvdWxkIG5vdCBiZSByZWFkIVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGNoZWNrR2l2ZW5VUkwobm9kZSwgYmdPYmope1xuICAgICAgICB2YXIgdXJsID0gYmdPYmpbJ2JhY2tncm91bmQtaW1hZ2UnXTtcbiAgICAgICAgdmFyIGV4dGVuc2lvbiA9ICh1cmwuc3BsaXQoL1s/I10vKVswXSkuc3BsaXQoXCIuXCIpLnBvcCgpO1xuICAgICAgICB2YXIgdmFsaWRFeHRlbnNpb25zID0gW1wicG5nXCIsIFwic3ZnXCIsIFwianBnXCIsIFwianBlZ1wiXTtcblxuICAgICAgICBpZighdmFsaWRFeHRlbnNpb25zLmluY2x1ZGVzKGV4dGVuc2lvbikpe1xuICAgICAgICAgIGlmKHR5cGVvZiBwcm9tcHRJbnZhbGlkSW1hZ2UgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICBwcm9tcHRJbnZhbGlkSW1hZ2UoXCJJbnZhbGlkIFVSTCBpcyBnaXZlbiFcIik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgJC5hamF4KHtcbiAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICB0eXBlOiAnR0VUJyxcbiAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbihyZXN1bHQsIHN0YXR1cywgeGhyKXtcbiAgICAgICAgICAgIGFwcGx5QmFja2dyb3VuZChub2RlLCBiZ09iaik7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlcnJvcjogZnVuY3Rpb24oeGhyLCBzdGF0dXMsIGVycm9yKXtcbiAgICAgICAgICAgIGlmKHByb21wdEludmFsaWRJbWFnZSlcbiAgICAgICAgICAgICAgcHJvbXB0SW52YWxpZEltYWdlKFwiSW52YWxpZCBVUkwgaXMgZ2l2ZW4hXCIpO1xuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBhcHBseUJhY2tncm91bmQobm9kZSwgYmdPYmopIHtcblxuICAgICAgICBpZihlbGVtZW50VXRpbGl0aWVzLmhhc0JhY2tncm91bmRJbWFnZShub2RlKSlcbiAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgdmFyIGltZ3MgPSBub2RlLmRhdGEoJ2JhY2tncm91bmQtaW1hZ2UnKSA/IG5vZGUuZGF0YSgnYmFja2dyb3VuZC1pbWFnZScpLnNwbGl0KFwiIFwiKSA6IFtdO1xuICAgICAgICB2YXIgeFBvcyA9IG5vZGUuZGF0YSgnYmFja2dyb3VuZC1wb3NpdGlvbi14JykgPyBub2RlLmRhdGEoJ2JhY2tncm91bmQtcG9zaXRpb24teCcpLnNwbGl0KFwiIFwiKSA6IFtdO1xuICAgICAgICB2YXIgeVBvcyA9IG5vZGUuZGF0YSgnYmFja2dyb3VuZC1wb3NpdGlvbi15JykgPyBub2RlLmRhdGEoJ2JhY2tncm91bmQtcG9zaXRpb24teScpLnNwbGl0KFwiIFwiKSA6IFtdO1xuICAgICAgICB2YXIgd2lkdGhzID0gbm9kZS5kYXRhKCdiYWNrZ3JvdW5kLXdpZHRoJykgPyBub2RlLmRhdGEoJ2JhY2tncm91bmQtd2lkdGgnKS5zcGxpdChcIiBcIikgOiBbXTtcbiAgICAgICAgdmFyIGhlaWdodHMgPSBub2RlLmRhdGEoJ2JhY2tncm91bmQtaGVpZ2h0JykgPyBub2RlLmRhdGEoJ2JhY2tncm91bmQtaGVpZ2h0Jykuc3BsaXQoXCIgXCIpIDogW107XG4gICAgICAgIHZhciBmaXRzID0gbm9kZS5kYXRhKCdiYWNrZ3JvdW5kLWZpdCcpID8gbm9kZS5kYXRhKCdiYWNrZ3JvdW5kLWZpdCcpLnNwbGl0KFwiIFwiKSA6IFtdO1xuICAgICAgICB2YXIgb3BhY2l0aWVzID0gbm9kZS5kYXRhKCdiYWNrZ3JvdW5kLWltYWdlLW9wYWNpdHknKSA/IChcIlwiICsgbm9kZS5kYXRhKCdiYWNrZ3JvdW5kLWltYWdlLW9wYWNpdHknKSkuc3BsaXQoXCIgXCIpIDogW107XG5cbiAgICAgICAgdmFyIGluZGV4VG9JbnNlcnQgPSBpbWdzLmxlbmd0aDtcblxuICAgICAgICAvLyBpbnNlcnQgdG8gbGVuZ3RoLTFcbiAgICAgICAgaWYoZWxlbWVudFV0aWxpdGllcy5oYXNDbG9uZU1hcmtlcihpbWdzKSl7XG4gICAgICAgICAgaW5kZXhUb0luc2VydC0tO1xuICAgICAgICB9XG5cbiAgICAgICAgaW1ncy5zcGxpY2UoaW5kZXhUb0luc2VydCwgMCwgYmdPYmpbJ2JhY2tncm91bmQtaW1hZ2UnXSk7XG4gICAgICAgIGZpdHMuc3BsaWNlKGluZGV4VG9JbnNlcnQsIDAsIGJnT2JqWydiYWNrZ3JvdW5kLWZpdCddKTtcbiAgICAgICAgb3BhY2l0aWVzLnNwbGljZShpbmRleFRvSW5zZXJ0LCAwLCBiZ09ialsnYmFja2dyb3VuZC1pbWFnZS1vcGFjaXR5J10pO1xuICAgICAgICB4UG9zLnNwbGljZShpbmRleFRvSW5zZXJ0LCAwLCBiZ09ialsnYmFja2dyb3VuZC1wb3NpdGlvbi14J10pO1xuICAgICAgICB5UG9zLnNwbGljZShpbmRleFRvSW5zZXJ0LCAwLCBiZ09ialsnYmFja2dyb3VuZC1wb3NpdGlvbi15J10pO1xuICAgICAgICB3aWR0aHMuc3BsaWNlKGluZGV4VG9JbnNlcnQsIDAsIGJnT2JqWydiYWNrZ3JvdW5kLXdpZHRoJ10pO1xuICAgICAgICBoZWlnaHRzLnNwbGljZShpbmRleFRvSW5zZXJ0LCAwLCBiZ09ialsnYmFja2dyb3VuZC1oZWlnaHQnXSk7XG5cbiAgICAgICAgbm9kZS5kYXRhKCdiYWNrZ3JvdW5kLWltYWdlJywgaW1ncy5qb2luKFwiIFwiKSk7XG4gICAgICAgIG5vZGUuZGF0YSgnYmFja2dyb3VuZC1wb3NpdGlvbi14JywgeFBvcy5qb2luKFwiIFwiKSk7XG4gICAgICAgIG5vZGUuZGF0YSgnYmFja2dyb3VuZC1wb3NpdGlvbi15JywgeVBvcy5qb2luKFwiIFwiKSk7XG4gICAgICAgIG5vZGUuZGF0YSgnYmFja2dyb3VuZC13aWR0aCcsIHdpZHRocy5qb2luKFwiIFwiKSk7XG4gICAgICAgIG5vZGUuZGF0YSgnYmFja2dyb3VuZC1oZWlnaHQnLCBoZWlnaHRzLmpvaW4oXCIgXCIpKTtcbiAgICAgICAgbm9kZS5kYXRhKCdiYWNrZ3JvdW5kLWZpdCcsIGZpdHMuam9pbihcIiBcIikpO1xuICAgICAgICBub2RlLmRhdGEoJ2JhY2tncm91bmQtaW1hZ2Utb3BhY2l0eScsIG9wYWNpdGllcy5qb2luKFwiIFwiKSk7XG4gICAgICAgIGJnT2JqWydmaXJzdFRpbWUnXSA9IGZhbHNlO1xuXG4gICAgICAgIGlmKHVwZGF0ZUluZm8pXG4gICAgICAgICAgdXBkYXRlSW5mbygpO1xuXG4gICAgICB9XG4gICAgfTtcblxuICAgIGVsZW1lbnRVdGlsaXRpZXMuaGFzQ2xvbmVNYXJrZXIgPSBmdW5jdGlvbiAoaW1ncykge1xuICAgICAgdmFyIGNsb25lSW1nID0gJ2RhdGE6aW1hZ2Uvc3ZnK3htbDt1dGY4LCUzQ3N2ZyUyMHdpZHRoJTNEJTIyMTAwJTIyJTIwaGVpZ2h0JTNEJTIyMTAwJTIyJTIwdmlld0JveCUzRCUyMjAlMjAwJTIwMTAwJTIwMTAwJTIyJTIwc3R5bGUlM0QlMjJmaWxsJTNBbm9uZSUzQnN0cm9rZSUzQWJsYWNrJTNCc3Ryb2tlLXdpZHRoJTNBMCUzQiUyMiUyMHhtbG5zJTNEJTIyaHR0cCUzQS8vd3d3LnczLm9yZy8yMDAwL3N2ZyUyMiUyMCUzRSUzQ3JlY3QlMjB4JTNEJTIyMCUyMiUyMHklM0QlMjIwJTIyJTIwd2lkdGglM0QlMjIxMDAlMjIlMjBoZWlnaHQlM0QlMjIxMDAlMjIlMjBzdHlsZSUzRCUyMmZpbGwlM0ElMjM4MzgzODMlMjIvJTNFJTIwJTNDL3N2ZyUzRSc7XG4gICAgICByZXR1cm4gKGltZ3MuaW5kZXhPZihjbG9uZUltZykgPiAtMSk7XG4gICAgfTtcblxuICAgIC8vIFJlbW92ZSBhIGJhY2tncm91bmQgaW1hZ2UgZnJvbSBnaXZlbiBub2Rlcy5cbiAgICBlbGVtZW50VXRpbGl0aWVzLnJlbW92ZUJhY2tncm91bmRJbWFnZSA9IGZ1bmN0aW9uIChub2RlcywgYmdPYmopIHtcbiAgICAgIGlmKCFub2RlcyB8fCBub2Rlcy5sZW5ndGggPT0gMCB8fCAhYmdPYmopXG4gICAgICAgIHJldHVybjtcblxuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgdmFyIG9iaiA9IGJnT2JqW25vZGUuZGF0YSgnaWQnKV07XG4gICAgICAgIGlmKCFvYmopXG4gICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgdmFyIGltZ3MgPSBub2RlLmRhdGEoJ2JhY2tncm91bmQtaW1hZ2UnKSA/IG5vZGUuZGF0YSgnYmFja2dyb3VuZC1pbWFnZScpLnNwbGl0KFwiIFwiKSA6IFtdO1xuICAgICAgICB2YXIgeFBvcyA9IG5vZGUuZGF0YSgnYmFja2dyb3VuZC1wb3NpdGlvbi14JykgPyBub2RlLmRhdGEoJ2JhY2tncm91bmQtcG9zaXRpb24teCcpLnNwbGl0KFwiIFwiKSA6IFtdO1xuICAgICAgICB2YXIgeVBvcyA9IG5vZGUuZGF0YSgnYmFja2dyb3VuZC1wb3NpdGlvbi15JykgPyBub2RlLmRhdGEoJ2JhY2tncm91bmQtcG9zaXRpb24teScpLnNwbGl0KFwiIFwiKSA6IFtdO1xuICAgICAgICB2YXIgd2lkdGhzID0gbm9kZS5kYXRhKCdiYWNrZ3JvdW5kLXdpZHRoJykgPyBub2RlLmRhdGEoJ2JhY2tncm91bmQtd2lkdGgnKS5zcGxpdChcIiBcIikgOiBbXTtcbiAgICAgICAgdmFyIGhlaWdodHMgPSBub2RlLmRhdGEoJ2JhY2tncm91bmQtaGVpZ2h0JykgPyBub2RlLmRhdGEoJ2JhY2tncm91bmQtaGVpZ2h0Jykuc3BsaXQoXCIgXCIpIDogW107XG4gICAgICAgIHZhciBmaXRzID0gbm9kZS5kYXRhKCdiYWNrZ3JvdW5kLWZpdCcpID8gbm9kZS5kYXRhKCdiYWNrZ3JvdW5kLWZpdCcpLnNwbGl0KFwiIFwiKSA6IFtdO1xuICAgICAgICB2YXIgb3BhY2l0aWVzID0gbm9kZS5kYXRhKCdiYWNrZ3JvdW5kLWltYWdlLW9wYWNpdHknKSA/IChcIlwiICsgbm9kZS5kYXRhKCdiYWNrZ3JvdW5kLWltYWdlLW9wYWNpdHknKSkuc3BsaXQoXCIgXCIpIDogW107XG5cbiAgICAgICAgdmFyIGluZGV4ID0gLTE7XG4gICAgICAgIGlmKHR5cGVvZiBvYmpbJ2JhY2tncm91bmQtaW1hZ2UnXSA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICBpbmRleCA9IGltZ3MuaW5kZXhPZihvYmpbJ2JhY2tncm91bmQtaW1hZ2UnXS5zcGxpdChcIiBcIilbMF0pO1xuICAgICAgICBlbHNlIGlmKEFycmF5LmlzQXJyYXkob2JqWydiYWNrZ3JvdW5kLWltYWdlJ10pKVxuICAgICAgICAgIGluZGV4ID0gaW1ncy5pbmRleE9mKG9ialsnYmFja2dyb3VuZC1pbWFnZSddWzBdKTtcblxuICAgICAgICBpZihpbmRleCA+IC0xKXtcbiAgICAgICAgICBpbWdzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgZml0cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgIG9wYWNpdGllcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgIHhQb3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICB5UG9zLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgd2lkdGhzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgaGVpZ2h0cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9kZS5kYXRhKCdiYWNrZ3JvdW5kLWltYWdlJywgaW1ncy5qb2luKFwiIFwiKSk7XG4gICAgICAgIG5vZGUuZGF0YSgnYmFja2dyb3VuZC1wb3NpdGlvbi14JywgeFBvcy5qb2luKFwiIFwiKSk7XG4gICAgICAgIG5vZGUuZGF0YSgnYmFja2dyb3VuZC1wb3NpdGlvbi15JywgeVBvcy5qb2luKFwiIFwiKSk7XG4gICAgICAgIG5vZGUuZGF0YSgnYmFja2dyb3VuZC13aWR0aCcsIHdpZHRocy5qb2luKFwiIFwiKSk7XG4gICAgICAgIG5vZGUuZGF0YSgnYmFja2dyb3VuZC1oZWlnaHQnLCBoZWlnaHRzLmpvaW4oXCIgXCIpKTtcbiAgICAgICAgbm9kZS5kYXRhKCdiYWNrZ3JvdW5kLWZpdCcsIGZpdHMuam9pbihcIiBcIikpO1xuICAgICAgICBub2RlLmRhdGEoJ2JhY2tncm91bmQtaW1hZ2Utb3BhY2l0eScsIG9wYWNpdGllcy5qb2luKFwiIFwiKSk7XG4gICAgICAgIGJnT2JqWydmaXJzdFRpbWUnXSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBlbGVtZW50VXRpbGl0aWVzLnJldmVyc2VFZGdlID0gZnVuY3Rpb24oZWRnZSl7XG4gICAgICB2YXIgb2xkU291cmNlID0gZWRnZS5zb3VyY2UoKS5pZCgpO1xuICAgICAgdmFyIG9sZFRhcmdldCA9IGVkZ2UudGFyZ2V0KCkuaWQoKTtcbiAgICAgIHZhciBvbGRQb3J0U291cmNlID0gZWRnZS5kYXRhKFwicG9ydHNvdXJjZVwiKTtcbiAgICAgIHZhciBvbGRQb3J0VGFyZ2V0ID0gZWRnZS5kYXRhKFwicG9ydHRhcmdldFwiKTtcbiAgICAgIHZhciBzZWdtZW50UG9pbnRzID0gZWRnZS5zZWdtZW50UG9pbnRzKCk7XG4gICAgICB2YXIgY29udHJvbFBvaW50cyA9IGVkZ2UuY29udHJvbFBvaW50cygpO1xuXG4gICAgICBlZGdlLmRhdGEoKS5zb3VyY2UgPSBvbGRUYXJnZXQ7XG4gICAgICBlZGdlLmRhdGEoKS50YXJnZXQgPSBvbGRTb3VyY2U7XG4gICAgICBlZGdlLmRhdGEoKS5wb3J0c291cmNlID0gb2xkUG9ydFRhcmdldDtcbiAgICAgIGVkZ2UuZGF0YSgpLnBvcnR0YXJnZXQgPSBvbGRQb3J0U291cmNlO1xuICAgICAgIGVkZ2UgPSBlZGdlLm1vdmUoe1xuICAgICAgICAgdGFyZ2V0OiBvbGRTb3VyY2UsXG4gICAgICAgICBzb3VyY2UgOiBvbGRUYXJnZXQgICAgICAgIFxuICAgICAgfSk7XG5cbiAgICAgIGlmKEFycmF5LmlzQXJyYXkoc2VnbWVudFBvaW50cykpe1xuICAgICAgICBzZWdtZW50UG9pbnRzLnJldmVyc2UoKTtcbiAgICAgICAgZWRnZS5kYXRhKCkuYmVuZFBvaW50UG9zaXRpb25zID0gc2VnbWVudFBvaW50cztcbiAgICAgICAgaWYoQXJyYXkuaXNBcnJheShjb250cm9sUG9pbnRzKSkge1xuICAgICAgICAgIGNvbnRyb2xQb2ludHMucmV2ZXJzZSgpO1xuICAgICAgICAgIGVkZ2UuZGF0YSgpLmNvbnRyb2xQb2ludFBvc2l0aW9ucyA9IGNvbnRyb2xQb2ludHM7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVkZ2VFZGl0aW5nID0gY3kuZWRnZUVkaXRpbmcoJ2dldCcpO1xuICAgICAgICBlZGdlRWRpdGluZy5pbml0QW5jaG9yUG9pbnRzKGVkZ2UpO1xuICAgICAgfVxuICAgIFxuXG4gICAgICByZXR1cm4gZWRnZTtcbiAgICB9XG5cbiAgfVxuXG4gIHJldHVybiBlbGVtZW50VXRpbGl0aWVzRXh0ZW5kZXI7XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/utilities/element-utilities-extender-factory.js\n");

/***/ }),

/***/ "./src/utilities/lib-utilities.js":
/*!****************************************!*\
  !*** ./src/utilities/lib-utilities.js ***!
  \****************************************/
/***/ ((module) => {

eval("/* \n * Utility file to get and set the libraries to which sbgnviz is dependent from any file.\n */\nvar libUtilities = function libUtilities() {};\n\nlibUtilities.setLibs = function (libs) {\n  this.libs = libs;\n};\n\nlibUtilities.getLibs = function () {\n  return this.libs;\n};\n\nmodule.exports = libUtilities;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jaGlzZS8uL3NyYy91dGlsaXRpZXMvbGliLXV0aWxpdGllcy5qcz9iYWFmIl0sIm5hbWVzIjpbImxpYlV0aWxpdGllcyIsInNldExpYnMiLCJsaWJzIiwiZ2V0TGlicyIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUVBLElBQUlBLFlBQVksR0FBRyxTQUFmQSxZQUFlLEdBQVUsQ0FDNUIsQ0FERDs7QUFHQUEsWUFBWSxDQUFDQyxPQUFiLEdBQXVCLFVBQVNDLElBQVQsRUFBZTtBQUNwQyxPQUFLQSxJQUFMLEdBQVlBLElBQVo7QUFDRCxDQUZEOztBQUlBRixZQUFZLENBQUNHLE9BQWIsR0FBdUIsWUFBVztBQUNoQyxTQUFPLEtBQUtELElBQVo7QUFDRCxDQUZEOztBQUlBRSxNQUFNLENBQUNDLE9BQVAsR0FBaUJMLFlBQWpCIiwic291cmNlc0NvbnRlbnQiOlsiLyogXG4gKiBVdGlsaXR5IGZpbGUgdG8gZ2V0IGFuZCBzZXQgdGhlIGxpYnJhcmllcyB0byB3aGljaCBzYmdudml6IGlzIGRlcGVuZGVudCBmcm9tIGFueSBmaWxlLlxuICovXG5cbnZhciBsaWJVdGlsaXRpZXMgPSBmdW5jdGlvbigpe1xufTtcblxubGliVXRpbGl0aWVzLnNldExpYnMgPSBmdW5jdGlvbihsaWJzKSB7XG4gIHRoaXMubGlicyA9IGxpYnM7XG59O1xuXG5saWJVdGlsaXRpZXMuZ2V0TGlicyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5saWJzO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBsaWJVdGlsaXRpZXM7Il0sImZpbGUiOiIuL3NyYy91dGlsaXRpZXMvbGliLXV0aWxpdGllcy5qcy5qcyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/utilities/lib-utilities.js\n");

/***/ }),

/***/ "./src/utilities/main-utilities-factory.js":
/*!*************************************************!*\
  !*** ./src/utilities/main-utilities-factory.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar libs = __webpack_require__(/*! ./lib-utilities */ \"./src/utilities/lib-utilities.js\").getLibs();\n/*\n * The main utilities to be exposed directly.\n */\n\n\nmodule.exports = function () {\n  var elementUtilities, options, cy, sbgnvizInstance;\n\n  function mainUtilities(param) {\n    elementUtilities = param.elementUtilities;\n    options = param.optionUtilities.getOptions();\n    cy = param.sbgnvizInstanceUtilities.getCy();\n    sbgnvizInstance = param.sbgnvizInstanceUtilities.getInstance();\n  }\n\n  ;\n  /*\n   * Adds a new node with the given class and at the given coordinates. Considers undoable option.\n   */\n\n  mainUtilities.addNode = function (x, y, nodeParams, id, parent, visibility) {\n    if (elementUtilities.isGraphTopologyLocked()) {\n      return;\n    } // update map type\n\n\n    if (_typeof(nodeParams) == 'object') {\n      /* \n            if (!elementUtilities.getMapType())\n              elementUtilities.setMapType(nodeParams.language);\n            else if (elementUtilities.getMapType() != nodeParams.language)\n              elementUtilities.setMapType(\"Unknown\"); */\n    }\n\n    if (!options.undoable) {\n      return elementUtilities.addNode(x, y, nodeParams, id, parent, visibility);\n    } else {\n      var param = {\n        newNode: {\n          x: x,\n          y: y,\n          \"class\": nodeParams,\n          id: id,\n          parent: parent,\n          visibility: visibility\n        }\n      };\n      var result = cy.undoRedo()[\"do\"](\"addNode\", param);\n      return result.eles;\n    }\n  };\n  /*\n   * Adds a new edge with the given class and having the given source and target ids. Considers undoable option.\n   */\n\n\n  mainUtilities.addEdge = function (source, target, edgeParams, invalidEdgeCallback, id, visibility) {\n    if (elementUtilities.isGraphTopologyLocked()) {\n      return;\n    } // update map type\n\n\n    if (_typeof(edgeParams) == 'object') {\n      /*  if (!elementUtilities.getMapType())\n         elementUtilities.setMapType(edgeParams.language);\n       else if (elementUtilities.getMapType() != edgeParams.language)\n         elementUtilities.setMapType(\"HybridAny\"); */\n    } // Get the validation result\n\n\n    var edgeclass = edgeParams[\"class\"] ? edgeParams[\"class\"] : edgeParams;\n    var validation = elementUtilities.validateArrowEnds(edgeclass, cy.getElementById(source), cy.getElementById(target)); // If validation result is 'invalid' cancel the operation\n\n    if (validation === 'invalid') {\n      if (typeof invalidEdgeCallback === \"function\") {\n        invalidEdgeCallback();\n      }\n\n      return;\n    } // If validation result is 'reverse' reverse the source-target pair before creating the edge\n\n\n    if (validation === 'reverse') {\n      var temp = source;\n      source = target;\n      target = temp;\n    }\n\n    if (!options.undoable) {\n      return elementUtilities.addEdge(source, target, edgeParams, id, visibility);\n    } else {\n      var param = {\n        newEdge: {\n          source: source,\n          target: target,\n          \"class\": edgeParams,\n          id: id,\n          visibility: visibility\n        }\n      };\n      var result = cy.undoRedo()[\"do\"](\"addEdge\", param);\n      return result.eles;\n    }\n  };\n  /*\n   * Adds a process with convenient edges. For more information please see 'https://github.com/iVis-at-Bilkent/newt/issues/9'.\n   * Considers undoable option.\n   */\n\n\n  mainUtilities.addProcessWithConvenientEdges = function (_source, _target, processType) {\n    if (elementUtilities.isGraphTopologyLocked()) {\n      return;\n    } // If source and target IDs are given get the elements by IDs\n\n\n    var source = typeof _source === 'string' ? cy.getElementById(_source) : _source;\n    var target = typeof _target === 'string' ? cy.getElementById(_target) : _target; // If source or target does not have an EPN class the operation is not valid\n\n    if (!elementUtilities.isEPNClass(source) || !elementUtilities.isEPNClass(target)) {\n      return;\n    }\n\n    if (!options.undoable) {\n      return elementUtilities.addProcessWithConvenientEdges(_source, _target, processType);\n    } else {\n      var param = {\n        source: _source,\n        target: _target,\n        processType: processType\n      };\n      cy.undoRedo()[\"do\"](\"addProcessWithConvenientEdges\", param);\n    }\n  }; // convert collapsed compound nodes to simple nodes\n  // and update port values of pasted nodes and edges\n\n\n  var cloneCollapsedNodesAndPorts = function cloneCollapsedNodesAndPorts(elesBefore) {\n    if (elementUtilities.isGraphTopologyLocked()) {\n      return;\n    }\n\n    cy.elements().unselect();\n    var elesAfter = cy.elements();\n    var elesDiff = elesAfter.diff(elesBefore).left; // shallow copy collapsed nodes - collapsed compounds become simple nodes\n    // data related to collapsed nodes are removed from generated clones\n    // related issue: https://github.com/iVis-at-Bilkent/newt/issues/145\n\n    var collapsedNodes = elesDiff.filter('node.cy-expand-collapse-collapsed-node');\n    collapsedNodes.connectedEdges().remove();\n    collapsedNodes.removeClass('cy-expand-collapse-collapsed-node');\n    collapsedNodes.removeData('collapsedChildren');\n    collapsedNodes.removeData('position-before-collapse size-before-collapse');\n    collapsedNodes.removeData('expandcollapseRenderedCueSize expandcollapseRenderedStartX expandcollapseRenderedStartY'); // cloning ports\n\n    elesDiff.nodes().forEach(function (_node) {\n      if (_node.data(\"ports\").length == 2) {\n        var oldPortName0 = _node.data(\"ports\")[0].id;\n\n        var oldPortName1 = _node.data(\"ports\")[1].id;\n\n        _node.data(\"ports\")[0].id = _node.id() + \".1\";\n        _node.data(\"ports\")[1].id = _node.id() + \".2\";\n\n        _node.outgoers().edges().forEach(function (_edge) {\n          if (_edge.data(\"portsource\") == oldPortName0) {\n            _edge.data(\"portsource\", _node.data(\"ports\")[0].id);\n          } else if (_edge.data(\"portsource\") == oldPortName1) {\n            _edge.data(\"portsource\", _node.data(\"ports\")[1].id);\n          } else {\n            _edge.data(\"portsource\", _node.id());\n          }\n        });\n\n        _node.incomers().edges().forEach(function (_edge) {\n          if (_edge.data(\"porttarget\") == oldPortName0) {\n            _edge.data(\"porttarget\", _node.data(\"ports\")[0].id);\n          } else if (_edge.data(\"porttarget\") == oldPortName1) {\n            _edge.data(\"porttarget\", _node.data(\"ports\")[1].id);\n          } else {\n            _edge.data(\"porttarget\", _node.id());\n          }\n        });\n      } else {\n        _node.outgoers().edges().forEach(function (_edge) {\n          _edge.data(\"portsource\", _node.id());\n        });\n\n        _node.incomers().edges().forEach(function (_edge) {\n          _edge.data(\"porttarget\", _node.id());\n        });\n      }\n    });\n    elesDiff.select();\n  };\n  /*\n   * Clone given elements. Considers undoable option. Requires cytoscape-clipboard extension.\n   */\n\n\n  mainUtilities.cloneElements = function (eles, pasteAtMouseLoc) {\n    if (elementUtilities.isGraphTopologyLocked()) {\n      return;\n    }\n\n    if (eles.length === 0) {\n      return;\n    }\n\n    this.copyElements(eles);\n    this.pasteElements(pasteAtMouseLoc);\n  };\n  /*\n   * Copy given elements to clipboard. Requires cytoscape-clipboard extension.\n   */\n\n\n  mainUtilities.copyElements = function (eles) {\n    cy.clipboard().copy(eles);\n  };\n  /*\n   * Paste the elements copied to clipboard. Considers undoable option. Requires cytoscape-clipboard extension.\n   */\n\n\n  mainUtilities.pasteElements = function (pasteAtMouseLoc) {\n    if (elementUtilities.isGraphTopologyLocked()) {\n      return;\n    }\n\n    var elesBefore = cy.elements();\n\n    if (options.undoable) {\n      cy.undoRedo()[\"do\"](\"paste\", {\n        pasteAtMouseLoc: pasteAtMouseLoc\n      });\n    } else {\n      cy.clipboard().paste();\n    }\n\n    cloneCollapsedNodesAndPorts(elesBefore);\n    cy.nodes(\":selected\").emit('data');\n  };\n  /*\n   * Aligns given nodes in given horizontal and vertical order.\n   * Horizontal and vertical parameters may be 'none' or undefined.\n   * alignTo parameter indicates the leading node.\n   * Requrires cytoscape-grid-guide extension and considers undoable option.\n   */\n\n\n  mainUtilities.align = function (nodes, horizontal, vertical, alignTo) {\n    if (nodes.length === 0) {\n      return;\n    }\n\n    if (options.undoable) {\n      cy.undoRedo()[\"do\"](\"align\", {\n        nodes: nodes,\n        horizontal: horizontal,\n        vertical: vertical,\n        alignTo: alignTo\n      });\n    } else {\n      nodes.align(horizontal, vertical, alignTo);\n    }\n\n    if (cy.edges(\":selected\").length == 1) {\n      cy.edges().unselect();\n    }\n  };\n  /*\n   * Create compound for given nodes. compoundType may be 'complex' or 'compartment'.\n   * This method considers undoable option.\n   */\n\n\n  mainUtilities.createCompoundForGivenNodes = function (_nodes, compoundType) {\n    if (elementUtilities.isGraphTopologyLocked()) {\n      return;\n    }\n\n    var nodes = _nodes;\n    /*\n     * Eleminate the nodes which cannot have a parent with given compound type\n     */\n\n    nodes = _nodes.filter(function (element, i) {\n      if (typeof element === \"number\") {\n        element = i;\n      }\n\n      var sbgnclass = element.data(\"class\");\n      return elementUtilities.isValidParent(sbgnclass, compoundType, element);\n    });\n    nodes = elementUtilities.getTopMostNodes(nodes); // All elements should have the same parent and the common parent should not be a 'complex'\n    // if compoundType is 'compartent'\n    // because the old common parent will be the parent of the new compartment after this operation and\n    // 'complexes' cannot include 'compartments'\n\n    if (nodes.length == 0 || !elementUtilities.allHaveTheSameParent(nodes) || (compoundType === 'compartment' || compoundType == 'submap') && nodes.parent().data('class') && nodes.parent().data('class').startsWith('complex')) {\n      return;\n    }\n\n    if (cy.undoRedo()) {\n      var param = {\n        compoundType: compoundType,\n        nodesToMakeCompound: nodes\n      };\n      cy.undoRedo()[\"do\"](\"createCompoundForGivenNodes\", param);\n    } else {\n      elementUtilities.createCompoundForGivenNodes(nodes, compoundType);\n    }\n  };\n  /*\n   * Move the nodes to a new parent and change their position if possDiff params are set.\n   * Considers undoable option and checks if the operation is valid.\n   */\n\n\n  mainUtilities.changeParent = function (nodes, _newParent, posDiffX, posDiffY) {\n    if (elementUtilities.isGraphTopologyLocked()) {\n      return;\n    }\n\n    var newParent = typeof _newParent === 'string' ? cy.getElementById(_newParent) : _newParent; // New parent is supposed to be one of the root, a complex or a compartment\n\n    if (newParent && !newParent.data(\"class\").startsWith(\"complex\") && newParent.data(\"class\") != \"compartment\" && newParent.data(\"class\") != \"submap\") {\n      return;\n    }\n    /*\n     * Eleminate the nodes which cannot have the newParent as their parent\n     */\n\n\n    nodes = nodes.filter(function (element, i) {\n      if (typeof element === \"number\") {\n        element = i;\n      }\n\n      var sbgnclass = element.data(\"class\");\n      return elementUtilities.isValidParent(sbgnclass, newParent, element);\n    }); // Discard the nodes whose parent is already newParent.\n    // Discard the newParent itself if it is among the nodes\n\n    nodes = nodes.filter(function (ele, i) {\n      if (typeof ele === \"number\") {\n        ele = i;\n      } // Discard the newParent if it is among the nodes\n\n\n      if (newParent && ele.id() === newParent.id()) {\n        return false;\n      } // Discard the nodes whose parent is already newParent\n\n\n      if (!newParent) {\n        return ele.data('parent') != null;\n      }\n\n      return ele.data('parent') !== newParent.id();\n    }); // If some nodes are ancestor of new parent eleminate them\n\n    if (newParent) {\n      nodes = nodes.difference(newParent.ancestors());\n    } // If all nodes are eleminated return directly\n\n\n    if (nodes.length === 0) {\n      return;\n    } // Just move the top most nodes\n\n\n    nodes = elementUtilities.getTopMostNodes(nodes);\n    var parentId = newParent ? newParent.id() : null;\n\n    if (options.undoable) {\n      var param = {\n        firstTime: true,\n        parentData: parentId,\n        // It keeps the newParentId (Just an id for each nodes for the first time)\n        nodes: nodes,\n        posDiffX: posDiffX,\n        posDiffY: posDiffY,\n        // This is needed because the changeParent function called is not from elementUtilities\n        // but from the undoRedo extension directly, so maintaining pointer is not automatically done.\n        callback: elementUtilities.maintainPointer\n      };\n      cy.undoRedo()[\"do\"](\"changeParent\", param); // This action is registered by undoRedo extension\n    } else {\n      elementUtilities.changeParent(nodes, parentId, posDiffX, posDiffY);\n    }\n  };\n  /*\n   * Creates an activation reaction with given parameters. Requires cose-bilkent layout to tile the free macromolecules included\n   * in the complex. Considers undoable option. For more information see the same function in elementUtilities\n   */\n\n\n  mainUtilities.createTranslationReaction = function (mRnaName, proteinName, processPosition, edgeLength) {\n    if (elementUtilities.isGraphTopologyLocked()) {\n      return;\n    }\n\n    if (!options.undoable) {\n      elementUtilities.createTranslationReaction(mRnaName, proteinName, processPosition, edgeLength);\n    } else {\n      var param = {\n        mRnaName: mRnaName,\n        proteinName: proteinName,\n        processPosition: processPosition,\n        edgeLength: edgeLength\n      };\n      cy.undoRedo()[\"do\"](\"createTranslationReaction\", param);\n    }\n  };\n  /*\n   * Creates an activation reaction with given parameters. Requires cose-bilkent layout to tile the free macromolecules included\n   * in the complex. Considers undoable option. For more information see the same function in elementUtilities\n   */\n\n\n  mainUtilities.createTranscriptionReaction = function (geneName, mRnaName, processPosition, edgeLength) {\n    if (elementUtilities.isGraphTopologyLocked()) {\n      return;\n    }\n\n    if (!options.undoable) {\n      elementUtilities.createTranscriptionReaction(geneName, mRnaName, processPosition, edgeLength);\n    } else {\n      var param = {\n        geneName: geneName,\n        mRnaName: mRnaName,\n        processPosition: processPosition,\n        edgeLength: edgeLength\n      };\n      cy.undoRedo()[\"do\"](\"createTranscriptionReaction\", param);\n    }\n  };\n\n  mainUtilities.createTranslation = function (regulatorLabel, outputLabel, orientation) {\n    if (elementUtilities.isGraphTopologyLocked()) {\n      return;\n    }\n\n    if (!options.undoable) {\n      elementUtilities.createTranslation(regulatorLabel, outputLabel, orientation);\n    } else {\n      var param = {\n        regulatorLabel: regulatorLabel,\n        outputLabel: outputLabel,\n        orientation: orientation\n      };\n      cy.undoRedo()[\"do\"](\"createTranslation\", param);\n    }\n  };\n\n  mainUtilities.createTranscription = function (label, orientation) {\n    if (elementUtilities.isGraphTopologyLocked()) {\n      return;\n    }\n\n    if (!options.undoable) {\n      elementUtilities.createTranscription(label, orientation);\n    } else {\n      var param = {\n        label: label,\n        orientation: orientation\n      };\n      cy.undoRedo()[\"do\"](\"createTranscription\", param);\n    }\n  };\n\n  mainUtilities.createDegradation = function (macromolecule, orientation) {\n    if (elementUtilities.isGraphTopologyLocked()) {\n      return;\n    }\n\n    if (!options.undoable) {\n      elementUtilities.createDegradation(macromolecule, orientation);\n    } else {\n      var param = {\n        macromolecule: macromolecule,\n        orientation: orientation\n      };\n      cy.undoRedo()[\"do\"](\"createDegradation\", param);\n    }\n  };\n\n  mainUtilities.createComplexProteinFormation = function (proteinLabels, complexLabel, regulator, orientation, reverse) {\n    if (elementUtilities.isGraphTopologyLocked()) {\n      return;\n    }\n\n    if (!options.undoable) {\n      elementUtilities.createComplexProteinFormation(proteinLabels, complexLabel, regulator, orientation, reverse);\n    } else {\n      var param = {\n        proteinLabels: proteinLabels,\n        complexLabel: complexLabel,\n        regulator: regulator,\n        orientation: orientation,\n        reverse: reverse\n      };\n      cy.undoRedo()[\"do\"](\"createComplexProteinFormation\", param);\n    }\n  };\n\n  mainUtilities.createMultimerization = function (macromolecule, regulator, regulatorMultimer, orientation) {\n    if (elementUtilities.isGraphTopologyLocked()) {\n      return;\n    }\n\n    if (!options.undoable) {\n      elementUtilities.createMultimerization(macromolecule, regulator, regulatorMultimer, orientation);\n    } else {\n      var param = {\n        macromolecule: macromolecule,\n        regulator: regulator,\n        regulatorMultimer: regulatorMultimer,\n        orientation: orientation\n      };\n      cy.undoRedo()[\"do\"](\"createMultimerization\", param);\n    }\n  };\n\n  mainUtilities.createConversion = function (macromolecule, regulator, regulatorMultimer, orientation, inputInfoboxLabels, outputInfoboxLabels) {\n    if (elementUtilities.isGraphTopologyLocked()) {\n      return;\n    }\n\n    if (!options.undoable) {\n      elementUtilities.createConversion(macromolecule, regulator, regulatorMultimer, orientation, inputInfoboxLabels, outputInfoboxLabels);\n    } else {\n      var param = {\n        macromolecule: macromolecule,\n        regulator: regulator,\n        regulatorMultimer: regulatorMultimer,\n        orientation: orientation,\n        inputInfoboxLabels: inputInfoboxLabels,\n        outputInfoboxLabels: outputInfoboxLabels\n      };\n      cy.undoRedo()[\"do\"](\"createConversion\", param);\n    }\n  };\n\n  mainUtilities.createMetabolicReaction = function (inputs, outputs, reversible, regulator, regulatorMultimer, orientation) {\n    if (elementUtilities.isGraphTopologyLocked()) {\n      return;\n    }\n\n    if (!options.undoable) {\n      elementUtilities.createMetabolicReaction(inputs, outputs, reversible, regulator, regulatorMultimer, orientation);\n    } else {\n      var param = {\n        inputs: inputs,\n        outputs: outputs,\n        reversible: reversible,\n        regulator: regulator,\n        regulatorMultimer: regulatorMultimer,\n        orientation: orientation\n      };\n      cy.undoRedo()[\"do\"](\"createMetabolicReaction\", param);\n    }\n  };\n  /*\n   * Creates an activation reaction with given parameters. Requires cose-bilkent layout to tile the free macromolecules included\n   * in the complex. Considers undoable option. For more information see the same function in elementUtilities\n   */\n\n\n  mainUtilities.createMetabolicCatalyticActivity = function (inputNodeList, outputNodeList, catalystName, catalystType, processPosition, tilingPaddingVertical, tilingPaddingHorizontal, edgeLength) {\n    if (elementUtilities.isGraphTopologyLocked()) {\n      return;\n    }\n\n    if (!options.undoable) {\n      elementUtilities.createMetabolicCatalyticActivity(inputNodeList, outputNodeList, catalystName, catalystType, processPosition, tilingPaddingVertical, tilingPaddingHorizontal, edgeLength);\n    } else {\n      var param = {\n        inputNodeList: inputNodeList,\n        outputNodeList: outputNodeList,\n        catalystName: catalystName,\n        catalystType: catalystType,\n        processPosition: processPosition,\n        tilingPaddingVertical: tilingPaddingVertical,\n        tilingPaddingHorizontal: tilingPaddingHorizontal,\n        edgeLength: edgeLength\n      };\n      cy.undoRedo()[\"do\"](\"createMetabolicCatalyticActivity\", param);\n    }\n  };\n  /*\n   * Creates an activation reaction with given parameters. Requires cose-bilkent layout to tile the free macromolecules included\n   * in the complex. Considers undoable option. For more information see the same function in elementUtilities\n   */\n\n\n  mainUtilities.createActivationReaction = function (proteinName, processPosition, edgeLength, reverse) {\n    if (elementUtilities.isGraphTopologyLocked()) {\n      return;\n    }\n\n    if (!options.undoable) {\n      elementUtilities.createActivationReaction(proteinName, processPosition, edgeLength, reverse);\n    } else {\n      var param = {\n        proteinName: proteinName,\n        processPosition: processPosition,\n        edgeLength: edgeLength,\n        reverse: reverse\n      };\n      cy.undoRedo()[\"do\"](\"createActivationReaction\", param);\n    }\n  };\n  /*\n   * Creates a template reaction with given parameters. Requires cose-bilkent layout to tile the free macromolecules included\n   * in the complex. Considers undoable option. For more information see the same function in elementUtilities\n   */\n\n\n  mainUtilities.createTemplateReaction = function (templateType, macromoleculeList, complexName, processPosition, tilingPaddingVertical, tilingPaddingHorizontal, edgeLength, layoutParam) {\n    if (elementUtilities.isGraphTopologyLocked()) {\n      return;\n    }\n\n    if (!options.undoable) {\n      if (templateType === \"reversible\") {\n        elementUtilities.setMapType(\"HybridAny\");\n      }\n\n      elementUtilities.createTemplateReaction(templateType, macromoleculeList, complexName, processPosition, tilingPaddingVertical, tilingPaddingHorizontal, edgeLength, layoutParam);\n    } else {\n      var param = {\n        templateType: templateType,\n        macromoleculeList: macromoleculeList,\n        complexName: complexName,\n        processPosition: processPosition,\n        tilingPaddingVertical: tilingPaddingVertical,\n        tilingPaddingHorizontal: tilingPaddingHorizontal,\n        edgeLength: edgeLength,\n        layoutParam: layoutParam\n      };\n\n      if (templateType === \"reversible\") {\n        var actions = [];\n        actions.push({\n          name: \"changeMapType\",\n          param: {\n            mapType: \"HybridAny\",\n            callback: function callback() {}\n          }\n        });\n        actions.push({\n          name: \"createTemplateReaction\",\n          param: param\n        });\n        cy.undoRedo()[\"do\"](\"batch\", actions);\n      } else {\n        cy.undoRedo()[\"do\"](\"createTemplateReaction\", param);\n      }\n    }\n  };\n  /*\n   * Resize given nodes if useAspectRatio is truthy one of width or height should not be set.\n   * Considers undoable option.\n   */\n\n\n  mainUtilities.resizeNodes = function (nodes, width, height, useAspectRatio, preserveRelativePos) {\n    if (nodes.length === 0) {\n      return;\n    }\n\n    if (options.undoable) {\n      var param = {\n        nodes: nodes,\n        width: width,\n        height: height,\n        useAspectRatio: useAspectRatio,\n        performOperation: true,\n        preserveRelativePos: preserveRelativePos\n      };\n      cy.undoRedo()[\"do\"](\"resizeNodes\", param);\n    } else {\n      elementUtilities.resizeNodes(nodes, width, height, useAspectRatio);\n      cy.style().update();\n    }\n  };\n  /*\n   * Resize given nodes if useAspectRatio is truthy one of width or height should not be set.\n   * Considers undoable option.\n   */\n\n\n  mainUtilities.resizeNodesToContent = function (nodes, useAspectRatio) {\n    if (nodes.length === 0) {\n      return;\n    }\n\n    if (options.undoable) {\n      var actions = [];\n      nodes.forEach(function (node) {\n        var width = elementUtilities.calculateMinWidth(node);\n        var height = elementUtilities.calculateMinHeight(node);\n        actions.push({\n          name: \"resizeNodes\",\n          param: {\n            nodes: node,\n            width: width,\n            height: height,\n            useAspectRatio: useAspectRatio,\n            performOperation: true,\n            preserveRelativePos: true\n          }\n        });\n        var stateAndInfos = node.data('statesandinfos');\n        var length = stateAndInfos.length;\n\n        if (length != 0) {\n          var param = {\n            node: node,\n            locations: [\"top\", \"right\", \"bottom\", \"left\"]\n          };\n          actions.push({\n            name: \"fitUnits\",\n            param: param\n          });\n        }\n      });\n      cy.undoRedo()[\"do\"](\"batch\", actions);\n      cy.style().update();\n      return actions;\n    } else {\n      nodes.forEach(function (node) {\n        var width = elementUtilities.calculateMinWidth(node);\n        var height = elementUtilities.calculateMinHeight(node);\n        elementUtilities.resizeNodes(node, width, height, useAspectRatio, true);\n      });\n    }\n\n    cy.style().update();\n  };\n  /*\n   * Changes the label of the given nodes to the given label. Considers undoable option.\n   */\n\n\n  mainUtilities.changeNodeLabel = function (nodes, label) {\n    if (nodes.length === 0) {\n      return;\n    }\n\n    if (!options.undoable) {\n      nodes.data('label', label);\n    } else {\n      var param = {\n        nodes: nodes,\n        label: label,\n        firstTime: true\n      };\n      cy.undoRedo()[\"do\"](\"changeNodeLabel\", param);\n    }\n\n    cy.style().update();\n  };\n  /*\n   * Change font properties for given nodes use the given font data.\n   * Considers undoable option.\n   */\n\n\n  mainUtilities.changeFontProperties = function (eles, data) {\n    if (eles.length === 0) {\n      return;\n    }\n\n    if (options.undoable) {\n      var param = {\n        eles: eles,\n        data: data,\n        firstTime: true\n      };\n      cy.undoRedo()[\"do\"](\"changeFontProperties\", param);\n    } else {\n      elementUtilities.changeFontProperties(eles, data);\n    }\n\n    cy.style().update();\n  };\n  /*\n   * Change state value or unit of information box of given nodes with given index.\n   * Considers undoable option.\n   * For more information about the parameters see elementUtilities.changeStateOrInfoBox\n   */\n\n\n  mainUtilities.changeStateOrInfoBox = function (nodes, index, value, type) {\n    if (nodes.length === 0) {\n      return;\n    }\n\n    if (options.undoable) {\n      var param = {\n        index: index,\n        value: value,\n        type: type,\n        nodes: nodes\n      };\n      cy.undoRedo()[\"do\"](\"changeStateOrInfoBox\", param);\n    } else {\n      return elementUtilities.changeStateOrInfoBox(nodes, index, value, type);\n    }\n\n    cy.style().update();\n  }; // Add a new state or info box to given nodes.\n  // The box is represented by the parameter obj.\n  // Considers undoable option.\n\n\n  mainUtilities.addStateOrInfoBox = function (nodes, obj) {\n    if (nodes.length === 0) {\n      return;\n    }\n\n    if (!options.undoable) {\n      elementUtilities.addStateOrInfoBox(nodes, obj);\n    } else {\n      var param = {\n        obj: obj,\n        nodes: nodes\n      };\n      cy.undoRedo()[\"do\"](\"addStateOrInfoBox\", param);\n    }\n\n    cy.style().update();\n  }; // Remove the state or info boxes of the given nodes at given index.\n  // Considers undoable option.\n\n\n  mainUtilities.removeStateOrInfoBox = function (nodes, index) {\n    if (nodes.length === 0) {\n      return;\n    }\n\n    if (!options.undoable) {\n      elementUtilities.removeStateOrInfoBox(nodes, {\n        index: index\n      });\n    } else {\n      var param = {\n        locationObj: {\n          index: index\n        },\n        nodes: nodes\n      };\n      cy.undoRedo()[\"do\"](\"removeStateOrInfoBox\", param);\n    }\n\n    cy.style().update();\n  }; //Arrange information boxes\n  //If force check is true, it rearranges all information boxes\n\n\n  mainUtilities.fitUnits = function (node, locations) {\n    if (node.data('auxunitlayouts') === undefined || node.data('statesandinfos').length <= 0) {\n      return;\n    }\n\n    if (locations === undefined || locations.length <= 0) {\n      return;\n    }\n\n    if (!options.undoable) {\n      elementUtilities.fitUnits(node, locations);\n    } else {\n      var param = {\n        node: node,\n        locations: locations\n      };\n      cy.undoRedo()[\"do\"](\"fitUnits\", param);\n    }\n\n    cy.style().update();\n  };\n  /*\n   * Set multimer status of the given nodes to the given status.\n   * Considers undoable option.\n   */\n\n\n  mainUtilities.setMultimerStatus = function (nodes, status) {\n    if (nodes.length === 0) {\n      return;\n    }\n\n    if (options.undoable) {\n      var param = {\n        status: status,\n        nodes: nodes,\n        firstTime: true\n      };\n      cy.undoRedo()[\"do\"](\"setMultimerStatus\", param);\n    } else {\n      elementUtilities.setMultimerStatus(nodes, status);\n    }\n\n    cy.style().update();\n  };\n  /**\n   * Redraw clone markers on given nodes without considering undo.\n   * See https://github.com/iVis-at-Bilkent/newt/issues/574 \n   */\n\n\n  mainUtilities.redrawCloneMarkers = function (nodes) {\n    elementUtilities.setCloneMarkerStatus(nodes, true);\n  };\n  /*\n   * Set clone marker status of given nodes to the given status.\n   * Considers undoable option.\n   */\n\n\n  mainUtilities.setCloneMarkerStatus = function (nodes, status) {\n    if (nodes.length === 0) {\n      return;\n    }\n\n    if (options.undoable) {\n      var param = {\n        status: status,\n        nodes: nodes,\n        firstTime: true\n      };\n      cy.undoRedo()[\"do\"](\"setCloneMarkerStatus\", param);\n    } else {\n      elementUtilities.setCloneMarkerStatus(nodes, status);\n    }\n\n    cy.style().update();\n  };\n  /*\n   * Change style/css of given eles by setting getting property name to the given given value/values (Note that valueMap parameter may be\n   * a single string or an id to value map). Considers undoable option.\n   */\n\n\n  mainUtilities.changeCss = function (eles, name, valueMap) {\n    if (eles.length === 0) {\n      return;\n    }\n\n    if (!options.undoable) {\n      elementUtilities.changeCss(eles, name, valueMap);\n    } else {\n      var param = {\n        eles: eles,\n        valueMap: valueMap,\n        name: name\n      };\n      cy.undoRedo()[\"do\"](\"changeCss\", param);\n    }\n\n    cy.style().update();\n  };\n  /*\n   * Change data of given eles by setting getting property name to the given given value/values (Note that valueMap parameter may be\n   * a single string or an id to value map). Considers undoable option.\n   */\n\n\n  mainUtilities.changeData = function (eles, name, valueMap) {\n    if (eles.length === 0) {\n      return;\n    }\n\n    if (!options.undoable) {\n      elementUtilities.changeData(eles, name, valueMap);\n    } else {\n      var param = {\n        eles: eles,\n        valueMap: valueMap,\n        name: name\n      };\n      cy.undoRedo()[\"do\"](\"changeData\", param);\n    }\n\n    cy.style().update();\n  };\n\n  mainUtilities.updateSetField = function (ele, fieldName, toDelete, toAdd, callback) {\n    if (!options.undoable) {\n      elementUtilities.changeData(ele, fieldName, toDelete, toAdd, callback);\n    } else {\n      var param = {\n        ele: ele,\n        fieldName: fieldName,\n        toDelete: toDelete,\n        toAdd: toAdd,\n        callback: callback\n      };\n      cy.undoRedo()[\"do\"](\"updateSetField\", param);\n    }\n  };\n\n  mainUtilities.setDefaultProperty = function (_class, name, value) {\n    if (!options.undoable) {\n      var propMap = {};\n      propMap[name] = value;\n      elementUtilities.setDefaultProperties(_class, propMap);\n    } else {\n      var param = {\n        \"class\": _class,\n        name: name,\n        value: value\n      };\n      cy.undoRedo()[\"do\"](\"setDefaultProperty\", param);\n    }\n  };\n\n  mainUtilities.updateInfoboxStyle = function (node, index, newProps) {\n    if (!options.undoable) {\n      elementUtilities.updateInfoboxStyle(node, index, newProps);\n    } else {\n      var param = {\n        node: node,\n        index: index,\n        newProps: newProps\n      };\n      cy.undoRedo()[\"do\"](\"updateInfoboxStyle\", param);\n    }\n\n    cy.style().update();\n  };\n\n  mainUtilities.updateInfoboxObj = function (node, index, newProps) {\n    if (!options.undoable) {\n      elementUtilities.updateInfoboxObj(node, index, newProps);\n    } else {\n      var param = {\n        node: node,\n        index: index,\n        newProps: newProps\n      };\n      cy.undoRedo()[\"do\"](\"updateInfoboxObj\", param);\n    }\n\n    cy.style().update();\n  };\n\n  mainUtilities.deleteAndPerformLayout = function (eles, layoutparam) {\n    var nodes = eles.nodes(); // Ensure that nodes list just include nodes\n\n    var allNodes = cy.nodes(\":visible\");\n    var nodesToKeep = elementUtilities.extendRemainingNodes(nodes, allNodes);\n    var nodesToRemove = allNodes.not(nodesToKeep);\n\n    if (nodesToRemove.length === 0) {\n      return;\n    }\n\n    if (!options.undoable) {\n      elementUtilities.deleteAndPerformLayout(nodesToRemove, layoutparam);\n    } else {\n      var param = {\n        eles: nodesToRemove,\n        layoutparam: layoutparam,\n        firstTime: true\n      };\n      cy.undoRedo()[\"do\"](\"deleteAndPerformLayout\", param);\n    }\n  };\n  /*\n   * Hides given eles (the ones which are selected) and perform given layout afterward. Layout parameter may be layout options\n   * or a function to call. Requires viewUtilities extension and considers undoable option.\n   */\n\n\n  mainUtilities.hideAndPerformLayout = function (eles, layoutparam) {\n    var nodes = eles.nodes(); // Ensure that nodes list just include nodes\n\n    var allNodes = cy.nodes(\":visible\");\n    var nodesToShow = elementUtilities.extendRemainingNodes(nodes, allNodes);\n    var nodesToHide = allNodes.not(nodesToShow);\n\n    if (nodesToHide.length === 0) {\n      return;\n    }\n\n    if (!options.undoable) {\n      var nodesWithHiddenNeighbor = cy.edges(\":hidden\").connectedNodes(':visible');\n      sbgnvizInstance.thinBorder(nodesWithHiddenNeighbor);\n      elementUtilities.hideAndPerformLayout(nodesToHide, layoutparam);\n      var nodesWithHiddenNeighbor = cy.edges(\":hidden\").connectedNodes(':visible');\n      sbgnvizInstance.thickenBorder(nodesWithHiddenNeighbor);\n    } else {\n      var param = {\n        eles: nodesToHide,\n        layoutparam: layoutparam,\n        firstTime: true\n      };\n      var ur = cy.undoRedo();\n      ur.action(\"thickenBorder\", sbgnvizInstance.thickenBorder, sbgnvizInstance.thinBorder);\n      ur.action(\"thinBorder\", sbgnvizInstance.thinBorder, sbgnvizInstance.thickenBorder);\n      var actions = [];\n      var nodesWithHiddenNeighbor = cy.edges(\":hidden\").connectedNodes().intersection(nodesToHide);\n      actions.push({\n        name: \"thinBorder\",\n        param: nodesWithHiddenNeighbor\n      });\n      actions.push({\n        name: \"hideAndPerformLayout\",\n        param: param\n      });\n      nodesWithHiddenNeighbor = nodesToHide.neighborhood(\":visible\").nodes().difference(nodesToHide).difference(cy.nodes(\"[thickBorder]\"));\n      actions.push({\n        name: \"thickenBorder\",\n        param: nodesWithHiddenNeighbor\n      });\n      cy.undoRedo()[\"do\"](\"batch\", actions);\n    }\n  };\n  /*\n   * Shows all elements (the ones which are hidden if any) and perform given layout afterward. Layout parameter may be layout options\n   * or a function to call. Requires viewUtilities extension and considers undoable option.\n   */\n\n\n  mainUtilities.showAllAndPerformLayout = function (layoutparam) {\n    var hiddenEles = cy.elements(':hidden');\n\n    if (hiddenEles.length === 0) {\n      return;\n    }\n\n    if (!options.undoable) {\n      var nodesWithHiddenNeighbor = cy.edges(\":hidden\").connectedNodes(':visible');\n      sbgnvizInstance.thinBorder(nodesWithHiddenNeighbor);\n      elementUtilities.showAndPerformLayout(hiddenEles, layoutparam);\n    } else {\n      var param = {\n        eles: hiddenEles,\n        layoutparam: layoutparam,\n        firstTime: true\n      };\n      var ur = cy.undoRedo();\n      ur.action(\"thickenBorder\", sbgnvizInstance.thickenBorder, sbgnvizInstance.thinBorder);\n      ur.action(\"thinBorder\", sbgnvizInstance.thinBorder, sbgnvizInstance.thickenBorder);\n      var actions = [];\n      var nodesWithHiddenNeighbor = cy.nodes(\"[thickBorder]\");\n      actions.push({\n        name: \"thinBorder\",\n        param: nodesWithHiddenNeighbor\n      });\n      actions.push({\n        name: \"showAndPerformLayout\",\n        param: param\n      });\n      cy.undoRedo()[\"do\"](\"batch\", actions);\n    }\n  };\n  /*\n   * Unhide given eles (the ones which are hidden if any) and perform given layout afterward. Layout parameter may be layout options\n   * or a function to call. Requires viewUtilities extension and considers undoable option.\n   */\n\n\n  mainUtilities.showAndPerformLayout = function (mainEle, eles, layoutparam) {\n    var hiddenEles = eles.filter(':hidden');\n\n    if (hiddenEles.length === 0) {\n      return;\n    }\n\n    mainUtilities.closeUpElements(mainEle, hiddenEles.nodes());\n\n    if (!options.undoable) {\n      var nodesWithHiddenNeighbor = cy.edges(\":hidden\").connectedNodes(':visible');\n      sbgnvizInstance.thinBorder(nodesWithHiddenNeighbor);\n      elementUtilities.showAndPerformLayout(hiddenEles, layoutparam);\n      var nodesWithHiddenNeighbor = cy.edges(\":hidden\").connectedNodes(':visible');\n      sbgnvizInstance.thickenBorder(nodesWithHiddenNeighbor);\n    } else {\n      var param = {\n        eles: hiddenEles,\n        layoutparam: layoutparam,\n        firstTime: true\n      };\n      var ur = cy.undoRedo();\n      ur.action(\"thickenBorder\", sbgnvizInstance.thickenBorder, sbgnvizInstance.thinBorder);\n      ur.action(\"thinBorder\", sbgnvizInstance.thinBorder, sbgnvizInstance.thickenBorder);\n      var actions = [];\n      var nodesToThinBorder = hiddenEles.neighborhood(\":visible\").nodes(\"[thickBorder]\").difference(cy.edges(\":hidden\").difference(hiddenEles.edges().union(hiddenEles.nodes().connectedEdges())).connectedNodes());\n      actions.push({\n        name: \"thinBorder\",\n        param: nodesToThinBorder\n      });\n      actions.push({\n        name: \"showAndPerformLayout\",\n        param: param\n      });\n      var nodesToThickenBorder = hiddenEles.nodes().edgesWith(cy.nodes(\":hidden\").difference(hiddenEles.nodes())).connectedNodes().intersection(hiddenEles.nodes());\n      actions.push({\n        name: \"thickenBorder\",\n        param: nodesToThickenBorder\n      });\n      cy.undoRedo()[\"do\"](\"batch\", actions);\n    }\n  };\n  /*\n  * Takes the hidden elements close to the nodes whose neighbors will be shown\n  * */\n\n\n  mainUtilities.closeUpElements = function (mainEle, hiddenEles) {\n    var leftX = Number.MAX_VALUE;\n    var rightX = Number.MIN_VALUE;\n    var topY = Number.MAX_VALUE;\n    var bottomY = Number.MIN_VALUE; // Check the x and y limits of all hidden elements and store them in the variables above\n\n    hiddenEles.forEach(function (ele) {\n      if (ele.data('class') != 'compartment' && ele.data('class') != 'complex') {\n        var halfWidth = ele.outerWidth() / 2;\n        var halfHeight = ele.outerHeight() / 2;\n        if (ele.position(\"x\") - halfWidth < leftX) leftX = ele.position(\"x\") - halfWidth;\n        if (ele.position(\"x\") + halfWidth > rightX) rightX = ele.position(\"x\") + halfWidth;\n        if (ele.position(\"y\") - halfHeight < topY) topY = ele.position(\"y\") - halfHeight;\n        if (ele.position(\"y\") + halfHeight > topY) bottomY = ele.position(\"y\") + halfHeight;\n      }\n    }); //The coordinates of the old center containing the hidden nodes\n\n    var oldCenterX = (leftX + rightX) / 2;\n    var oldCenterY = (topY + bottomY) / 2; //Here we calculate two parameters which define the area in which the hidden elements are placed initially\n\n    var minHorizontalParam = mainEle.outerWidth() / 2 + (rightX - leftX) / 2;\n    var maxHorizontalParam = mainEle.outerWidth() + (rightX - leftX) / 2;\n    var minVerticalParam = mainEle.outerHeight() / 2 + (bottomY - topY) / 2;\n    var maxVerticalParam = mainEle.outerHeight() + (bottomY - topY) / 2; //Quadrants is an object of the form {first:\"obtained\", second:\"free\", third:\"free\", fourth:\"obtained\"}\n    // which holds which quadrant are free (that's where hidden nodes will be brought)\n\n    var quadrants = mainUtilities.checkOccupiedQuadrants(mainEle, hiddenEles);\n    var freeQuadrants = [];\n\n    for (var property in quadrants) {\n      if (quadrants[property] === \"free\") freeQuadrants.push(property);\n    } //Can take values 1 and -1 and are used to place the hidden nodes in the random quadrant\n\n\n    var horizontalMult;\n    var verticalMult;\n\n    if (freeQuadrants.length > 0) {\n      if (freeQuadrants.length === 3) {\n        if (freeQuadrants.includes('first') && freeQuadrants.includes('second') && freeQuadrants.includes('third')) {\n          horizontalMult = -1;\n          verticalMult = -1;\n        } else if (freeQuadrants.includes('first') && freeQuadrants.includes('second') && freeQuadrants.includes('fourth')) {\n          horizontalMult = 1;\n          verticalMult = -1;\n        } else if (freeQuadrants.includes('first') && freeQuadrants.includes('third') && freeQuadrants.includes('fourth')) {\n          horizontalMult = 1;\n          verticalMult = 1;\n        } else if (freeQuadrants.includes('second') && freeQuadrants.includes('third') && freeQuadrants.includes('fourth')) {\n          horizontalMult = -1;\n          verticalMult = 1;\n        }\n      } else {\n        //Randomly picks one quadrant from the free quadrants\n        var randomQuadrant = freeQuadrants[Math.floor(Math.random() * freeQuadrants.length)];\n\n        if (randomQuadrant === \"first\") {\n          horizontalMult = 1;\n          verticalMult = -1;\n        } else if (randomQuadrant === \"second\") {\n          horizontalMult = -1;\n          verticalMult = -1;\n        } else if (randomQuadrant === \"third\") {\n          horizontalMult = -1;\n          verticalMult = 1;\n        } else if (randomQuadrant === \"fourth\") {\n          horizontalMult = 1;\n          verticalMult = 1;\n        }\n      }\n    } else {\n      horizontalMult = 0;\n      verticalMult = 0;\n    } // If the horizontalMult is 0 it means that no quadrant is free, so we randomly choose a quadrant\n\n\n    var horizontalParam = mainUtilities.generateRandom(minHorizontalParam, maxHorizontalParam, horizontalMult);\n    var verticalParam = mainUtilities.generateRandom(minVerticalParam, maxVerticalParam, verticalMult); //The coordinates of the center where the hidden nodes will be transfered\n\n    var newCenterX = mainEle.position(\"x\") + horizontalParam;\n    var newCenterY = mainEle.position(\"y\") + verticalParam;\n    var xdiff = newCenterX - oldCenterX;\n    var ydiff = newCenterY - oldCenterY; //Change the position of hidden elements\n\n    hiddenEles.forEach(function (ele) {\n      var newx = ele.position(\"x\") + xdiff;\n      var newy = ele.position(\"y\") + ydiff;\n      ele.position(\"x\", newx);\n      ele.position(\"y\", newy);\n    });\n  };\n  /*\n   * Generates a number between 2 nr and multimplies it with 1 or -1\n   * */\n\n\n  mainUtilities.generateRandom = function (min, max, mult) {\n    var val = [-1, 1];\n    if (mult === 0) mult = val[Math.floor(Math.random() * val.length)];\n    return (Math.floor(Math.random() * (max - min + 1)) + min) * mult;\n  };\n  /*\n   * This function makes sure that the random number lies in free quadrant\n   * */\n\n\n  mainUtilities.checkOccupiedQuadrants = function (mainEle, hiddenEles) {\n    if (elementUtilities.getMapType() == 'PD') {\n      var visibleNeighborEles = mainEle.neighborhood().difference(hiddenEles).nodes();\n      var visibleNeighborsOfNeighbors = visibleNeighborEles.neighborhood().difference(hiddenEles).difference(mainEle).nodes();\n      var visibleEles = visibleNeighborEles.union(visibleNeighborsOfNeighbors);\n    } else var visibleEles = mainEle.neighborhood().difference(hiddenEles).nodes();\n\n    var occupiedQuadrants = {\n      first: \"free\",\n      second: \"free\",\n      third: \"free\",\n      fourth: \"free\"\n    };\n    visibleEles.forEach(function (ele) {\n      if (ele.data('class') != 'compartment' && ele.data('class') != 'complex') {\n        if (ele.position(\"x\") < mainEle.position(\"x\") && ele.position(\"y\") < mainEle.position(\"y\")) occupiedQuadrants.second = \"occupied\";else if (ele.position(\"x\") > mainEle.position(\"x\") && ele.position(\"y\") < mainEle.position(\"y\")) occupiedQuadrants.first = \"occupied\";else if (ele.position(\"x\") < mainEle.position(\"x\") && ele.position(\"y\") > mainEle.position(\"y\")) occupiedQuadrants.third = \"occupied\";else if (ele.position(\"x\") > mainEle.position(\"x\") && ele.position(\"y\") > mainEle.position(\"y\")) occupiedQuadrants.fourth = \"occupied\";\n      }\n    });\n    return occupiedQuadrants;\n  }; // Overrides highlightProcesses from SBGNVIZ - do not highlight any nodes when the map type is AF\n\n\n  mainUtilities.highlightProcesses = function (_nodes) {\n    if (elementUtilities.getMapType() == \"AF\") return;\n    sbgnvizInstance.highlightProcesses(_nodes);\n  };\n  /**\n   * Resets map type to undefined\n   */\n\n\n  mainUtilities.resetMapType = function () {\n    elementUtilities.resetMapType();\n  };\n  /**\n   * return : map type\n   */\n\n\n  mainUtilities.getMapType = function () {\n    return elementUtilities.getMapType();\n  };\n\n  mainUtilities.addBackgroundImage = function (nodes, bgObj, updateInfo, promptInvalidImage, validateURL) {\n    if (nodes.length === 0 || !bgObj) {\n      return;\n    }\n\n    bgObj['firstTime'] = true;\n\n    if (options.undoable) {\n      var param = {\n        bgObj: bgObj,\n        nodes: nodes,\n        updateInfo: updateInfo,\n        promptInvalidImage: promptInvalidImage,\n        validateURL: validateURL\n      };\n      cy.undoRedo()[\"do\"](\"addBackgroundImage\", param);\n    } else {\n      elementUtilities.addBackgroundImage(nodes, bgObj, updateInfo, promptInvalidImage, validateURL);\n    }\n\n    cy.style().update();\n  };\n\n  mainUtilities.removeBackgroundImage = function (nodes, bgObj) {\n    if (nodes.length === 0 || !bgObj) {\n      return;\n    }\n\n    bgObj['firstTime'] = true;\n\n    if (options.undoable) {\n      var param = {\n        bgObj: bgObj,\n        nodes: nodes\n      };\n      cy.undoRedo()[\"do\"](\"removeBackgroundImage\", param);\n    } else {\n      elementUtilities.removeBackgroundImage(nodes, bgObj);\n    }\n\n    cy.style().update();\n  };\n\n  mainUtilities.updateBackgroundImage = function (nodes, bgObj) {\n    if (nodes.length === 0 || !bgObj) {\n      return;\n    }\n\n    if (options.undoable) {\n      var param = {\n        bgObj: bgObj,\n        nodes: nodes\n      };\n      cy.undoRedo()[\"do\"](\"updateBackgroundImage\", param);\n    } else {\n      elementUtilities.updateBackgroundImage(nodes, bgObj);\n    }\n\n    cy.style().update();\n  };\n\n  mainUtilities.changeBackgroundImage = function (nodes, oldImg, newImg, updateInfo, promptInvalidImage, validateURL) {\n    if (nodes.length === 0 || !oldImg || !newImg) {\n      return;\n    }\n\n    if (options.undoable) {\n      var param = {\n        oldImg: oldImg,\n        newImg: newImg,\n        nodes: nodes,\n        firstTime: true,\n        updateInfo: updateInfo,\n        promptInvalidImage: promptInvalidImage,\n        validateURL: validateURL\n      };\n      cy.undoRedo()[\"do\"](\"changeBackgroundImage\", param);\n    } else {\n      elementUtilities.changeBackgroundImage(nodes, oldImg, newImg, true, updateInfo, promptInvalidImage, validateURL);\n    }\n\n    cy.style().update();\n  };\n\n  return mainUtilities;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jaGlzZS8uL3NyYy91dGlsaXRpZXMvbWFpbi11dGlsaXRpZXMtZmFjdG9yeS5qcz8wOGY4Il0sIm5hbWVzIjpbImxpYnMiLCJyZXF1aXJlIiwibW9kdWxlIiwiZXhwb3J0cyIsImVsZW1lbnRVdGlsaXRpZXMiLCJvcHRpb25zIiwiY3kiLCJzYmdudml6SW5zdGFuY2UiLCJtYWluVXRpbGl0aWVzIiwicGFyYW0iLCJvcHRpb25VdGlsaXRpZXMiLCJnZXRPcHRpb25zIiwic2JnbnZpekluc3RhbmNlVXRpbGl0aWVzIiwiZ2V0Q3kiLCJnZXRJbnN0YW5jZSIsImFkZE5vZGUiLCJ4IiwieSIsIm5vZGVQYXJhbXMiLCJpZCIsInBhcmVudCIsInZpc2liaWxpdHkiLCJpc0dyYXBoVG9wb2xvZ3lMb2NrZWQiLCJ1bmRvYWJsZSIsIm5ld05vZGUiLCJyZXN1bHQiLCJ1bmRvUmVkbyIsImVsZXMiLCJhZGRFZGdlIiwic291cmNlIiwidGFyZ2V0IiwiZWRnZVBhcmFtcyIsImludmFsaWRFZGdlQ2FsbGJhY2siLCJlZGdlY2xhc3MiLCJ2YWxpZGF0aW9uIiwidmFsaWRhdGVBcnJvd0VuZHMiLCJnZXRFbGVtZW50QnlJZCIsInRlbXAiLCJuZXdFZGdlIiwiYWRkUHJvY2Vzc1dpdGhDb252ZW5pZW50RWRnZXMiLCJfc291cmNlIiwiX3RhcmdldCIsInByb2Nlc3NUeXBlIiwiaXNFUE5DbGFzcyIsImNsb25lQ29sbGFwc2VkTm9kZXNBbmRQb3J0cyIsImVsZXNCZWZvcmUiLCJlbGVtZW50cyIsInVuc2VsZWN0IiwiZWxlc0FmdGVyIiwiZWxlc0RpZmYiLCJkaWZmIiwibGVmdCIsImNvbGxhcHNlZE5vZGVzIiwiZmlsdGVyIiwiY29ubmVjdGVkRWRnZXMiLCJyZW1vdmUiLCJyZW1vdmVDbGFzcyIsInJlbW92ZURhdGEiLCJub2RlcyIsImZvckVhY2giLCJfbm9kZSIsImRhdGEiLCJsZW5ndGgiLCJvbGRQb3J0TmFtZTAiLCJvbGRQb3J0TmFtZTEiLCJvdXRnb2VycyIsImVkZ2VzIiwiX2VkZ2UiLCJpbmNvbWVycyIsInNlbGVjdCIsImNsb25lRWxlbWVudHMiLCJwYXN0ZUF0TW91c2VMb2MiLCJjb3B5RWxlbWVudHMiLCJwYXN0ZUVsZW1lbnRzIiwiY2xpcGJvYXJkIiwiY29weSIsInBhc3RlIiwiZW1pdCIsImFsaWduIiwiaG9yaXpvbnRhbCIsInZlcnRpY2FsIiwiYWxpZ25UbyIsImNyZWF0ZUNvbXBvdW5kRm9yR2l2ZW5Ob2RlcyIsIl9ub2RlcyIsImNvbXBvdW5kVHlwZSIsImVsZW1lbnQiLCJpIiwic2JnbmNsYXNzIiwiaXNWYWxpZFBhcmVudCIsImdldFRvcE1vc3ROb2RlcyIsImFsbEhhdmVUaGVTYW1lUGFyZW50Iiwic3RhcnRzV2l0aCIsIm5vZGVzVG9NYWtlQ29tcG91bmQiLCJjaGFuZ2VQYXJlbnQiLCJfbmV3UGFyZW50IiwicG9zRGlmZlgiLCJwb3NEaWZmWSIsIm5ld1BhcmVudCIsImVsZSIsImRpZmZlcmVuY2UiLCJhbmNlc3RvcnMiLCJwYXJlbnRJZCIsImZpcnN0VGltZSIsInBhcmVudERhdGEiLCJjYWxsYmFjayIsIm1haW50YWluUG9pbnRlciIsImNyZWF0ZVRyYW5zbGF0aW9uUmVhY3Rpb24iLCJtUm5hTmFtZSIsInByb3RlaW5OYW1lIiwicHJvY2Vzc1Bvc2l0aW9uIiwiZWRnZUxlbmd0aCIsImNyZWF0ZVRyYW5zY3JpcHRpb25SZWFjdGlvbiIsImdlbmVOYW1lIiwiY3JlYXRlVHJhbnNsYXRpb24iLCJyZWd1bGF0b3JMYWJlbCIsIm91dHB1dExhYmVsIiwib3JpZW50YXRpb24iLCJjcmVhdGVUcmFuc2NyaXB0aW9uIiwibGFiZWwiLCJjcmVhdGVEZWdyYWRhdGlvbiIsIm1hY3JvbW9sZWN1bGUiLCJjcmVhdGVDb21wbGV4UHJvdGVpbkZvcm1hdGlvbiIsInByb3RlaW5MYWJlbHMiLCJjb21wbGV4TGFiZWwiLCJyZWd1bGF0b3IiLCJyZXZlcnNlIiwiY3JlYXRlTXVsdGltZXJpemF0aW9uIiwicmVndWxhdG9yTXVsdGltZXIiLCJjcmVhdGVDb252ZXJzaW9uIiwiaW5wdXRJbmZvYm94TGFiZWxzIiwib3V0cHV0SW5mb2JveExhYmVscyIsImNyZWF0ZU1ldGFib2xpY1JlYWN0aW9uIiwiaW5wdXRzIiwib3V0cHV0cyIsInJldmVyc2libGUiLCJjcmVhdGVNZXRhYm9saWNDYXRhbHl0aWNBY3Rpdml0eSIsImlucHV0Tm9kZUxpc3QiLCJvdXRwdXROb2RlTGlzdCIsImNhdGFseXN0TmFtZSIsImNhdGFseXN0VHlwZSIsInRpbGluZ1BhZGRpbmdWZXJ0aWNhbCIsInRpbGluZ1BhZGRpbmdIb3Jpem9udGFsIiwiY3JlYXRlQWN0aXZhdGlvblJlYWN0aW9uIiwiY3JlYXRlVGVtcGxhdGVSZWFjdGlvbiIsInRlbXBsYXRlVHlwZSIsIm1hY3JvbW9sZWN1bGVMaXN0IiwiY29tcGxleE5hbWUiLCJsYXlvdXRQYXJhbSIsInNldE1hcFR5cGUiLCJhY3Rpb25zIiwicHVzaCIsIm5hbWUiLCJtYXBUeXBlIiwicmVzaXplTm9kZXMiLCJ3aWR0aCIsImhlaWdodCIsInVzZUFzcGVjdFJhdGlvIiwicHJlc2VydmVSZWxhdGl2ZVBvcyIsInBlcmZvcm1PcGVyYXRpb24iLCJzdHlsZSIsInVwZGF0ZSIsInJlc2l6ZU5vZGVzVG9Db250ZW50Iiwibm9kZSIsImNhbGN1bGF0ZU1pbldpZHRoIiwiY2FsY3VsYXRlTWluSGVpZ2h0Iiwic3RhdGVBbmRJbmZvcyIsImxvY2F0aW9ucyIsImNoYW5nZU5vZGVMYWJlbCIsImNoYW5nZUZvbnRQcm9wZXJ0aWVzIiwiY2hhbmdlU3RhdGVPckluZm9Cb3giLCJpbmRleCIsInZhbHVlIiwidHlwZSIsImFkZFN0YXRlT3JJbmZvQm94Iiwib2JqIiwicmVtb3ZlU3RhdGVPckluZm9Cb3giLCJsb2NhdGlvbk9iaiIsImZpdFVuaXRzIiwidW5kZWZpbmVkIiwic2V0TXVsdGltZXJTdGF0dXMiLCJzdGF0dXMiLCJyZWRyYXdDbG9uZU1hcmtlcnMiLCJzZXRDbG9uZU1hcmtlclN0YXR1cyIsImNoYW5nZUNzcyIsInZhbHVlTWFwIiwiY2hhbmdlRGF0YSIsInVwZGF0ZVNldEZpZWxkIiwiZmllbGROYW1lIiwidG9EZWxldGUiLCJ0b0FkZCIsInNldERlZmF1bHRQcm9wZXJ0eSIsIl9jbGFzcyIsInByb3BNYXAiLCJzZXREZWZhdWx0UHJvcGVydGllcyIsInVwZGF0ZUluZm9ib3hTdHlsZSIsIm5ld1Byb3BzIiwidXBkYXRlSW5mb2JveE9iaiIsImRlbGV0ZUFuZFBlcmZvcm1MYXlvdXQiLCJsYXlvdXRwYXJhbSIsImFsbE5vZGVzIiwibm9kZXNUb0tlZXAiLCJleHRlbmRSZW1haW5pbmdOb2RlcyIsIm5vZGVzVG9SZW1vdmUiLCJub3QiLCJoaWRlQW5kUGVyZm9ybUxheW91dCIsIm5vZGVzVG9TaG93Iiwibm9kZXNUb0hpZGUiLCJub2Rlc1dpdGhIaWRkZW5OZWlnaGJvciIsImNvbm5lY3RlZE5vZGVzIiwidGhpbkJvcmRlciIsInRoaWNrZW5Cb3JkZXIiLCJ1ciIsImFjdGlvbiIsImludGVyc2VjdGlvbiIsIm5laWdoYm9yaG9vZCIsInNob3dBbGxBbmRQZXJmb3JtTGF5b3V0IiwiaGlkZGVuRWxlcyIsInNob3dBbmRQZXJmb3JtTGF5b3V0IiwibWFpbkVsZSIsImNsb3NlVXBFbGVtZW50cyIsIm5vZGVzVG9UaGluQm9yZGVyIiwidW5pb24iLCJub2Rlc1RvVGhpY2tlbkJvcmRlciIsImVkZ2VzV2l0aCIsImxlZnRYIiwiTnVtYmVyIiwiTUFYX1ZBTFVFIiwicmlnaHRYIiwiTUlOX1ZBTFVFIiwidG9wWSIsImJvdHRvbVkiLCJoYWxmV2lkdGgiLCJvdXRlcldpZHRoIiwiaGFsZkhlaWdodCIsIm91dGVySGVpZ2h0IiwicG9zaXRpb24iLCJvbGRDZW50ZXJYIiwib2xkQ2VudGVyWSIsIm1pbkhvcml6b250YWxQYXJhbSIsIm1heEhvcml6b250YWxQYXJhbSIsIm1pblZlcnRpY2FsUGFyYW0iLCJtYXhWZXJ0aWNhbFBhcmFtIiwicXVhZHJhbnRzIiwiY2hlY2tPY2N1cGllZFF1YWRyYW50cyIsImZyZWVRdWFkcmFudHMiLCJwcm9wZXJ0eSIsImhvcml6b250YWxNdWx0IiwidmVydGljYWxNdWx0IiwiaW5jbHVkZXMiLCJyYW5kb21RdWFkcmFudCIsIk1hdGgiLCJmbG9vciIsInJhbmRvbSIsImhvcml6b250YWxQYXJhbSIsImdlbmVyYXRlUmFuZG9tIiwidmVydGljYWxQYXJhbSIsIm5ld0NlbnRlclgiLCJuZXdDZW50ZXJZIiwieGRpZmYiLCJ5ZGlmZiIsIm5ld3giLCJuZXd5IiwibWluIiwibWF4IiwibXVsdCIsInZhbCIsImdldE1hcFR5cGUiLCJ2aXNpYmxlTmVpZ2hib3JFbGVzIiwidmlzaWJsZU5laWdoYm9yc09mTmVpZ2hib3JzIiwidmlzaWJsZUVsZXMiLCJvY2N1cGllZFF1YWRyYW50cyIsImZpcnN0Iiwic2Vjb25kIiwidGhpcmQiLCJmb3VydGgiLCJoaWdobGlnaHRQcm9jZXNzZXMiLCJyZXNldE1hcFR5cGUiLCJhZGRCYWNrZ3JvdW5kSW1hZ2UiLCJiZ09iaiIsInVwZGF0ZUluZm8iLCJwcm9tcHRJbnZhbGlkSW1hZ2UiLCJ2YWxpZGF0ZVVSTCIsInJlbW92ZUJhY2tncm91bmRJbWFnZSIsInVwZGF0ZUJhY2tncm91bmRJbWFnZSIsImNoYW5nZUJhY2tncm91bmRJbWFnZSIsIm9sZEltZyIsIm5ld0ltZyJdLCJtYXBwaW5ncyI6Ijs7QUFBQSxJQUFJQSxJQUFJLEdBQUdDLHNGQUFBLEVBQVg7QUFFQTtBQUNBO0FBQ0E7OztBQUNBQyxNQUFNLENBQUNDLE9BQVAsR0FBaUIsWUFBWTtBQUUzQixNQUFJQyxnQkFBSixFQUFzQkMsT0FBdEIsRUFBK0JDLEVBQS9CLEVBQW1DQyxlQUFuQzs7QUFFQSxXQUFTQyxhQUFULENBQXdCQyxLQUF4QixFQUErQjtBQUM3Qkwsb0JBQWdCLEdBQUdLLEtBQUssQ0FBQ0wsZ0JBQXpCO0FBQ0FDLFdBQU8sR0FBR0ksS0FBSyxDQUFDQyxlQUFOLENBQXNCQyxVQUF0QixFQUFWO0FBQ0FMLE1BQUUsR0FBR0csS0FBSyxDQUFDRyx3QkFBTixDQUErQkMsS0FBL0IsRUFBTDtBQUNBTixtQkFB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QThDO0FBQzVDO0FBQ0Q7O0FBRUQsUUFBSXpSLE9BQU8sQ0FBQ2tCLFFBQVosRUFBc0I7QUFDcEIsVUFBSWQsS0FBSyxHQUFHO0FBQ1ZvUixjQUFNLEVBQUVBLE1BREU7QUFFVkMsY0FBTSxFQUFFQSxNQUZFO0FBR1ZwTyxhQUFLLEVBQUVBLEtBSEc7QUFJVjRDLGlCQUFTLEVBQUUsSUFKRDtBQUtWaUwsa0JBQVUsRUFBRUEsVUFMRjtBQU1WQywwQkFBa0IsRUFBRUEsa0JBTlY7QUFPVkMsbUJBQVcsRUFBRUE7QUFQSCxPQUFaO0FBVUFuUixRQUFFLENBQUNvQixRQUFILFNBQWlCLHVCQUFqQixFQUEwQ2pCLEtBQTFDO0FBQ0QsS0FaRCxNQWFLO0FBQ0hMLHNCQUFnQixDQUFDd1IscUJBQWpCLENBQXVDbE8sS0FBdkMsRUFBOENtTyxNQUE5QyxFQUFzREMsTUFBdEQsRUFBOEQsSUFBOUQsRUFBb0VQLFVBQXBFLEVBQWdGQyxrQkFBaEYsRUFBb0dDLFdBQXBHO0FBQ0Q7O0FBRURuUixNQUFFLENBQUN5SixLQUFILEdBQVdDLE1BQVg7QUFDRCxHQXZCRDs7QUF5QkEsU0FBT3hKLGFBQVA7QUFDRCxDQXA5Q0QiLCJmaWxlIjoiLi9zcmMvdXRpbGl0aWVzL21haW4tdXRpbGl0aWVzLWZhY3RvcnkuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgbGlicyA9IHJlcXVpcmUoJy4vbGliLXV0aWxpdGllcycpLmdldExpYnMoKTtcblxuLypcbiAqIFRoZSBtYWluIHV0aWxpdGllcyB0byBiZSBleHBvc2VkIGRpcmVjdGx5LlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcblxuICB2YXIgZWxlbWVudFV0aWxpdGllcywgb3B0aW9ucywgY3ksIHNiZ252aXpJbnN0YW5jZTtcblxuICBmdW5jdGlvbiBtYWluVXRpbGl0aWVzIChwYXJhbSkge1xuICAgIGVsZW1lbnRVdGlsaXRpZXMgPSBwYXJhbS5lbGVtZW50VXRpbGl0aWVzO1xuICAgIG9wdGlvbnMgPSBwYXJhbS5vcHRpb25VdGlsaXRpZXMuZ2V0T3B0aW9ucygpO1xuICAgIGN5ID0gcGFyYW0uc2JnbnZpekluc3RhbmNlVXRpbGl0aWVzLmdldEN5KCk7XG4gICAgc2JnbnZpekluc3RhbmNlID0gcGFyYW0uc2JnbnZpekluc3RhbmNlVXRpbGl0aWVzLmdldEluc3RhbmNlKCk7XG4gIH07XG5cbiAgLypcbiAgICogQWRkcyBhIG5ldyBub2RlIHdpdGggdGhlIGdpdmVuIGNsYXNzIGFuZCBhdCB0aGUgZ2l2ZW4gY29vcmRpbmF0ZXMuIENvbnNpZGVycyB1bmRvYWJsZSBvcHRpb24uXG4gICAqL1xuICBtYWluVXRpbGl0aWVzLmFkZE5vZGUgPSBmdW5jdGlvbih4LCB5ICwgbm9kZVBhcmFtcywgaWQsIHBhcmVudCwgdmlzaWJpbGl0eSkge1xuICAgIGlmICggZWxlbWVudFV0aWxpdGllcy5pc0dyYXBoVG9wb2xvZ3lMb2NrZWQoKSApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgbWFwIHR5cGVcbiAgICBpZiAodHlwZW9mIG5vZGVQYXJhbXMgPT0gJ29iamVjdCcpe1xuLyogXG4gICAgICBpZiAoIWVsZW1lbnRVdGlsaXRpZXMuZ2V0TWFwVHlwZSgpKVxuICAgICAgICBlbGVtZW50VXRpbGl0aWVzLnNldE1hcFR5cGUobm9kZVBhcmFtcy5sYW5ndWFnZSk7XG4gICAgICBlbHNlIGlmIChlbGVtZW50VXRpbGl0aWVzLmdldE1hcFR5cGUoKSAhPSBub2RlUGFyYW1zLmxhbmd1YWdlKVxuICAgICAgICBlbGVtZW50VXRpbGl0aWVzLnNldE1hcFR5cGUoXCJVbmtub3duXCIpOyAqL1xuICAgIH1cblxuICAgIGlmICghb3B0aW9ucy51bmRvYWJsZSkge1xuICAgICAgcmV0dXJuIGVsZW1lbnRVdGlsaXRpZXMuYWRkTm9kZSh4LCB5LCBub2RlUGFyYW1zLCBpZCwgcGFyZW50LCB2aXNpYmlsaXR5KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2YXIgcGFyYW0gPSB7XG4gICAgICAgIG5ld05vZGUgOiB7XG4gICAgICAgICAgeDogeCxcbiAgICAgICAgICB5OiB5LFxuICAgICAgICAgIGNsYXNzOiBub2RlUGFyYW1zLFxuICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICAgICAgICB2aXNpYmlsaXR5OiB2aXNpYmlsaXR5XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHZhciByZXN1bHQgPSBjeS51bmRvUmVkbygpLmRvKFwiYWRkTm9kZVwiLCBwYXJhbSk7XG4gICAgICByZXR1cm4gcmVzdWx0LmVsZXM7XG4gICAgfVxuICB9O1xuXG4gIC8qXG4gICAqIEFkZHMgYSBuZXcgZWRnZSB3aXRoIHRoZSBnaXZlbiBjbGFzcyBhbmQgaGF2aW5nIHRoZSBnaXZlbiBzb3VyY2UgYW5kIHRhcmdldCBpZHMuIENvbnNpZGVycyB1bmRvYWJsZSBvcHRpb24uXG4gICAqL1xuICBtYWluVXRpbGl0aWVzLmFkZEVkZ2UgPSBmdW5jdGlvbihzb3VyY2UsIHRhcmdldCwgZWRnZVBhcmFtcywgaW52YWxpZEVkZ2VDYWxsYmFjaywgaWQsIHZpc2liaWxpdHkpIHtcbiAgICBpZiAoIGVsZW1lbnRVdGlsaXRpZXMuaXNHcmFwaFRvcG9sb2d5TG9ja2VkKCkgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIG1hcCB0eXBlXG4gICAgaWYgKHR5cGVvZiBlZGdlUGFyYW1zID09ICdvYmplY3QnKXtcblxuICAgICAvKiAgaWYgKCFlbGVtZW50VXRpbGl0aWVzLmdldE1hcFR5cGUoKSlcbiAgICAgICAgZWxlbWVudFV0aWxpdGllcy5zZXRNYXBUeXBlKGVkZ2VQYXJhbXMubGFuZ3VhZ2UpO1xuICAgICAgZWxzZSBpZiAoZWxlbWVudFV0aWxpdGllcy5nZXRNYXBUeXBlKCkgIT0gZWRnZVBhcmFtcy5sYW5ndWFnZSlcbiAgICAgICAgZWxlbWVudFV0aWxpdGllcy5zZXRNYXBUeXBlKFwiSHlicmlkQW55XCIpOyAqL1xuICAgIH1cbiAgICAvLyBHZXQgdGhlIHZhbGlkYXRpb24gcmVzdWx0XG4gICAgdmFyIGVkZ2VjbGFzcyA9IGVkZ2VQYXJhbXMuY2xhc3MgPyBlZGdlUGFyYW1zLmNsYXNzIDogZWRnZVBhcmFtcztcbiAgICB2YXIgdmFsaWRhdGlvbiA9IGVsZW1lbnRVdGlsaXRpZXMudmFsaWRhdGVBcnJvd0VuZHMoZWRnZWNsYXNzLCBjeS5nZXRFbGVtZW50QnlJZChzb3VyY2UpLCBjeS5nZXRFbGVtZW50QnlJZCh0YXJnZXQpKTtcblxuICAgIC8vIElmIHZhbGlkYXRpb24gcmVzdWx0IGlzICdpbnZhbGlkJyBjYW5jZWwgdGhlIG9wZXJhdGlvblxuICAgIGlmICh2YWxpZGF0aW9uID09PSAnaW52YWxpZCcpIHtcbiAgICAgIGlmKHR5cGVvZiBpbnZhbGlkRWRnZUNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIpe1xuICAgICAgICBpbnZhbGlkRWRnZUNhbGxiYWNrKCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSWYgdmFsaWRhdGlvbiByZXN1bHQgaXMgJ3JldmVyc2UnIHJldmVyc2UgdGhlIHNvdXJjZS10YXJnZXQgcGFpciBiZWZvcmUgY3JlYXRpbmcgdGhlIGVkZ2VcbiAgICBpZiAodmFsaWRhdGlvbiA9PT0gJ3JldmVyc2UnKSB7XG4gICAgICB2YXIgdGVtcCA9IHNvdXJjZTtcbiAgICAgIHNvdXJjZSA9IHRhcmdldDtcbiAgICAgIHRhcmdldCA9IHRlbXA7XG4gICAgfVxuXG4gICAgaWYgKCFvcHRpb25zLnVuZG9hYmxlKSB7XG4gICAgICByZXR1cm4gZWxlbWVudFV0aWxpdGllcy5hZGRFZGdlKHNvdXJjZSwgdGFyZ2V0LCBlZGdlUGFyYW1zLCBpZCwgdmlzaWJpbGl0eSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIHBhcmFtID0ge1xuICAgICAgICBuZXdFZGdlIDoge1xuICAgICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgICAgIGNsYXNzOiBlZGdlUGFyYW1zLFxuICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICB2aXNpYmlsaXR5OiB2aXNpYmlsaXR5XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHZhciByZXN1bHQgPSBjeS51bmRvUmVkbygpLmRvKFwiYWRkRWRnZVwiLCBwYXJhbSk7XG4gICAgICByZXR1cm4gcmVzdWx0LmVsZXM7XG4gICAgfVxuICB9O1xuXG4gIC8qXG4gICAqIEFkZHMgYSBwcm9jZXNzIHdpdGggY29udmVuaWVudCBlZGdlcy4gRm9yIG1vcmUgaW5mb3JtYXRpb24gcGxlYXNlIHNlZSAnaHR0cHM6Ly9naXRodWIuY29tL2lWaXMtYXQtQmlsa2VudC9uZXd0L2lzc3Vlcy85Jy5cbiAgICogQ29uc2lkZXJzIHVuZG9hYmxlIG9wdGlvbi5cbiAgICovXG4gIG1haW5VdGlsaXRpZXMuYWRkUHJvY2Vzc1dpdGhDb252ZW5pZW50RWRnZXMgPSBmdW5jdGlvbihfc291cmNlLCBfdGFyZ2V0LCBwcm9jZXNzVHlwZSkge1xuICAgIGlmICggZWxlbWVudFV0aWxpdGllcy5pc0dyYXBoVG9wb2xvZ3lMb2NrZWQoKSApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJZiBzb3VyY2UgYW5kIHRhcmdldCBJRHMgYXJlIGdpdmVuIGdldCB0aGUgZWxlbWVudHMgYnkgSURzXG4gICAgdmFyIHNvdXJjZSA9IHR5cGVvZiBfc291cmNlID09PSAnc3RyaW5nJyA/IGN5LmdldEVsZW1lbnRCeUlkKF9zb3VyY2UpIDogX3NvdXJjZTtcbiAgICB2YXIgdGFyZ2V0ID0gdHlwZW9mIF90YXJnZXQgPT09ICdzdHJpbmcnID8gY3kuZ2V0RWxlbWVudEJ5SWQoX3RhcmdldCkgOiBfdGFyZ2V0O1xuXG4gICAgLy8gSWYgc291cmNlIG9yIHRhcmdldCBkb2VzIG5vdCBoYXZlIGFuIEVQTiBjbGFzcyB0aGUgb3BlcmF0aW9uIGlzIG5vdCB2YWxpZFxuICAgIGlmICghZWxlbWVudFV0aWxpdGllcy5pc0VQTkNsYXNzKHNvdXJjZSkgfHwgIWVsZW1lbnRVdGlsaXRpZXMuaXNFUE5DbGFzcyh0YXJnZXQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFvcHRpb25zLnVuZG9hYmxlKSB7XG4gICAgICByZXR1cm4gZWxlbWVudFV0aWxpdGllcy5hZGRQcm9jZXNzV2l0aENvbnZlbmllbnRFZGdlcyhfc291cmNlLCBfdGFyZ2V0LCBwcm9jZXNzVHlwZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIHBhcmFtID0ge1xuICAgICAgICBzb3VyY2U6IF9zb3VyY2UsXG4gICAgICAgIHRhcmdldDogX3RhcmdldCxcbiAgICAgICAgcHJvY2Vzc1R5cGU6IHByb2Nlc3NUeXBlXG4gICAgICB9O1xuXG4gICAgICBjeS51bmRvUmVkbygpLmRvKFwiYWRkUHJvY2Vzc1dpdGhDb252ZW5pZW50RWRnZXNcIiwgcGFyYW0pO1xuICAgIH1cbiAgfTtcblxuICAvLyBjb252ZXJ0IGNvbGxhcHNlZCBjb21wb3VuZCBub2RlcyB0byBzaW1wbGUgbm9kZXNcbiAgLy8gYW5kIHVwZGF0ZSBwb3J0IHZhbHVlcyBvZiBwYXN0ZWQgbm9kZXMgYW5kIGVkZ2VzXG4gIHZhciBjbG9uZUNvbGxhcHNlZE5vZGVzQW5kUG9ydHMgPSBmdW5jdGlvbiAoZWxlc0JlZm9yZSl7XG4gICAgaWYgKCBlbGVtZW50VXRpbGl0aWVzLmlzR3JhcGhUb3BvbG9neUxvY2tlZCgpICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGN5LmVsZW1lbnRzKCkudW5zZWxlY3QoKTtcbiAgICB2YXIgZWxlc0FmdGVyID0gY3kuZWxlbWVudHMoKTtcbiAgICB2YXIgZWxlc0RpZmYgPSBlbGVzQWZ0ZXIuZGlmZihlbGVzQmVmb3JlKS5sZWZ0O1xuXG4gICAgLy8gc2hhbGxvdyBjb3B5IGNvbGxhcHNlZCBub2RlcyAtIGNvbGxhcHNlZCBjb21wb3VuZHMgYmVjb21lIHNpbXBsZSBub2Rlc1xuICAgIC8vIGRhdGEgcmVsYXRlZCB0byBjb2xsYXBzZWQgbm9kZXMgYXJlIHJlbW92ZWQgZnJvbSBnZW5lcmF0ZWQgY2xvbmVzXG4gICAgLy8gcmVsYXRlZCBpc3N1ZTogaHR0cHM6Ly9naXRodWIuY29tL2lWaXMtYXQtQmlsa2VudC9uZXd0L2lzc3Vlcy8xNDVcbiAgICB2YXIgY29sbGFwc2VkTm9kZXMgPSBlbGVzRGlmZi5maWx0ZXIoJ25vZGUuY3ktZXhwYW5kLWNvbGxhcHNlLWNvbGxhcHNlZC1ub2RlJyk7XG5cbiAgICBjb2xsYXBzZWROb2Rlcy5jb25uZWN0ZWRFZGdlcygpLnJlbW92ZSgpO1xuICAgIGNvbGxhcHNlZE5vZGVzLnJlbW92ZUNsYXNzKCdjeS1leHBhbmQtY29sbGFwc2UtY29sbGFwc2VkLW5vZGUnKTtcbiAgICBjb2xsYXBzZWROb2Rlcy5yZW1vdmVEYXRhKCdjb2xsYXBzZWRDaGlsZHJlbicpO1xuICAgIGNvbGxhcHNlZE5vZGVzLnJlbW92ZURhdGEoJ3Bvc2l0aW9uLWJlZm9yZS1jb2xsYXBzZSBzaXplLWJlZm9yZS1jb2xsYXBzZScpO1xuICAgIGNvbGxhcHNlZE5vZGVzLnJlbW92ZURhdGEoJ2V4cGFuZGNvbGxhcHNlUmVuZGVyZWRDdWVTaXplIGV4cGFuZGNvbGxhcHNlUmVuZGVyZWRTdGFydFggZXhwYW5kY29sbGFwc2VSZW5kZXJlZFN0YXJ0WScpO1xuXG4gICAgLy8gY2xvbmluZyBwb3J0c1xuICAgIGVsZXNEaWZmLm5vZGVzKCkuZm9yRWFjaChmdW5jdGlvbihfbm9kZSl7XG4gICAgICBpZihfbm9kZS5kYXRhKFwicG9ydHNcIikubGVuZ3RoID09IDIpe1xuICAgICAgICAgIHZhciBvbGRQb3J0TmFtZTAgPSBfbm9kZS5kYXRhKFwicG9ydHNcIilbMF0uaWQ7XG4gICAgICAgICAgdmFyIG9sZFBvcnROYW1lMSA9IF9ub2RlLmRhdGEoXCJwb3J0c1wiKVsxXS5pZDtcbiAgICAgICAgICBfbm9kZS5kYXRhKFwicG9ydHNcIilbMF0uaWQgPSBfbm9kZS5pZCgpICsgXCIuMVwiO1xuICAgICAgICAgIF9ub2RlLmRhdGEoXCJwb3J0c1wiKVsxXS5pZCA9IF9ub2RlLmlkKCkgKyBcIi4yXCI7XG5cbiAgICAgICAgICBfbm9kZS5vdXRnb2VycygpLmVkZ2VzKCkuZm9yRWFjaChmdW5jdGlvbihfZWRnZSl7XG4gICAgICAgICAgICBpZihfZWRnZS5kYXRhKFwicG9ydHNvdXJjZVwiKSA9PSBvbGRQb3J0TmFtZTApe1xuICAgICAgICAgICAgICBfZWRnZS5kYXRhKFwicG9ydHNvdXJjZVwiLCBfbm9kZS5kYXRhKFwicG9ydHNcIilbMF0uaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZihfZWRnZS5kYXRhKFwicG9ydHNvdXJjZVwiKSA9PSBvbGRQb3J0TmFtZTEpe1xuICAgICAgICAgICAgICBfZWRnZS5kYXRhKFwicG9ydHNvdXJjZVwiLCBfbm9kZS5kYXRhKFwicG9ydHNcIilbMV0uaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgICAgX2VkZ2UuZGF0YShcInBvcnRzb3VyY2VcIiwgX25vZGUuaWQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgX25vZGUuaW5jb21lcnMoKS5lZGdlcygpLmZvckVhY2goZnVuY3Rpb24oX2VkZ2Upe1xuICAgICAgICAgICAgaWYoX2VkZ2UuZGF0YShcInBvcnR0YXJnZXRcIikgPT0gb2xkUG9ydE5hbWUwKXtcbiAgICAgICAgICAgICAgX2VkZ2UuZGF0YShcInBvcnR0YXJnZXRcIiwgX25vZGUuZGF0YShcInBvcnRzXCIpWzBdLmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYoX2VkZ2UuZGF0YShcInBvcnR0YXJnZXRcIikgPT0gb2xkUG9ydE5hbWUxKXtcbiAgICAgICAgICAgICAgX2VkZ2UuZGF0YShcInBvcnR0YXJnZXRcIiwgX25vZGUuZGF0YShcInBvcnRzXCIpWzFdLmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgIF9lZGdlLmRhdGEoXCJwb3J0dGFyZ2V0XCIsIF9ub2RlLmlkKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZWxzZXtcbiAgICAgICAgX25vZGUub3V0Z29lcnMoKS5lZGdlcygpLmZvckVhY2goZnVuY3Rpb24oX2VkZ2Upe1xuICAgICAgICAgIF9lZGdlLmRhdGEoXCJwb3J0c291cmNlXCIsIF9ub2RlLmlkKCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgX25vZGUuaW5jb21lcnMoKS5lZGdlcygpLmZvckVhY2goZnVuY3Rpb24oX2VkZ2Upe1xuICAgICAgICAgIF9lZGdlLmRhdGEoXCJwb3J0dGFyZ2V0XCIsIF9ub2RlLmlkKCkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBlbGVzRGlmZi5zZWxlY3QoKTtcbiAgfVxuXG4gIC8qXG4gICAqIENsb25lIGdpdmVuIGVsZW1lbnRzLiBDb25zaWRlcnMgdW5kb2FibGUgb3B0aW9uLiBSZXF1aXJlcyBjeXRvc2NhcGUtY2xpcGJvYXJkIGV4dGVuc2lvbi5cbiAgICovXG4gIG1haW5VdGlsaXRpZXMuY2xvbmVFbGVtZW50cyA9IGZ1bmN0aW9uIChlbGVzLCBwYXN0ZUF0TW91c2VMb2MpIHtcbiAgICBpZiAoIGVsZW1lbnRVdGlsaXRpZXMuaXNHcmFwaFRvcG9sb2d5TG9ja2VkKCkgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGVsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5jb3B5RWxlbWVudHMoZWxlcyk7XG5cbiAgICB0aGlzLnBhc3RlRWxlbWVudHMocGFzdGVBdE1vdXNlTG9jKTtcbiAgfTtcblxuICAvKlxuICAgKiBDb3B5IGdpdmVuIGVsZW1lbnRzIHRvIGNsaXBib2FyZC4gUmVxdWlyZXMgY3l0b3NjYXBlLWNsaXBib2FyZCBleHRlbnNpb24uXG4gICAqL1xuICBtYWluVXRpbGl0aWVzLmNvcHlFbGVtZW50cyA9IGZ1bmN0aW9uIChlbGVzKSB7XG4gICAgY3kuY2xpcGJvYXJkKCkuY29weShlbGVzKTtcbiAgfTtcblxuICAvKlxuICAgKiBQYXN0ZSB0aGUgZWxlbWVudHMgY29waWVkIHRvIGNsaXBib2FyZC4gQ29uc2lkZXJzIHVuZG9hYmxlIG9wdGlvbi4gUmVxdWlyZXMgY3l0b3NjYXBlLWNsaXBib2FyZCBleHRlbnNpb24uXG4gICAqL1xuICBtYWluVXRpbGl0aWVzLnBhc3RlRWxlbWVudHMgPSBmdW5jdGlvbihwYXN0ZUF0TW91c2VMb2MpIHtcbiAgICBpZiAoIGVsZW1lbnRVdGlsaXRpZXMuaXNHcmFwaFRvcG9sb2d5TG9ja2VkKCkgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGVsZXNCZWZvcmUgPSBjeS5lbGVtZW50cygpO1xuXG4gICAgaWYgKG9wdGlvbnMudW5kb2FibGUpIHtcbiAgICAgIGN5LnVuZG9SZWRvKCkuZG8oXCJwYXN0ZVwiLHtwYXN0ZUF0TW91c2VMb2M6IHBhc3RlQXRNb3VzZUxvY30pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGN5LmNsaXBib2FyZCgpLnBhc3RlKCk7XG4gICAgfVxuICAgIGNsb25lQ29sbGFwc2VkTm9kZXNBbmRQb3J0cyhlbGVzQmVmb3JlKTtcbiAgICBjeS5ub2RlcyhcIjpzZWxlY3RlZFwiKS5lbWl0KCdkYXRhJyk7XG4gIH07XG5cbiAgLypcbiAgICogQWxpZ25zIGdpdmVuIG5vZGVzIGluIGdpdmVuIGhvcml6b250YWwgYW5kIHZlcnRpY2FsIG9yZGVyLlxuICAgKiBIb3Jpem9udGFsIGFuZCB2ZXJ0aWNhbCBwYXJhbWV0ZXJzIG1heSBiZSAnbm9uZScgb3IgdW5kZWZpbmVkLlxuICAgKiBhbGlnblRvIHBhcmFtZXRlciBpbmRpY2F0ZXMgdGhlIGxlYWRpbmcgbm9kZS5cbiAgICogUmVxdXJpcmVzIGN5dG9zY2FwZS1ncmlkLWd1aWRlIGV4dGVuc2lvbiBhbmQgY29uc2lkZXJzIHVuZG9hYmxlIG9wdGlvbi5cbiAgICovXG4gIG1haW5VdGlsaXRpZXMuYWxpZ24gPSBmdW5jdGlvbiAobm9kZXMsIGhvcml6b250YWwsIHZlcnRpY2FsLCBhbGlnblRvKSB7XG4gICAgaWYgKG5vZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnVuZG9hYmxlKSB7XG4gICAgICBjeS51bmRvUmVkbygpLmRvKFwiYWxpZ25cIiwge1xuICAgICAgICBub2Rlczogbm9kZXMsXG4gICAgICAgIGhvcml6b250YWw6IGhvcml6b250YWwsXG4gICAgICAgIHZlcnRpY2FsOiB2ZXJ0aWNhbCxcbiAgICAgICAgYWxpZ25UbzogYWxpZ25Ub1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGVzLmFsaWduKGhvcml6b250YWwsIHZlcnRpY2FsLCBhbGlnblRvKTtcbiAgICB9XG5cbiAgICBpZihjeS5lZGdlcyhcIjpzZWxlY3RlZFwiKS5sZW5ndGggPT0gMSApIHtcbiAgICAgIGN5LmVkZ2VzKCkudW5zZWxlY3QoKTsgICAgICBcbiAgICB9XG4gICAgXG4gIH07XG5cbiAgLypcbiAgICogQ3JlYXRlIGNvbXBvdW5kIGZvciBnaXZlbiBub2Rlcy4gY29tcG91bmRUeXBlIG1heSBiZSAnY29tcGxleCcgb3IgJ2NvbXBhcnRtZW50Jy5cbiAgICogVGhpcyBtZXRob2QgY29uc2lkZXJzIHVuZG9hYmxlIG9wdGlvbi5cbiAgICovXG4gIG1haW5VdGlsaXRpZXMuY3JlYXRlQ29tcG91bmRGb3JHaXZlbk5vZGVzID0gZnVuY3Rpb24gKF9ub2RlcywgY29tcG91bmRUeXBlKSB7XG4gICAgaWYgKCBlbGVtZW50VXRpbGl0aWVzLmlzR3JhcGhUb3BvbG9neUxvY2tlZCgpICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBub2RlcyA9IF9ub2RlcztcbiAgICAvKlxuICAgICAqIEVsZW1pbmF0ZSB0aGUgbm9kZXMgd2hpY2ggY2Fubm90IGhhdmUgYSBwYXJlbnQgd2l0aCBnaXZlbiBjb21wb3VuZCB0eXBlXG4gICAgICovXG4gICAgbm9kZXMgPSBfbm9kZXMuZmlsdGVyKGZ1bmN0aW9uIChlbGVtZW50LCBpKSB7XG4gICAgICBpZih0eXBlb2YgZWxlbWVudCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBlbGVtZW50ID0gaTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNiZ25jbGFzcyA9IGVsZW1lbnQuZGF0YShcImNsYXNzXCIpO1xuICAgICAgcmV0dXJuIGVsZW1lbnRVdGlsaXRpZXMuaXNWYWxpZFBhcmVudChzYmduY2xhc3MsIGNvbXBvdW5kVHlwZSwgZWxlbWVudCk7XG4gICAgfSk7XG5cbiAgICBub2RlcyA9IGVsZW1lbnRVdGlsaXRpZXMuZ2V0VG9wTW9zdE5vZGVzKG5vZGVzKTtcblxuICAgIC8vIEFsbCBlbGVtZW50cyBzaG91bGQgaGF2ZSB0aGUgc2FtZSBwYXJlbnQgYW5kIHRoZSBjb21tb24gcGFyZW50IHNob3VsZCBub3QgYmUgYSAnY29tcGxleCdcbiAgICAvLyBpZiBjb21wb3VuZFR5cGUgaXMgJ2NvbXBhcnRlbnQnXG4gICAgLy8gYmVjYXVzZSB0aGUgb2xkIGNvbW1vbiBwYXJlbnQgd2lsbCBiZSB0aGUgcGFyZW50IG9mIHRoZSBuZXcgY29tcGFydG1lbnQgYWZ0ZXIgdGhpcyBvcGVyYXRpb24gYW5kXG4gICAgLy8gJ2NvbXBsZXhlcycgY2Fubm90IGluY2x1ZGUgJ2NvbXBhcnRtZW50cydcbiAgICBpZiAobm9kZXMubGVuZ3RoID09IDAgfHwgIWVsZW1lbnRVdGlsaXRpZXMuYWxsSGF2ZVRoZVNhbWVQYXJlbnQobm9kZXMpXG4gICAgICAgICAgICB8fCAoIChjb21wb3VuZFR5cGUgPT09ICdjb21wYXJ0bWVudCcgfHwgY29tcG91bmRUeXBlID09ICdzdWJtYXAnKSAmJiBub2Rlcy5wYXJlbnQoKS5kYXRhKCdjbGFzcycpXG4gICAgICAgICAgICAmJiBub2Rlcy5wYXJlbnQoKS5kYXRhKCdjbGFzcycpLnN0YXJ0c1dpdGgoJ2NvbXBsZXgnKSApKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGN5LnVuZG9SZWRvKCkpIHtcbiAgICAgIHZhciBwYXJhbSA9IHtcbiAgICAgICAgY29tcG91bmRUeXBlOiBjb21wb3VuZFR5cGUsXG4gICAgICAgIG5vZGVzVG9NYWtlQ29tcG91bmQ6IG5vZGVzXG4gICAgICB9O1xuXG4gICAgICBjeS51bmRvUmVkbygpLmRvKFwiY3JlYXRlQ29tcG91bmRGb3JHaXZlbk5vZGVzXCIsIHBhcmFtKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBlbGVtZW50VXRpbGl0aWVzLmNyZWF0ZUNvbXBvdW5kRm9yR2l2ZW5Ob2Rlcyhub2RlcywgY29tcG91bmRUeXBlKTtcbiAgICB9XG4gIH07XG5cbiAgLypcbiAgICogTW92ZSB0aGUgbm9kZXMgdG8gYSBuZXcgcGFyZW50IGFuZCBjaGFuZ2UgdGhlaXIgcG9zaXRpb24gaWYgcG9zc0RpZmYgcGFyYW1zIGFyZSBzZXQuXG4gICAqIENvbnNpZGVycyB1bmRvYWJsZSBvcHRpb24gYW5kIGNoZWNrcyBpZiB0aGUgb3BlcmF0aW9uIGlzIHZhbGlkLlxuICAgKi9cbiAgbWFpblV0aWxpdGllcy5jaGFuZ2VQYXJlbnQgPSBmdW5jdGlvbihub2RlcywgX25ld1BhcmVudCwgcG9zRGlmZlgsIHBvc0RpZmZZKSB7XG4gICAgaWYgKCBlbGVtZW50VXRpbGl0aWVzLmlzR3JhcGhUb3BvbG9neUxvY2tlZCgpICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuZXdQYXJlbnQgPSB0eXBlb2YgX25ld1BhcmVudCA9PT0gJ3N0cmluZycgPyBjeS5nZXRFbGVtZW50QnlJZChfbmV3UGFyZW50KSA6IF9uZXdQYXJlbnQ7XG4gICAgLy8gTmV3IHBhcmVudCBpcyBzdXBwb3NlZCB0byBiZSBvbmUgb2YgdGhlIHJvb3QsIGEgY29tcGxleCBvciBhIGNvbXBhcnRtZW50XG4gICAgaWYgKG5ld1BhcmVudCAmJiAhbmV3UGFyZW50LmRhdGEoXCJjbGFzc1wiKS5zdGFydHNXaXRoKFwiY29tcGxleFwiKSAmJiBuZXdQYXJlbnQuZGF0YShcImNsYXNzXCIpICE9IFwiY29tcGFydG1lbnRcIlxuICAgICAgICAgICAgJiYgbmV3UGFyZW50LmRhdGEoXCJjbGFzc1wiKSAhPSBcInN1Ym1hcFwiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8qXG4gICAgICogRWxlbWluYXRlIHRoZSBub2RlcyB3aGljaCBjYW5ub3QgaGF2ZSB0aGUgbmV3UGFyZW50IGFzIHRoZWlyIHBhcmVudFxuICAgICAqL1xuICAgIG5vZGVzID0gbm9kZXMuZmlsdGVyKGZ1bmN0aW9uIChlbGVtZW50LCBpKSB7XG4gICAgICBpZih0eXBlb2YgZWxlbWVudCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBlbGVtZW50ID0gaTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNiZ25jbGFzcyA9IGVsZW1lbnQuZGF0YShcImNsYXNzXCIpO1xuICAgICAgcmV0dXJuIGVsZW1lbnRVdGlsaXRpZXMuaXNWYWxpZFBhcmVudChzYmduY2xhc3MsIG5ld1BhcmVudCwgZWxlbWVudCk7XG4gICAgfSk7XG5cbiAgICAvLyBEaXNjYXJkIHRoZSBub2RlcyB3aG9zZSBwYXJlbnQgaXMgYWxyZWFkeSBuZXdQYXJlbnQuXG4gICAgLy8gRGlzY2FyZCB0aGUgbmV3UGFyZW50IGl0c2VsZiBpZiBpdCBpcyBhbW9uZyB0aGUgbm9kZXNcbiAgICBub2RlcyA9IG5vZGVzLmZpbHRlcihmdW5jdGlvbiAoZWxlLCBpKSB7XG4gICAgICBpZih0eXBlb2YgZWxlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGVsZSA9IGk7XG4gICAgICB9XG5cbiAgICAgIC8vIERpc2NhcmQgdGhlIG5ld1BhcmVudCBpZiBpdCBpcyBhbW9uZyB0aGUgbm9kZXNcbiAgICAgIGlmIChuZXdQYXJlbnQgJiYgZWxlLmlkKCkgPT09IG5ld1BhcmVudC5pZCgpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIERpc2NhcmQgdGhlIG5vZGVzIHdob3NlIHBhcmVudCBpcyBhbHJlYWR5IG5ld1BhcmVudFxuICAgICAgaWYgKCFuZXdQYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIGVsZS5kYXRhKCdwYXJlbnQnKSAhPSBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVsZS5kYXRhKCdwYXJlbnQnKSAhPT0gbmV3UGFyZW50LmlkKCk7XG4gICAgfSk7XG5cbiAgICAvLyBJZiBzb21lIG5vZGVzIGFyZSBhbmNlc3RvciBvZiBuZXcgcGFyZW50IGVsZW1pbmF0ZSB0aGVtXG4gICAgaWYgKG5ld1BhcmVudCkge1xuICAgICAgbm9kZXMgPSBub2Rlcy5kaWZmZXJlbmNlKG5ld1BhcmVudC5hbmNlc3RvcnMoKSk7XG4gICAgfVxuXG4gICAgLy8gSWYgYWxsIG5vZGVzIGFyZSBlbGVtaW5hdGVkIHJldHVybiBkaXJlY3RseVxuICAgIGlmIChub2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBKdXN0IG1vdmUgdGhlIHRvcCBtb3N0IG5vZGVzXG4gICAgbm9kZXMgPSBlbGVtZW50VXRpbGl0aWVzLmdldFRvcE1vc3ROb2Rlcyhub2Rlcyk7XG5cbiAgICB2YXIgcGFyZW50SWQgPSBuZXdQYXJlbnQgPyBuZXdQYXJlbnQuaWQoKSA6IG51bGw7XG5cbiAgICBpZiAob3B0aW9ucy51bmRvYWJsZSkge1xuICAgICAgdmFyIHBhcmFtID0ge1xuICAgICAgICBmaXJzdFRpbWU6IHRydWUsXG4gICAgICAgIHBhcmVudERhdGE6IHBhcmVudElkLCAvLyBJdCBrZWVwcyB0aGUgbmV3UGFyZW50SWQgKEp1c3QgYW4gaWQgZm9yIGVhY2ggbm9kZXMgZm9yIHRoZSBmaXJzdCB0aW1lKVxuICAgICAgICBub2Rlczogbm9kZXMsXG4gICAgICAgIHBvc0RpZmZYOiBwb3NEaWZmWCxcbiAgICAgICAgcG9zRGlmZlk6IHBvc0RpZmZZLFxuICAgICAgICAvLyBUaGlzIGlzIG5lZWRlZCBiZWNhdXNlIHRoZSBjaGFuZ2VQYXJlbnQgZnVuY3Rpb24gY2FsbGVkIGlzIG5vdCBmcm9tIGVsZW1lbnRVdGlsaXRpZXNcbiAgICAgICAgLy8gYnV0IGZyb20gdGhlIHVuZG9SZWRvIGV4dGVuc2lvbiBkaXJlY3RseSwgc28gbWFpbnRhaW5pbmcgcG9pbnRlciBpcyBub3QgYXV0b21hdGljYWxseSBkb25lLlxuICAgICAgICBjYWxsYmFjazogZWxlbWVudFV0aWxpdGllcy5tYWludGFpblBvaW50ZXJcbiAgICAgIH07XG5cbiAgICAgIGN5LnVuZG9SZWRvKCkuZG8oXCJjaGFuZ2VQYXJlbnRcIiwgcGFyYW0pOyAvLyBUaGlzIGFjdGlvbiBpcyByZWdpc3RlcmVkIGJ5IHVuZG9SZWRvIGV4dGVuc2lvblxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGVsZW1lbnRVdGlsaXRpZXMuY2hhbmdlUGFyZW50KG5vZGVzLCBwYXJlbnRJZCwgcG9zRGlmZlgsIHBvc0RpZmZZKTtcbiAgICB9XG4gIH07XG5cbiAgLypcbiAgICogQ3JlYXRlcyBhbiBhY3RpdmF0aW9uIHJlYWN0aW9uIHdpdGggZ2l2ZW4gcGFyYW1ldGVycy4gUmVxdWlyZXMgY29zZS1iaWxrZW50IGxheW91dCB0byB0aWxlIHRoZSBmcmVlIG1hY3JvbW9sZWN1bGVzIGluY2x1ZGVkXG4gICAqIGluIHRoZSBjb21wbGV4LiBDb25zaWRlcnMgdW5kb2FibGUgb3B0aW9uLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBzZWUgdGhlIHNhbWUgZnVuY3Rpb24gaW4gZWxlbWVudFV0aWxpdGllc1xuICAgKi9cbiAgbWFpblV0aWxpdGllcy5jcmVhdGVUcmFuc2xhdGlvblJlYWN0aW9uID0gZnVuY3Rpb24gKG1SbmFOYW1lLCBwcm90ZWluTmFtZSwgcHJvY2Vzc1Bvc2l0aW9uLCBlZGdlTGVuZ3RoKSB7XG4gICAgaWYgKCBlbGVtZW50VXRpbGl0aWVzLmlzR3JhcGhUb3BvbG9neUxvY2tlZCgpICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghb3B0aW9ucy51bmRvYWJsZSkge1xuICAgICAgZWxlbWVudFV0aWxpdGllcy5jcmVhdGVUcmFuc2xhdGlvblJlYWN0aW9uKG1SbmFOYW1lLCBwcm90ZWluTmFtZSwgcHJvY2Vzc1Bvc2l0aW9uLCBlZGdlTGVuZ3RoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2YXIgcGFyYW0gPSB7XG4gICAgICAgIG1SbmFOYW1lOiBtUm5hTmFtZSxcbiAgICAgICAgcHJvdGVpbk5hbWU6IHByb3RlaW5OYW1lLFxuICAgICAgICBwcm9jZXNzUG9zaXRpb246IHByb2Nlc3NQb3NpdGlvbixcbiAgICAgICAgZWRnZUxlbmd0aDogZWRnZUxlbmd0aFxuICAgICAgfTtcblxuICAgICAgY3kudW5kb1JlZG8oKS5kbyhcImNyZWF0ZVRyYW5zbGF0aW9uUmVhY3Rpb25cIiwgcGFyYW0pO1xuICB9fTtcblxuICAvKlxuICAgKiBDcmVhdGVzIGFuIGFjdGl2YXRpb24gcmVhY3Rpb24gd2l0aCBnaXZlbiBwYXJhbWV0ZXJzLiBSZXF1aXJlcyBjb3NlLWJpbGtlbnQgbGF5b3V0IHRvIHRpbGUgdGhlIGZyZWUgbWFjcm9tb2xlY3VsZXMgaW5jbHVkZWRcbiAgICogaW4gdGhlIGNvbXBsZXguIENvbnNpZGVycyB1bmRvYWJsZSBvcHRpb24uIEZvciBtb3JlIGluZm9ybWF0aW9uIHNlZSB0aGUgc2FtZSBmdW5jdGlvbiBpbiBlbGVtZW50VXRpbGl0aWVzXG4gICAqL1xuICBtYWluVXRpbGl0aWVzLmNyZWF0ZVRyYW5zY3JpcHRpb25SZWFjdGlvbiA9IGZ1bmN0aW9uIChnZW5lTmFtZSwgbVJuYU5hbWUsIHByb2Nlc3NQb3NpdGlvbiwgZWRnZUxlbmd0aCkge1xuICAgIGlmICggZWxlbWVudFV0aWxpdGllcy5pc0dyYXBoVG9wb2xvZ3lMb2NrZWQoKSApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIW9wdGlvbnMudW5kb2FibGUpIHtcbiAgICAgIGVsZW1lbnRVdGlsaXRpZXMuY3JlYXRlVHJhbnNjcmlwdGlvblJlYWN0aW9uKGdlbmVOYW1lLCBtUm5hTmFtZSwgcHJvY2Vzc1Bvc2l0aW9uLCBlZGdlTGVuZ3RoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2YXIgcGFyYW0gPSB7XG4gICAgICAgIGdlbmVOYW1lOiBnZW5lTmFtZSxcbiAgICAgICAgbVJuYU5hbWU6IG1SbmFOYW1lLFxuICAgICAgICBwcm9jZXNzUG9zaXRpb246IHByb2Nlc3NQb3NpdGlvbixcbiAgICAgICAgZWRnZUxlbmd0aDogZWRnZUxlbmd0aFxuICAgICAgfTtcblxuICAgICAgY3kudW5kb1JlZG8oKS5kbyhcImNyZWF0ZVRyYW5zY3JpcHRpb25SZWFjdGlvblwiLCBwYXJhbSk7XG4gIH19O1xuXG4gIG1haW5VdGlsaXRpZXMuY3JlYXRlVHJhbnNsYXRpb24gPSBmdW5jdGlvbihyZWd1bGF0b3JMYWJlbCwgb3V0cHV0TGFiZWwsIG9yaWVudGF0aW9uKSB7XG4gICAgaWYgKCBlbGVtZW50VXRpbGl0aWVzLmlzR3JhcGhUb3BvbG9neUxvY2tlZCgpICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghb3B0aW9ucy51bmRvYWJsZSkge1xuICAgICAgZWxlbWVudFV0aWxpdGllcy5jcmVhdGVUcmFuc2xhdGlvbihyZWd1bGF0b3JMYWJlbCwgb3V0cHV0TGFiZWwsIG9yaWVudGF0aW9uKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCBwYXJhbSA9IHtcbiAgICAgICAgcmVndWxhdG9yTGFiZWw6IHJlZ3VsYXRvckxhYmVsLFxuICAgICAgICBvdXRwdXRMYWJlbDogb3V0cHV0TGFiZWwsXG4gICAgICAgIG9yaWVudGF0aW9uOiBvcmllbnRhdGlvblxuICAgICAgfTtcblxuICAgICAgY3kudW5kb1JlZG8oKS5kbyhcImNyZWF0ZVRyYW5zbGF0aW9uXCIsIHBhcmFtKTtcbiAgICB9ICBcbiAgfTtcblxuICBtYWluVXRpbGl0aWVzLmNyZWF0ZVRyYW5zY3JpcHRpb24gPSBmdW5jdGlvbihsYWJlbCwgb3JpZW50YXRpb24pIHtcbiAgICBpZiAoIGVsZW1lbnRVdGlsaXRpZXMuaXNHcmFwaFRvcG9sb2d5TG9ja2VkKCkgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFvcHRpb25zLnVuZG9hYmxlKSB7XG4gICAgICBlbGVtZW50VXRpbGl0aWVzLmNyZWF0ZVRyYW5zY3JpcHRpb24obGFiZWwsIG9yaWVudGF0aW9uKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCBwYXJhbSA9IHtcbiAgICAgICAgbGFiZWw6IGxhYmVsLFxuICAgICAgICBvcmllbnRhdGlvbjogb3JpZW50YXRpb25cbiAgICAgIH07XG5cbiAgICAgIGN5LnVuZG9SZWRvKCkuZG8oXCJjcmVhdGVUcmFuc2NyaXB0aW9uXCIsIHBhcmFtKTtcbiAgICB9ICBcbiAgfTtcblxuICBtYWluVXRpbGl0aWVzLmNyZWF0ZURlZ3JhZGF0aW9uID0gZnVuY3Rpb24obWFjcm9tb2xlY3VsZSwgb3JpZW50YXRpb24pIHtcbiAgICBpZiAoIGVsZW1lbnRVdGlsaXRpZXMuaXNHcmFwaFRvcG9sb2d5TG9ja2VkKCkgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFvcHRpb25zLnVuZG9hYmxlKSB7XG4gICAgICBlbGVtZW50VXRpbGl0aWVzLmNyZWF0ZURlZ3JhZGF0aW9uKG1hY3JvbW9sZWN1bGUsIG9yaWVudGF0aW9uKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCBwYXJhbSA9IHtcbiAgICAgICAgbWFjcm9tb2xlY3VsZTogbWFjcm9tb2xlY3VsZSxcbiAgICAgICAgb3JpZW50YXRpb246IG9yaWVudGF0aW9uXG4gICAgICB9O1xuXG4gICAgICBjeS51bmRvUmVkbygpLmRvKFwiY3JlYXRlRGVncmFkYXRpb25cIiwgcGFyYW0pO1xuICAgIH0gIFxuICB9O1xuXG4gIG1haW5VdGlsaXRpZXMuY3JlYXRlQ29tcGxleFByb3RlaW5Gb3JtYXRpb24gPSBmdW5jdGlvbihwcm90ZWluTGFiZWxzLCBjb21wbGV4TGFiZWwsIHJlZ3VsYXRvciwgb3JpZW50YXRpb24sIHJldmVyc2UpIHtcbiAgICBpZiAoIGVsZW1lbnRVdGlsaXRpZXMuaXNHcmFwaFRvcG9sb2d5TG9ja2VkKCkgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFvcHRpb25zLnVuZG9hYmxlKSB7XG4gICAgICBlbGVtZW50VXRpbGl0aWVzLmNyZWF0ZUNvbXBsZXhQcm90ZWluRm9ybWF0aW9uKHByb3RlaW5MYWJlbHMsIGNvbXBsZXhMYWJlbCwgcmVndWxhdG9yLCBvcmllbnRhdGlvbiwgcmV2ZXJzZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY29uc3QgcGFyYW0gPSB7XG4gICAgICAgIHByb3RlaW5MYWJlbHM6IHByb3RlaW5MYWJlbHMsXG4gICAgICAgIGNvbXBsZXhMYWJlbDogY29tcGxleExhYmVsLFxuICAgICAgICByZWd1bGF0b3I6IHJlZ3VsYXRvcixcbiAgICAgICAgb3JpZW50YXRpb246IG9yaWVudGF0aW9uLFxuICAgICAgICByZXZlcnNlOiByZXZlcnNlXG4gICAgICB9O1xuXG4gICAgICBjeS51bmRvUmVkbygpLmRvKFwiY3JlYXRlQ29tcGxleFByb3RlaW5Gb3JtYXRpb25cIiwgcGFyYW0pO1xuICAgIH0gIFxuICB9O1xuXG4gIG1haW5VdGlsaXRpZXMuY3JlYXRlTXVsdGltZXJpemF0aW9uID0gZnVuY3Rpb24obWFjcm9tb2xlY3VsZSwgcmVndWxhdG9yLCByZWd1bGF0b3JNdWx0aW1lciwgb3JpZW50YXRpb24pIHtcbiAgICBpZiAoIGVsZW1lbnRVdGlsaXRpZXMuaXNHcmFwaFRvcG9sb2d5TG9ja2VkKCkgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFvcHRpb25zLnVuZG9hYmxlKSB7XG4gICAgICBlbGVtZW50VXRpbGl0aWVzLmNyZWF0ZU11bHRpbWVyaXphdGlvbihtYWNyb21vbGVjdWxlLCByZWd1bGF0b3IsIHJlZ3VsYXRvck11bHRpbWVyLCBvcmllbnRhdGlvbik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY29uc3QgcGFyYW0gPSB7XG4gICAgICAgIG1hY3JvbW9sZWN1bGU6IG1hY3JvbW9sZWN1bGUsXG4gICAgICAgIHJlZ3VsYXRvcjogcmVndWxhdG9yLFxuICAgICAgICByZWd1bGF0b3JNdWx0aW1lcjogcmVndWxhdG9yTXVsdGltZXIsXG4gICAgICAgIG9yaWVudGF0aW9uOiBvcmllbnRhdGlvblxuICAgICAgfTtcblxuICAgICAgY3kudW5kb1JlZG8oKS5kbyhcImNyZWF0ZU11bHRpbWVyaXphdGlvblwiLCBwYXJhbSk7XG4gICAgfSAgXG4gIH07XG5cbiAgbWFpblV0aWxpdGllcy5jcmVhdGVDb252ZXJzaW9uID0gZnVuY3Rpb24obWFjcm9tb2xlY3VsZSwgcmVndWxhdG9yLCByZWd1bGF0b3JNdWx0aW1lciwgb3JpZW50YXRpb24sIGlucHV0SW5mb2JveExhYmVscywgb3V0cHV0SW5mb2JveExhYmVscykge1xuICAgIGlmICggZWxlbWVudFV0aWxpdGllcy5pc0dyYXBoVG9wb2xvZ3lMb2NrZWQoKSApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIW9wdGlvbnMudW5kb2FibGUpIHtcbiAgICAgIGVsZW1lbnRVdGlsaXRpZXMuY3JlYXRlQ29udmVyc2lvbihtYWNyb21vbGVjdWxlLCByZWd1bGF0b3IsIHJlZ3VsYXRvck11bHRpbWVyLCBvcmllbnRhdGlvbiwgaW5wdXRJbmZvYm94TGFiZWxzLCBvdXRwdXRJbmZvYm94TGFiZWxzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCBwYXJhbSA9IHtcbiAgICAgICAgbWFjcm9tb2xlY3VsZTogbWFjcm9tb2xlY3VsZSxcbiAgICAgICAgcmVndWxhdG9yOiByZWd1bGF0b3IsXG4gICAgICAgIHJlZ3VsYXRvck11bHRpbWVyOiByZWd1bGF0b3JNdWx0aW1lcixcbiAgICAgICAgb3JpZW50YXRpb246IG9yaWVudGF0aW9uLFxuICAgICAgICBpbnB1dEluZm9ib3hMYWJlbHM6IGlucHV0SW5mb2JveExhYmVscyxcbiAgICAgICAgb3V0cHV0SW5mb2JveExhYmVsczogb3V0cHV0SW5mb2JveExhYmVsc1xuICAgICAgfTtcblxuICAgICAgY3kudW5kb1JlZG8oKS5kbyhcImNyZWF0ZUNvbnZlcnNpb25cIiwgcGFyYW0pO1xuICAgIH0gIFxuICB9O1xuXG4gIG1haW5VdGlsaXRpZXMuY3JlYXRlTWV0YWJvbGljUmVhY3Rpb24gPSBmdW5jdGlvbihpbnB1dHMsIG91dHB1dHMsIHJldmVyc2libGUsIHJlZ3VsYXRvciwgcmVndWxhdG9yTXVsdGltZXIsIG9yaWVudGF0aW9uKSB7XG4gICAgaWYgKCBlbGVtZW50VXRpbGl0aWVzLmlzR3JhcGhUb3BvbG9neUxvY2tlZCgpICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghb3B0aW9ucy51bmRvYWJsZSkge1xuICAgICAgZWxlbWVudFV0aWxpdGllcy5jcmVhdGVNZXRhYm9saWNSZWFjdGlvbihpbnB1dHMsIG91dHB1dHMsIHJldmVyc2libGUsIHJlZ3VsYXRvciwgcmVndWxhdG9yTXVsdGltZXIsIG9yaWVudGF0aW9uKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCBwYXJhbSA9IHtcbiAgICAgICAgaW5wdXRzOiBpbnB1dHMsXG4gICAgICAgIG91dHB1dHM6IG91dHB1dHMsXG4gICAgICAgIHJldmVyc2libGU6IHJldmVyc2libGUsXG4gICAgICAgIHJlZ3VsYXRvcjogcmVndWxhdG9yLFxuICAgICAgICByZWd1bGF0b3JNdWx0aW1lcjogcmVndWxhdG9yTXVsdGltZXIsXG4gICAgICAgIG9yaWVudGF0aW9uOiBvcmllbnRhdGlvblxuICAgICAgfTtcblxuICAgICAgY3kudW5kb1JlZG8oKS5kbyhcImNyZWF0ZU1ldGFib2xpY1JlYWN0aW9uXCIsIHBhcmFtKTtcbiAgICB9ICBcbiAgfTtcblxuICAvKlxuICAgKiBDcmVhdGVzIGFuIGFjdGl2YXRpb24gcmVhY3Rpb24gd2l0aCBnaXZlbiBwYXJhbWV0ZXJzLiBSZXF1aXJlcyBjb3NlLWJpbGtlbnQgbGF5b3V0IHRvIHRpbGUgdGhlIGZyZWUgbWFjcm9tb2xlY3VsZXMgaW5jbHVkZWRcbiAgICogaW4gdGhlIGNvbXBsZXguIENvbnNpZGVycyB1bmRvYWJsZSBvcHRpb24uIEZvciBtb3JlIGluZm9ybWF0aW9uIHNlZSB0aGUgc2FtZSBmdW5jdGlvbiBpbiBlbGVtZW50VXRpbGl0aWVzXG4gICAqL1xuICBtYWluVXRpbGl0aWVzLmNyZWF0ZU1ldGFib2xpY0NhdGFseXRpY0FjdGl2aXR5ID0gZnVuY3Rpb24gKGlucHV0Tm9kZUxpc3QsIG91dHB1dE5vZGVMaXN0LCBjYXRhbHlzdE5hbWUsIGNhdGFseXN0VHlwZSwgcHJvY2Vzc1Bvc2l0aW9uLCB0aWxpbmdQYWRkaW5nVmVydGljYWwsIHRpbGluZ1BhZGRpbmdIb3Jpem9udGFsLCBlZGdlTGVuZ3RoKSB7XG4gICAgaWYgKCBlbGVtZW50VXRpbGl0aWVzLmlzR3JhcGhUb3BvbG9neUxvY2tlZCgpICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghb3B0aW9ucy51bmRvYWJsZSkge1xuICAgICAgZWxlbWVudFV0aWxpdGllcy5jcmVhdGVNZXRhYm9saWNDYXRhbHl0aWNBY3Rpdml0eShpbnB1dE5vZGVMaXN0LCBvdXRwdXROb2RlTGlzdCwgY2F0YWx5c3ROYW1lLCBjYXRhbHlzdFR5cGUsIHByb2Nlc3NQb3NpdGlvbiwgdGlsaW5nUGFkZGluZ1ZlcnRpY2FsLCB0aWxpbmdQYWRkaW5nSG9yaXpvbnRhbCwgZWRnZUxlbmd0aCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIHBhcmFtID0ge1xuICAgICAgICBpbnB1dE5vZGVMaXN0OiBpbnB1dE5vZGVMaXN0LFxuICAgICAgICBvdXRwdXROb2RlTGlzdDogb3V0cHV0Tm9kZUxpc3QsXG4gICAgICAgIGNhdGFseXN0TmFtZTogY2F0YWx5c3ROYW1lLFxuICAgICAgICBjYXRhbHlzdFR5cGU6IGNhdGFseXN0VHlwZSxcbiAgICAgICAgcHJvY2Vzc1Bvc2l0aW9uOiBwcm9jZXNzUG9zaXRpb24sXG4gICAgICAgIHRpbGluZ1BhZGRpbmdWZXJ0aWNhbDogdGlsaW5nUGFkZGluZ1ZlcnRpY2FsLFxuICAgICAgICB0aWxpbmdQYWRkaW5nSG9yaXpvbnRhbDogdGlsaW5nUGFkZGluZ0hvcml6b250YWwsXG4gICAgICAgIGVkZ2VMZW5ndGg6IGVkZ2VMZW5ndGgsXG4gICAgICB9O1xuXG4gICAgICBjeS51bmRvUmVkbygpLmRvKFwiY3JlYXRlTWV0YWJvbGljQ2F0YWx5dGljQWN0aXZpdHlcIiwgcGFyYW0pO1xuICAgIH1cbiAgfTtcblxuICAvKlxuICAgKiBDcmVhdGVzIGFuIGFjdGl2YXRpb24gcmVhY3Rpb24gd2l0aCBnaXZlbiBwYXJhbWV0ZXJzLiBSZXF1aXJlcyBjb3NlLWJpbGtlbnQgbGF5b3V0IHRvIHRpbGUgdGhlIGZyZWUgbWFjcm9tb2xlY3VsZXMgaW5jbHVkZWRcbiAgICogaW4gdGhlIGNvbXBsZXguIENvbnNpZGVycyB1bmRvYWJsZSBvcHRpb24uIEZvciBtb3JlIGluZm9ybWF0aW9uIHNlZSB0aGUgc2FtZSBmdW5jdGlvbiBpbiBlbGVtZW50VXRpbGl0aWVzXG4gICAqL1xuICBtYWluVXRpbGl0aWVzLmNyZWF0ZUFjdGl2YXRpb25SZWFjdGlvbiA9IGZ1bmN0aW9uIChwcm90ZWluTmFtZSwgcHJvY2Vzc1Bvc2l0aW9uLCBlZGdlTGVuZ3RoLCByZXZlcnNlKSB7XG4gICAgaWYgKCBlbGVtZW50VXRpbGl0aWVzLmlzR3JhcGhUb3BvbG9neUxvY2tlZCgpICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghb3B0aW9ucy51bmRvYWJsZSkge1xuICAgICAgZWxlbWVudFV0aWxpdGllcy5jcmVhdGVBY3RpdmF0aW9uUmVhY3Rpb24ocHJvdGVpbk5hbWUsIHByb2Nlc3NQb3NpdGlvbiwgZWRnZUxlbmd0aCwgcmV2ZXJzZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIHBhcmFtID0ge1xuICAgICAgICBwcm90ZWluTmFtZTogcHJvdGVpbk5hbWUsXG4gICAgICAgIHByb2Nlc3NQb3NpdGlvbjogcHJvY2Vzc1Bvc2l0aW9uLFxuICAgICAgICBlZGdlTGVuZ3RoOiBlZGdlTGVuZ3RoLFxuICAgICAgICByZXZlcnNlOiByZXZlcnNlXG4gICAgICB9O1xuXG4gICAgICBjeS51bmRvUmVkbygpLmRvKFwiY3JlYXRlQWN0aXZhdGlvblJlYWN0aW9uXCIsIHBhcmFtKTtcbiAgfX07XG5cbiAgLypcbiAgICogQ3JlYXRlcyBhIHRlbXBsYXRlIHJlYWN0aW9uIHdpdGggZ2l2ZW4gcGFyYW1ldGVycy4gUmVxdWlyZXMgY29zZS1iaWxrZW50IGxheW91dCB0byB0aWxlIHRoZSBmcmVlIG1hY3JvbW9sZWN1bGVzIGluY2x1ZGVkXG4gICAqIGluIHRoZSBjb21wbGV4LiBDb25zaWRlcnMgdW5kb2FibGUgb3B0aW9uLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBzZWUgdGhlIHNhbWUgZnVuY3Rpb24gaW4gZWxlbWVudFV0aWxpdGllc1xuICAgKi9cbiAgbWFpblV0aWxpdGllcy5jcmVhdGVUZW1wbGF0ZVJlYWN0aW9uID0gZnVuY3Rpb24gKHRlbXBsYXRlVHlwZSwgbWFjcm9tb2xlY3VsZUxpc3QsIGNvbXBsZXhOYW1lLCBwcm9jZXNzUG9zaXRpb24sIHRpbGluZ1BhZGRpbmdWZXJ0aWNhbCwgdGlsaW5nUGFkZGluZ0hvcml6b250YWwsIGVkZ2VMZW5ndGgsIGxheW91dFBhcmFtKSB7XG4gICAgaWYgKCBlbGVtZW50VXRpbGl0aWVzLmlzR3JhcGhUb3BvbG9neUxvY2tlZCgpICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghb3B0aW9ucy51bmRvYWJsZSkge1xuICAgICAgaWYgKHRlbXBsYXRlVHlwZSA9PT0gXCJyZXZlcnNpYmxlXCIpIHtcbiAgICAgICAgZWxlbWVudFV0aWxpdGllcy5zZXRNYXBUeXBlKFwiSHlicmlkQW55XCIpO1xuICAgICAgfVxuICAgICAgZWxlbWVudFV0aWxpdGllcy5jcmVhdGVUZW1wbGF0ZVJlYWN0aW9uKHRlbXBsYXRlVHlwZSwgbWFjcm9tb2xlY3VsZUxpc3QsIGNvbXBsZXhOYW1lLCBwcm9jZXNzUG9zaXRpb24sIHRpbGluZ1BhZGRpbmdWZXJ0aWNhbCwgdGlsaW5nUGFkZGluZ0hvcml6b250YWwsIGVkZ2VMZW5ndGgsIGxheW91dFBhcmFtKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2YXIgcGFyYW0gPSB7XG4gICAgICAgIHRlbXBsYXRlVHlwZTogdGVtcGxhdGVUeXBlLFxuICAgICAgICBtYWNyb21vbGVjdWxlTGlzdDogbWFjcm9tb2xlY3VsZUxpc3QsXG4gICAgICAgIGNvbXBsZXhOYW1lOiBjb21wbGV4TmFtZSxcbiAgICAgICAgcHJvY2Vzc1Bvc2l0aW9uOiBwcm9jZXNzUG9zaXRpb24sXG4gICAgICAgIHRpbGluZ1BhZGRpbmdWZXJ0aWNhbDogdGlsaW5nUGFkZGluZ1ZlcnRpY2FsLFxuICAgICAgICB0aWxpbmdQYWRkaW5nSG9yaXpvbnRhbDogdGlsaW5nUGFkZGluZ0hvcml6b250YWwsXG4gICAgICAgIGVkZ2VMZW5ndGg6IGVkZ2VMZW5ndGgsXG4gICAgICAgIGxheW91dFBhcmFtOiBsYXlvdXRQYXJhbVxuICAgICAgfTtcbiAgICAgIGlmICh0ZW1wbGF0ZVR5cGUgPT09IFwicmV2ZXJzaWJsZVwiKSB7XG4gICAgICAgIHZhciBhY3Rpb25zID0gW107XG4gICAgICAgIGFjdGlvbnMucHVzaCh7bmFtZTpcImNoYW5nZU1hcFR5cGVcIiwgcGFyYW06IHttYXBUeXBlOiBcIkh5YnJpZEFueVwiLCBjYWxsYmFjazogZnVuY3Rpb24oKXt9IH19KTtcbiAgICAgICAgYWN0aW9ucy5wdXNoKHtuYW1lOlwiY3JlYXRlVGVtcGxhdGVSZWFjdGlvblwiLCBwYXJhbTogcGFyYW19KTtcbiAgICAgICAgY3kudW5kb1JlZG8oKS5kbyhcImJhdGNoXCIsIGFjdGlvbnMpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGN5LnVuZG9SZWRvKCkuZG8oXCJjcmVhdGVUZW1wbGF0ZVJlYWN0aW9uXCIsIHBhcmFtKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLypcbiAgICogUmVzaXplIGdpdmVuIG5vZGVzIGlmIHVzZUFzcGVjdFJhdGlvIGlzIHRydXRoeSBvbmUgb2Ygd2lkdGggb3IgaGVpZ2h0IHNob3VsZCBub3QgYmUgc2V0LlxuICAgKiBDb25zaWRlcnMgdW5kb2FibGUgb3B0aW9uLlxuICAgKi9cbiAgbWFpblV0aWxpdGllcy5yZXNpemVOb2RlcyA9IGZ1bmN0aW9uKG5vZGVzLCB3aWR0aCwgaGVpZ2h0LCB1c2VBc3BlY3RSYXRpbywgcHJlc2VydmVSZWxhdGl2ZVBvcykge1xuICAgIGlmIChub2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy51bmRvYWJsZSkge1xuICAgICAgdmFyIHBhcmFtID0ge1xuICAgICAgICBub2Rlczogbm9kZXMsXG4gICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgIHVzZUFzcGVjdFJhdGlvOiB1c2VBc3BlY3RSYXRpbyxcbiAgICAgICAgcGVyZm9ybU9wZXJhdGlvbjogdHJ1ZSxcbiAgICAgICAgcHJlc2VydmVSZWxhdGl2ZVBvczogcHJlc2VydmVSZWxhdGl2ZVBvc1xuICAgICAgfTtcblxuICAgICAgY3kudW5kb1JlZG8oKS5kbyhcInJlc2l6ZU5vZGVzXCIsIHBhcmFtKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBlbGVtZW50VXRpbGl0aWVzLnJlc2l6ZU5vZGVzKG5vZGVzLCB3aWR0aCwgaGVpZ2h0LCB1c2VBc3BlY3RSYXRpbyk7XG4gICAgICBjeS5zdHlsZSgpLnVwZGF0ZSgpO1xuICAgIH1cblxuXG4gIH07XG5cbiAgICAvKlxuICAgICAqIFJlc2l6ZSBnaXZlbiBub2RlcyBpZiB1c2VBc3BlY3RSYXRpbyBpcyB0cnV0aHkgb25lIG9mIHdpZHRoIG9yIGhlaWdodCBzaG91bGQgbm90IGJlIHNldC5cbiAgICAgKiBDb25zaWRlcnMgdW5kb2FibGUgb3B0aW9uLlxuICAgICAqL1xuICAgIG1haW5VdGlsaXRpZXMucmVzaXplTm9kZXNUb0NvbnRlbnQgPSBmdW5jdGlvbihub2RlcywgdXNlQXNwZWN0UmF0aW8pIHtcbiAgICAgICAgaWYgKG5vZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IFxuICAgICAgICBpZiAob3B0aW9ucy51bmRvYWJsZSkge1xuICAgICAgICAgIHZhciBhY3Rpb25zID0gW107XG4gICAgICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbihub2RlKXtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IGVsZW1lbnRVdGlsaXRpZXMuY2FsY3VsYXRlTWluV2lkdGgobm9kZSk7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gZWxlbWVudFV0aWxpdGllcy5jYWxjdWxhdGVNaW5IZWlnaHQobm9kZSk7XG4gICAgICAgICAgICBhY3Rpb25zLnB1c2goe25hbWU6IFwicmVzaXplTm9kZXNcIiwgcGFyYW06IHtcbiAgICAgICAgICAgICAgICBub2Rlczogbm9kZSxcbiAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgICAgICAgICAgdXNlQXNwZWN0UmF0aW86IHVzZUFzcGVjdFJhdGlvLFxuICAgICAgICAgICAgICAgIHBlcmZvcm1PcGVyYXRpb246IHRydWUsXG4gICAgICAgICAgICAgICAgcHJlc2VydmVSZWxhdGl2ZVBvczogdHJ1ZVxuICAgICAgICAgICAgfX0pO1xuXG4gICAgICAgICAgICB2YXIgc3RhdGVBbmRJbmZvcyA9IG5vZGUuZGF0YSgnc3RhdGVzYW5kaW5mb3MnKTtcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSBzdGF0ZUFuZEluZm9zLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChsZW5ndGggIT0gMCkge1xuICAgICAgICAgICAgICB2YXIgcGFyYW0gPSB7XG4gICAgICAgICAgICAgICAgbm9kZTogbm9kZSxcbiAgICAgICAgICAgICAgICBsb2NhdGlvbnM6IFtcInRvcFwiLFwicmlnaHRcIixcImJvdHRvbVwiLFwibGVmdFwiXVxuICAgICAgICAgICAgICB9OyAgICAgICAgICBcbiAgICAgICAgICAgICAgYWN0aW9ucy5wdXNoKHtuYW1lOlwiZml0VW5pdHNcIixwYXJhbSA6IHBhcmFtfSlcbiAgICAgICAgICAgICB9XG4gIFxuXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgXG4gICAgICAgICBcbiAgICAgICAgICBjeS51bmRvUmVkbygpLmRvKFwiYmF0Y2hcIiwgYWN0aW9ucyk7XG4gICAgICAgICAgY3kuc3R5bGUoKS51cGRhdGUoKTtcbiAgICAgICAgICByZXR1cm4gYWN0aW9ucztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24obm9kZSl7XG4gICAgICAgICAgICAgIHZhciB3aWR0aCA9IGVsZW1lbnRVdGlsaXRpZXMuY2FsY3VsYXRlTWluV2lkdGgobm9kZSk7XG4gICAgICAgICAgICAgIHZhciBoZWlnaHQgPSBlbGVtZW50VXRpbGl0aWVzLmNhbGN1bGF0ZU1pbkhlaWdodChub2RlKTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIGVsZW1lbnRVdGlsaXRpZXMucmVzaXplTm9kZXMobm9kZSwgd2lkdGgsIGhlaWdodCwgdXNlQXNwZWN0UmF0aW8sIHRydWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBjeS5zdHlsZSgpLnVwZGF0ZSgpO1xuICAgIH07XG5cbiAgLypcbiAgICogQ2hhbmdlcyB0aGUgbGFiZWwgb2YgdGhlIGdpdmVuIG5vZGVzIHRvIHRoZSBnaXZlbiBsYWJlbC4gQ29uc2lkZXJzIHVuZG9hYmxlIG9wdGlvbi5cbiAgICovXG4gIG1haW5VdGlsaXRpZXMuY2hhbmdlTm9kZUxhYmVsID0gZnVuY3Rpb24obm9kZXMsIGxhYmVsKSB7XG4gICAgaWYgKG5vZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghb3B0aW9ucy51bmRvYWJsZSkge1xuICAgICAgbm9kZXMuZGF0YSgnbGFiZWwnLCBsYWJlbCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIHBhcmFtID0ge1xuICAgICAgICBub2Rlczogbm9kZXMsXG4gICAgICAgIGxhYmVsOiBsYWJlbCxcbiAgICAgICAgZmlyc3RUaW1lOiB0cnVlXG4gICAgICB9O1xuXG4gICAgICBjeS51bmRvUmVkbygpLmRvKFwiY2hhbmdlTm9kZUxhYmVsXCIsIHBhcmFtKTtcbiAgICB9XG5cbiAgICBjeS5zdHlsZSgpLnVwZGF0ZSgpO1xuICB9O1xuXG4gIC8qXG4gICAqIENoYW5nZSBmb250IHByb3BlcnRpZXMgZm9yIGdpdmVuIG5vZGVzIHVzZSB0aGUgZ2l2ZW4gZm9udCBkYXRhLlxuICAgKiBDb25zaWRlcnMgdW5kb2FibGUgb3B0aW9uLlxuICAgKi9cbiAgbWFpblV0aWxpdGllcy5jaGFuZ2VGb250UHJvcGVydGllcyA9IGZ1bmN0aW9uKGVsZXMsIGRhdGEpIHtcbiAgICBpZiAoZWxlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy51bmRvYWJsZSkge1xuICAgICAgdmFyIHBhcmFtID0ge1xuICAgICAgICBlbGVzOiBlbGVzLFxuICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICBmaXJzdFRpbWU6IHRydWVcbiAgICAgIH07XG5cbiAgICAgIGN5LnVuZG9SZWRvKCkuZG8oXCJjaGFuZ2VGb250UHJvcGVydGllc1wiLCBwYXJhbSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZWxlbWVudFV0aWxpdGllcy5jaGFuZ2VGb250UHJvcGVydGllcyhlbGVzLCBkYXRhKTtcbiAgICB9XG5cbiAgICBjeS5zdHlsZSgpLnVwZGF0ZSgpO1xuICB9O1xuXG4gIC8qXG4gICAqIENoYW5nZSBzdGF0ZSB2YWx1ZSBvciB1bml0IG9mIGluZm9ybWF0aW9uIGJveCBvZiBnaXZlbiBub2RlcyB3aXRoIGdpdmVuIGluZGV4LlxuICAgKiBDb25zaWRlcnMgdW5kb2FibGUgb3B0aW9uLlxuICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcGFyYW1ldGVycyBzZWUgZWxlbWVudFV0aWxpdGllcy5jaGFuZ2VTdGF0ZU9ySW5mb0JveFxuICAgKi9cbiAgbWFpblV0aWxpdGllcy5jaGFuZ2VTdGF0ZU9ySW5mb0JveCA9IGZ1bmN0aW9uKG5vZGVzLCBpbmRleCwgdmFsdWUsIHR5cGUpIHtcbiAgICBpZiAobm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnVuZG9hYmxlKSB7XG4gICAgICB2YXIgcGFyYW0gPSB7XG4gICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICBub2Rlczogbm9kZXNcbiAgICAgIH07XG5cbiAgICAgIGN5LnVuZG9SZWRvKCkuZG8oXCJjaGFuZ2VTdGF0ZU9ySW5mb0JveFwiLCBwYXJhbSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIGVsZW1lbnRVdGlsaXRpZXMuY2hhbmdlU3RhdGVPckluZm9Cb3gobm9kZXMsIGluZGV4LCB2YWx1ZSwgdHlwZSk7XG4gICAgfVxuXG4gICAgY3kuc3R5bGUoKS51cGRhdGUoKTtcbiAgfTtcblxuICAvLyBBZGQgYSBuZXcgc3RhdGUgb3IgaW5mbyBib3ggdG8gZ2l2ZW4gbm9kZXMuXG4gIC8vIFRoZSBib3ggaXMgcmVwcmVzZW50ZWQgYnkgdGhlIHBhcmFtZXRlciBvYmouXG4gIC8vIENvbnNpZGVycyB1bmRvYWJsZSBvcHRpb24uXG4gIG1haW5VdGlsaXRpZXMuYWRkU3RhdGVPckluZm9Cb3ggPSBmdW5jdGlvbihub2Rlcywgb2JqKSB7XG4gICAgaWYgKG5vZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghb3B0aW9ucy51bmRvYWJsZSkge1xuICAgICAgZWxlbWVudFV0aWxpdGllcy5hZGRTdGF0ZU9ySW5mb0JveChub2Rlcywgb2JqKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2YXIgcGFyYW0gPSB7XG4gICAgICAgIG9iajogb2JqLFxuICAgICAgICBub2Rlczogbm9kZXNcbiAgICAgIH07XG5cbiAgICAgIGN5LnVuZG9SZWRvKCkuZG8oXCJhZGRTdGF0ZU9ySW5mb0JveFwiLCBwYXJhbSk7XG4gICAgfVxuXG4gICAgY3kuc3R5bGUoKS51cGRhdGUoKTtcbiAgfTtcblxuICAvLyBSZW1vdmUgdGhlIHN0YXRlIG9yIGluZm8gYm94ZXMgb2YgdGhlIGdpdmVuIG5vZGVzIGF0IGdpdmVuIGluZGV4LlxuICAvLyBDb25zaWRlcnMgdW5kb2FibGUgb3B0aW9uLlxuICBtYWluVXRpbGl0aWVzLnJlbW92ZVN0YXRlT3JJbmZvQm94ID0gZnVuY3Rpb24obm9kZXMsIGluZGV4KSB7XG4gICAgaWYgKG5vZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghb3B0aW9ucy51bmRvYWJsZSkge1xuICAgICAgZWxlbWVudFV0aWxpdGllcy5yZW1vdmVTdGF0ZU9ySW5mb0JveChub2Rlcywge2luZGV4OiBpbmRleH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHZhciBwYXJhbSA9IHtcbiAgICAgICAgbG9jYXRpb25PYmo6IHtpbmRleDogaW5kZXh9LFxuICAgICAgICBub2Rlczogbm9kZXNcbiAgICAgIH07XG5cbiAgICAgIGN5LnVuZG9SZWRvKCkuZG8oXCJyZW1vdmVTdGF0ZU9ySW5mb0JveFwiLCBwYXJhbSk7XG4gICAgfVxuXG4gICAgY3kuc3R5bGUoKS51cGRhdGUoKTtcbiAgfTtcblxuXG4gIC8vQXJyYW5nZSBpbmZvcm1hdGlvbiBib3hlc1xuICAvL0lmIGZvcmNlIGNoZWNrIGlzIHRydWUsIGl0IHJlYXJyYW5nZXMgYWxsIGluZm9ybWF0aW9uIGJveGVzXG4gIG1haW5VdGlsaXRpZXMuZml0VW5pdHMgPSBmdW5jdGlvbiAobm9kZSwgbG9jYXRpb25zKSB7XG4gICAgaWYgKG5vZGUuZGF0YSgnYXV4dW5pdGxheW91dHMnKSA9PT0gdW5kZWZpbmVkIHx8IG5vZGUuZGF0YSgnc3RhdGVzYW5kaW5mb3MnKS5sZW5ndGggPD0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobG9jYXRpb25zID09PSB1bmRlZmluZWQgfHwgbG9jYXRpb25zLmxlbmd0aCA8PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFvcHRpb25zLnVuZG9hYmxlKSB7XG4gICAgICBlbGVtZW50VXRpbGl0aWVzLmZpdFVuaXRzKG5vZGUsIGxvY2F0aW9ucyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIHBhcmFtID0ge1xuICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICBsb2NhdGlvbnM6IGxvY2F0aW9uc1xuICAgICAgfTtcblxuICAgICAgY3kudW5kb1JlZG8oKS5kbyhcImZpdFVuaXRzXCIsIHBhcmFtKTtcbiAgICB9XG5cbiAgICBjeS5zdHlsZSgpLnVwZGF0ZSgpO1xuICB9O1xuXG4gIC8qXG4gICAqIFNldCBtdWx0aW1lciBzdGF0dXMgb2YgdGhlIGdpdmVuIG5vZGVzIHRvIHRoZSBnaXZlbiBzdGF0dXMuXG4gICAqIENvbnNpZGVycyB1bmRvYWJsZSBvcHRpb24uXG4gICAqL1xuICBtYWluVXRpbGl0aWVzLnNldE11bHRpbWVyU3RhdHVzID0gZnVuY3Rpb24obm9kZXMsIHN0YXR1cykge1xuICAgIGlmIChub2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy51bmRvYWJsZSkge1xuICAgICAgdmFyIHBhcmFtID0ge1xuICAgICAgICBzdGF0dXM6IHN0YXR1cyxcbiAgICAgICAgbm9kZXM6IG5vZGVzLFxuICAgICAgICBmaXJzdFRpbWU6IHRydWVcbiAgICAgIH07XG5cbiAgICAgIGN5LnVuZG9SZWRvKCkuZG8oXCJzZXRNdWx0aW1lclN0YXR1c1wiLCBwYXJhbSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZWxlbWVudFV0aWxpdGllcy5zZXRNdWx0aW1lclN0YXR1cyhub2Rlcywgc3RhdHVzKTtcbiAgICB9XG5cbiAgICBjeS5zdHlsZSgpLnVwZGF0ZSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZWRyYXcgY2xvbmUgbWFya2VycyBvbiBnaXZlbiBub2RlcyB3aXRob3V0IGNvbnNpZGVyaW5nIHVuZG8uXG4gICAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vaVZpcy1hdC1CaWxrZW50L25ld3QvaXNzdWVzLzU3NCBcbiAgICovXG4gIG1haW5VdGlsaXRpZXMucmVkcmF3Q2xvbmVNYXJrZXJzID0gZnVuY3Rpb24obm9kZXMpIHtcbiAgICBlbGVtZW50VXRpbGl0aWVzLnNldENsb25lTWFya2VyU3RhdHVzKG5vZGVzLCB0cnVlKTtcbiAgfVxuXG4gIC8qXG4gICAqIFNldCBjbG9uZSBtYXJrZXIgc3RhdHVzIG9mIGdpdmVuIG5vZGVzIHRvIHRoZSBnaXZlbiBzdGF0dXMuXG4gICAqIENvbnNpZGVycyB1bmRvYWJsZSBvcHRpb24uXG4gICAqL1xuICBtYWluVXRpbGl0aWVzLnNldENsb25lTWFya2VyU3RhdHVzID0gZnVuY3Rpb24obm9kZXMsIHN0YXR1cykge1xuICAgIGlmIChub2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy51bmRvYWJsZSkge1xuICAgICAgdmFyIHBhcmFtID0ge1xuICAgICAgICBzdGF0dXM6IHN0YXR1cyxcbiAgICAgICAgbm9kZXM6IG5vZGVzLFxuICAgICAgICBmaXJzdFRpbWU6IHRydWVcbiAgICAgIH07XG5cbiAgICAgIGN5LnVuZG9SZWRvKCkuZG8oXCJzZXRDbG9uZU1hcmtlclN0YXR1c1wiLCBwYXJhbSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZWxlbWVudFV0aWxpdGllcy5zZXRDbG9uZU1hcmtlclN0YXR1cyhub2Rlcywgc3RhdHVzKTtcbiAgICB9XG5cbiAgICBjeS5zdHlsZSgpLnVwZGF0ZSgpO1xuICB9O1xuXG4gIC8qXG4gICAqIENoYW5nZSBzdHlsZS9jc3Mgb2YgZ2l2ZW4gZWxlcyBieSBzZXR0aW5nIGdldHRpbmcgcHJvcGVydHkgbmFtZSB0byB0aGUgZ2l2ZW4gZ2l2ZW4gdmFsdWUvdmFsdWVzIChOb3RlIHRoYXQgdmFsdWVNYXAgcGFyYW1ldGVyIG1heSBiZVxuICAgKiBhIHNpbmdsZSBzdHJpbmcgb3IgYW4gaWQgdG8gdmFsdWUgbWFwKS4gQ29uc2lkZXJzIHVuZG9hYmxlIG9wdGlvbi5cbiAgICovXG4gIG1haW5VdGlsaXRpZXMuY2hhbmdlQ3NzID0gZnVuY3Rpb24oZWxlcywgbmFtZSwgdmFsdWVNYXApIHtcbiAgICBpZiAoZWxlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIW9wdGlvbnMudW5kb2FibGUpIHtcbiAgICAgIGVsZW1lbnRVdGlsaXRpZXMuY2hhbmdlQ3NzKGVsZXMsIG5hbWUsIHZhbHVlTWFwKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2YXIgcGFyYW0gPSB7XG4gICAgICAgIGVsZXM6IGVsZXMsXG4gICAgICAgIHZhbHVlTWFwOiB2YWx1ZU1hcCxcbiAgICAgICAgbmFtZTogbmFtZVxuICAgICAgfTtcblxuICAgICAgY3kudW5kb1JlZG8oKS5kbyhcImNoYW5nZUNzc1wiLCBwYXJhbSk7XG4gICAgfVxuXG4gICAgY3kuc3R5bGUoKS51cGRhdGUoKTtcbiAgfTtcblxuICAvKlxuICAgKiBDaGFuZ2UgZGF0YSBvZiBnaXZlbiBlbGVzIGJ5IHNldHRpbmcgZ2V0dGluZyBwcm9wZXJ0eSBuYW1lIHRvIHRoZSBnaXZlbiBnaXZlbiB2YWx1ZS92YWx1ZXMgKE5vdGUgdGhhdCB2YWx1ZU1hcCBwYXJhbWV0ZXIgbWF5IGJlXG4gICAqIGEgc2luZ2xlIHN0cmluZyBvciBhbiBpZCB0byB2YWx1ZSBtYXApLiBDb25zaWRlcnMgdW5kb2FibGUgb3B0aW9uLlxuICAgKi9cbiAgbWFpblV0aWxpdGllcy5jaGFuZ2VEYXRhID0gZnVuY3Rpb24oZWxlcywgbmFtZSwgdmFsdWVNYXApIHtcbiAgICBpZiAoZWxlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIW9wdGlvbnMudW5kb2FibGUpIHtcbiAgICAgIGVsZW1lbnRVdGlsaXRpZXMuY2hhbmdlRGF0YShlbGVzLCBuYW1lLCB2YWx1ZU1hcCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIHBhcmFtID0ge1xuICAgICAgICBlbGVzOiBlbGVzLFxuICAgICAgICB2YWx1ZU1hcDogdmFsdWVNYXAsXG4gICAgICAgIG5hbWU6IG5hbWVcbiAgICAgIH07XG5cbiAgICAgIGN5LnVuZG9SZWRvKCkuZG8oXCJjaGFuZ2VEYXRhXCIsIHBhcmFtKTtcbiAgICB9XG5cbiAgICBjeS5zdHlsZSgpLnVwZGF0ZSgpO1xuICB9O1xuXG4gIG1haW5VdGlsaXRpZXMudXBkYXRlU2V0RmllbGQgPSBmdW5jdGlvbihlbGUsIGZpZWxkTmFtZSwgdG9EZWxldGUsIHRvQWRkLCBjYWxsYmFjaykge1xuICAgIGlmICghb3B0aW9ucy51bmRvYWJsZSkge1xuICAgICAgZWxlbWVudFV0aWxpdGllcy5jaGFuZ2VEYXRhKGVsZSwgZmllbGROYW1lLCB0b0RlbGV0ZSwgdG9BZGQsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2YXIgcGFyYW0gPSB7XG4gICAgICAgIGVsZSxcbiAgICAgICAgZmllbGROYW1lLFxuICAgICAgICB0b0RlbGV0ZSxcbiAgICAgICAgdG9BZGQsXG4gICAgICAgIGNhbGxiYWNrXG4gICAgICB9O1xuXG4gICAgICBjeS51bmRvUmVkbygpLmRvKFwidXBkYXRlU2V0RmllbGRcIiwgcGFyYW0pO1xuICAgIH1cbiAgfTtcblxuICBtYWluVXRpbGl0aWVzLnNldERlZmF1bHRQcm9wZXJ0eSA9IGZ1bmN0aW9uKCBfY2xhc3MsIG5hbWUsIHZhbHVlICkge1xuICAgIGlmICghb3B0aW9ucy51bmRvYWJsZSkge1xuICAgICAgdmFyIHByb3BNYXAgPSB7fTtcbiAgICAgIHByb3BNYXBbIG5hbWUgXSA9IHZhbHVlO1xuXG4gICAgICBlbGVtZW50VXRpbGl0aWVzLnNldERlZmF1bHRQcm9wZXJ0aWVzKF9jbGFzcywgcHJvcE1hcCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIHBhcmFtID0ge1xuICAgICAgICBjbGFzczogX2NsYXNzLFxuICAgICAgICBuYW1lLFxuICAgICAgICB2YWx1ZVxuICAgICAgfTtcblxuICAgICAgY3kudW5kb1JlZG8oKS5kbyhcInNldERlZmF1bHRQcm9wZXJ0eVwiLCBwYXJhbSk7XG4gICAgfVxuICB9O1xuXG4gIG1haW5VdGlsaXRpZXMudXBkYXRlSW5mb2JveFN0eWxlID0gZnVuY3Rpb24oIG5vZGUsIGluZGV4LCBuZXdQcm9wcyApIHtcbiAgICBpZiAoIW9wdGlvbnMudW5kb2FibGUpIHtcbiAgICAgIGVsZW1lbnRVdGlsaXRpZXMudXBkYXRlSW5mb2JveFN0eWxlKCBub2RlLCBpbmRleCwgbmV3UHJvcHMgKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2YXIgcGFyYW0gPSB7XG4gICAgICAgIG5vZGU6IG5vZGUsXG4gICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgbmV3UHJvcHM6IG5ld1Byb3BzXG4gICAgICB9O1xuXG4gICAgICBjeS51bmRvUmVkbygpLmRvKFwidXBkYXRlSW5mb2JveFN0eWxlXCIsIHBhcmFtKTtcbiAgICB9XG5cbiAgICBjeS5zdHlsZSgpLnVwZGF0ZSgpO1xuICB9O1xuXG4gIG1haW5VdGlsaXRpZXMudXBkYXRlSW5mb2JveE9iaiA9IGZ1bmN0aW9uKCBub2RlLCBpbmRleCwgbmV3UHJvcHMgKSB7XG4gICAgaWYgKCFvcHRpb25zLnVuZG9hYmxlKSB7XG4gICAgICBlbGVtZW50VXRpbGl0aWVzLnVwZGF0ZUluZm9ib3hPYmooIG5vZGUsIGluZGV4LCBuZXdQcm9wcyApO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHZhciBwYXJhbSA9IHtcbiAgICAgICAgbm9kZTogbm9kZSxcbiAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICBuZXdQcm9wczogbmV3UHJvcHNcbiAgICAgIH07XG5cbiAgICAgIGN5LnVuZG9SZWRvKCkuZG8oXCJ1cGRhdGVJbmZvYm94T2JqXCIsIHBhcmFtKTtcbiAgICB9XG5cbiAgICBjeS5zdHlsZSgpLnVwZGF0ZSgpO1xuICB9O1xuXG4gIG1haW5VdGlsaXRpZXMuZGVsZXRlQW5kUGVyZm9ybUxheW91dCA9IGZ1bmN0aW9uIChlbGVzLCBsYXlvdXRwYXJhbSkge1xuICAgIHZhciBub2RlcyA9IGVsZXMubm9kZXMoKTsgLy8gRW5zdXJlIHRoYXQgbm9kZXMgbGlzdCBqdXN0IGluY2x1ZGUgbm9kZXNcblxuICAgIHZhciBhbGxOb2RlcyA9IGN5Lm5vZGVzKFwiOnZpc2libGVcIik7XG4gICAgdmFyIG5vZGVzVG9LZWVwID0gZWxlbWVudFV0aWxpdGllcy5leHRlbmRSZW1haW5pbmdOb2Rlcyhub2RlcywgYWxsTm9kZXMpO1xuICAgIHZhciBub2Rlc1RvUmVtb3ZlID0gYWxsTm9kZXMubm90KG5vZGVzVG9LZWVwKTtcblxuICAgIGlmIChub2Rlc1RvUmVtb3ZlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFvcHRpb25zLnVuZG9hYmxlKSB7XG5cbiAgICAgICAgZWxlbWVudFV0aWxpdGllcy5kZWxldGVBbmRQZXJmb3JtTGF5b3V0KG5vZGVzVG9SZW1vdmUsIGxheW91dHBhcmFtKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBwYXJhbSA9IHtcbiAgICAgICAgICAgIGVsZXM6IG5vZGVzVG9SZW1vdmUsXG4gICAgICAgICAgICBsYXlvdXRwYXJhbTogbGF5b3V0cGFyYW0sXG4gICAgICAgICAgICBmaXJzdFRpbWU6IHRydWVcbiAgICAgICAgfTtcblxuICAgICAgICBjeS51bmRvUmVkbygpLmRvKFwiZGVsZXRlQW5kUGVyZm9ybUxheW91dFwiLCBwYXJhbSk7XG4gICAgfVxuICB9O1xuXG4gIC8qXG4gICAqIEhpZGVzIGdpdmVuIGVsZXMgKHRoZSBvbmVzIHdoaWNoIGFyZSBzZWxlY3RlZCkgYW5kIHBlcmZvcm0gZ2l2ZW4gbGF5b3V0IGFmdGVyd2FyZC4gTGF5b3V0IHBhcmFtZXRlciBtYXkgYmUgbGF5b3V0IG9wdGlvbnNcbiAgICogb3IgYSBmdW5jdGlvbiB0byBjYWxsLiBSZXF1aXJlcyB2aWV3VXRpbGl0aWVzIGV4dGVuc2lvbiBhbmQgY29uc2lkZXJzIHVuZG9hYmxlIG9wdGlvbi5cbiAgICovXG4gIG1haW5VdGlsaXRpZXMuaGlkZUFuZFBlcmZvcm1MYXlvdXQgPSBmdW5jdGlvbihlbGVzLCBsYXlvdXRwYXJhbSkge1xuICAgICAgdmFyIG5vZGVzID0gZWxlcy5ub2RlcygpOyAvLyBFbnN1cmUgdGhhdCBub2RlcyBsaXN0IGp1c3QgaW5jbHVkZSBub2Rlc1xuXG4gICAgICB2YXIgYWxsTm9kZXMgPSBjeS5ub2RlcyhcIjp2aXNpYmxlXCIpO1xuICAgICAgdmFyIG5vZGVzVG9TaG93ID0gZWxlbWVudFV0aWxpdGllcy5leHRlbmRSZW1haW5pbmdOb2Rlcyhub2RlcywgYWxsTm9kZXMpO1xuICAgICAgdmFyIG5vZGVzVG9IaWRlID0gYWxsTm9kZXMubm90KG5vZGVzVG9TaG93KTtcblxuICAgICAgaWYgKG5vZGVzVG9IaWRlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFvcHRpb25zLnVuZG9hYmxlKSB7XG5cbiAgICAgICAgICB2YXIgbm9kZXNXaXRoSGlkZGVuTmVpZ2hib3IgPSBjeS5lZGdlcyhcIjpoaWRkZW5cIikuY29ubmVjdGVkTm9kZXMoJzp2aXNpYmxlJyk7XG4gICAgICAgICAgc2JnbnZpekluc3RhbmNlLnRoaW5Cb3JkZXIobm9kZXNXaXRoSGlkZGVuTmVpZ2hib3IpO1xuICAgICAgICAgIGVsZW1lbnRVdGlsaXRpZXMuaGlkZUFuZFBlcmZvcm1MYXlvdXQobm9kZXNUb0hpZGUsIGxheW91dHBhcmFtKTtcbiAgICAgICAgICB2YXIgbm9kZXNXaXRoSGlkZGVuTmVpZ2hib3IgPSBjeS5lZGdlcyhcIjpoaWRkZW5cIikuY29ubmVjdGVkTm9kZXMoJzp2aXNpYmxlJyk7XG4gICAgICAgICAgc2JnbnZpekluc3RhbmNlLnRoaWNrZW5Cb3JkZXIobm9kZXNXaXRoSGlkZGVuTmVpZ2hib3IpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIHBhcmFtID0ge1xuICAgICAgICAgICAgICBlbGVzOiBub2Rlc1RvSGlkZSxcbiAgICAgICAgICAgICAgbGF5b3V0cGFyYW06IGxheW91dHBhcmFtLFxuICAgICAgICAgICAgICBmaXJzdFRpbWU6IHRydWVcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgdmFyIHVyID0gY3kudW5kb1JlZG8oKTtcbiAgICAgICAgICB1ci5hY3Rpb24oXCJ0aGlja2VuQm9yZGVyXCIsIHNiZ252aXpJbnN0YW5jZS50aGlja2VuQm9yZGVyLCBzYmdudml6SW5zdGFuY2UudGhpbkJvcmRlcik7XG4gICAgICAgICAgdXIuYWN0aW9uKFwidGhpbkJvcmRlclwiLCBzYmdudml6SW5zdGFuY2UudGhpbkJvcmRlciwgc2JnbnZpekluc3RhbmNlLnRoaWNrZW5Cb3JkZXIpO1xuXG4gICAgICAgICAgdmFyIGFjdGlvbnMgPSBbXTtcbiAgICAgICAgICB2YXIgbm9kZXNXaXRoSGlkZGVuTmVpZ2hib3IgPSBjeS5lZGdlcyhcIjpoaWRkZW5cIikuY29ubmVjdGVkTm9kZXMoKS5pbnRlcnNlY3Rpb24obm9kZXNUb0hpZGUpO1xuICAgICAgICAgIGFjdGlvbnMucHVzaCh7bmFtZTogXCJ0aGluQm9yZGVyXCIsIHBhcmFtOiBub2Rlc1dpdGhIaWRkZW5OZWlnaGJvcn0pO1xuICAgICAgICAgIGFjdGlvbnMucHVzaCh7bmFtZTogXCJoaWRlQW5kUGVyZm9ybUxheW91dFwiLCBwYXJhbTogcGFyYW19KTtcbiAgICAgICAgICBub2Rlc1dpdGhIaWRkZW5OZWlnaGJvciA9IG5vZGVzVG9IaWRlLm5laWdoYm9yaG9vZChcIjp2aXNpYmxlXCIpLm5vZGVzKCkuZGlmZmVyZW5jZShub2Rlc1RvSGlkZSkuZGlmZmVyZW5jZShjeS5ub2RlcyhcIlt0aGlja0JvcmRlcl1cIikpO1xuICAgICAgICAgIGFjdGlvbnMucHVzaCh7bmFtZTogXCJ0aGlja2VuQm9yZGVyXCIsIHBhcmFtOiBub2Rlc1dpdGhIaWRkZW5OZWlnaGJvcn0pO1xuICAgICAgICAgIGN5LnVuZG9SZWRvKCkuZG8oXCJiYXRjaFwiLCBhY3Rpb25zKTtcbiAgICAgIH1cbiAgfTtcblxuICAvKlxuICAgKiBTaG93cyBhbGwgZWxlbWVudHMgKHRoZSBvbmVzIHdoaWNoIGFyZSBoaWRkZW4gaWYgYW55KSBhbmQgcGVyZm9ybSBnaXZlbiBsYXlvdXQgYWZ0ZXJ3YXJkLiBMYXlvdXQgcGFyYW1ldGVyIG1heSBiZSBsYXlvdXQgb3B0aW9uc1xuICAgKiBvciBhIGZ1bmN0aW9uIHRvIGNhbGwuIFJlcXVpcmVzIHZpZXdVdGlsaXRpZXMgZXh0ZW5zaW9uIGFuZCBjb25zaWRlcnMgdW5kb2FibGUgb3B0aW9uLlxuICAgKi9cbiAgbWFpblV0aWxpdGllcy5zaG93QWxsQW5kUGVyZm9ybUxheW91dCA9IGZ1bmN0aW9uKGxheW91dHBhcmFtKSB7XG4gICAgdmFyIGhpZGRlbkVsZXMgPSBjeS5lbGVtZW50cygnOmhpZGRlbicpO1xuICAgIGlmIChoaWRkZW5FbGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIW9wdGlvbnMudW5kb2FibGUpIHtcbiAgICAgIHZhciBub2Rlc1dpdGhIaWRkZW5OZWlnaGJvciA9IGN5LmVkZ2VzKFwiOmhpZGRlblwiKS5jb25uZWN0ZWROb2RlcygnOnZpc2libGUnKTtcbiAgICAgIHNiZ252aXpJbnN0YW5jZS50aGluQm9yZGVyKG5vZGVzV2l0aEhpZGRlbk5laWdoYm9yKTtcbiAgICAgIGVsZW1lbnRVdGlsaXRpZXMuc2hvd0FuZFBlcmZvcm1MYXlvdXQoaGlkZGVuRWxlcywgbGF5b3V0cGFyYW0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHZhciBwYXJhbSA9IHtcbiAgICAgICAgZWxlczogaGlkZGVuRWxlcyxcbiAgICAgICAgbGF5b3V0cGFyYW06IGxheW91dHBhcmFtLFxuICAgICAgICBmaXJzdFRpbWU6IHRydWVcbiAgICAgIH07XG5cbiAgICAgIHZhciB1ciA9IGN5LnVuZG9SZWRvKCk7XG4gICAgICB1ci5hY3Rpb24oXCJ0aGlja2VuQm9yZGVyXCIsIHNiZ252aXpJbnN0YW5jZS50aGlja2VuQm9yZGVyLCBzYmdudml6SW5zdGFuY2UudGhpbkJvcmRlcik7XG4gICAgICB1ci5hY3Rpb24oXCJ0aGluQm9yZGVyXCIsIHNiZ252aXpJbnN0YW5jZS50aGluQm9yZGVyLCBzYmdudml6SW5zdGFuY2UudGhpY2tlbkJvcmRlcik7XG5cbiAgICAgIHZhciBhY3Rpb25zID0gW107XG4gICAgICB2YXIgbm9kZXNXaXRoSGlkZGVuTmVpZ2hib3IgPSBjeS5ub2RlcyhcIlt0aGlja0JvcmRlcl1cIik7XG4gICAgICBhY3Rpb25zLnB1c2goe25hbWU6IFwidGhpbkJvcmRlclwiLCBwYXJhbTogbm9kZXNXaXRoSGlkZGVuTmVpZ2hib3J9KTtcbiAgICAgIGFjdGlvbnMucHVzaCh7bmFtZTogXCJzaG93QW5kUGVyZm9ybUxheW91dFwiLCBwYXJhbTogcGFyYW19KTtcbiAgICAgIGN5LnVuZG9SZWRvKCkuZG8oXCJiYXRjaFwiLCBhY3Rpb25zKTtcbiAgICB9XG4gIH07XG5cbiAgLypcbiAgICogVW5oaWRlIGdpdmVuIGVsZXMgKHRoZSBvbmVzIHdoaWNoIGFyZSBoaWRkZW4gaWYgYW55KSBhbmQgcGVyZm9ybSBnaXZlbiBsYXlvdXQgYWZ0ZXJ3YXJkLiBMYXlvdXQgcGFyYW1ldGVyIG1heSBiZSBsYXlvdXQgb3B0aW9uc1xuICAgKiBvciBhIGZ1bmN0aW9uIHRvIGNhbGwuIFJlcXVpcmVzIHZpZXdVdGlsaXRpZXMgZXh0ZW5zaW9uIGFuZCBjb25zaWRlcnMgdW5kb2FibGUgb3B0aW9uLlxuICAgKi9cbiAgbWFpblV0aWxpdGllcy5zaG93QW5kUGVyZm9ybUxheW91dCA9IGZ1bmN0aW9uKG1haW5FbGUsIGVsZXMsIGxheW91dHBhcmFtKSB7XG4gICAgICB2YXIgaGlkZGVuRWxlcyA9IGVsZXMuZmlsdGVyKCc6aGlkZGVuJyk7XG4gICAgICBpZiAoaGlkZGVuRWxlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBtYWluVXRpbGl0aWVzLmNsb3NlVXBFbGVtZW50cyhtYWluRWxlLCBoaWRkZW5FbGVzLm5vZGVzKCkpO1xuICAgICAgaWYgKCFvcHRpb25zLnVuZG9hYmxlKSB7XG4gICAgICAgICAgdmFyIG5vZGVzV2l0aEhpZGRlbk5laWdoYm9yID0gY3kuZWRnZXMoXCI6aGlkZGVuXCIpLmNvbm5lY3RlZE5vZGVzKCc6dmlzaWJsZScpO1xuICAgICAgICAgIHNiZ252aXpJbnN0YW5jZS50aGluQm9yZGVyKG5vZGVzV2l0aEhpZGRlbk5laWdoYm9yKTtcbiAgICAgICAgICBlbGVtZW50VXRpbGl0aWVzLnNob3dBbmRQZXJmb3JtTGF5b3V0KGhpZGRlbkVsZXMsIGxheW91dHBhcmFtKTtcbiAgICAgICAgICB2YXIgbm9kZXNXaXRoSGlkZGVuTmVpZ2hib3IgPSBjeS5lZGdlcyhcIjpoaWRkZW5cIikuY29ubmVjdGVkTm9kZXMoJzp2aXNpYmxlJyk7XG4gICAgICAgICAgc2JnbnZpekluc3RhbmNlLnRoaWNrZW5Cb3JkZXIobm9kZXNXaXRoSGlkZGVuTmVpZ2hib3IpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIHBhcmFtID0ge1xuICAgICAgICAgICAgICBlbGVzOiBoaWRkZW5FbGVzLFxuICAgICAgICAgICAgICBsYXlvdXRwYXJhbTogbGF5b3V0cGFyYW0sXG4gICAgICAgICAgICAgIGZpcnN0VGltZTogdHJ1ZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICB2YXIgdXIgPSBjeS51bmRvUmVkbygpO1xuICAgICAgICAgIHVyLmFjdGlvbihcInRoaWNrZW5Cb3JkZXJcIiwgc2JnbnZpekluc3RhbmNlLnRoaWNrZW5Cb3JkZXIsIHNiZ252aXpJbnN0YW5jZS50aGluQm9yZGVyKTtcbiAgICAgICAgICB1ci5hY3Rpb24oXCJ0aGluQm9yZGVyXCIsIHNiZ252aXpJbnN0YW5jZS50aGluQm9yZGVyLCBzYmdudml6SW5zdGFuY2UudGhpY2tlbkJvcmRlcik7XG5cbiAgICAgICAgICB2YXIgYWN0aW9ucyA9IFtdO1xuICAgICAgICAgIHZhciBub2Rlc1RvVGhpbkJvcmRlciA9IChoaWRkZW5FbGVzLm5laWdoYm9yaG9vZChcIjp2aXNpYmxlXCIpLm5vZGVzKFwiW3RoaWNrQm9yZGVyXVwiKSlcbiAgICAgICAgICAgICAgICAgIC5kaWZmZXJlbmNlKGN5LmVkZ2VzKFwiOmhpZGRlblwiKS5kaWZmZXJlbmNlKGhpZGRlbkVsZXMuZWRnZXMoKS51bmlvbihoaWRkZW5FbGVzLm5vZGVzKCkuY29ubmVjdGVkRWRnZXMoKSkpLmNvbm5lY3RlZE5vZGVzKCkpO1xuICAgICAgICAgIGFjdGlvbnMucHVzaCh7bmFtZTogXCJ0aGluQm9yZGVyXCIsIHBhcmFtOiBub2Rlc1RvVGhpbkJvcmRlcn0pO1xuICAgICAgICAgIGFjdGlvbnMucHVzaCh7bmFtZTogXCJzaG93QW5kUGVyZm9ybUxheW91dFwiLCBwYXJhbTogcGFyYW19KTtcbiAgICAgICAgICB2YXIgbm9kZXNUb1RoaWNrZW5Cb3JkZXIgPSBoaWRkZW5FbGVzLm5vZGVzKCkuZWRnZXNXaXRoKGN5Lm5vZGVzKFwiOmhpZGRlblwiKS5kaWZmZXJlbmNlKGhpZGRlbkVsZXMubm9kZXMoKSkpXG4gIFx0ICAgICAgICAgICAgLmNvbm5lY3RlZE5vZGVzKCkuaW50ZXJzZWN0aW9uKGhpZGRlbkVsZXMubm9kZXMoKSk7XG4gICAgICAgICAgYWN0aW9ucy5wdXNoKHtuYW1lOiBcInRoaWNrZW5Cb3JkZXJcIiwgcGFyYW06IG5vZGVzVG9UaGlja2VuQm9yZGVyfSk7XG4gICAgICAgICAgY3kudW5kb1JlZG8oKS5kbyhcImJhdGNoXCIsIGFjdGlvbnMpO1xuICAgICAgfVxuICB9O1xuXG4gIC8qXG4gICogVGFrZXMgdGhlIGhpZGRlbiBlbGVtZW50cyBjbG9zZSB0byB0aGUgbm9kZXMgd2hvc2UgbmVpZ2hib3JzIHdpbGwgYmUgc2hvd25cbiAgKiAqL1xuICBtYWluVXRpbGl0aWVzLmNsb3NlVXBFbGVtZW50cyA9IGZ1bmN0aW9uKG1haW5FbGUsIGhpZGRlbkVsZXMpIHtcbiAgICAgIHZhciBsZWZ0WCA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICB2YXIgcmlnaHRYID0gTnVtYmVyLk1JTl9WQUxVRTtcbiAgICAgIHZhciB0b3BZID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgIHZhciBib3R0b21ZID0gTnVtYmVyLk1JTl9WQUxVRTtcbiAgICAgIC8vIENoZWNrIHRoZSB4IGFuZCB5IGxpbWl0cyBvZiBhbGwgaGlkZGVuIGVsZW1lbnRzIGFuZCBzdG9yZSB0aGVtIGluIHRoZSB2YXJpYWJsZXMgYWJvdmVcbiAgICAgIGhpZGRlbkVsZXMuZm9yRWFjaChmdW5jdGlvbiggZWxlICl7XG4gICAgICAgICAgaWYgKGVsZS5kYXRhKCdjbGFzcycpICE9ICdjb21wYXJ0bWVudCcgJiYgIGVsZS5kYXRhKCdjbGFzcycpICE9ICdjb21wbGV4JylcbiAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBoYWxmV2lkdGggPSBlbGUub3V0ZXJXaWR0aCgpLzI7XG4gICAgICAgICAgICAgIHZhciBoYWxmSGVpZ2h0ID0gZWxlLm91dGVySGVpZ2h0KCkvMjtcbiAgICAgICAgICAgICAgaWYgKGVsZS5wb3NpdGlvbihcInhcIikgLSBoYWxmV2lkdGggPCBsZWZ0WClcbiAgICAgICAgICAgICAgICAgIGxlZnRYID0gZWxlLnBvc2l0aW9uKFwieFwiKSAtIGhhbGZXaWR0aDtcbiAgICAgICAgICAgICAgaWYgKGVsZS5wb3NpdGlvbihcInhcIikgKyBoYWxmV2lkdGggPiByaWdodFgpXG4gICAgICAgICAgICAgICAgICByaWdodFggPSBlbGUucG9zaXRpb24oXCJ4XCIpICsgaGFsZldpZHRoO1xuICAgICAgICAgICAgICBpZiAoZWxlLnBvc2l0aW9uKFwieVwiKSAtIGhhbGZIZWlnaHQgPCB0b3BZKVxuICAgICAgICAgICAgICAgICAgdG9wWSA9IGVsZS5wb3NpdGlvbihcInlcIikgLSBoYWxmSGVpZ2h0O1xuICAgICAgICAgICAgICBpZiAoZWxlLnBvc2l0aW9uKFwieVwiKSArIGhhbGZIZWlnaHQgPiB0b3BZKVxuICAgICAgICAgICAgICAgICAgYm90dG9tWSA9IGVsZS5wb3NpdGlvbihcInlcIikgKyBoYWxmSGVpZ2h0O1xuICAgICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvL1RoZSBjb29yZGluYXRlcyBvZiB0aGUgb2xkIGNlbnRlciBjb250YWluaW5nIHRoZSBoaWRkZW4gbm9kZXNcbiAgICAgIHZhciBvbGRDZW50ZXJYID0gKGxlZnRYICsgcmlnaHRYKS8yO1xuICAgICAgdmFyIG9sZENlbnRlclkgPSAodG9wWSArIGJvdHRvbVkpLzI7XG5cbiAgICAgIC8vSGVyZSB3ZSBjYWxjdWxhdGUgdHdvIHBhcmFtZXRlcnMgd2hpY2ggZGVmaW5lIHRoZSBhcmVhIGluIHdoaWNoIHRoZSBoaWRkZW4gZWxlbWVudHMgYXJlIHBsYWNlZCBpbml0aWFsbHlcbiAgICAgIHZhciBtaW5Ib3Jpem9udGFsUGFyYW0gPSBtYWluRWxlLm91dGVyV2lkdGgoKS8yICsgKHJpZ2h0WCAtIGxlZnRYKS8yO1xuICAgICAgdmFyIG1heEhvcml6b250YWxQYXJhbSA9IG1haW5FbGUub3V0ZXJXaWR0aCgpICsgKHJpZ2h0WCAtIGxlZnRYKS8yO1xuICAgICAgdmFyIG1pblZlcnRpY2FsUGFyYW0gPSBtYWluRWxlLm91dGVySGVpZ2h0KCkvMiArIChib3R0b21ZIC0gdG9wWSkvMjtcbiAgICAgIHZhciBtYXhWZXJ0aWNhbFBhcmFtID0gbWFpbkVsZS5vdXRlckhlaWdodCgpICsgKGJvdHRvbVkgLSB0b3BZKS8yO1xuXG4gICAgICAvL1F1YWRyYW50cyBpcyBhbiBvYmplY3Qgb2YgdGhlIGZvcm0ge2ZpcnN0Olwib2J0YWluZWRcIiwgc2Vjb25kOlwiZnJlZVwiLCB0aGlyZDpcImZyZWVcIiwgZm91cnRoOlwib2J0YWluZWRcIn1cbiAgICAgIC8vIHdoaWNoIGhvbGRzIHdoaWNoIHF1YWRyYW50IGFyZSBmcmVlICh0aGF0J3Mgd2hlcmUgaGlkZGVuIG5vZGVzIHdpbGwgYmUgYnJvdWdodClcbiAgICAgIHZhciBxdWFkcmFudHMgPSBtYWluVXRpbGl0aWVzLmNoZWNrT2NjdXBpZWRRdWFkcmFudHMobWFpbkVsZSwgaGlkZGVuRWxlcyk7XG4gICAgICB2YXIgZnJlZVF1YWRyYW50cyA9IFtdO1xuICAgICAgZm9yICh2YXIgcHJvcGVydHkgaW4gcXVhZHJhbnRzKSB7XG4gICAgICAgICAgaWYgKHF1YWRyYW50c1twcm9wZXJ0eV0gPT09IFwiZnJlZVwiKVxuICAgICAgICAgICAgICBmcmVlUXVhZHJhbnRzLnB1c2gocHJvcGVydHkpO1xuICAgICAgfVxuXG4gICAgICAvL0NhbiB0YWtlIHZhbHVlcyAxIGFuZCAtMSBhbmQgYXJlIHVzZWQgdG8gcGxhY2UgdGhlIGhpZGRlbiBub2RlcyBpbiB0aGUgcmFuZG9tIHF1YWRyYW50XG4gICAgICB2YXIgaG9yaXpvbnRhbE11bHQ7XG4gICAgICB2YXIgdmVydGljYWxNdWx0O1xuICAgICAgaWYgKGZyZWVRdWFkcmFudHMubGVuZ3RoID4gMClcbiAgICAgIHtcbiAgICAgICAgaWYgKGZyZWVRdWFkcmFudHMubGVuZ3RoID09PSAzKVxuICAgICAgICB7XG4gICAgICAgICAgaWYgKGZyZWVRdWFkcmFudHMuaW5jbHVkZXMoJ2ZpcnN0JykgJiYgZnJlZVF1YWRyYW50cy5pbmNsdWRlcygnc2Vjb25kJykgJiYgZnJlZVF1YWRyYW50cy5pbmNsdWRlcygndGhpcmQnKSlcbiAgICAgICAgICB7XG4gICAgICAgICAgICBob3Jpem9udGFsTXVsdCA9IC0xO1xuICAgICAgICAgICAgdmVydGljYWxNdWx0ID0gLTE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGZyZWVRdWFkcmFudHMuaW5jbHVkZXMoJ2ZpcnN0JykgJiYgZnJlZVF1YWRyYW50cy5pbmNsdWRlcygnc2Vjb25kJykgJiYgZnJlZVF1YWRyYW50cy5pbmNsdWRlcygnZm91cnRoJykpXG4gICAgICAgICAge1xuICAgICAgICAgICAgaG9yaXpvbnRhbE11bHQgPSAxO1xuICAgICAgICAgICAgdmVydGljYWxNdWx0ID0gLTE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGZyZWVRdWFkcmFudHMuaW5jbHVkZXMoJ2ZpcnN0JykgJiYgZnJlZVF1YWRyYW50cy5pbmNsdWRlcygndGhpcmQnKSAmJiBmcmVlUXVhZHJhbnRzLmluY2x1ZGVzKCdmb3VydGgnKSlcbiAgICAgICAgICB7XG4gICAgICAgICAgICBob3Jpem9udGFsTXVsdCA9IDE7XG4gICAgICAgICAgICB2ZXJ0aWNhbE11bHQgPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChmcmVlUXVhZHJhbnRzLmluY2x1ZGVzKCdzZWNvbmQnKSAmJiBmcmVlUXVhZHJhbnRzLmluY2x1ZGVzKCd0aGlyZCcpICYmIGZyZWVRdWFkcmFudHMuaW5jbHVkZXMoJ2ZvdXJ0aCcpKVxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGhvcml6b250YWxNdWx0ID0gLTE7XG4gICAgICAgICAgICB2ZXJ0aWNhbE11bHQgPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAvL1JhbmRvbWx5IHBpY2tzIG9uZSBxdWFkcmFudCBmcm9tIHRoZSBmcmVlIHF1YWRyYW50c1xuICAgICAgICAgIHZhciByYW5kb21RdWFkcmFudCA9IGZyZWVRdWFkcmFudHNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKmZyZWVRdWFkcmFudHMubGVuZ3RoKV07XG5cbiAgICAgICAgICBpZiAocmFuZG9tUXVhZHJhbnQgPT09IFwiZmlyc3RcIikge1xuICAgICAgICAgICAgICBob3Jpem9udGFsTXVsdCA9IDE7XG4gICAgICAgICAgICAgIHZlcnRpY2FsTXVsdCA9IC0xO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChyYW5kb21RdWFkcmFudCA9PT0gXCJzZWNvbmRcIikge1xuICAgICAgICAgICAgICBob3Jpem9udGFsTXVsdCA9IC0xO1xuICAgICAgICAgICAgICB2ZXJ0aWNhbE11bHQgPSAtMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAocmFuZG9tUXVhZHJhbnQgPT09IFwidGhpcmRcIikge1xuICAgICAgICAgICAgICBob3Jpem9udGFsTXVsdCA9IC0xO1xuICAgICAgICAgICAgICB2ZXJ0aWNhbE11bHQgPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChyYW5kb21RdWFkcmFudCA9PT0gXCJmb3VydGhcIikge1xuICAgICAgICAgICAgICBob3Jpem9udGFsTXVsdCA9IDE7XG4gICAgICAgICAgICAgIHZlcnRpY2FsTXVsdCA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlXG4gICAgICB7XG4gICAgICAgICAgaG9yaXpvbnRhbE11bHQgPSAwO1xuICAgICAgICAgIHZlcnRpY2FsTXVsdCA9IDA7XG4gICAgICB9XG4gICAgICAvLyBJZiB0aGUgaG9yaXpvbnRhbE11bHQgaXMgMCBpdCBtZWFucyB0aGF0IG5vIHF1YWRyYW50IGlzIGZyZWUsIHNvIHdlIHJhbmRvbWx5IGNob29zZSBhIHF1YWRyYW50XG4gICAgICB2YXIgaG9yaXpvbnRhbFBhcmFtID0gbWFpblV0aWxpdGllcy5nZW5lcmF0ZVJhbmRvbShtaW5Ib3Jpem9udGFsUGFyYW0sbWF4SG9yaXpvbnRhbFBhcmFtLGhvcml6b250YWxNdWx0KTtcbiAgICAgIHZhciB2ZXJ0aWNhbFBhcmFtID0gbWFpblV0aWxpdGllcy5nZW5lcmF0ZVJhbmRvbShtaW5WZXJ0aWNhbFBhcmFtLG1heFZlcnRpY2FsUGFyYW0sdmVydGljYWxNdWx0KTtcblxuICAgICAgLy9UaGUgY29vcmRpbmF0ZXMgb2YgdGhlIGNlbnRlciB3aGVyZSB0aGUgaGlkZGVuIG5vZGVzIHdpbGwgYmUgdHJhbnNmZXJlZFxuICAgICAgdmFyIG5ld0NlbnRlclggPSBtYWluRWxlLnBvc2l0aW9uKFwieFwiKSArIGhvcml6b250YWxQYXJhbTtcbiAgICAgIHZhciBuZXdDZW50ZXJZID0gbWFpbkVsZS5wb3NpdGlvbihcInlcIikgKyB2ZXJ0aWNhbFBhcmFtO1xuXG4gICAgICB2YXIgeGRpZmYgPSBuZXdDZW50ZXJYIC0gb2xkQ2VudGVyWDtcbiAgICAgIHZhciB5ZGlmZiA9IG5ld0NlbnRlclkgLSBvbGRDZW50ZXJZO1xuXG4gICAgICAvL0NoYW5nZSB0aGUgcG9zaXRpb24gb2YgaGlkZGVuIGVsZW1lbnRzXG4gICAgICBoaWRkZW5FbGVzLmZvckVhY2goZnVuY3Rpb24oIGVsZSApe1xuICAgICAgICAgIHZhciBuZXd4ID0gZWxlLnBvc2l0aW9uKFwieFwiKSArIHhkaWZmO1xuICAgICAgICAgIHZhciBuZXd5ID0gZWxlLnBvc2l0aW9uKFwieVwiKSArIHlkaWZmO1xuICAgICAgICAgIGVsZS5wb3NpdGlvbihcInhcIiwgbmV3eCk7XG4gICAgICAgICAgZWxlLnBvc2l0aW9uKFwieVwiLG5ld3kpO1xuICAgICAgfSk7XG4gIH07XG5cbiAgLypcbiAgICogR2VuZXJhdGVzIGEgbnVtYmVyIGJldHdlZW4gMiBuciBhbmQgbXVsdGltcGxpZXMgaXQgd2l0aCAxIG9yIC0xXG4gICAqICovXG4gIG1haW5VdGlsaXRpZXMuZ2VuZXJhdGVSYW5kb20gPSBmdW5jdGlvbihtaW4sIG1heCwgbXVsdCkge1xuICAgICAgdmFyIHZhbCA9IFstMSwxXTtcbiAgICAgIGlmIChtdWx0ID09PSAwKVxuICAgICAgICAgIG11bHQgPSB2YWxbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKnZhbC5sZW5ndGgpXTtcbiAgICAgIHJldHVybiAoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbiArIDEpKSArIG1pbikgKiBtdWx0O1xuICB9O1xuXG4gIC8qXG4gICAqIFRoaXMgZnVuY3Rpb24gbWFrZXMgc3VyZSB0aGF0IHRoZSByYW5kb20gbnVtYmVyIGxpZXMgaW4gZnJlZSBxdWFkcmFudFxuICAgKiAqL1xuICBtYWluVXRpbGl0aWVzLmNoZWNrT2NjdXBpZWRRdWFkcmFudHMgPSBmdW5jdGlvbihtYWluRWxlLCBoaWRkZW5FbGVzKSB7XG4gICAgICBpZiAoZWxlbWVudFV0aWxpdGllcy5nZXRNYXBUeXBlKCkgPT0gJ1BEJylcbiAgICAgIHtcbiAgICAgICAgdmFyIHZpc2libGVOZWlnaGJvckVsZXMgPSBtYWluRWxlLm5laWdoYm9yaG9vZCgpLmRpZmZlcmVuY2UoaGlkZGVuRWxlcykubm9kZXMoKTtcbiAgICAgICAgdmFyIHZpc2libGVOZWlnaGJvcnNPZk5laWdoYm9ycyA9IHZpc2libGVOZWlnaGJvckVsZXMubmVpZ2hib3Job29kKCkuZGlmZmVyZW5jZShoaWRkZW5FbGVzKS5kaWZmZXJlbmNlKG1haW5FbGUpLm5vZGVzKCk7XG4gICAgICAgIHZhciB2aXNpYmxlRWxlcyA9IHZpc2libGVOZWlnaGJvckVsZXMudW5pb24odmlzaWJsZU5laWdoYm9yc09mTmVpZ2hib3JzKTtcbiAgICAgIH1cbiAgICAgIGVsc2VcbiAgICAgICAgdmFyIHZpc2libGVFbGVzID0gbWFpbkVsZS5uZWlnaGJvcmhvb2QoKS5kaWZmZXJlbmNlKGhpZGRlbkVsZXMpLm5vZGVzKCk7XG4gICAgICB2YXIgb2NjdXBpZWRRdWFkcmFudHMgPSB7Zmlyc3Q6XCJmcmVlXCIsIHNlY29uZDpcImZyZWVcIiwgdGhpcmQ6XCJmcmVlXCIsIGZvdXJ0aDpcImZyZWVcIn07XG5cbiAgICAgIHZpc2libGVFbGVzLmZvckVhY2goZnVuY3Rpb24oIGVsZSApe1xuICAgICAgICAgIGlmIChlbGUuZGF0YSgnY2xhc3MnKSAhPSAnY29tcGFydG1lbnQnICYmICBlbGUuZGF0YSgnY2xhc3MnKSAhPSAnY29tcGxleCcpXG4gICAgICAgICAge1xuICAgICAgICAgICAgICBpZiAoZWxlLnBvc2l0aW9uKFwieFwiKSA8IG1haW5FbGUucG9zaXRpb24oXCJ4XCIpICYmIGVsZS5wb3NpdGlvbihcInlcIikgPCBtYWluRWxlLnBvc2l0aW9uKFwieVwiKSlcbiAgICAgICAgICAgICAgICAgIG9jY3VwaWVkUXVhZHJhbnRzLnNlY29uZCA9IFwib2NjdXBpZWRcIjtcbiAgICAgICAgICAgICAgZWxzZSBpZiAoZWxlLnBvc2l0aW9uKFwieFwiKSA+IG1haW5FbGUucG9zaXRpb24oXCJ4XCIpICYmIGVsZS5wb3NpdGlvbihcInlcIikgPCBtYWluRWxlLnBvc2l0aW9uKFwieVwiKSlcbiAgICAgICAgICAgICAgICAgIG9jY3VwaWVkUXVhZHJhbnRzLmZpcnN0ID0gXCJvY2N1cGllZFwiO1xuICAgICAgICAgICAgICBlbHNlIGlmIChlbGUucG9zaXRpb24oXCJ4XCIpIDwgbWFpbkVsZS5wb3NpdGlvbihcInhcIikgJiYgZWxlLnBvc2l0aW9uKFwieVwiKSA+IG1haW5FbGUucG9zaXRpb24oXCJ5XCIpKVxuICAgICAgICAgICAgICAgICAgb2NjdXBpZWRRdWFkcmFudHMudGhpcmQgPSBcIm9jY3VwaWVkXCI7XG4gICAgICAgICAgICAgIGVsc2UgaWYgKGVsZS5wb3NpdGlvbihcInhcIikgPiBtYWluRWxlLnBvc2l0aW9uKFwieFwiKSAmJiBlbGUucG9zaXRpb24oXCJ5XCIpID4gbWFpbkVsZS5wb3NpdGlvbihcInlcIikpXG4gICAgICAgICAgICAgICAgICBvY2N1cGllZFF1YWRyYW50cy5mb3VydGggPSBcIm9jY3VwaWVkXCI7XG4gICAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gb2NjdXBpZWRRdWFkcmFudHM7XG4gIH07XG5cbiAgLy8gT3ZlcnJpZGVzIGhpZ2hsaWdodFByb2Nlc3NlcyBmcm9tIFNCR05WSVogLSBkbyBub3QgaGlnaGxpZ2h0IGFueSBub2RlcyB3aGVuIHRoZSBtYXAgdHlwZSBpcyBBRlxuICBtYWluVXRpbGl0aWVzLmhpZ2hsaWdodFByb2Nlc3NlcyA9IGZ1bmN0aW9uKF9ub2Rlcykge1xuICAgIGlmIChlbGVtZW50VXRpbGl0aWVzLmdldE1hcFR5cGUoKSA9PSBcIkFGXCIpXG4gICAgICByZXR1cm47XG4gICAgc2JnbnZpekluc3RhbmNlLmhpZ2hsaWdodFByb2Nlc3Nlcyhfbm9kZXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXNldHMgbWFwIHR5cGUgdG8gdW5kZWZpbmVkXG4gICAqL1xuICBtYWluVXRpbGl0aWVzLnJlc2V0TWFwVHlwZSA9IGZ1bmN0aW9uKCl7XG4gICAgZWxlbWVudFV0aWxpdGllcy5yZXNldE1hcFR5cGUoKTtcbiAgfTtcblxuICAvKipcbiAgICogcmV0dXJuIDogbWFwIHR5cGVcbiAgICovXG4gIG1haW5VdGlsaXRpZXMuZ2V0TWFwVHlwZSA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIGVsZW1lbnRVdGlsaXRpZXMuZ2V0TWFwVHlwZSgpO1xuICB9O1xuXG4gIG1haW5VdGlsaXRpZXMuYWRkQmFja2dyb3VuZEltYWdlID0gZnVuY3Rpb24obm9kZXMsIGJnT2JqLCB1cGRhdGVJbmZvLCBwcm9tcHRJbnZhbGlkSW1hZ2UsIHZhbGlkYXRlVVJMKXtcbiAgICBpZiAobm9kZXMubGVuZ3RoID09PSAwIHx8ICFiZ09iaikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGJnT2JqWydmaXJzdFRpbWUnXSA9IHRydWU7XG4gICAgaWYgKG9wdGlvbnMudW5kb2FibGUpIHtcbiAgICAgIHZhciBwYXJhbSA9IHtcbiAgICAgICAgYmdPYmo6IGJnT2JqLFxuICAgICAgICBub2Rlczogbm9kZXMsXG4gICAgICAgIHVwZGF0ZUluZm86IHVwZGF0ZUluZm8sXG4gICAgICAgIHByb21wdEludmFsaWRJbWFnZTogcHJvbXB0SW52YWxpZEltYWdlLFxuICAgICAgICB2YWxpZGF0ZVVSTDogdmFsaWRhdGVVUkwsXG4gICAgICB9O1xuXG4gICAgICBjeS51bmRvUmVkbygpLmRvKFwiYWRkQmFja2dyb3VuZEltYWdlXCIsIHBhcmFtKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBlbGVtZW50VXRpbGl0aWVzLmFkZEJhY2tncm91bmRJbWFnZShub2RlcywgYmdPYmosIHVwZGF0ZUluZm8sIHByb21wdEludmFsaWRJbWFnZSwgdmFsaWRhdGVVUkwpO1xuICAgIH1cblxuICAgIGN5LnN0eWxlKCkudXBkYXRlKCk7XG4gIH1cblxuICBtYWluVXRpbGl0aWVzLnJlbW92ZUJhY2tncm91bmRJbWFnZSA9IGZ1bmN0aW9uKG5vZGVzLCBiZ09iail7XG4gICAgaWYgKG5vZGVzLmxlbmd0aCA9PT0gMCB8fCAhYmdPYmopIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBiZ09ialsnZmlyc3RUaW1lJ10gPSB0cnVlO1xuICAgIGlmIChvcHRpb25zLnVuZG9hYmxlKSB7XG4gICAgICB2YXIgcGFyYW0gPSB7XG4gICAgICAgIGJnT2JqOiBiZ09iaixcbiAgICAgICAgbm9kZXM6IG5vZGVzXG4gICAgICB9O1xuXG4gICAgICBjeS51bmRvUmVkbygpLmRvKFwicmVtb3ZlQmFja2dyb3VuZEltYWdlXCIsIHBhcmFtKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBlbGVtZW50VXRpbGl0aWVzLnJlbW92ZUJhY2tncm91bmRJbWFnZShub2RlcywgYmdPYmopO1xuICAgIH1cblxuICAgIGN5LnN0eWxlKCkudXBkYXRlKCk7XG4gIH1cblxuICBtYWluVXRpbGl0aWVzLnVwZGF0ZUJhY2tncm91bmRJbWFnZSA9IGZ1bmN0aW9uKG5vZGVzLCBiZ09iail7XG4gICAgaWYgKG5vZGVzLmxlbmd0aCA9PT0gMCB8fCAhYmdPYmopIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy51bmRvYWJsZSkge1xuICAgICAgdmFyIHBhcmFtID0ge1xuICAgICAgICBiZ09iajogYmdPYmosXG4gICAgICAgIG5vZGVzOiBub2Rlc1xuICAgICAgfTtcblxuICAgICAgY3kudW5kb1JlZG8oKS5kbyhcInVwZGF0ZUJhY2tncm91bmRJbWFnZVwiLCBwYXJhbSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZWxlbWVudFV0aWxpdGllcy51cGRhdGVCYWNrZ3JvdW5kSW1hZ2Uobm9kZXMsIGJnT2JqKTtcbiAgICB9XG5cbiAgICBjeS5zdHlsZSgpLnVwZGF0ZSgpO1xuICB9XG5cbiAgbWFpblV0aWxpdGllcy5jaGFuZ2VCYWNrZ3JvdW5kSW1hZ2UgPSBmdW5jdGlvbihub2Rlcywgb2xkSW1nLCBuZXdJbWcsIHVwZGF0ZUluZm8sIHByb21wdEludmFsaWRJbWFnZSwgdmFsaWRhdGVVUkwpe1xuICAgIGlmIChub2Rlcy5sZW5ndGggPT09IDAgfHwgIW9sZEltZyB8fCAhbmV3SW1nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMudW5kb2FibGUpIHtcbiAgICAgIHZhciBwYXJhbSA9IHtcbiAgICAgICAgb2xkSW1nOiBvbGRJbWcsXG4gICAgICAgIG5ld0ltZzogbmV3SW1nLFxuICAgICAgICBub2Rlczogbm9kZXMsXG4gICAgICAgIGZpcnN0VGltZTogdHJ1ZSxcbiAgICAgICAgdXBkYXRlSW5mbzogdXBkYXRlSW5mbyxcbiAgICAgICAgcHJvbXB0SW52YWxpZEltYWdlOiBwcm9tcHRJbnZhbGlkSW1hZ2UsXG4gICAgICAgIHZhbGlkYXRlVVJMOiB2YWxpZGF0ZVVSTFxuICAgICAgfTtcblxuICAgICAgY3kudW5kb1JlZG8oKS5kbyhcImNoYW5nZUJhY2tncm91bmRJbWFnZVwiLCBwYXJhbSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZWxlbWVudFV0aWxpdGllcy5jaGFuZ2VCYWNrZ3JvdW5kSW1hZ2Uobm9kZXMsIG9sZEltZywgbmV3SW1nLCB0cnVlLCB1cGRhdGVJbmZvLCBwcm9tcHRJbnZhbGlkSW1hZ2UsIHZhbGlkYXRlVVJMKTtcbiAgICB9XG5cbiAgICBjeS5zdHlsZSgpLnVwZGF0ZSgpO1xuICB9XG5cbiAgcmV0dXJuIG1haW5VdGlsaXRpZXM7XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/utilities/main-utilities-factory.js\n");

/***/ }),

/***/ "./src/utilities/option-utilities-factory.js":
/*!***************************************************!*\
  !*** ./src/utilities/option-utilities-factory.js ***!
  \***************************************************/
/***/ ((module) => {

eval("/*\n *  Extend default options and get current options by using this file\n */\nmodule.exports = function () {\n  // default options\n  var defaults = {\n    // The path of core library images when sbgnviz is required from npm and the index html\n    // file and node_modules are under the same folder then using the default value is fine\n    imgPath: 'node_modules/sbgnviz/src/img',\n    // Whether to fit labels to nodes\n    fitLabelsToNodes: function fitLabelsToNodes() {\n      return false;\n    },\n    fitLabelsToInfoboxes: function fitLabelsToInfoboxes() {\n      return false;\n    },\n    // dynamic label size it may be 'small', 'regular', 'large'\n    dynamicLabelSize: function dynamicLabelSize() {\n      return 'regular';\n    },\n    // Whether to infer nesting on load \n    inferNestingOnLoad: function inferNestingOnLoad() {\n      return false;\n    },\n    // percentage used to calculate compound paddings\n    compoundPadding: function compoundPadding() {\n      return 10;\n    },\n    // The selector of the component containing the sbgn network\n    networkContainerSelector: '#sbgn-network-container',\n    // Whether the actions are undoable, requires cytoscape-undo-redo extension\n    undoable: true,\n    // Whether to have undoable drag feature in undo/redo extension. This options will be passed to undo/redo extension\n    undoableDrag: true\n  };\n\n  var optionUtilities = function optionUtilities() {}; // Extend the defaults options with the user options\n\n\n  optionUtilities.extendOptions = function (options) {\n    var result = {};\n\n    for (var prop in defaults) {\n      result[prop] = defaults[prop];\n    }\n\n    for (var prop in options) {\n      result[prop] = options[prop];\n    }\n\n    optionUtilities.options = result;\n    return options;\n  };\n\n  optionUtilities.getOptions = function () {\n    return optionUtilities.options;\n  };\n\n  return optionUtilities;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jaGlzZS8uL3NyYy91dGlsaXRpZXMvb3B0aW9uLXV0aWxpdGllcy1mYWN0b3J5LmpzPzllNDciXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsImRlZmF1bHRzIiwiaW1nUGF0aCIsImZpdExhYmVsc1RvTm9kZXMiLCJmaXRMYWJlbHNUb0luZm9ib3hlcyIsImR5bmFtaWNMYWJlbFNpemUiLCJpbmZlck5lc3RpbmdPbkxvYWQiLCJjb21wb3VuZFBhZGRpbmciLCJuZXR3b3JrQ29udGFpbmVyU2VsZWN0b3IiLCJ1bmRvYWJsZSIsInVuZG9hYmxlRHJhZyIsIm9wdGlvblV0aWxpdGllcyIsImV4dGVuZE9wdGlvbnMiLCJvcHRpb25zIiwicmVzdWx0IiwicHJvcCIsImdldE9wdGlvbnMiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUVBQSxNQUFNLENBQUNDLE9BQVAsR0FBaUIsWUFBWTtBQUUzQjtBQUNBLE1BQUlDLFFBQVEsR0FBRztBQUNiO0FBQ0E7QUFDQUMsSUFBQUEsT0FBTyxFQUFFLDhCQUhJO0FBSWI7QUFDQUMsSUFBQUEsZ0JBQWdCLEVBQUUsNEJBQVk7QUFDNUIsYUFBTyxLQUFQO0FBQ0QsS0FQWTtBQVFiQyxJQUFBQSxvQkFBb0IsRUFBRSxnQ0FBWTtBQUNoQyxhQUFPLEtBQVA7QUFDRCxLQVZZO0FBV2I7QUFDQUMsSUFBQUEsZ0JBQWdCLEVBQUUsNEJBQVk7QUFDNUIsYUFBTyxTQUFQO0FBQ0QsS0FkWTtBQWViO0FBQ0FDLElBQUFBLGtCQUFrQixFQUFFLDhCQUFZO0FBQzlCLGFBQU8sS0FBUDtBQUNELEtBbEJZO0FBbUJiO0FBQ0FDLElBQUFBLGVBQWUsRUFBRSwyQkFBWTtBQUMzQixhQUFPLEVBQVA7QUFDRCxLQXRCWTtBQXVCYjtBQUNBQyxJQUFBQSx3QkFBd0IsRUFBRSx5QkF4QmI7QUF5QmI7QUFDQUMsSUFBQUEsUUFBUSxFQUFFLElBMUJHO0FBMkJiO0FBQ0FDLElBQUFBLFlBQVksRUFBRTtBQTVCRCxHQUFmOztBQStCQSxNQUFJQyxlQUFlLEdBQUcsU0FBbEJBLGVBQWtCLEdBQVksQ0FDakMsQ0FERCxDQWxDMkIsQ0FxQzNCOzs7QUFDQUEsRUFBQUEsZUFBZSxDQUFDQyxhQUFoQixHQUFnQyxVQUFVQyxPQUFWLEVBQW1CO0FBQ2pELFFBQUlDLE1BQU0sR0FBRyxFQUFiOztBQUVBLFNBQUssSUFBSUMsSUFBVCxJQUFpQmQsUUFBakIsRUFBMkI7QUFDekJhLE1BQUFBLE1BQU0sQ0FBQ0MsSUFBRCxDQUFOLEdBQWVkLFFBQVEsQ0FBQ2MsSUFBRCxDQUF2QjtBQUNEOztBQUVELFNBQUssSUFBSUEsSUFBVCxJQUFpQkYsT0FBakIsRUFBMEI7QUFDeEJDLE1BQUFBLE1BQU0sQ0FBQ0MsSUFBRCxDQUFOLEdBQWVGLE9BQU8sQ0FBQ0UsSUFBRCxDQUF0QjtBQUNEOztBQUVESixJQUFBQSxlQUFlLENBQUNFLE9BQWhCLEdBQTBCQyxNQUExQjtBQUVBLFdBQU9ELE9BQVA7QUFDRCxHQWREOztBQWdCQUYsRUFBQUEsZUFBZSxDQUFDSyxVQUFoQixHQUE2QixZQUFZO0FBQ3ZDLFdBQU9MLGVBQWUsQ0FBQ0UsT0FBdkI7QUFDRCxHQUZEOztBQUlBLFNBQU9GLGVBQVA7QUFDRCxDQTNERCIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiAgRXh0ZW5kIGRlZmF1bHQgb3B0aW9ucyBhbmQgZ2V0IGN1cnJlbnQgb3B0aW9ucyBieSB1c2luZyB0aGlzIGZpbGVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcblxuICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgdmFyIGRlZmF1bHRzID0ge1xuICAgIC8vIFRoZSBwYXRoIG9mIGNvcmUgbGlicmFyeSBpbWFnZXMgd2hlbiBzYmdudml6IGlzIHJlcXVpcmVkIGZyb20gbnBtIGFuZCB0aGUgaW5kZXggaHRtbFxuICAgIC8vIGZpbGUgYW5kIG5vZGVfbW9kdWxlcyBhcmUgdW5kZXIgdGhlIHNhbWUgZm9sZGVyIHRoZW4gdXNpbmcgdGhlIGRlZmF1bHQgdmFsdWUgaXMgZmluZVxuICAgIGltZ1BhdGg6ICdub2RlX21vZHVsZXMvc2JnbnZpei9zcmMvaW1nJyxcbiAgICAvLyBXaGV0aGVyIHRvIGZpdCBsYWJlbHMgdG8gbm9kZXNcbiAgICBmaXRMYWJlbHNUb05vZGVzOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBmaXRMYWJlbHNUb0luZm9ib3hlczogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgLy8gZHluYW1pYyBsYWJlbCBzaXplIGl0IG1heSBiZSAnc21hbGwnLCAncmVndWxhcicsICdsYXJnZSdcbiAgICBkeW5hbWljTGFiZWxTaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gJ3JlZ3VsYXInO1xuICAgIH0sXG4gICAgLy8gV2hldGhlciB0byBpbmZlciBuZXN0aW5nIG9uIGxvYWQgXG4gICAgaW5mZXJOZXN0aW5nT25Mb2FkOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICAvLyBwZXJjZW50YWdlIHVzZWQgdG8gY2FsY3VsYXRlIGNvbXBvdW5kIHBhZGRpbmdzXG4gICAgY29tcG91bmRQYWRkaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gMTA7XG4gICAgfSxcbiAgICAvLyBUaGUgc2VsZWN0b3Igb2YgdGhlIGNvbXBvbmVudCBjb250YWluaW5nIHRoZSBzYmduIG5ldHdvcmtcbiAgICBuZXR3b3JrQ29udGFpbmVyU2VsZWN0b3I6ICcjc2Jnbi1uZXR3b3JrLWNvbnRhaW5lcicsXG4gICAgLy8gV2hldGhlciB0aGUgYWN0aW9ucyBhcmUgdW5kb2FibGUsIHJlcXVpcmVzIGN5dG9zY2FwZS11bmRvLXJlZG8gZXh0ZW5zaW9uXG4gICAgdW5kb2FibGU6IHRydWUsXG4gICAgLy8gV2hldGhlciB0byBoYXZlIHVuZG9hYmxlIGRyYWcgZmVhdHVyZSBpbiB1bmRvL3JlZG8gZXh0ZW5zaW9uLiBUaGlzIG9wdGlvbnMgd2lsbCBiZSBwYXNzZWQgdG8gdW5kby9yZWRvIGV4dGVuc2lvblxuICAgIHVuZG9hYmxlRHJhZzogdHJ1ZVxuICB9O1xuXG4gIHZhciBvcHRpb25VdGlsaXRpZXMgPSBmdW5jdGlvbiAoKSB7XG4gIH07XG5cbiAgLy8gRXh0ZW5kIHRoZSBkZWZhdWx0cyBvcHRpb25zIHdpdGggdGhlIHVzZXIgb3B0aW9uc1xuICBvcHRpb25VdGlsaXRpZXMuZXh0ZW5kT3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuXG4gICAgZm9yICh2YXIgcHJvcCBpbiBkZWZhdWx0cykge1xuICAgICAgcmVzdWx0W3Byb3BdID0gZGVmYXVsdHNbcHJvcF07XG4gICAgfVxuXG4gICAgZm9yICh2YXIgcHJvcCBpbiBvcHRpb25zKSB7XG4gICAgICByZXN1bHRbcHJvcF0gPSBvcHRpb25zW3Byb3BdO1xuICAgIH1cblxuICAgIG9wdGlvblV0aWxpdGllcy5vcHRpb25zID0gcmVzdWx0O1xuXG4gICAgcmV0dXJuIG9wdGlvbnM7XG4gIH07XG5cbiAgb3B0aW9uVXRpbGl0aWVzLmdldE9wdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG9wdGlvblV0aWxpdGllcy5vcHRpb25zO1xuICB9O1xuXG4gIHJldHVybiBvcHRpb25VdGlsaXRpZXM7XG59O1xuIl0sImZpbGUiOiIuL3NyYy91dGlsaXRpZXMvb3B0aW9uLXV0aWxpdGllcy1mYWN0b3J5LmpzLmpzIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/utilities/option-utilities-factory.js\n");

/***/ }),

/***/ "./src/utilities/register-undo-redo-actions-factory.js":
/*!*************************************************************!*\
  !*** ./src/utilities/register-undo-redo-actions-factory.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var libs = __webpack_require__(/*! ./lib-utilities */ \"./src/utilities/lib-utilities.js\").getLibs();\n\nvar $ = libs.jQuery;\n\nmodule.exports = function () {\n  var undoRedoActionFunctions, options, cy;\n\n  var registerUndoRedoActions = function registerUndoRedoActions(param) {\n    undoRedoActionFunctions = param.undoRedoActionFunctions;\n    options = param.optionUtilities.getOptions();\n    cy = param.sbgnvizInstanceUtilities.getCy();\n\n    if (!options.undoable) {\n      return;\n    } // create undo-redo instance\n\n\n    var ur = cy.undoRedo({\n      undoableDrag: options.undoableDrag\n    }); // register add remove actions\n\n    ur.action(\"addNode\", undoRedoActionFunctions.addNode, undoRedoActionFunctions.deleteElesSimple);\n    ur.action(\"deleteElesSimple\", undoRedoActionFunctions.deleteElesSimple, undoRedoActionFunctions.restoreEles);\n    ur.action(\"addEdge\", undoRedoActionFunctions.addEdge, undoRedoActionFunctions.deleteElesSimple);\n    ur.action(\"addProcessWithConvenientEdges\", undoRedoActionFunctions.addProcessWithConvenientEdges, undoRedoActionFunctions.deleteElesSimple);\n    ur.action(\"deleteElesSmart\", undoRedoActionFunctions.deleteElesSmart, undoRedoActionFunctions.restoreEles);\n    ur.action(\"createCompoundForGivenNodes\", undoRedoActionFunctions.createCompoundForGivenNodes, undoRedoActionFunctions.createCompoundForGivenNodes); // register general actions\n\n    ur.action(\"resizeNodes\", undoRedoActionFunctions.resizeNodes, undoRedoActionFunctions.resizeNodes);\n    ur.action(\"changeNodeLabel\", undoRedoActionFunctions.changeNodeLabel, undoRedoActionFunctions.changeNodeLabel);\n    ur.action(\"changeData\", undoRedoActionFunctions.changeData, undoRedoActionFunctions.changeData);\n    ur.action(\"updateSetField\", undoRedoActionFunctions.updateSetField, undoRedoActionFunctions.updateSetField);\n    ur.action(\"changeCss\", undoRedoActionFunctions.changeCss, undoRedoActionFunctions.changeCss);\n    ur.action(\"changeBendPoints\", undoRedoActionFunctions.changeBendPoints, undoRedoActionFunctions.changeBendPoints);\n    ur.action(\"changeFontProperties\", undoRedoActionFunctions.changeFontProperties, undoRedoActionFunctions.changeFontProperties);\n    ur.action(\"showAndPerformLayout\", undoRedoActionFunctions.showAndPerformLayout, undoRedoActionFunctions.undoShowAndPerformLayout);\n    ur.action(\"hideAndPerformLayout\", undoRedoActionFunctions.hideAndPerformLayout, undoRedoActionFunctions.undoHideAndPerformLayout);\n    ur.action(\"deleteAndPerformLayout\", undoRedoActionFunctions.deleteAndPerformLayout, undoRedoActionFunctions.undoDeleteAndPerformLayout);\n    ur.action(\"applySIFTopologyGrouping\", undoRedoActionFunctions.applySIFTopologyGrouping, undoRedoActionFunctions.applySIFTopologyGrouping); // register SBGN actions\n\n    ur.action(\"addStateOrInfoBox\", undoRedoActionFunctions.addStateOrInfoBox, undoRedoActionFunctions.removeStateOrInfoBox);\n    ur.action(\"changeStateOrInfoBox\", undoRedoActionFunctions.changeStateOrInfoBox, undoRedoActionFunctions.changeStateOrInfoBox);\n    ur.action(\"setMultimerStatus\", undoRedoActionFunctions.setMultimerStatus, undoRedoActionFunctions.setMultimerStatus);\n    ur.action(\"setCloneMarkerStatus\", undoRedoActionFunctions.setCloneMarkerStatus, undoRedoActionFunctions.setCloneMarkerStatus);\n    ur.action(\"removeStateOrInfoBox\", undoRedoActionFunctions.removeStateOrInfoBox, undoRedoActionFunctions.addStateOrInfoBox);\n    ur.action(\"fitUnits\", undoRedoActionFunctions.fitUnits, undoRedoActionFunctions.restoreUnits);\n    ur.action(\"addBackgroundImage\", undoRedoActionFunctions.addBackgroundImage, undoRedoActionFunctions.removeBackgroundImage);\n    ur.action(\"removeBackgroundImage\", undoRedoActionFunctions.removeBackgroundImage, undoRedoActionFunctions.addBackgroundImage);\n    ur.action(\"updateBackgroundImage\", undoRedoActionFunctions.updateBackgroundImage, undoRedoActionFunctions.updateBackgroundImage);\n    ur.action(\"changeBackgroundImage\", undoRedoActionFunctions.changeBackgroundImage, undoRedoActionFunctions.changeBackgroundImage);\n    ur.action(\"updateInfoboxStyle\", undoRedoActionFunctions.updateInfoboxStyle, undoRedoActionFunctions.updateInfoboxStyle);\n    ur.action(\"updateInfoboxObj\", undoRedoActionFunctions.updateInfoboxObj, undoRedoActionFunctions.updateInfoboxObj); // register easy creation actions\n\n    ur.action(\"createTemplateReaction\", undoRedoActionFunctions.createTemplateReaction, undoRedoActionFunctions.deleteElesSimple);\n    ur.action(\"createActivationReaction\", undoRedoActionFunctions.createActivationReaction, undoRedoActionFunctions.deleteElesSimple);\n    ur.action(\"createMetabolicCatalyticActivity\", undoRedoActionFunctions.createMetabolicCatalyticActivity, undoRedoActionFunctions.deleteElesSimple);\n    ur.action(\"createMetabolicReaction\", undoRedoActionFunctions.createMetabolicReaction, undoRedoActionFunctions.deleteElesSimple);\n    ur.action(\"createConversion\", undoRedoActionFunctions.createConversion, undoRedoActionFunctions.deleteElesSimple);\n    ur.action(\"createMultimerization\", undoRedoActionFunctions.createMultimerization, undoRedoActionFunctions.deleteElesSimple);\n    ur.action(\"createComplexProteinFormation\", undoRedoActionFunctions.createComplexProteinFormation, undoRedoActionFunctions.deleteElesSimple);\n    ur.action(\"createDegradation\", undoRedoActionFunctions.createDegradation, undoRedoActionFunctions.deleteElesSimple);\n    ur.action(\"createTranscription\", undoRedoActionFunctions.createTranscription, undoRedoActionFunctions.deleteElesSimple);\n    ur.action(\"createTranslation\", undoRedoActionFunctions.createTranslation, undoRedoActionFunctions.deleteElesSimple);\n    ur.action(\"createTranscriptionReaction\", undoRedoActionFunctions.createTranscriptionReaction, undoRedoActionFunctions.deleteElesSimple);\n    ur.action(\"createTranslationReaction\", undoRedoActionFunctions.createTranslationReaction, undoRedoActionFunctions.deleteElesSimple);\n    ur.action(\"setDefaultProperty\", undoRedoActionFunctions.setDefaultProperty, undoRedoActionFunctions.setDefaultProperty);\n    ur.action(\"convertIntoReversibleReaction\", undoRedoActionFunctions.convertIntoReversibleReaction, undoRedoActionFunctions.convertIntoReversibleReaction);\n    ur.action(\"moveEdge\", undoRedoActionFunctions.moveEdge, undoRedoActionFunctions.moveEdge);\n    ur.action(\"fixError\", undoRedoActionFunctions.fixError, undoRedoActionFunctions.unfixError);\n    ur.action(\"cloneHighDegreeNode\", undoRedoActionFunctions.cloneHighDegreeNode, undoRedoActionFunctions.unCloneHighDegreeNode);\n    ur.action(\"changeMapType\", undoRedoActionFunctions.changeMapType, undoRedoActionFunctions.changeMapType);\n    ur.action(\"setCompoundPadding\", undoRedoActionFunctions.setCompoundPadding, undoRedoActionFunctions.setCompoundPadding);\n  };\n\n  return registerUndoRedoActions;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jaGlzZS8uL3NyYy91dGlsaXRpZXMvcmVnaXN0ZXItdW5kby1yZWRvLWFjdGlvbnMtZmFjdG9yeS5qcz81YTNhIl0sIm5hbWVzIjpbImxpYnMiLCJyZXF1aXJlIiwiJCIsImpRdWVyeSIsIm1vZHVsZSIsImV4cG9ydHMiLCJ1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucyIsIm9wdGlvbnMiLCJjeSIsInJlZ2lzdGVyVW5kb1JlZG9BY3Rpb25zIiwicGFyYW0iLCJvcHRpb25VdGlsaXRpZXMiLCJnZXRPcHRpb25zIiwic2JnbnZpekluc3RhbmNlVXRpbGl0aWVzIiwiZ2V0Q3kiLCJ1bmRvYWJsZSIsInVyIiwidW5kb1JlZG8iLCJ1bmRvYWJsZURyYWciLCJhY3Rpb24iLCJhZGROb2RlIiwiZGVsZXRlRWxlc1NpbXBsZSIsInJlc3RvcmVFbGVzIiwiYWRkRWRnZSIsImFkZFByb2Nlc3NXaXRoQ29udmVuaWVudEVkZ2VzIiwiZGVsZXRlRWxlc1NtYXJ0IiwiY3JlYXRlQ29tcG91bmRGb3JHaXZlbk5vZGVzIiwicmVzaXplTm9kZXMiLCJjaGFuZ2VOb2RlTGFiZWwiLCJjaGFuZ2VEYXRhIiwidXBkYXRlU2V0RmllbGQiLCJjaGFuZ2VDc3MiLCJjaGFuZ2VCZW5kUG9pbnRzIiwiY2hhbmdlRm9udFByb3BlcnRpZXMiLCJzaG93QW5kUGVyZm9ybUxheW91dCIsInVuZG9TaG93QW5kUGVyZm9ybUxheW91dCIsImhpZGVBbmRQZXJmb3JtTGF5b3V0IiwidW5kb0hpZGVBbmRQZXJmb3JtTGF5b3V0IiwiZGVsZXRlQW5kUGVyZm9ybUxheW91dCIsInVuZG9EZWxldGVBbmRQZXJmb3JtTGF5b3V0IiwiYXBwbHlTSUZUb3BvbG9neUdyb3VwaW5nIiwiYWRkU3RhdGVPckluZm9Cb3giLCJyZW1vdmVTdGF0ZU9ySW5mb0JveCIsImNoYW5nZVN0YXRlT3JJbmZvQm94Iiwic2V0TXVsdGltZXJTdGF0dXMiLCJzZXRDbG9uZU1hcmtlclN0YXR1cyIsImZpdFVuaXRzIiwicmVzdG9yZVVuaXRzIiwiYWRkQmFja2dyb3VuZEltYWdlIiwicmVtb3ZlQmFja2dyb3VuZEltYWdlIiwidXBkYXRlQmFja2dyb3VuZEltYWdlIiwiY2hhbmdlQmFja2dyb3VuZEltYWdlIiwidXBkYXRlSW5mb2JveFN0eWxlIiwidXBkYXRlSW5mb2JveE9iaiIsImNyZWF0ZVRlbXBsYXRlUmVhY3Rpb24iLCJjcmVhdGVBY3RpdmF0aW9uUmVhY3Rpb24iLCJjcmVhdGVNZXRhYm9saWNDYXRhbHl0aWNBY3Rpdml0eSIsImNyZWF0ZU1ldGFib2xpY1JlYWN0aW9uIiwiY3JlYXRlQ29udmVyc2lvbiIsImNyZWF0ZU11bHRpbWVyaXphdGlvbiIsImNyZWF0ZUNvbXBsZXhQcm90ZWluRm9ybWF0aW9uIiwiY3JlYXRlRGVncmFkYXRpb24iLCJjcmVhdGVUcmFuc2NyaXB0aW9uIiwiY3JlYXRlVHJhbnNsYXRpb24iLCJjcmVhdGVUcmFuc2NyaXB0aW9uUmVhY3Rpb24iLCJjcmVhdGVUcmFuc2xhdGlvblJlYWN0aW9uIiwic2V0RGVmYXVsdFByb3BlcnR5IiwiY29udmVydEludG9SZXZlcnNpYmxlUmVhY3Rpb24iLCJtb3ZlRWRnZSIsImZpeEVycm9yIiwidW5maXhFcnJvciIsImNsb25lSGlnaERlZ3JlZU5vZGUiLCJ1bkNsb25lSGlnaERlZ3JlZU5vZGUiLCJjaGFuZ2VNYXBUeXBlIiwic2V0Q29tcG91bmRQYWRkaW5nIl0sIm1hcHBpbmdzIjoiQUFBQSxJQUFJQSxJQUFJLEdBQUdDLHNGQUFBLEVBQVg7O0FBQ0EsSUFBSUMsQ0FBQyxHQUFHRixJQUFJLENBQUNHLE1BQWI7O0FBRUFDLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQixZQUFZO0FBRTNCLE1BQUlDLHVCQUFKLEVBQTZCQyxPQUE3QixFQUFzQ0MsRUFBdEM7O0FBRUEsTUFBSUMsdUJBQXVCLEdBQUcsU0FBMUJBLHVCQUEwQixDQUFVQyxLQUFWLEVBQWlCO0FBRTdDSiwyQkFBdUIsR0FBR0ksS0FBSyxDQUFDSix1QkFBaEM7QUFDQUMsV0FBTyxHQUFH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QUFDQXpELE1BQUUsQ0FBQ0csTUFBSCxDQUFVLG9CQUFWLEVBQWdDYix1QkFBdUIsQ0FBQ29FLGtCQUF4RCxFQUE0RXBFLHVCQUF1QixDQUFDb0Usa0JBQXBHO0FBRUQsR0F6RUQ7O0FBMkVBLFNBQU9qRSx1QkFBUDtBQUNELENBaEZEIiwiZmlsZSI6Ii4vc3JjL3V0aWxpdGllcy9yZWdpc3Rlci11bmRvLXJlZG8tYWN0aW9ucy1mYWN0b3J5LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGxpYnMgPSByZXF1aXJlKCcuL2xpYi11dGlsaXRpZXMnKS5nZXRMaWJzKCk7XG52YXIgJCA9IGxpYnMualF1ZXJ5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcblxuICB2YXIgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMsIG9wdGlvbnMsIGN5O1xuXG4gIHZhciByZWdpc3RlclVuZG9SZWRvQWN0aW9ucyA9IGZ1bmN0aW9uIChwYXJhbSkge1xuXG4gICAgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMgPSBwYXJhbS51bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucztcbiAgICBvcHRpb25zID0gcGFyYW0ub3B0aW9uVXRpbGl0aWVzLmdldE9wdGlvbnMoKTtcbiAgICBjeSA9IHBhcmFtLnNiZ252aXpJbnN0YW5jZVV0aWxpdGllcy5nZXRDeSgpO1xuXG4gICAgaWYgKCFvcHRpb25zLnVuZG9hYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gY3JlYXRlIHVuZG8tcmVkbyBpbnN0YW5jZVxuICAgIHZhciB1ciA9IGN5LnVuZG9SZWRvKHtcbiAgICAgIHVuZG9hYmxlRHJhZzogb3B0aW9ucy51bmRvYWJsZURyYWdcbiAgICB9KTtcblxuICAgIC8vIHJlZ2lzdGVyIGFkZCByZW1vdmUgYWN0aW9uc1xuICAgIHVyLmFjdGlvbihcImFkZE5vZGVcIiwgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMuYWRkTm9kZSwgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMuZGVsZXRlRWxlc1NpbXBsZSk7XG4gICAgdXIuYWN0aW9uKFwiZGVsZXRlRWxlc1NpbXBsZVwiLCB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5kZWxldGVFbGVzU2ltcGxlLCB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5yZXN0b3JlRWxlcyk7XG4gICAgdXIuYWN0aW9uKFwiYWRkRWRnZVwiLCB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5hZGRFZGdlLCB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5kZWxldGVFbGVzU2ltcGxlKTtcbiAgICB1ci5hY3Rpb24oXCJhZGRQcm9jZXNzV2l0aENvbnZlbmllbnRFZGdlc1wiLCB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5hZGRQcm9jZXNzV2l0aENvbnZlbmllbnRFZGdlcywgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMuZGVsZXRlRWxlc1NpbXBsZSk7XG4gICAgdXIuYWN0aW9uKFwiZGVsZXRlRWxlc1NtYXJ0XCIsIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLmRlbGV0ZUVsZXNTbWFydCwgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMucmVzdG9yZUVsZXMpO1xuICAgIHVyLmFjdGlvbihcImNyZWF0ZUNvbXBvdW5kRm9yR2l2ZW5Ob2Rlc1wiLCB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5jcmVhdGVDb21wb3VuZEZvckdpdmVuTm9kZXMsIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLmNyZWF0ZUNvbXBvdW5kRm9yR2l2ZW5Ob2Rlcyk7XG5cbiAgICAvLyByZWdpc3RlciBnZW5lcmFsIGFjdGlvbnNcbiAgICB1ci5hY3Rpb24oXCJyZXNpemVOb2Rlc1wiLCB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5yZXNpemVOb2RlcywgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMucmVzaXplTm9kZXMpO1xuICAgIHVyLmFjdGlvbihcImNoYW5nZU5vZGVMYWJlbFwiLCB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5jaGFuZ2VOb2RlTGFiZWwsIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLmNoYW5nZU5vZGVMYWJlbCk7XG4gICAgdXIuYWN0aW9uKFwiY2hhbmdlRGF0YVwiLCB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5jaGFuZ2VEYXRhLCB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5jaGFuZ2VEYXRhKTtcbiAgICB1ci5hY3Rpb24oXCJ1cGRhdGVTZXRGaWVsZFwiLCB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy51cGRhdGVTZXRGaWVsZCwgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMudXBkYXRlU2V0RmllbGQpO1xuICAgIHVyLmFjdGlvbihcImNoYW5nZUNzc1wiLCB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5jaGFuZ2VDc3MsIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLmNoYW5nZUNzcyk7XG4gICAgdXIuYWN0aW9uKFwiY2hhbmdlQmVuZFBvaW50c1wiLCB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5jaGFuZ2VCZW5kUG9pbnRzLCB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5jaGFuZ2VCZW5kUG9pbnRzKTtcbiAgICB1ci5hY3Rpb24oXCJjaGFuZ2VGb250UHJvcGVydGllc1wiLCB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5jaGFuZ2VGb250UHJvcGVydGllcywgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMuY2hhbmdlRm9udFByb3BlcnRpZXMpO1xuICAgIHVyLmFjdGlvbihcInNob3dBbmRQZXJmb3JtTGF5b3V0XCIsIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLnNob3dBbmRQZXJmb3JtTGF5b3V0LCB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy51bmRvU2hvd0FuZFBlcmZvcm1MYXlvdXQpO1xuICAgIHVyLmFjdGlvbihcImhpZGVBbmRQZXJmb3JtTGF5b3V0XCIsIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLmhpZGVBbmRQZXJmb3JtTGF5b3V0LCB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy51bmRvSGlkZUFuZFBlcmZvcm1MYXlvdXQpO1xuICAgIHVyLmFjdGlvbihcImRlbGV0ZUFuZFBlcmZvcm1MYXlvdXRcIiwgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMuZGVsZXRlQW5kUGVyZm9ybUxheW91dCwgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMudW5kb0RlbGV0ZUFuZFBlcmZvcm1MYXlvdXQpO1xuICAgIHVyLmFjdGlvbihcImFwcGx5U0lGVG9wb2xvZ3lHcm91cGluZ1wiLCB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5hcHBseVNJRlRvcG9sb2d5R3JvdXBpbmcsIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLmFwcGx5U0lGVG9wb2xvZ3lHcm91cGluZyk7XG5cbiAgICAvLyByZWdpc3RlciBTQkdOIGFjdGlvbnNcbiAgICB1ci5hY3Rpb24oXCJhZGRTdGF0ZU9ySW5mb0JveFwiLCB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5hZGRTdGF0ZU9ySW5mb0JveCwgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMucmVtb3ZlU3RhdGVPckluZm9Cb3gpO1xuICAgIHVyLmFjdGlvbihcImNoYW5nZVN0YXRlT3JJbmZvQm94XCIsIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLmNoYW5nZVN0YXRlT3JJbmZvQm94LCB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5jaGFuZ2VTdGF0ZU9ySW5mb0JveCk7XG4gICAgdXIuYWN0aW9uKFwic2V0TXVsdGltZXJTdGF0dXNcIiwgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMuc2V0TXVsdGltZXJTdGF0dXMsIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLnNldE11bHRpbWVyU3RhdHVzKTtcbiAgICB1ci5hY3Rpb24oXCJzZXRDbG9uZU1hcmtlclN0YXR1c1wiLCB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5zZXRDbG9uZU1hcmtlclN0YXR1cywgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMuc2V0Q2xvbmVNYXJrZXJTdGF0dXMpO1xuICAgIHVyLmFjdGlvbihcInJlbW92ZVN0YXRlT3JJbmZvQm94XCIsIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLnJlbW92ZVN0YXRlT3JJbmZvQm94LCB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5hZGRTdGF0ZU9ySW5mb0JveCk7XG4gICAgdXIuYWN0aW9uKFwiZml0VW5pdHNcIiwgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMuZml0VW5pdHMsIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLnJlc3RvcmVVbml0cyk7XG4gICAgdXIuYWN0aW9uKFwiYWRkQmFja2dyb3VuZEltYWdlXCIsIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLmFkZEJhY2tncm91bmRJbWFnZSwgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMucmVtb3ZlQmFja2dyb3VuZEltYWdlKTtcbiAgICB1ci5hY3Rpb24oXCJyZW1vdmVCYWNrZ3JvdW5kSW1hZ2VcIiwgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMucmVtb3ZlQmFja2dyb3VuZEltYWdlLCB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5hZGRCYWNrZ3JvdW5kSW1hZ2UpO1xuICAgIHVyLmFjdGlvbihcInVwZGF0ZUJhY2tncm91bmRJbWFnZVwiLCB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy51cGRhdGVCYWNrZ3JvdW5kSW1hZ2UsIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLnVwZGF0ZUJhY2tncm91bmRJbWFnZSk7XG4gICAgdXIuYWN0aW9uKFwiY2hhbmdlQmFja2dyb3VuZEltYWdlXCIsIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLmNoYW5nZUJhY2tncm91bmRJbWFnZSwgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMuY2hhbmdlQmFja2dyb3VuZEltYWdlKTtcbiAgICB1ci5hY3Rpb24oXCJ1cGRhdGVJbmZvYm94U3R5bGVcIiwgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMudXBkYXRlSW5mb2JveFN0eWxlLCB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy51cGRhdGVJbmZvYm94U3R5bGUpO1xuICAgIHVyLmFjdGlvbihcInVwZGF0ZUluZm9ib3hPYmpcIiwgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMudXBkYXRlSW5mb2JveE9iaiwgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMudXBkYXRlSW5mb2JveE9iaik7XG5cbiAgICAvLyByZWdpc3RlciBlYXN5IGNyZWF0aW9uIGFjdGlvbnNcbiAgICB1ci5hY3Rpb24oXCJjcmVhdGVUZW1wbGF0ZVJlYWN0aW9uXCIsIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLmNyZWF0ZVRlbXBsYXRlUmVhY3Rpb24sIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLmRlbGV0ZUVsZXNTaW1wbGUpO1xuICAgIHVyLmFjdGlvbihcImNyZWF0ZUFjdGl2YXRpb25SZWFjdGlvblwiLCB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5jcmVhdGVBY3RpdmF0aW9uUmVhY3Rpb24sIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLmRlbGV0ZUVsZXNTaW1wbGUpO1xuICAgIHVyLmFjdGlvbihcImNyZWF0ZU1ldGFib2xpY0NhdGFseXRpY0FjdGl2aXR5XCIsIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLmNyZWF0ZU1ldGFib2xpY0NhdGFseXRpY0FjdGl2aXR5LCB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5kZWxldGVFbGVzU2ltcGxlKTtcbiAgICB1ci5hY3Rpb24oXCJjcmVhdGVNZXRhYm9saWNSZWFjdGlvblwiLCB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5jcmVhdGVNZXRhYm9saWNSZWFjdGlvbiwgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMuZGVsZXRlRWxlc1NpbXBsZSk7XG4gICAgdXIuYWN0aW9uKFwiY3JlYXRlQ29udmVyc2lvblwiLCB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5jcmVhdGVDb252ZXJzaW9uLCB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5kZWxldGVFbGVzU2ltcGxlKTtcbiAgICB1ci5hY3Rpb24oXCJjcmVhdGVNdWx0aW1lcml6YXRpb25cIiwgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMuY3JlYXRlTXVsdGltZXJpemF0aW9uLCB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5kZWxldGVFbGVzU2ltcGxlKTtcbiAgICB1ci5hY3Rpb24oXCJjcmVhdGVDb21wbGV4UHJvdGVpbkZvcm1hdGlvblwiLCB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5jcmVhdGVDb21wbGV4UHJvdGVpbkZvcm1hdGlvbiwgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMuZGVsZXRlRWxlc1NpbXBsZSk7XG4gICAgdXIuYWN0aW9uKFwiY3JlYXRlRGVncmFkYXRpb25cIiwgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMuY3JlYXRlRGVncmFkYXRpb24sIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLmRlbGV0ZUVsZXNTaW1wbGUpO1xuICAgIHVyLmFjdGlvbihcImNyZWF0ZVRyYW5zY3JpcHRpb25cIiwgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMuY3JlYXRlVHJhbnNjcmlwdGlvbiwgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMuZGVsZXRlRWxlc1NpbXBsZSk7XG4gICAgdXIuYWN0aW9uKFwiY3JlYXRlVHJhbnNsYXRpb25cIiwgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMuY3JlYXRlVHJhbnNsYXRpb24sIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLmRlbGV0ZUVsZXNTaW1wbGUpO1xuICAgIHVyLmFjdGlvbihcImNyZWF0ZVRyYW5zY3JpcHRpb25SZWFjdGlvblwiLCB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5jcmVhdGVUcmFuc2NyaXB0aW9uUmVhY3Rpb24sIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLmRlbGV0ZUVsZXNTaW1wbGUpO1xuICAgIHVyLmFjdGlvbihcImNyZWF0ZVRyYW5zbGF0aW9uUmVhY3Rpb25cIiwgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMuY3JlYXRlVHJhbnNsYXRpb25SZWFjdGlvbiwgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMuZGVsZXRlRWxlc1NpbXBsZSk7XG4gICAgdXIuYWN0aW9uKFwic2V0RGVmYXVsdFByb3BlcnR5XCIsIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLnNldERlZmF1bHRQcm9wZXJ0eSwgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMuc2V0RGVmYXVsdFByb3BlcnR5KTtcbiAgICB1ci5hY3Rpb24oXCJjb252ZXJ0SW50b1JldmVyc2libGVSZWFjdGlvblwiLCB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5jb252ZXJ0SW50b1JldmVyc2libGVSZWFjdGlvbiwgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMuY29udmVydEludG9SZXZlcnNpYmxlUmVhY3Rpb24pO1xuXG4gICAgdXIuYWN0aW9uKFwibW92ZUVkZ2VcIiwgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMubW92ZUVkZ2UsIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLm1vdmVFZGdlKTtcbiAgICB1ci5hY3Rpb24oXCJmaXhFcnJvclwiLCB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5maXhFcnJvcix1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy51bmZpeEVycm9yKTtcbiAgICB1ci5hY3Rpb24oXCJjbG9uZUhpZ2hEZWdyZWVOb2RlXCIsIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLmNsb25lSGlnaERlZ3JlZU5vZGUsdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMudW5DbG9uZUhpZ2hEZWdyZWVOb2RlKTtcblxuICAgIHVyLmFjdGlvbihcImNoYW5nZU1hcFR5cGVcIiwgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMuY2hhbmdlTWFwVHlwZSx1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5jaGFuZ2VNYXBUeXBlKTtcbiAgICB1ci5hY3Rpb24oXCJzZXRDb21wb3VuZFBhZGRpbmdcIiwgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMuc2V0Q29tcG91bmRQYWRkaW5nLCB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5zZXRDb21wb3VuZFBhZGRpbmcpO1xuXG4gIH07XG5cbiAgcmV0dXJuIHJlZ2lzdGVyVW5kb1JlZG9BY3Rpb25zO1xufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/utilities/register-undo-redo-actions-factory.js\n");

/***/ }),

/***/ "./src/utilities/sbgnviz-instance-utilities-factory.js":
/*!*************************************************************!*\
  !*** ./src/utilities/sbgnviz-instance-utilities-factory.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var libs = __webpack_require__(/*! ./lib-utilities */ \"./src/utilities/lib-utilities.js\").getLibs();\n\nmodule.exports = function () {\n  var instance;\n\n  function sbgnvizInstanceUtilities(options) {\n    instance = libs.sbgnviz(options);\n    return instance;\n  }\n\n  sbgnvizInstanceUtilities.getInstance = function () {\n    return instance;\n  };\n\n  sbgnvizInstanceUtilities.getCy = function () {\n    return this.getInstance().getCy();\n  };\n\n  return sbgnvizInstanceUtilities;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jaGlzZS8uL3NyYy91dGlsaXRpZXMvc2JnbnZpei1pbnN0YW5jZS11dGlsaXRpZXMtZmFjdG9yeS5qcz8zM2M4Il0sIm5hbWVzIjpbImxpYnMiLCJyZXF1aXJlIiwibW9kdWxlIiwiZXhwb3J0cyIsImluc3RhbmNlIiwic2JnbnZpekluc3RhbmNlVXRpbGl0aWVzIiwib3B0aW9ucyIsInNiZ252aXoiLCJnZXRJbnN0YW5jZSIsImdldEN5Il0sIm1hcHBpbmdzIjoiQUFBQSxJQUFJQSxJQUFJLEdBQUdDLHNGQUFBLEVBQVg7O0FBRUFDLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQixZQUFZO0FBRTNCLE1BQUlDLFFBQUo7O0FBRUEsV0FBU0Msd0JBQVQsQ0FBbUNDLE9BQW5DLEVBQTRDO0FBRTFDRixZQUFRLEdBQUdKLElBQUksQ0FBQ08sT0FBTCxDQUFhRCxPQUFiLENBQVg7QUFFQSxXQUFPRixRQUFQO0FBQ0Q7O0FBRURDLDBCQUF3QixDQUFDRyxXQUF6QixHQUF1QyxZQUFZO0FBQ2pELFdBQU9KLFFBQVA7QUFDRCxHQUZEOztBQUlBQywwQkFBd0IsQ0FBQ0ksS0FBekIsR0FBaUMsWUFBWTtBQUMzQyxXQUFPLEtBQUtELFdBQUwsR0FBbUJDLEtBQW5CLEVBQVA7QUFDRCxHQUZEOztBQUlBLFNBQU9KLHdCQUFQO0FBQ0QsQ0FwQkQiLCJmaWxlIjoiLi9zcmMvdXRpbGl0aWVzL3NiZ252aXotaW5zdGFuY2UtdXRpbGl0aWVzLWZhY3RvcnkuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgbGlicyA9IHJlcXVpcmUoJy4vbGliLXV0aWxpdGllcycpLmdldExpYnMoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIGluc3RhbmNlO1xuXG4gIGZ1bmN0aW9uIHNiZ252aXpJbnN0YW5jZVV0aWxpdGllcyAob3B0aW9ucykge1xuXG4gICAgaW5zdGFuY2UgPSBsaWJzLnNiZ252aXoob3B0aW9ucyk7XG5cbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH1cblxuICBzYmdudml6SW5zdGFuY2VVdGlsaXRpZXMuZ2V0SW5zdGFuY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9XG5cbiAgc2JnbnZpekluc3RhbmNlVXRpbGl0aWVzLmdldEN5ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmdldEluc3RhbmNlKCkuZ2V0Q3koKTtcbiAgfVxuXG4gIHJldHVybiBzYmdudml6SW5zdGFuY2VVdGlsaXRpZXM7XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/utilities/sbgnviz-instance-utilities-factory.js\n");

/***/ }),

/***/ "./src/utilities/topology-grouping-factory.js":
/*!****************************************************!*\
  !*** ./src/utilities/topology-grouping-factory.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var isEqual = __webpack_require__(/*! lodash.isequal */ \"./node_modules/lodash.isequal/index.js\");\n\nmodule.exports = function () {\n  var cy, elementUtilities;\n  var groupCompoundType, metaEdgeIdentifier, lockGraphTopology, shouldApply;\n  var DEFAULT_GROUP_COMPOUND_TYPE = 'topology group';\n  var EDGE_STYLE_NAMES = ['line-color', 'width'];\n\n  function topologyGrouping(param, props) {\n    cy = param.sbgnvizInstanceUtilities.getCy();\n    elementUtilities = param.elementUtilities;\n    groupCompoundType = props.groupCompoundType || DEFAULT_GROUP_COMPOUND_TYPE;\n    metaEdgeIdentifier = props.metaEdgeIdentifier;\n    lockGraphTopology = props.lockGraphTopology;\n    shouldApply = props.shouldApply || true;\n    topologyGrouping.applied = false;\n    initMetaStyleMap();\n  }\n\n  topologyGrouping.apply = function () {\n    if (topologyGrouping.applied || !evalOpt(shouldApply)) {\n      return;\n    }\n\n    var list = cy.nodes().map(function (node) {\n      return [node];\n    }); // determine node groups by their topology\n\n    var groups = getNodeGroups(list); // apply grouping in cy level\n\n    var metaEdges = topologyGrouping.getMetaEdges();\n    var compounds = topologyGrouping.getGroupCompounds();\n    applyGrouping(groups, metaEdges, compounds);\n    topologyGrouping.applied = true;\n\n    if (lockGraphTopology) {\n      elementUtilities.lockGraphTopology();\n    }\n\n    return groups;\n  };\n\n  topologyGrouping.unapply = function () {\n    if (!topologyGrouping.applied) {\n      return;\n    }\n\n    var metaEdges = topologyGrouping.getMetaEdges();\n    metaEdges.forEach(function (edge) {\n      var toRestore = edge.data('tg-to-restore');\n      edge.remove();\n      toRestore.restore();\n      EDGE_STYLE_NAMES.forEach(function (name) {\n        var oldVal = topologyGrouping.metaStyleMap[name][edge.id()];\n        var newVal = edge.data(name);\n\n        if (oldVal !== newVal) {\n          toRestore.data(name, newVal);\n        }\n      });\n    });\n    initMetaStyleMap();\n    var parents = topologyGrouping.getGroupCompounds();\n    elementUtilities.changeParent(parents.children(), null);\n    parents.remove();\n    topologyGrouping.applied = false;\n\n    if (lockGraphTopology) {\n      elementUtilities.unlockGraphTopology();\n    }\n  };\n\n  topologyGrouping.getMetaEdges = function () {\n    var metaEdges = cy.edges('[' + metaEdgeIdentifier + ']');\n    return metaEdges;\n  };\n\n  topologyGrouping.getGroupCompounds = function () {\n    var className = groupCompoundType;\n    return cy.nodes('[class=\"' + className + '\"]');\n  };\n\n  topologyGrouping.clearAppliedFlag = function () {\n    topologyGrouping.applied = false;\n  };\n\n  topologyGrouping.setAppliedFlag = function (applied) {\n    topologyGrouping.applied = applied;\n  };\n\n  topologyGrouping.toggleAppliedFlag = function () {\n    topologyGrouping.applied = !topologyGrouping.applied;\n  };\n\n  function initMetaStyleMap() {\n    topologyGrouping.metaStyleMap = {};\n    EDGE_STYLE_NAMES.forEach(function (name) {\n      topologyGrouping.metaStyleMap[name] = {};\n    });\n  }\n\n  function evalOpt(opt) {\n    if (typeof opt === 'function') {\n      return opt();\n    }\n\n    return opt;\n  }\n\n  function getNodeGroups(list) {\n    if (list.length <= 1) {\n      return list;\n    }\n\n    var halves = getHalves(list);\n    var firstPart = getNodeGroups(halves[0]);\n    var secondPart = getNodeGroups(halves[1]); // merge the halves\n\n    var groups = mergeGroups(firstPart, secondPart);\n    return groups;\n  }\n\n  function getParentOrSelf(node) {\n    var parent = node.parent();\n    return parent.size() > 0 ? parent : node;\n  }\n\n  function calcGroupingKey(edge) {\n    var srcId = getParentOrSelf(edge.source()).id();\n    var tgtId = getParentOrSelf(edge.target()).id();\n    var edgeType = getEdgeType(edge);\n    return [edgeType, srcId, tgtId].join('-');\n  }\n\n  function addToMapChain(map, key, val) {\n    if (!map[key]) {\n      map[key] = cy.collection();\n    }\n\n    map[key] = map[key].add(val);\n  }\n\n  function applyGrouping(groups, metaEdges, groupCompounds) {\n    var compounds;\n\n    if (groupCompounds.length > 0) {\n      compounds = groupCompounds;\n    } else {\n      groups.forEach(function (group) {\n        createGroupCompound(group);\n      });\n      compounds = topologyGrouping.getGroupCompounds();\n    }\n\n    var childrenEdges = compounds.children().connectedEdges();\n    var edgesMap = [];\n    childrenEdges.forEach(function (edge) {\n      var key = calcGroupingKey(edge);\n      addToMapChain(edgesMap, key, edge);\n      edge.remove();\n    });\n\n    if (metaEdges.length > 0) {\n      Object.keys(edgesMap).forEach(function (key) {\n        var edges = edgesMap[key];\n        var temp = edges[0];\n        var metaEdge = metaEdges.filter(function (edge) {\n          return edge.source().id() === getParentOrSelf(temp.source()).id() && edge.target().id() === getParentOrSelf(temp.target()).id();\n        })[0];\n        metaEdge.data('tg-to-restore', edges);\n        edges.remove();\n      });\n    } else {\n      Object.keys(edgesMap).forEach(function (key) {\n        createMetaEdgeFor(edgesMap[key]);\n      });\n    }\n  }\n\n  function createGroupCompound(group) {\n    if (group.length < 2) {\n      return;\n    }\n\n    var collection = cy.collection();\n    group.forEach(function (node) {\n      collection = collection.add(node);\n    });\n    elementUtilities.createCompoundForGivenNodes(collection, groupCompoundType);\n  }\n\n  function createMetaEdgeFor(edges) {\n    var srcId = getParentOrSelf(edges.source()).id();\n    var tgtId = getParentOrSelf(edges.target()).id();\n    var type = edges.data('class');\n    cy.remove(edges);\n    var metaEdge = elementUtilities.addEdge(srcId, tgtId, type);\n    metaEdge.data('tg-to-restore', edges);\n    metaEdge.data(metaEdgeIdentifier, true);\n    EDGE_STYLE_NAMES.forEach(function (styleName) {\n      edges.forEach(function (edge) {\n        topologyGrouping.metaStyleMap[styleName][edge.id()] = edge.data(styleName);\n      });\n      var commonVal = elementUtilities.getCommonProperty(edges, styleName, 'data');\n\n      if (commonVal) {\n        metaEdge.data(styleName, commonVal);\n      }\n    });\n    return metaEdge;\n  }\n\n  function mergeGroups(groups1, groups2) {\n    // notMergedGrs will include members of groups1 that are not merged\n    // mergedGrs will include the merged members from 2 groups\n    var notMergedGrs = [],\n        mergedGrs = [];\n    groups1.forEach(function (gr1) {\n      var merged = false;\n      mergedGrs.concat(groups2).forEach(function (gr2, index2) {\n        // if groups should be merged merge them, remove gr2 from where it\n        // comes from and push the merge result to mergedGrs\n        if (shouldMerge(gr1, gr2)) {\n          var mergedGr = gr1.concat(gr2);\n\n          if (index2 >= mergedGrs.length) {\n            removeAt(groups2, index2 - mergedGrs.length);\n          } else {\n            removeAt(mergedGrs, index2);\n          } // mark as merged and break the loop\n\n\n          mergedGrs.push(mergedGr);\n          merged = true;\n          return;\n        }\n      }); // if gr1 is not merged push it to notMergedGrs\n\n      if (!merged) {\n        notMergedGrs.push(gr1);\n      }\n    }); // the groups that comes from groups2 but not merged are still included\n    // in groups2 add them to the result together with mergedGrs and notMergedGrs\n\n    return notMergedGrs.concat(mergedGrs, groups2);\n  }\n\n  function shouldMerge(group1, group2) {\n    // using first elements is enough to decide whether to merge\n    var node1 = group1[0];\n    var node2 = group2[0];\n\n    if (node1.edges().length !== node2.edges().length) {\n      return false;\n    }\n\n    var getUndirectedEdges = function getUndirectedEdges(node) {\n      var edges = node.connectedEdges().filter(isUndirectedEdge);\n      return edges;\n    }; // undirected edges of node1 and node2 respectively\n\n\n    var undir1 = getUndirectedEdges(node1);\n    var undir2 = getUndirectedEdges(node2);\n    var in1 = node1.incomers().edges().not(undir1);\n    var in2 = node2.incomers().edges().not(undir2);\n    var out1 = node1.outgoers().edges().not(undir1);\n    var out2 = node2.outgoers().edges().not(undir2);\n    return compareEdgeGroup(in1, in2, node1, node2) && compareEdgeGroup(out1, out2, node1, node2) && compareEdgeGroup(undir1, undir2, node1, node2);\n  } // decide if 2 edge groups contains set of edges with similar content (type,\n  // source,target) relative to their nodes where gr1 are edges of node1 and gr2 are edges of\n  // node2\n\n\n  function compareEdgeGroup(gr1, gr2, node1, node2) {\n    var id1 = node1.id();\n    var id2 = node2.id();\n    var map1 = fillIdToTypeSetMap(gr1, node1);\n    var map2 = fillIdToTypeSetMap(gr2, node2);\n\n    if (Object.keys(map1).length !== Object.keys(map2).length) {\n      return;\n    }\n\n    var failed = false;\n    Object.keys(map1).forEach(function (key) {\n      // if already failed just return\n      if (failed) {\n        return;\n      } // if key is id2 use id1 instead because comparison is relative to nodes\n\n\n      var otherKey = key == id2 ? id1 : key; // check if the sets have the same content\n      // if check fails return false\n\n      if (!isEqual(map1[key], map2[otherKey])) {\n        failed = true;\n      }\n    }); // if check passes for each key return true\n\n    return !failed;\n  }\n\n  function fillIdToTypeSetMap(edgeGroup, node) {\n    var map = {};\n    var nodeId = node.id();\n    edgeGroup.forEach(function (edge) {\n      var srcId = edge.data('source');\n      var tgtId = edge.data('target');\n      var edgeId = edge.id();\n      var otherEnd = nodeId === tgtId ? srcId : tgtId;\n\n      function addToRelatedSet(sideStr, value) {\n        if (!map[sideStr]) {\n          map[sideStr] = new Set();\n        }\n\n        map[sideStr].add(value);\n      }\n\n      var edgeType = getEdgeType(edge);\n      addToRelatedSet(otherEnd, edgeType);\n    });\n    return map;\n  }\n\n  function getEdgeType(edge) {\n    return edge.data('class');\n  }\n\n  function isUndirectedEdge(edge) {\n    return elementUtilities.isUndirectedEdge(edge);\n  } // get halves of a list. It is assumed that list size is at least 2.\n\n\n  function getHalves(list) {\n    var s = list.length;\n    var halfIndex = Math.floor(s / 2);\n    var firstHalf = list.slice(0, halfIndex);\n    var secondHalf = list.slice(halfIndex, s);\n    return [firstHalf, secondHalf];\n  }\n\n  function removeAt(arr, index) {\n    arr.splice(index, 1);\n  }\n\n  return topologyGrouping;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jaGlzZS8uL3NyYy91dGlsaXRpZXMvdG9wb2xvZ3ktZ3JvdXBpbmctZmFjdG9yeS5qcz85YzEyIl0sIm5hbWVzIjpbImlzRXF1YWwiLCJyZXF1aXJlIiwibW9kdWxlIiwiZXhwb3J0cyIsImN5IiwiZWxlbWVudFV0aWxpdGllcyIsImdyb3VwQ29tcG91bmRUeXBlIiwibWV0YUVkZ2VJZGVudGlmaWVyIiwibG9ja0dyYXBoVG9wb2xvZ3kiLCJzaG91bGRBcHBseSIsIkRFRkFVTFRfR1JPVVBfQ09NUE9VTkRfVFlQRSIsIkVER0VfU1RZTEVfTkFNRVMiLCJ0b3BvbG9neUdyb3VwaW5nIiwicGFyYW0iLCJwcm9wcyIsInNiZ252aXpJbnN0YW5jZVV0aWxpdGllcyIsImdldEN5IiwiYXBwbGllZCIsImluaXRNZXRhU3R5bGVNYXAiLCJhcHBseSIsImV2YWxPcHQiLCJsaXN0Iiwibm9kZXMiLCJtYXAiLCJub2RlIiwiZ3JvdXBzIiwiZ2V0Tm9kZUdyb3VwcyIsIm1ldGFFZGdlcyIsImdldE1ldGFFZGdlcyIsImNvbXBvdW5kcyIsImdldEdyb3VwQ29tcG91bmRzIiwiYXBwbHlHcm91cGluZyIsInVuYXBwbHkiLCJmb3JFYWNoIiwiZWRnZSIsInRvUmVzdG9yZSIsImRhdGEiLCJyZW1vdmUiLCJyZXN0b3JlIiwibmFtZSIsIm9sZFZhbCIsIm1ldGFTdHlsZU1hcCIsImlkIiwibmV3VmFsIiwicGFyZW50cyIsImNoYW5nZVBhcmVudCIsImNoaWxkcmVuIiwidW5sb2NrR3JhcGhUb3BvbG9neSIsImVkZ2VzIiwiY2xhc3NOYW1lIiwiY2xlYXJBcHBsaWVkRmxhZyIsInNldEFwcGxpZWRGbGFnIiwidG9nZ2xlQXBwbGllZEZsYWciLCJvcHQiLCJsZW5ndGgiLCJoYWx2ZXMiLCJnZXRIYWx2ZXMiLCJmaXJzdFBhcnQiLCJzZWNvbmRQYXJ0IiwibWVyZ2VHcm91cHMiLCJnZXRQYXJlbnRPclNlbGYiLCJwYXJlbnQiLCJzaXplIiwiY2FsY0dyb3VwaW5nS2V5Iiwic3JjSWQiLCJzb3VyY2UiLCJ0Z3RJZCIsInRhcmdldCIsImVkZ2VUeXBlIiwiZ2V0RWRnZVR5cGUiLCJqb2luIiwiYWRkVG9NYXBDaGFpbiIsImtleSIsInZhbCIsImNvbGxlY3Rpb24iLCJhZGQiLCJncm91cENvbXBvdW5kcyIsImdyb3VwIiwiY3JlYXRlR3JvdXBDb21wb3VuZCIsImNoaWxkcmVuRWRnZXMiLCJjb25uZWN0ZWRFZGdlcyIsImVkZ2VzTWFwIiwiT2JqZWN0Iiwia2V5cyIsInRlbXAiLCJtZXRhRWRnZSIsImZpbHRlciIsImNyZWF0ZU1ldGFFZGdlRm9yIiwiY3JlYXRlQ29tcG91bmRGb3JHaXZlbk5vZGVzIiwidHlwZSIsImFkZEVkZ2UiLCJzdHlsZU5hbWUiLCJjb21tb25WYWwiLCJnZXRDb21tb25Qcm9wZXJ0eSIsImdyb3VwczEiLCJncm91cHMyIiwibm90TWVyZ2VkR3JzIiwibWVyZ2VkR3JzIiwiZ3IxIiwibWVyZ2VkIiwiY29uY2F0IiwiZ3IyIiwiaW5kZXgyIiwic2hvdWxkTWVyZ2UiLCJtZXJnZWRHciIsInJlbW92ZUF0IiwicHVzaCIsImdyb3VwMSIsImdyb3VwMiIsIm5vZGUxIiwibm9kZTIiLCJnZXRVbmRpcmVjdGVkRWRnZXMiLCJpc1VuZGlyZWN0ZWRFZGdlIiwidW5kaXIxIiwidW5kaXIyIiwiaW4xIiwiaW5jb21lcnMiLCJub3QiLCJpbjIiLCJvdXQxIiwib3V0Z29lcnMiLCJvdXQyIiwiY29tcGFyZUVkZ2VHcm91cCIsImlkMSIsImlkMiIsIm1hcDEiLCJmaWxsSWRUb1R5cGVTZXRNYXAiLCJtYXAyIiwiZmFpbGVkIiwib3RoZXJLZXkiLCJlZGdlR3JvdXAiLCJub2RlSWQiLCJlZGdlSWQiLCJvdGhlckVuZCIsImFkZFRvUmVsYXRlZFNldCIsInNpZGVTdHIiLCJ2YWx1ZSIsIlNldCIsInMiLCJoYWxmSW5kZXgiLCJNYXRoIiwiZmxvb3IiLCJmaXJzdEhhbGYiLCJzbGljZSIsInNlY29uZEhhbGYiLCJhcnIiLCJpbmRleCIsInNwbGljZSJdLCJtYXBw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QjZELEtBQXBCO0FBQ0Q7O0FBRUQsVUFBSXBFLFFBQVEsR0FBR0MsV0FBVyxDQUFFbkMsSUFBRixDQUExQjtBQUVBb0cscUJBQWUsQ0FBRUQsUUFBRixFQUFZakUsUUFBWixDQUFmO0FBQ0QsS0FsQkQ7QUFvQkEsV0FBTzdDLEdBQVA7QUFDRDs7QUFFRCxXQUFTOEMsV0FBVCxDQUFzQm5DLElBQXRCLEVBQTZCO0FBQzNCLFdBQU9BLElBQUksQ0FBQ0UsSUFBTCxDQUFXLE9BQVgsQ0FBUDtBQUNEOztBQUVELFdBQVM0RSxnQkFBVCxDQUEyQjlFLElBQTNCLEVBQWtDO0FBQ2hDLFdBQU83QixnQkFBZ0IsQ0FBQzJHLGdCQUFqQixDQUFtQzlFLElBQW5DLENBQVA7QUFDRCxHQWpYeUIsQ0FtWDFCOzs7QUFDQSxXQUFTc0IsU0FBVCxDQUFvQm5DLElBQXBCLEVBQTJCO0FBQ3pCLFFBQUlxSCxDQUFDLEdBQUdySCxJQUFJLENBQUNpQyxNQUFiO0FBQ0EsUUFBSXFGLFNBQVMsR0FBR0MsSUFBSSxDQUFDQyxLQUFMLENBQVlILENBQUMsR0FBRyxDQUFoQixDQUFoQjtBQUNBLFFBQUlJLFNBQVMsR0FBR3pILElBQUksQ0FBQzBILEtBQUwsQ0FBWSxDQUFaLEVBQWVKLFNBQWYsQ0FBaEI7QUFDQSxRQUFJSyxVQUFVLEdBQUczSCxJQUFJLENBQUMwSCxLQUFMLENBQVlKLFNBQVosRUFBdUJELENBQXZCLENBQWpCO0FBRUEsV0FBTyxDQUFFSSxTQUFGLEVBQWFFLFVBQWIsQ0FBUDtBQUNEOztBQUVELFdBQVN2QyxRQUFULENBQW1Cd0MsR0FBbkIsRUFBd0JDLEtBQXhCLEVBQWdDO0FBQzlCRCxPQUFHLENBQUNFLE1BQUosQ0FBWUQsS0FBWixFQUFtQixDQUFuQjtBQUNEOztBQUVELFNBQU90SSxnQkFBUDtBQUNELENBbFlEIiwiZmlsZSI6Ii4vc3JjL3V0aWxpdGllcy90b3BvbG9neS1ncm91cGluZy1mYWN0b3J5LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGlzRXF1YWwgPSByZXF1aXJlKCdsb2Rhc2guaXNlcXVhbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuXG4gIHZhciBjeSwgZWxlbWVudFV0aWxpdGllcztcbiAgdmFyIGdyb3VwQ29tcG91bmRUeXBlLCBtZXRhRWRnZUlkZW50aWZpZXIsIGxvY2tHcmFwaFRvcG9sb2d5LCBzaG91bGRBcHBseTtcblxuICB2YXIgREVGQVVMVF9HUk9VUF9DT01QT1VORF9UWVBFID0gJ3RvcG9sb2d5IGdyb3VwJztcbiAgdmFyIEVER0VfU1RZTEVfTkFNRVMgPSBbICdsaW5lLWNvbG9yJywgJ3dpZHRoJyBdO1xuXG4gIGZ1bmN0aW9uIHRvcG9sb2d5R3JvdXBpbmcoIHBhcmFtLCBwcm9wcyApIHtcbiAgICBjeSA9IHBhcmFtLnNiZ252aXpJbnN0YW5jZVV0aWxpdGllcy5nZXRDeSgpXG4gICAgZWxlbWVudFV0aWxpdGllcyA9IHBhcmFtLmVsZW1lbnRVdGlsaXRpZXM7XG5cbiAgICBncm91cENvbXBvdW5kVHlwZSA9IHByb3BzLmdyb3VwQ29tcG91bmRUeXBlIHx8IERFRkFVTFRfR1JPVVBfQ09NUE9VTkRfVFlQRTtcbiAgICBtZXRhRWRnZUlkZW50aWZpZXIgPSBwcm9wcy5tZXRhRWRnZUlkZW50aWZpZXI7XG4gICAgbG9ja0dyYXBoVG9wb2xvZ3kgPSBwcm9wcy5sb2NrR3JhcGhUb3BvbG9neTtcbiAgICBzaG91bGRBcHBseSA9IHByb3BzLnNob3VsZEFwcGx5IHx8IHRydWU7XG5cbiAgICB0b3BvbG9neUdyb3VwaW5nLmFwcGxpZWQgPSBmYWxzZTtcbiAgICBpbml0TWV0YVN0eWxlTWFwKCk7XG4gIH1cblxuICB0b3BvbG9neUdyb3VwaW5nLmFwcGx5ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCB0b3BvbG9neUdyb3VwaW5nLmFwcGxpZWQgfHwgIWV2YWxPcHQoIHNob3VsZEFwcGx5ICkgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGxpc3QgPSBjeS5ub2RlcygpLm1hcCggZnVuY3Rpb24oIG5vZGUgKSB7XG4gICAgICByZXR1cm4gWyBub2RlIF07XG4gICAgfSApO1xuXG4gICAgLy8gZGV0ZXJtaW5lIG5vZGUgZ3JvdXBzIGJ5IHRoZWlyIHRvcG9sb2d5XG4gICAgdmFyIGdyb3VwcyA9IGdldE5vZGVHcm91cHMoIGxpc3QgKTtcbiAgICBcbiAgICAvLyBhcHBseSBncm91cGluZyBpbiBjeSBsZXZlbFxuICAgIHZhciBtZXRhRWRnZXMgPSB0b3BvbG9neUdyb3VwaW5nLmdldE1ldGFFZGdlcygpO1xuICAgIHZhciBjb21wb3VuZHMgPSB0b3BvbG9neUdyb3VwaW5nLmdldEdyb3VwQ29tcG91bmRzKCk7XG4gIFx0YXBwbHlHcm91cGluZyhncm91cHMsIG1ldGFFZGdlcywgY29tcG91bmRzKTtcblxuICAgIHRvcG9sb2d5R3JvdXBpbmcuYXBwbGllZCA9IHRydWU7XG5cbiAgICBpZiAoIGxvY2tHcmFwaFRvcG9sb2d5ICkge1xuICAgICAgZWxlbWVudFV0aWxpdGllcy5sb2NrR3JhcGhUb3BvbG9neSgpO1xuICAgIH1cblxuICBcdHJldHVybiBncm91cHM7XG4gIH07XG5cbiAgdG9wb2xvZ3lHcm91cGluZy51bmFwcGx5ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCAhdG9wb2xvZ3lHcm91cGluZy5hcHBsaWVkICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBtZXRhRWRnZXMgPSB0b3BvbG9neUdyb3VwaW5nLmdldE1ldGFFZGdlcygpO1xuICAgIG1ldGFFZGdlcy5mb3JFYWNoKCBmdW5jdGlvbiggZWRnZSApIHtcbiAgICAgIHZhciB0b1Jlc3RvcmUgPSBlZGdlLmRhdGEoJ3RnLXRvLXJlc3RvcmUnKTtcbiAgICAgIGVkZ2UucmVtb3ZlKCk7XG4gICAgICB0b1Jlc3RvcmUucmVzdG9yZSgpO1xuXG4gICAgICBFREdFX1NUWUxFX05BTUVTLmZvckVhY2goIGZ1bmN0aW9uKCBuYW1lICkge1xuICAgICAgICB2YXIgb2xkVmFsID0gdG9wb2xvZ3lHcm91cGluZy5tZXRhU3R5bGVNYXBbIG5hbWUgXVsgZWRnZS5pZCgpIF07XG4gICAgICAgIHZhciBuZXdWYWwgPSBlZGdlLmRhdGEoIG5hbWUgKTtcblxuICAgICAgICBpZiAoIG9sZFZhbCAhPT0gbmV3VmFsICkge1xuICAgICAgICAgIHRvUmVzdG9yZS5kYXRhKCBuYW1lLCBuZXdWYWwgKTtcbiAgICAgICAgfVxuICAgICAgfSApO1xuICAgIH0gKTtcblxuICAgIGluaXRNZXRhU3R5bGVNYXAoKTtcblxuICAgIHZhciBwYXJlbnRzID0gdG9wb2xvZ3lHcm91cGluZy5nZXRHcm91cENvbXBvdW5kcygpO1xuICAgIGVsZW1lbnRVdGlsaXRpZXMuY2hhbmdlUGFyZW50KCBwYXJlbnRzLmNoaWxkcmVuKCksIG51bGwgKTtcbiAgICBwYXJlbnRzLnJlbW92ZSgpO1xuXG4gICAgdG9wb2xvZ3lHcm91cGluZy5hcHBsaWVkID0gZmFsc2U7XG5cbiAgICBpZiAoIGxvY2tHcmFwaFRvcG9sb2d5ICkge1xuICAgICAgZWxlbWVudFV0aWxpdGllcy51bmxvY2tHcmFwaFRvcG9sb2d5KCk7XG4gICAgfVxuICB9O1xuXG4gIHRvcG9sb2d5R3JvdXBpbmcuZ2V0TWV0YUVkZ2VzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG1ldGFFZGdlcyA9IGN5LmVkZ2VzKCdbJyArIG1ldGFFZGdlSWRlbnRpZmllciArICddJyk7XG4gICAgcmV0dXJuIG1ldGFFZGdlcztcbiAgfTtcblxuICB0b3BvbG9neUdyb3VwaW5nLmdldEdyb3VwQ29tcG91bmRzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNsYXNzTmFtZSA9IGdyb3VwQ29tcG91bmRUeXBlO1xuICAgIHJldHVybiBjeS5ub2RlcygnW2NsYXNzPVwiJyArIGNsYXNzTmFtZSArICdcIl0nKTtcbiAgfTtcblxuICB0b3BvbG9neUdyb3VwaW5nLmNsZWFyQXBwbGllZEZsYWcgPSBmdW5jdGlvbigpIHtcbiAgICB0b3BvbG9neUdyb3VwaW5nLmFwcGxpZWQgPSBmYWxzZTtcbiAgfTtcblxuICB0b3BvbG9neUdyb3VwaW5nLnNldEFwcGxpZWRGbGFnID0gZnVuY3Rpb24oYXBwbGllZCkge1xuICAgIHRvcG9sb2d5R3JvdXBpbmcuYXBwbGllZCA9IGFwcGxpZWQ7XG4gIH07XG5cbiAgdG9wb2xvZ3lHcm91cGluZy50b2dnbGVBcHBsaWVkRmxhZyA9IGZ1bmN0aW9uKCkge1xuICAgIHRvcG9sb2d5R3JvdXBpbmcuYXBwbGllZCA9ICF0b3BvbG9neUdyb3VwaW5nLmFwcGxpZWQ7XG4gIH07XG5cbiAgZnVuY3Rpb24gaW5pdE1ldGFTdHlsZU1hcCgpIHtcbiAgICB0b3BvbG9neUdyb3VwaW5nLm1ldGFTdHlsZU1hcCA9IHt9O1xuICAgIEVER0VfU1RZTEVfTkFNRVMuZm9yRWFjaCggZnVuY3Rpb24oIG5hbWUgKSB7XG4gICAgICB0b3BvbG9neUdyb3VwaW5nLm1ldGFTdHlsZU1hcFsgbmFtZSBdID0ge307XG4gICAgfSApO1xuICB9XG5cbiAgZnVuY3Rpb24gZXZhbE9wdCggb3B0ICkge1xuICAgIGlmICggdHlwZW9mIG9wdCA9PT0gJ2Z1bmN0aW9uJyApIHtcbiAgICAgIHJldHVybiBvcHQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3B0O1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Tm9kZUdyb3VwcyggbGlzdCApIHtcbiAgICBpZiAoIGxpc3QubGVuZ3RoIDw9IDEgKSB7XG4gICAgICByZXR1cm4gbGlzdDtcbiAgICB9XG5cbiAgICB2YXIgaGFsdmVzID0gZ2V0SGFsdmVzKCBsaXN0ICk7XG4gICAgdmFyIGZpcnN0UGFydCA9IGdldE5vZGVHcm91cHMoIGhhbHZlc1sgMCBdICk7XG4gICAgdmFyIHNlY29uZFBhcnQgPSBnZXROb2RlR3JvdXBzKCBoYWx2ZXNbIDEgXSApO1xuICAgIC8vIG1lcmdlIHRoZSBoYWx2ZXNcblx0ICB2YXIgZ3JvdXBzID0gbWVyZ2VHcm91cHMoIGZpcnN0UGFydCwgc2Vjb25kUGFydCApO1xuXG4gICAgcmV0dXJuIGdyb3VwcztcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFBhcmVudE9yU2VsZiggbm9kZSApIHtcbiAgICB2YXIgcGFyZW50ID0gbm9kZS5wYXJlbnQoKTtcbiAgICByZXR1cm4gcGFyZW50LnNpemUoKSA+IDAgPyBwYXJlbnQgOiBub2RlO1xuICB9XG5cbiAgZnVuY3Rpb24gY2FsY0dyb3VwaW5nS2V5KCBlZGdlICkge1xuICAgIHZhciBzcmNJZCA9IGdldFBhcmVudE9yU2VsZiggZWRnZS5zb3VyY2UoKSApLmlkKCk7XG4gICAgdmFyIHRndElkID0gZ2V0UGFyZW50T3JTZWxmKCBlZGdlLnRhcmdldCgpICkuaWQoKTtcbiAgICB2YXIgZWRnZVR5cGUgPSBnZXRFZGdlVHlwZSggZWRnZSApO1xuXG4gICAgcmV0dXJuIFsgZWRnZVR5cGUsIHNyY0lkLCB0Z3RJZCBdLmpvaW4oICctJyApO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkVG9NYXBDaGFpbiggbWFwLCBrZXksIHZhbCApIHtcbiAgICBpZiAoICFtYXBbIGtleSBdICkge1xuICAgICAgbWFwWyBrZXkgXSA9IGN5LmNvbGxlY3Rpb24oKTtcbiAgICB9XG5cbiAgICBtYXBbIGtleSBdID0gbWFwWyBrZXkgXS5hZGQoIHZhbCApO1xuICB9XG5cbiAgZnVuY3Rpb24gYXBwbHlHcm91cGluZyhncm91cHMsIG1ldGFFZGdlcywgZ3JvdXBDb21wb3VuZHMpIHtcbiAgICB2YXIgY29tcG91bmRzO1xuXG4gICAgaWYgKGdyb3VwQ29tcG91bmRzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbXBvdW5kcyA9IGdyb3VwQ29tcG91bmRzO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGdyb3Vwcy5mb3JFYWNoKCBmdW5jdGlvbiggZ3JvdXAgKSB7XG4gICAgICAgIGNyZWF0ZUdyb3VwQ29tcG91bmQoIGdyb3VwICk7XG4gICAgICB9ICk7XG4gIFxuICAgICAgY29tcG91bmRzID0gdG9wb2xvZ3lHcm91cGluZy5nZXRHcm91cENvbXBvdW5kcygpO1xuICAgIH1cblxuICAgIHZhciBjaGlsZHJlbkVkZ2VzID0gY29tcG91bmRzLmNoaWxkcmVuKCkuY29ubmVjdGVkRWRnZXMoKTtcbiAgICB2YXIgZWRnZXNNYXAgPSBbXTtcblxuICAgIGNoaWxkcmVuRWRnZXMuZm9yRWFjaCggZnVuY3Rpb24oIGVkZ2UgKXtcbiAgICAgIHZhciBrZXkgPSBjYWxjR3JvdXBpbmdLZXkoIGVkZ2UgKTtcbiAgICAgIGFkZFRvTWFwQ2hhaW4oIGVkZ2VzTWFwLCBrZXksIGVkZ2UgKTtcbiAgICAgIGVkZ2UucmVtb3ZlKCk7XG4gICAgfSApO1xuXG4gICAgaWYgKG1ldGFFZGdlcy5sZW5ndGggPiAwKSB7XG4gICAgICBPYmplY3Qua2V5cyggZWRnZXNNYXAgKS5mb3JFYWNoKCBmdW5jdGlvbigga2V5ICkge1xuICAgICAgICB2YXIgZWRnZXMgPSBlZGdlc01hcFtrZXldO1xuICAgICAgICB2YXIgdGVtcCA9IGVkZ2VzWzBdO1xuICAgICAgICB2YXIgbWV0YUVkZ2UgPSBtZXRhRWRnZXMuZmlsdGVyKGVkZ2UgPT4ge1xuICAgICAgICAgIHJldHVybiBlZGdlLnNvdXJjZSgpLmlkKCkgPT09IGdldFBhcmVudE9yU2VsZiggdGVtcC5zb3VyY2UoKSApLmlkKCkgJiZcbiAgICAgICAgICAgICAgICAgIGVkZ2UudGFyZ2V0KCkuaWQoKSA9PT0gZ2V0UGFyZW50T3JTZWxmKCB0ZW1wLnRhcmdldCgpICkuaWQoKTtcbiAgICAgICAgfSlbMF07XG4gICAgICAgIG1ldGFFZGdlLmRhdGEoICd0Zy10by1yZXN0b3JlJywgZWRnZXMgKTtcbiAgICAgICAgZWRnZXMucmVtb3ZlKCk7XG4gICAgICB9ICk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgT2JqZWN0LmtleXMoIGVkZ2VzTWFwICkuZm9yRWFjaCggZnVuY3Rpb24oIGtleSApIHtcbiAgICAgICAgY3JlYXRlTWV0YUVkZ2VGb3IoIGVkZ2VzTWFwWyBrZXkgXSApO1xuICAgICAgfSApO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUdyb3VwQ29tcG91bmQoIGdyb3VwICkge1xuICAgIGlmICggZ3JvdXAubGVuZ3RoIDwgMiApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgY29sbGVjdGlvbiA9IGN5LmNvbGxlY3Rpb24oKTtcblxuICAgIGdyb3VwLmZvckVhY2goIGZ1bmN0aW9uKCBub2RlICkge1xuICAgICAgY29sbGVjdGlvbiA9IGNvbGxlY3Rpb24uYWRkKCBub2RlICk7XG4gICAgfSApO1xuXG4gICAgZWxlbWVudFV0aWxpdGllcy5jcmVhdGVDb21wb3VuZEZvckdpdmVuTm9kZXMoIGNvbGxlY3Rpb24sIGdyb3VwQ29tcG91bmRUeXBlICk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVNZXRhRWRnZUZvciggZWRnZXMgKSB7XG4gICAgdmFyIHNyY0lkID0gZ2V0UGFyZW50T3JTZWxmKCBlZGdlcy5zb3VyY2UoKSApLmlkKCk7XG4gICAgdmFyIHRndElkID0gZ2V0UGFyZW50T3JTZWxmKCBlZGdlcy50YXJnZXQoKSApLmlkKCk7XG4gICAgdmFyIHR5cGUgPSBlZGdlcy5kYXRhKCAnY2xhc3MnICk7XG4gICAgY3kucmVtb3ZlKCBlZGdlcyApO1xuXG4gICAgdmFyIG1ldGFFZGdlID0gZWxlbWVudFV0aWxpdGllcy5hZGRFZGdlKCBzcmNJZCwgdGd0SWQsIHR5cGUgKTtcbiAgICBtZXRhRWRnZS5kYXRhKCAndGctdG8tcmVzdG9yZScsIGVkZ2VzICk7XG4gICAgbWV0YUVkZ2UuZGF0YSggbWV0YUVkZ2VJZGVudGlmaWVyLCB0cnVlICk7XG5cbiAgICBFREdFX1NUWUxFX05BTUVTLmZvckVhY2goIGZ1bmN0aW9uKCBzdHlsZU5hbWUgKSB7XG4gICAgICBlZGdlcy5mb3JFYWNoKCBmdW5jdGlvbiggZWRnZSApIHtcbiAgICAgICAgdG9wb2xvZ3lHcm91cGluZy5tZXRhU3R5bGVNYXBbIHN0eWxlTmFtZSBdWyBlZGdlLmlkKCkgXSA9IGVkZ2UuZGF0YSggc3R5bGVOYW1lICk7XG4gICAgICB9ICk7XG5cbiAgICAgIHZhciBjb21tb25WYWwgPSBlbGVtZW50VXRpbGl0aWVzLmdldENvbW1vblByb3BlcnR5KGVkZ2VzLCBzdHlsZU5hbWUsICdkYXRhJyk7XG4gICAgICBpZiAoIGNvbW1vblZhbCApIHtcbiAgICAgICAgbWV0YUVkZ2UuZGF0YSggc3R5bGVOYW1lLCBjb21tb25WYWwgKTtcbiAgICAgIH1cbiAgICB9ICk7XG5cbiAgICByZXR1cm4gbWV0YUVkZ2U7XG4gIH1cblxuICBmdW5jdGlvbiBtZXJnZUdyb3VwcyggZ3JvdXBzMSwgZ3JvdXBzMiApIHtcbiAgICAvLyBub3RNZXJnZWRHcnMgd2lsbCBpbmNsdWRlIG1lbWJlcnMgb2YgZ3JvdXBzMSB0aGF0IGFyZSBub3QgbWVyZ2VkXG4gIFx0Ly8gbWVyZ2VkR3JzIHdpbGwgaW5jbHVkZSB0aGUgbWVyZ2VkIG1lbWJlcnMgZnJvbSAyIGdyb3Vwc1xuICBcdHZhciBub3RNZXJnZWRHcnMgPSBbXSwgbWVyZ2VkR3JzID0gW107XG5cbiAgICBncm91cHMxLmZvckVhY2goIGZ1bmN0aW9uKCBncjEgKSB7XG4gICAgICB2YXIgbWVyZ2VkID0gZmFsc2U7XG5cbiAgICAgIG1lcmdlZEdycy5jb25jYXQoIGdyb3VwczIgKS5mb3JFYWNoKCBmdW5jdGlvbiggZ3IyLCBpbmRleDIgKSB7XG4gICAgICAgIC8vIGlmIGdyb3VwcyBzaG91bGQgYmUgbWVyZ2VkIG1lcmdlIHRoZW0sIHJlbW92ZSBncjIgZnJvbSB3aGVyZSBpdFxuICAgICAgICAvLyBjb21lcyBmcm9tIGFuZCBwdXNoIHRoZSBtZXJnZSByZXN1bHQgdG8gbWVyZ2VkR3JzXG4gICAgICAgIGlmICggc2hvdWxkTWVyZ2UoIGdyMSwgZ3IyICkgKSB7XG4gICAgICAgICAgdmFyIG1lcmdlZEdyID0gZ3IxLmNvbmNhdCggZ3IyICk7XG5cbiAgICAgICAgICBpZiAoIGluZGV4MiA+PSBtZXJnZWRHcnMubGVuZ3RoICkge1xuICAgICAgICAgICAgcmVtb3ZlQXQoIGdyb3VwczIsIGluZGV4MiAtIG1lcmdlZEdycy5sZW5ndGggKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZW1vdmVBdCggbWVyZ2VkR3JzLCBpbmRleDIgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBtYXJrIGFzIG1lcmdlZCBhbmQgYnJlYWsgdGhlIGxvb3BcbiAgICAgICAgICBtZXJnZWRHcnMucHVzaCggbWVyZ2VkR3IgKTtcbiAgICAgICAgICBtZXJnZWQgPSB0cnVlO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSApO1xuXG4gICAgICAvLyBpZiBncjEgaXMgbm90IG1lcmdlZCBwdXNoIGl0IHRvIG5vdE1lcmdlZEdyc1xuICAgICAgaWYgKCAhbWVyZ2VkICkge1xuICAgICAgICBub3RNZXJnZWRHcnMucHVzaCggZ3IxICk7XG4gICAgICB9XG4gICAgfSApO1xuXG4gICAgLy8gdGhlIGdyb3VwcyB0aGF0IGNvbWVzIGZyb20gZ3JvdXBzMiBidXQgbm90IG1lcmdlZCBhcmUgc3RpbGwgaW5jbHVkZWRcblx0ICAvLyBpbiBncm91cHMyIGFkZCB0aGVtIHRvIHRoZSByZXN1bHQgdG9nZXRoZXIgd2l0aCBtZXJnZWRHcnMgYW5kIG5vdE1lcmdlZEdyc1xuICAgIHJldHVybiBub3RNZXJnZWRHcnMuY29uY2F0KCBtZXJnZWRHcnMsIGdyb3VwczIgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNob3VsZE1lcmdlKCBncm91cDEsIGdyb3VwMiApIHtcbiAgICAvLyB1c2luZyBmaXJzdCBlbGVtZW50cyBpcyBlbm91Z2ggdG8gZGVjaWRlIHdoZXRoZXIgdG8gbWVyZ2VcbiAgXHR2YXIgbm9kZTEgPSBncm91cDFbIDAgXTtcbiAgXHR2YXIgbm9kZTIgPSBncm91cDJbIDAgXTtcblxuICAgIGlmICggbm9kZTEuZWRnZXMoKS5sZW5ndGggIT09IG5vZGUyLmVkZ2VzKCkubGVuZ3RoICkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBnZXRVbmRpcmVjdGVkRWRnZXMgPSBmdW5jdGlvbiggbm9kZSApIHtcbiAgICAgIHZhciBlZGdlcyA9IG5vZGUuY29ubmVjdGVkRWRnZXMoKS5maWx0ZXIoIGlzVW5kaXJlY3RlZEVkZ2UgKTtcbiAgICAgIHJldHVybiBlZGdlcztcbiAgICB9O1xuICAgIC8vIHVuZGlyZWN0ZWQgZWRnZXMgb2Ygbm9kZTEgYW5kIG5vZGUyIHJlc3BlY3RpdmVseVxuICAgIHZhciB1bmRpcjEgPSBnZXRVbmRpcmVjdGVkRWRnZXMoIG5vZGUxICk7XG4gICAgdmFyIHVuZGlyMiA9IGdldFVuZGlyZWN0ZWRFZGdlcyggbm9kZTIgKTtcblxuICAgIHZhciBpbjEgPSBub2RlMS5pbmNvbWVycygpLmVkZ2VzKCkubm90KCB1bmRpcjEgKTtcbiAgICB2YXIgaW4yID0gbm9kZTIuaW5jb21lcnMoKS5lZGdlcygpLm5vdCggdW5kaXIyICk7XG5cbiAgICB2YXIgb3V0MSA9IG5vZGUxLm91dGdvZXJzKCkuZWRnZXMoKS5ub3QoIHVuZGlyMSApO1xuXHQgIHZhciBvdXQyID0gbm9kZTIub3V0Z29lcnMoKS5lZGdlcygpLm5vdCggdW5kaXIyICk7XG5cbiAgICByZXR1cm4gY29tcGFyZUVkZ2VHcm91cCggaW4xLCBpbjIsIG5vZGUxLCBub2RlMiApXG4gICAgICAgICAgICAmJiBjb21wYXJlRWRnZUdyb3VwKCBvdXQxLCBvdXQyLCBub2RlMSwgbm9kZTIgKVxuICAgICAgICAgICAgJiYgY29tcGFyZUVkZ2VHcm91cCggdW5kaXIxLCB1bmRpcjIsIG5vZGUxLCBub2RlMiApO1xuICB9XG5cbiAgLy8gZGVjaWRlIGlmIDIgZWRnZSBncm91cHMgY29udGFpbnMgc2V0IG9mIGVkZ2VzIHdpdGggc2ltaWxhciBjb250ZW50ICh0eXBlLFxuICAvLyBzb3VyY2UsdGFyZ2V0KSByZWxhdGl2ZSB0byB0aGVpciBub2RlcyB3aGVyZSBncjEgYXJlIGVkZ2VzIG9mIG5vZGUxIGFuZCBncjIgYXJlIGVkZ2VzIG9mXG4gIC8vIG5vZGUyXG4gIGZ1bmN0aW9uIGNvbXBhcmVFZGdlR3JvdXAoIGdyMSwgZ3IyLCBub2RlMSwgbm9kZTIgKSB7XG4gICAgdmFyIGlkMSA9IG5vZGUxLmlkKCk7XG4gICAgdmFyIGlkMiA9IG5vZGUyLmlkKCk7XG5cbiAgICB2YXIgbWFwMSA9IGZpbGxJZFRvVHlwZVNldE1hcCggZ3IxLCBub2RlMSApO1xuICAgIHZhciBtYXAyID0gZmlsbElkVG9UeXBlU2V0TWFwKCBncjIsIG5vZGUyICk7XG5cbiAgICBpZiAoIE9iamVjdC5rZXlzKCBtYXAxICkubGVuZ3RoICE9PSBPYmplY3Qua2V5cyggbWFwMiApLmxlbmd0aCApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZmFpbGVkID0gZmFsc2U7XG5cbiAgICBPYmplY3Qua2V5cyggbWFwMSApLmZvckVhY2goIGZ1bmN0aW9uKCBrZXkgKSB7XG4gICAgICAvLyBpZiBhbHJlYWR5IGZhaWxlZCBqdXN0IHJldHVyblxuICAgICAgaWYgKCBmYWlsZWQgKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gaWYga2V5IGlzIGlkMiB1c2UgaWQxIGluc3RlYWQgYmVjYXVzZSBjb21wYXJpc29uIGlzIHJlbGF0aXZlIHRvIG5vZGVzXG4gICAgICB2YXIgb3RoZXJLZXkgPSAoIGtleSA9PSBpZDIgKSA/IGlkMSA6IGtleTtcblxuICAgICAgLy8gY2hlY2sgaWYgdGhlIHNldHMgaGF2ZSB0aGUgc2FtZSBjb250ZW50XG4gIFx0XHQvLyBpZiBjaGVjayBmYWlscyByZXR1cm4gZmFsc2VcbiAgICAgIGlmICggIWlzRXF1YWwoIG1hcDFbIGtleSBdLCBtYXAyWyBvdGhlcktleSBdICkgKSB7XG4gICAgICAgIGZhaWxlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSApO1xuXG4gICAgLy8gaWYgY2hlY2sgcGFzc2VzIGZvciBlYWNoIGtleSByZXR1cm4gdHJ1ZVxuICAgIHJldHVybiAhZmFpbGVkO1xuICB9XG5cbiAgZnVuY3Rpb24gZmlsbElkVG9UeXBlU2V0TWFwKCBlZGdlR3JvdXAsIG5vZGUgKSB7XG4gICAgdmFyIG1hcCA9IHt9O1xuICAgIHZhciBub2RlSWQgPSBub2RlLmlkKCk7XG5cbiAgICBlZGdlR3JvdXAuZm9yRWFjaCggZnVuY3Rpb24oIGVkZ2UgKSB7XG4gICAgICB2YXIgc3JjSWQgPSBlZGdlLmRhdGEoJ3NvdXJjZScpO1xuICAgICAgdmFyIHRndElkID0gZWRnZS5kYXRhKCd0YXJnZXQnKTtcbiAgICAgIHZhciBlZGdlSWQgPSBlZGdlLmlkKCk7XG5cbiAgICAgIHZhciBvdGhlckVuZCA9ICggbm9kZUlkID09PSB0Z3RJZCApID8gc3JjSWQgOiB0Z3RJZDtcblxuICAgICAgZnVuY3Rpb24gYWRkVG9SZWxhdGVkU2V0KCBzaWRlU3RyLCB2YWx1ZSApIHtcbiAgICAgICAgaWYgKCAhbWFwWyBzaWRlU3RyIF0gKSB7XG4gICAgICAgICAgbWFwWyBzaWRlU3RyIF0gPSBuZXcgU2V0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBtYXBbIHNpZGVTdHIgXS5hZGQoIHZhbHVlICk7XG4gICAgICB9XG5cbiAgICAgIHZhciBlZGdlVHlwZSA9IGdldEVkZ2VUeXBlKCBlZGdlICk7XG5cbiAgICAgIGFkZFRvUmVsYXRlZFNldCggb3RoZXJFbmQsIGVkZ2VUeXBlICk7XG4gICAgfSApO1xuXG4gICAgcmV0dXJuIG1hcDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEVkZ2VUeXBlKCBlZGdlICkge1xuICAgIHJldHVybiBlZGdlLmRhdGEoICdjbGFzcycgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzVW5kaXJlY3RlZEVkZ2UoIGVkZ2UgKSB7XG4gICAgcmV0dXJuIGVsZW1lbnRVdGlsaXRpZXMuaXNVbmRpcmVjdGVkRWRnZSggZWRnZSApO1xuICB9XG5cbiAgLy8gZ2V0IGhhbHZlcyBvZiBhIGxpc3QuIEl0IGlzIGFzc3VtZWQgdGhhdCBsaXN0IHNpemUgaXMgYXQgbGVhc3QgMi5cbiAgZnVuY3Rpb24gZ2V0SGFsdmVzKCBsaXN0ICkge1xuICAgIHZhciBzID0gbGlzdC5sZW5ndGg7XG4gICAgdmFyIGhhbGZJbmRleCA9IE1hdGguZmxvb3IoIHMgLyAyICk7XG4gICAgdmFyIGZpcnN0SGFsZiA9IGxpc3Quc2xpY2UoIDAsIGhhbGZJbmRleCApO1xuICAgIHZhciBzZWNvbmRIYWxmID0gbGlzdC5zbGljZSggaGFsZkluZGV4LCBzICk7XG5cbiAgICByZXR1cm4gWyBmaXJzdEhhbGYsIHNlY29uZEhhbGYgXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZUF0KCBhcnIsIGluZGV4ICkge1xuICAgIGFyci5zcGxpY2UoIGluZGV4LCAxICk7XG4gIH1cblxuICByZXR1cm4gdG9wb2xvZ3lHcm91cGluZztcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/utilities/topology-grouping-factory.js\n");

/***/ }),

/***/ "./src/utilities/ur-action-functions-extender-factory.js":
/*!***************************************************************!*\
  !*** ./src/utilities/ur-action-functions-extender-factory.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Extends sbgnviz.undoRedoActionFunctions\nvar libs = __webpack_require__(/*! ./lib-utilities */ \"./src/utilities/lib-utilities.js\").getLibs();\n\nmodule.exports = function () {\n  var sbgnvizInstance, undoRedoActionFunctions, elementUtilities, cy, topologyGrouping;\n\n  function undoRedoActionFunctionsExtender(param) {\n    sbgnvizInstance = param.sbgnvizInstanceUtilities.getInstance();\n    cy = param.sbgnvizInstanceUtilities.getCy();\n    undoRedoActionFunctions = sbgnvizInstance.undoRedoActionFunctions;\n    elementUtilities = param.elementUtilities;\n    topologyGrouping = param.sifTopologyGrouping;\n    extend();\n  } // Extends undoRedoActionFunctions with chise specific features\n\n\n  function extend() {\n    undoRedoActionFunctions.applySIFTopologyGrouping = function (param) {\n      var oldEles, newEles;\n\n      if (param.firstTime) {\n        oldEles = cy.elements();\n\n        if (param.apply) {\n          topologyGrouping.apply();\n        } else {\n          topologyGrouping.unapply();\n        }\n\n        newEles = cy.elements();\n      } else {\n        oldEles = param.oldEles;\n        newEles = param.newEles;\n\n        if (elementUtilities.isGraphTopologyLocked()) {\n          elementUtilities.unlockGraphTopology();\n        } else {\n          elementUtilities.lockGraphTopology();\n        }\n\n        oldEles.remove();\n        newEles.restore();\n        topologyGrouping.toggleAppliedFlag();\n      }\n\n      var result = {\n        oldEles: newEles,\n        newEles: oldEles\n      };\n      return result;\n    }; // Section Start\n    // add/remove action functions\n\n\n    undoRedoActionFunctions.addNode = function (param) {\n      var result;\n\n      if (param.firstTime) {\n        var newNode = param.newNode;\n        result = elementUtilities.addNode(newNode.x, newNode.y, newNode[\"class\"], newNode.id, newNode.parent, newNode.visibility);\n      } else {\n        result = elementUtilities.restoreEles(param);\n      }\n\n      return {\n        eles: result\n      };\n    };\n\n    undoRedoActionFunctions.addEdge = function (param) {\n      var result;\n\n      if (param.firstTime) {\n        var newEdge = param.newEdge;\n        result = elementUtilities.addEdge(newEdge.source, newEdge.target, newEdge[\"class\"], newEdge.id, newEdge.visibility);\n      } else {\n        result = elementUtilities.restoreEles(param);\n      }\n\n      return {\n        eles: result\n      };\n    };\n\n    undoRedoActionFunctions.addProcessWithConvenientEdges = function (param) {\n      var result;\n\n      if (param.firstTime) {\n        result = elementUtilities.addProcessWithConvenientEdges(param.source, param.target, param.processType);\n      } else {\n        result = elementUtilities.restoreEles(param);\n      }\n\n      return {\n        eles: result\n      };\n    };\n\n    undoRedoActionFunctions.createCompoundForGivenNodes = function (param) {\n      var result = {};\n\n      if (param.firstTime) {\n        // Nodes to make compound, their descendants and edges connected to them will be removed during createCompoundForGivenNodes operation\n        // (internally by eles.move() operation), so mark them as removed eles for undo operation.\n        var nodesToMakeCompound = param.nodesToMakeCompound;\n        var removedEles = nodesToMakeCompound.union(nodesToMakeCompound.descendants());\n        removedEles = removedEles.union(removedEles.connectedEdges());\n        result.removedEles = removedEles; // Assume that all nodes to make compound have the same parent\n\n        var oldParentId = nodesToMakeCompound[0].data(\"parent\"); // The parent of new compound will be the old parent of the nodes to make compound\n        // New eles includes new compound and the moved eles and will be used in undo operation.\n\n        result.newEles = elementUtilities.createCompoundForGivenNodes(nodesToMakeCompound, param.compoundType);\n      } else {\n        result.removedEles = param.newEles.remove();\n        result.newEles = param.removedEles.restore();\n        elementUtilities.maintainPointer(result.newEles);\n      }\n\n      return result;\n    }; // Section End\n    // add/remove action functions\n    // Section Start\n    // easy creation action functions\n\n\n    undoRedoActionFunctions.createTemplateReaction = function (param) {\n      var firstTime = param.firstTime;\n      var eles;\n\n      if (firstTime) {\n        eles = elementUtilities.createTemplateReaction(param.templateType, param.macromoleculeList, param.complexName, param.processPosition, param.tilingPaddingVertical, param.tilingPaddingHorizontal, param.edgeLength, param.layoutParam);\n      } else {\n        eles = param;\n        cy.add(eles);\n        cy.elements().unselect();\n        eles.select();\n      }\n\n      return {\n        eles: eles\n      };\n    };\n\n    undoRedoActionFunctions.createActivationReaction = function (param) {\n      var firstTime = param.firstTime;\n      var eles;\n\n      if (firstTime) {\n        eles = elementUtilities.createActivationReaction(param.proteinName, param.processPosition, param.edgeLength, param.reverse);\n      } else {\n        eles = param;\n        cy.add(eles);\n        cy.elements().unselect();\n        eles.select();\n      }\n\n      return {\n        eles: eles\n      };\n    };\n\n    undoRedoActionFunctions.createTranslation = function (param) {\n      var firstTime = param.firstTime;\n      var eles;\n\n      if (firstTime) {\n        eles = elementUtilities.createTranslation(param.regulatorLabel, param.outputLabel, param.orientation);\n      } else {\n        eles = param;\n        cy.add(eles);\n        cy.elements().unselect();\n        eles.select();\n      }\n\n      return {\n        eles: eles\n      };\n    };\n\n    undoRedoActionFunctions.createTranscription = function (param) {\n      var firstTime = param.firstTime;\n      var eles;\n\n      if (firstTime) {\n        eles = elementUtilities.createTranscription(param.label, param.orientation);\n      } else {\n        eles = param;\n        cy.add(eles);\n        cy.elements().unselect();\n        eles.select();\n      }\n\n      return {\n        eles: eles\n      };\n    };\n\n    undoRedoActionFunctions.createDegradation = function (param) {\n      var firstTime = param.firstTime;\n      var eles;\n\n      if (firstTime) {\n        eles = elementUtilities.createDegradation(param.macromolecule, param.orientation);\n      } else {\n        eles = param;\n        cy.add(eles);\n        cy.elements().unselect();\n        eles.select();\n      }\n\n      return {\n        eles: eles\n      };\n    };\n\n    undoRedoActionFunctions.createComplexProteinFormation = function (param) {\n      var firstTime = param.firstTime;\n      var eles;\n\n      if (firstTime) {\n        eles = elementUtilities.createComplexProteinFormation(param.proteinLabels, param.complexLabel, param.regulator, param.orientation, param.reverse);\n      } else {\n        eles = param;\n        cy.add(eles);\n        cy.elements().unselect();\n        eles.select();\n      }\n\n      return {\n        eles: eles\n      };\n    };\n\n    undoRedoActionFunctions.createMultimerization = function (param) {\n      var firstTime = param.firstTime;\n      var eles;\n\n      if (firstTime) {\n        eles = elementUtilities.createMultimerization(param.macromolecule, param.regulator, param.regulatorMultimer, param.orientation);\n      } else {\n        eles = param;\n        cy.add(eles);\n        cy.elements().unselect();\n        eles.select();\n      }\n\n      return {\n        eles: eles\n      };\n    };\n\n    undoRedoActionFunctions.createConversion = function (param) {\n      var firstTime = param.firstTime;\n      var eles;\n\n      if (firstTime) {\n        eles = elementUtilities.createConversion(param.macromolecule, param.regulator, param.regulatorMultimer, param.orientation, param.inputInfoboxLabels, param.outputInfoboxLabels);\n      } else {\n        eles = param;\n        cy.add(eles);\n        cy.elements().unselect();\n        eles.select();\n      }\n\n      return {\n        eles: eles\n      };\n    };\n\n    undoRedoActionFunctions.createMetabolicReaction = function (param) {\n      var firstTime = param.firstTime;\n      var eles;\n\n      if (firstTime) {\n        eles = elementUtilities.createMetabolicReaction(param.inputs, param.outputs, param.reversible, param.regulator, param.regulatorMultimer, param.orientation);\n      } else {\n        eles = param;\n        cy.add(eles);\n        cy.elements().unselect();\n        eles.select();\n      }\n\n      return {\n        eles: eles\n      };\n    };\n\n    undoRedoActionFunctions.createMetabolicCatalyticActivity = function (param) {\n      var firstTime = param.firstTime;\n      var eles;\n\n      if (firstTime) {\n        eles = elementUtilities.createMetabolicCatalyticActivity(param.inputNodeList, param.outputNodeList, param.catalystName, param.catalystType, param.processPosition, param.tilingPaddingVertical, param.tilingPaddingHorizontal, param.edgeLength);\n      } else {\n        eles = param;\n        cy.add(eles);\n        cy.elements().unselect();\n        eles.select();\n      }\n\n      return {\n        eles: eles\n      };\n    };\n\n    undoRedoActionFunctions.createTranscriptionReaction = function (param) {\n      var firstTime = param.firstTime;\n      var eles;\n\n      if (firstTime) {\n        eles = elementUtilities.createTranscriptionReaction(param.geneName, param.mRnaName, param.processPosition, param.edgeLength);\n      } else {\n        eles = param;\n        cy.add(eles);\n        cy.elements().unselect();\n        eles.select();\n      }\n\n      return {\n        eles: eles\n      };\n    };\n\n    undoRedoActionFunctions.createTranslationReaction = function (param) {\n      var firstTime = param.firstTime;\n      var eles;\n\n      if (firstTime) {\n        eles = elementUtilities.createTranslationReaction(param.mRnaName, param.proteinName, param.processPosition, param.edgeLength);\n      } else {\n        eles = param;\n        cy.add(eles);\n        cy.elements().unselect();\n        eles.select();\n      }\n\n      return {\n        eles: eles\n      };\n    }; // Section End\n    // easy creation action functions\n    // Section Start\n    // general action functions\n\n\n    undoRedoActionFunctions.getNodePositions = function () {\n      var positions = {};\n      var nodes = cy.nodes();\n      nodes.each(function (ele, i) {\n        if (typeof ele === \"number\") {\n          ele = i;\n        }\n\n        positions[ele.id()] = {\n          x: ele.position(\"x\"),\n          y: ele.position(\"y\")\n        };\n      });\n      return positions;\n    };\n\n    undoRedoActionFunctions.returnToPositions = function (positions) {\n      var currentPositions = {};\n      cy.nodes().positions(function (ele, i) {\n        if (typeof ele === \"number\") {\n          ele = i;\n        }\n\n        currentPositions[ele.id()] = {\n          x: ele.position(\"x\"),\n          y: ele.position(\"y\")\n        };\n        var pos = positions[ele.id()];\n        return {\n          x: pos.x,\n          y: pos.y\n        };\n      });\n      return currentPositions;\n    };\n\n    undoRedoActionFunctions.resizeNodes = function (param) {\n      var result = {\n        performOperation: true\n      };\n      var nodes = param.nodes;\n      result.sizeMap = {};\n      result.useAspectRatio = false;\n      result.preserveRelativePos = param.preserveRelativePos;\n\n      for (var i = 0; i < nodes.length; i++) {\n        var node = nodes[i];\n\n        if (node.isParent()) {\n          result.sizeMap[node.id()] = {\n            w: node.data(\"minWidth\") || 0,\n            h: node.data(\"minHeight\") || 0,\n            biasL: node.data(\"minWidthBiasLeft\") || 0,\n            biasR: node.data(\"minWidthBiasRight\") || 0,\n            biasT: node.data(\"minHeightBiasTop\") || 0,\n            biasB: node.data(\"minHeightBiasBottom\") || 0 // w: node.css(\"minWidth\") != 0?  node.data(\"minWidth\") : node.children().boundingBox().w,\n            //h: node.css(\"min-height\") != 0?  node.data(\"minHeight\") : node.children().boundingBox().h\n\n          };\n        } else {\n          result.sizeMap[node.id()] = {\n            w: node.width(),\n            h: node.height()\n          };\n        }\n      }\n\n      result.nodes = nodes;\n\n      for (var i = 0; i < nodes.length; i++) {\n        var node = nodes[i];\n\n        if (param.performOperation) {\n          if (param.sizeMap) {\n            /* if (param.preserveRelativePos === true) {\n              var oldWidth = node.data(\"bbox\").w;\n              var oldHeight = node.data(\"bbox\").h;\n            } */\n            if (node.isParent()) {\n              node.data(\"minHeight\", param.sizeMap[node.id()].h);\n              node.data(\"minWidth\", param.sizeMap[node.id()].w);\n              node.data(\"minWidthBiasLeft\", param.sizeMap[node.id()].biasL);\n              node.data(\"minWidthBiasRight\", param.sizeMap[node.id()].biasR);\n              node.data(\"minHeightBiasTop\", param.sizeMap[node.id()].biasT);\n              node.data(\"minHeightBiasBottom\", param.sizeMap[node.id()].biasB);\n            } else {\n              node.data(\"bbox\").w = param.sizeMap[node.id()].w;\n              node.data(\"bbox\").h = param.sizeMap[node.id()].h;\n            }\n            /* if (param.preserveRelativePos === true) {\n              var statesandinfos = node.data('statesandinfos');\n              var topBottom = statesandinfos.filter(box => (box.anchorSide === \"top\" || box.anchorSide === \"bottom\"));\n              var rightLeft = statesandinfos.filter(box => (box.anchorSide === \"right\" || box.anchorSide === \"left\"));\n               topBottom.forEach(function(box){\n                if (box.bbox.x < 0) {\n                  box.bbox.x = 0;\n                }\n                else if (box.bbox.x > oldWidth) {\n                  box.bbox.x = oldWidth;\n                }\n                box.bbox.x = node.data(\"bbox\").w * box.bbox.x / oldWidth;\n              });\n               rightLeft.forEach(function(box){\n                if (box.bbox.y < 0) {\n                  box.bbox.y = 0;\n                }\n                else if (box.bbox.y > oldHeight) {\n                  box.bbox.y = oldHeight;\n                }\n                box.bbox.y = node.data(\"bbox\").h * box.bbox.y / oldHeight;\n              });\n            } */\n\n          } else {\n            elementUtilities.resizeNodes(param.nodes, param.width, param.height, param.useAspectRatio, param.preserveRelativePos);\n          }\n        }\n      }\n\n      cy.style().update();\n      return result;\n    };\n\n    undoRedoActionFunctions.changeNodeLabel = function (param) {\n      var result = {};\n      var nodes = param.nodes;\n      result.nodes = nodes;\n      result.label = {};\n\n      for (var i = 0; i < nodes.length; i++) {\n        var node = nodes[i];\n        result.label[node.id()] = node._private.data.label;\n      }\n\n      if (param.firstTime) {\n        nodes.data('label', param.label);\n      } else {\n        for (var i = 0; i < nodes.length; i++) {\n          var node = nodes[i];\n          node._private.data.label = param.label[node.id()];\n        }\n      }\n\n      return result;\n    };\n\n    undoRedoActionFunctions.updateInfoboxStyle = function (param) {\n      var result = {};\n      var style = param.node.data('statesandinfos')[param.index].style;\n      result.newProps = $.extend({}, style);\n      result.node = param.node;\n      result.index = param.index;\n      elementUtilities.updateInfoboxStyle(param.node, param.index, param.newProps);\n      return result;\n    };\n\n    undoRedoActionFunctions.updateInfoboxObj = function (param) {\n      var result = {};\n      var obj = param.node.data('statesandinfos')[param.index];\n      result.newProps = $.extend({}, obj);\n      result.node = param.node;\n      result.index = param.index;\n      elementUtilities.updateInfoboxObj(param.node, param.index, param.newProps);\n      return result;\n    };\n\n    undoRedoActionFunctions.changeData = function (param) {\n      var result = {};\n      var eles = param.eles;\n      result.name = param.name;\n      result.valueMap = {};\n      result.eles = eles;\n\n      for (var i = 0; i < eles.length; i++) {\n        var ele = eles[i];\n        result.valueMap[ele.id()] = ele.data(param.name);\n      }\n\n      elementUtilities.changeData(param.eles, param.name, param.valueMap);\n      return result;\n    };\n\n    undoRedoActionFunctions.updateSetField = function (param) {\n      var updates = elementUtilities.updateSetField(param.ele, param.fieldName, param.toDelete, param.toAdd, param.callback);\n      var result = {\n        ele: param.ele,\n        fieldName: param.fieldName,\n        callback: param.callback,\n        toDelete: updates.added,\n        toAdd: updates.deleted\n      };\n      return result;\n    };\n\n    undoRedoActionFunctions.changeCss = function (param) {\n      var result = {};\n      var eles = param.eles;\n      result.name = param.name;\n      result.valueMap = {};\n      result.eles = eles;\n\n      for (var i = 0; i < eles.length; i++) {\n        var ele = eles[i];\n        result.valueMap[ele.id()] = ele.css(param.name);\n      }\n\n      elementUtilities.changeCss(param.eles, param.name, param.valueMap);\n      return result;\n    };\n\n    undoRedoActionFunctions.changeFontProperties = function (param) {\n      var result = {};\n      var eles = param.eles;\n      result.data = {};\n      result.eles = eles;\n\n      for (var i = 0; i < eles.length; i++) {\n        var ele = eles[i];\n        result.data[ele.id()] = {};\n        var data = param.firstTime ? param.data : param.data[ele.id()];\n\n        for (var prop in data) {\n          result.data[ele.id()][prop] = ele.data(prop);\n        }\n      }\n\n      if (param.firstTime) {\n        elementUtilities.changeFontProperties(eles, data);\n      } else {\n        for (var i = 0; i < eles.length; i++) {\n          var ele = eles[i];\n          elementUtilities.changeFontProperties(ele, data);\n        }\n      }\n\n      return result;\n    };\n    /*\n     * Show eles and perform layout.\n     */\n\n\n    undoRedoActionFunctions.showAndPerformLayout = function (param) {\n      var eles = param.eles;\n      var result = {};\n      result.positions = undoRedoActionFunctions.getNodePositions();\n\n      if (param.firstTime) {\n        result.eles = elementUtilities.showAndPerformLayout(param.eles, param.layoutparam);\n      } else {\n        result.eles = cy.viewUtilities().show(eles); // Show given eles\n\n        undoRedoActionFunctions.returnToPositions(param.positions);\n      }\n\n      return result;\n    };\n\n    undoRedoActionFunctions.undoShowAndPerformLayout = function (param) {\n      var eles = param.eles;\n      var result = {};\n      result.positions = undoRedoActionFunctions.getNodePositions();\n      result.eles = cy.viewUtilities().hide(eles); // Hide previously unhidden eles;\n\n      undoRedoActionFunctions.returnToPositions(param.positions);\n      return result;\n    };\n    /*\n     * Hide eles and perform layout.\n     */\n\n\n    undoRedoActionFunctions.hideAndPerformLayout = function (param) {\n      var eles = param.eles;\n      var result = {};\n      result.positions = undoRedoActionFunctions.getNodePositions();\n\n      if (param.firstTime) {\n        result.eles = elementUtilities.hideAndPerformLayout(param.eles, param.layoutparam);\n      } else {\n        result.eles = cy.viewUtilities().hide(eles); // Hide given eles\n\n        undoRedoActionFunctions.returnToPositions(param.positions);\n      }\n\n      return result;\n    };\n\n    undoRedoActionFunctions.undoHideAndPerformLayout = function (param) {\n      var eles = param.eles;\n      var result = {};\n      result.positions = undoRedoActionFunctions.getNodePositions();\n      result.eles = cy.viewUtilities().show(eles); // Show previously hidden eles\n\n      undoRedoActionFunctions.returnToPositions(param.positions);\n      return result;\n    };\n    /*\n     * Delete eles and perform layout.\n     */\n\n\n    undoRedoActionFunctions.deleteAndPerformLayout = function (param) {\n      var eles = param.eles;\n      var result = {};\n      result.positions = undoRedoActionFunctions.getNodePositions();\n\n      if (param.firstTime) {\n        result.eles = elementUtilities.deleteAndPerformLayout(param.eles, param.layoutparam);\n      } else {\n        result.eles = eles.remove();\n        undoRedoActionFunctions.returnToPositions(param.positions);\n      }\n\n      return result;\n    };\n\n    undoRedoActionFunctions.undoDeleteAndPerformLayout = function (param) {\n      var eles = param.eles;\n      var result = {};\n      result.positions = undoRedoActionFunctions.getNodePositions();\n      result.eles = elementUtilities.restoreEles(eles);\n      undoRedoActionFunctions.returnToPositions(param.positions);\n      return result;\n    }; // Section End\n    // general action functions\n    // Section Start\n    // sbgn action functions\n\n\n    undoRedoActionFunctions.changeStateOrInfoBox = function (param) {\n      var result = {};\n      result.type = param.type;\n      result.nodes = param.nodes;\n      result.index = param.index;\n      var data = param.data;\n      var tempData = elementUtilities.saveUnits(param.nodes);\n      result.value = elementUtilities.changeStateOrInfoBox(param.nodes, param.index, param.value, param.type);\n      /* var locations = elementUtilities.checkFit(param.nodes);\n      if (locations !== undefined && locations.length > 0) {\n        elementUtilities.fitUnits(param.nodes, locations);\n      } */\n\n      if (data !== undefined) {\n        elementUtilities.restoreUnits(param.nodes, data);\n      }\n\n      cy.forceRender();\n      result.data = tempData;\n      return result;\n    };\n\n    undoRedoActionFunctions.addStateOrInfoBox = function (param) {\n      var obj = param.obj;\n      var nodes = param.nodes;\n      var data = param.data;\n      var tempData = elementUtilities.saveUnits(nodes);\n      var locationObj = elementUtilities.addStateOrInfoBox(nodes, obj);\n      /*  var locations = elementUtilities.checkFit(nodes);\n       if (locations !== undefined && locations.length > 0) {\n         elementUtilities.fitUnits(nodes, locations);\n       } */\n\n      if (data !== undefined) {\n        elementUtilities.restoreUnits(nodes, data);\n      }\n\n      cy.forceRender();\n      var result = {\n        nodes: nodes,\n        locationObj: locationObj,\n        obj: obj,\n        data: tempData\n      };\n      return result;\n    };\n\n    undoRedoActionFunctions.removeStateOrInfoBox = function (param) {\n      var locationObj = param.locationObj;\n      var nodes = param.nodes;\n      var data = param.data;\n      var tempData = elementUtilities.saveUnits(nodes);\n      var obj = elementUtilities.removeStateOrInfoBox(nodes, locationObj);\n\n      if (data !== undefined) {\n        elementUtilities.restoreUnits(nodes, data);\n      }\n\n      cy.forceRender();\n      var result = {\n        nodes: nodes,\n        obj: obj,\n        data: tempData\n      };\n      return result;\n    };\n\n    undoRedoActionFunctions.fitUnits = function (param) {\n      var node = param.node;\n      var locations = param.locations;\n      var obj = elementUtilities.fitUnits(node, locations);\n      cy.forceRender();\n      var result = {\n        node: node,\n        obj: obj,\n        locations: locations\n      };\n      return result;\n    };\n\n    undoRedoActionFunctions.restoreUnits = function (param) {\n      var node = param.node;\n      var locations = param.locations;\n      var obj = param.obj;\n      var index = 0;\n      node.data('statesandinfos').forEach(function (ele) {\n        var box = obj[index++];\n        ele.bbox.x = box.x;\n        ele.bbox.y = box.y;\n        var oldSide = ele.anchorSide;\n        ele.anchorSide = box.anchorSide;\n        elementUtilities.modifyUnits(node, ele, oldSide);\n      });\n      cy.forceRender();\n      var result = {\n        node: node,\n        locations: locations\n      };\n      return result;\n    };\n\n    undoRedoActionFunctions.setMultimerStatus = function (param) {\n      var firstTime = param.firstTime;\n      var nodes = param.nodes;\n      var status = param.status;\n      var resultStatus = {};\n\n      for (var i = 0; i < nodes.length; i++) {\n        var node = nodes[i];\n        var isMultimer = node.data('class').endsWith(' multimer');\n        resultStatus[node.id()] = isMultimer;\n      } // If this is the first time change the status of all nodes at once.\n      // If not change status of each seperately to the values mapped to their id.\n\n\n      if (firstTime) {\n        elementUtilities.setMultimerStatus(nodes, status);\n      } else {\n        for (var i = 0; i < nodes.length; i++) {\n          var node = nodes[i];\n          elementUtilities.setMultimerStatus(node, status[node.id()]);\n        }\n      } //  if (!firstTime && _.isEqual(nodes, cy.nodes(':selected'))) {\n      //    $('#inspector-is-multimer').attr(\"checked\", !$('#inspector-is-multimer').attr(\"checked\"));\n      //  }\n\n\n      var result = {\n        status: resultStatus,\n        nodes: nodes\n      };\n      return result;\n    };\n\n    undoRedoActionFunctions.setCloneMarkerStatus = function (param) {\n      var nodes = param.nodes;\n      var status = param.status;\n      var firstTime = param.firstTime;\n      var resultStatus = {};\n\n      for (var i = 0; i < nodes.length; i++) {\n        var node = nodes[i];\n        resultStatus[node.id()] = node.data('clonemarker');\n        var currentStatus = firstTime ? status : status[node.id()];\n        elementUtilities.setCloneMarkerStatus(node, currentStatus);\n      } //  if (!firstTime && _.isEqual(nodes, cy.nodes(':selected'))) {\n      //    $('#inspector-is-clone-marker').attr(\"checked\", !$('#inspector-is-clone-marker').attr(\"checked\"));\n      //  }\n\n\n      var result = {\n        status: resultStatus,\n        nodes: nodes\n      };\n      return result;\n    }; // param: {class: sbgnclass, name: propertyName, value: value}\n\n\n    undoRedoActionFunctions.setDefaultProperty = function (param) {\n      var sbgnclass = param[\"class\"];\n      var name = param.name;\n      var value = param.value;\n      var classDefaults = elementUtilities.getDefaultProperties(sbgnclass);\n      var result = {\n        \"class\": sbgnclass,\n        name: name,\n        value: classDefaults.hasOwnProperty(name) ? classDefaults[name] : undefined\n      };\n      var propMap = {};\n      propMap[name] = value;\n      elementUtilities.setDefaultProperties(sbgnclass, propMap);\n      return result;\n    };\n\n    undoRedoActionFunctions.addBackgroundImage = function (param) {\n      var bgObj = param.bgObj;\n      var nodes = param.nodes;\n      var updateInfo = param.updateInfo;\n      var promptInvalidImage = param.promptInvalidImage;\n      var validateURL = param.validateURL;\n      elementUtilities.addBackgroundImage(nodes, bgObj, updateInfo, promptInvalidImage, validateURL);\n      cy.forceRender();\n      var result = {\n        nodes: nodes,\n        bgObj: bgObj,\n        updateInfo: updateInfo,\n        promptInvalidImage: promptInvalidImage,\n        validateURL: validateURL\n      };\n      return result;\n    };\n\n    undoRedoActionFunctions.removeBackgroundImage = function (param) {\n      var bgObj = param.bgObj;\n      var nodes = param.nodes;\n      elementUtilities.removeBackgroundImage(nodes, bgObj);\n      cy.forceRender();\n      var result = {\n        nodes: nodes,\n        bgObj: bgObj\n      };\n      return result;\n    };\n\n    undoRedoActionFunctions.updateBackgroundImage = function (param) {\n      var bgObj = param.bgObj;\n      var nodes = param.nodes;\n      var oldBgObj = elementUtilities.updateBackgroundImage(nodes, bgObj);\n      cy.forceRender();\n      var result = {\n        nodes: nodes,\n        bgObj: oldBgObj\n      };\n      return result;\n    };\n\n    undoRedoActionFunctions.changeBackgroundImage = function (param) {\n      var oldImg = param.oldImg;\n      var newImg = param.newImg;\n      var nodes = param.nodes;\n      var firstTime = param.firstTime;\n      var updateInfo = param.updateInfo;\n      var promptInvalidImage = param.promptInvalidImage;\n      var validateURL = param.validateURL;\n      var result = elementUtilities.changeBackgroundImage(nodes, oldImg, newImg, firstTime, updateInfo, promptInvalidImage, validateURL);\n      cy.forceRender();\n      return result;\n    }; // Section End\n    // sbgn action functions\n\n\n    undoRedoActionFunctions.convertIntoReversibleReaction = function (param) {\n      var collection = cy.collection();\n      var mapType = elementUtilities.getMapType();\n      elementUtilities.setMapType(param.mapType);\n      $('#map-type').val(param.mapType);\n      param.collection.forEach(function (edge) {\n        var sourceNode = edge._private.data.source;\n        var targetNode = edge._private.data.target;\n        edge.move({\n          source: targetNode,\n          target: sourceNode\n        });\n        var convertedEdge = cy.getElementById(edge.id());\n\n        if (convertedEdge.data(\"cyedgebendeditingDistances\")) {\n          var distance = convertedEdge.data(\"cyedgebendeditingDistances\");\n          distance = distance.map(function (element) {\n            return -1 * element;\n          });\n          convertedEdge.data(\"cyedgebendeditingDistances\", distance.reverse());\n          var weight = convertedEdge.data(\"cyedgebendeditingWeights\");\n          weight = weight.map(function (element) {\n            return 1 - element;\n          });\n          convertedEdge.data(\"cyedgebendeditingWeights\", weight.reverse());\n        }\n\n        if (convertedEdge.data(\"cyedgecontroleditingDistances\")) {\n          var _distance = convertedEdge.data(\"cyedgecontroleditingDistances\");\n\n          _distance = _distance.map(function (element) {\n            return -1 * element;\n          });\n          convertedEdge.data(\"cyedgecontroleditingDistances\", _distance.reverse());\n\n          var _weight = convertedEdge.data(\"cyedgecontroleditingWeigths\");\n\n          _weight = _weight.map(function (element) {\n            return 1 - element;\n          });\n          convertedEdge.data(\"cyedgecontroleditingWeigths\", _weight.reverse());\n        }\n\n        if (convertedEdge._private.data[\"class\"] === \"consumption\") {\n          convertedEdge._private.data[\"class\"] = \"production\";\n          convertedEdge._private.data.portsource = targetNode + \".1\";\n          convertedEdge._private.data.porttarget = sourceNode;\n        } else if (convertedEdge._private.data[\"class\"] === \"production\") {\n          convertedEdge._private.data[\"class\"] = \"consumption\";\n          convertedEdge._private.data.portsource = targetNode;\n          convertedEdge._private.data.porttarget = sourceNode + \".1\";\n        }\n\n        collection = collection.add(convertedEdge);\n        cy.style().update();\n      });\n      var result = {\n        collection: collection,\n        mapType: mapType,\n        processId: param.processId\n      };\n      return result;\n    };\n\n    undoRedoActionFunctions.moveEdge = function (param) {\n      var result = {};\n      var edge = param.edge;\n      result.name = param.name;\n      result.source = edge.source().id();\n      result.target = edge.target().id();\n      result.portsource = edge.data(\"portsource\");\n      result.porttarget = edge.data(\"porttarget\");\n      elementUtilities.changeData(edge, 'source', param.source);\n      elementUtilities.changeData(edge, 'target', param.target);\n      elementUtilities.changeData(edge, 'portsource', param.portsource);\n      elementUtilities.changeData(edge, 'porttarget', param.porttarget);\n      edge = edge.move({\n        target: param.target,\n        source: param.source\n      });\n      result.edge = edge;\n      return result;\n    };\n\n    undoRedoActionFunctions.fixError = function (param) {\n      var errorCode = param.errorCode;\n      var result = {};\n      result.errorCode = errorCode;\n\n      if (errorCode == \"pd10101\" || errorCode == 'pd10102') {\n        result.edge = elementUtilities.reverseEdge(param.edge);\n        return result;\n      } else if (errorCode == \"pd10103\" || errorCode == 'pd10107') {\n        param.newNodes.forEach(function (newNode) {\n          elementUtilities.addNode(newNode.x, newNode.y, newNode[\"class\"], newNode.id, undefined);\n        });\n        param.newEdges.forEach(function (newEdge) {\n          elementUtilities.addEdge(newEdge.source, newEdge.target, newEdge[\"class\"]);\n        });\n        param.oldEdges.forEach(function (oldEdge) {\n          cy.elements().unselect(); //return \n\n          oldEdge.remove();\n        });\n        param.node.remove();\n        return param;\n      } else if (errorCode == \"pd10105\" || errorCode == 'pd10106') {\n        result.edge = elementUtilities.reverseEdge(param.edge);\n        return result;\n      } else if (errorCode == \"pd10140\") {\n        param.node.remove();\n        return param;\n      } else if (errorCode == \"pd10104\") {\n        param.edges.forEach(function (edge) {\n          edge.remove();\n        });\n        param.nodes.forEach(function (node) {\n          node.remove();\n        });\n        return param;\n      } else if (errorCode == \"pd10108\") {\n        param.edges.forEach(function (edge) {\n          edge.remove();\n        });\n        param.nodes.forEach(function (node) {\n          node.remove();\n        });\n        return param;\n      } else if (errorCode == \"pd10111\") {\n        param.edges.forEach(function (edge) {\n          edge.remove();\n        });\n        return param;\n      } else if (errorCode == \"pd10126\") {\n        param.edges.forEach(function (edge) {\n          edge.remove();\n        });\n        param.nodes.forEach(function (node) {\n          node.remove();\n        });\n        return param;\n      } else if (errorCode == \"pd10109\" || errorCode == \"pd10124\") {\n        result.newSource = param.edge.data().source;\n        result.newTarget = param.edge.data().target;\n        result.portsource = param.edge.data().portsource;\n        var clonedEdge = param.edge.clone();\n        var edgeParams = {\n          \"class\": clonedEdge.data()[\"class\"],\n          language: clonedEdge.data().language\n        };\n        clonedEdge.data().source = param.newSource;\n        clonedEdge.data().target = param.newTarget;\n        cy.remove(param.edge);\n        result.edge = elementUtilities.addEdge(param.newSource, param.newTarget, edgeParams, clonedEdge.data().id);\n        return result;\n      } else if (errorCode == \"pd10112\") {\n        param.callback = elementUtilities.maintainPointer; // If this is first time we should move the node to its new parent and relocate it by given posDiff params\n        // else we should remove the moved eles and restore the eles to restore\n\n        if (param.firstTime) {\n          var newParentId = param.parentData == undefined ? null : param.parentData; // These eles includes the nodes and their connected edges and will be removed in nodes.move().\n          // They should be restored in undo\n\n          var withDescendant = param.nodes.union(param.nodes.descendants());\n          result.elesToRestore = withDescendant.union(withDescendant.connectedEdges()); // These are the eles created by nodes.move(), they should be removed in undo.\n\n          result.movedEles = param.nodes.move({\n            \"parent\": newParentId\n          });\n          var posDiff = {\n            x: param.posDiffX,\n            y: param.posDiffY\n          };\n          elementUtilities.moveNodes(posDiff, result.movedEles);\n        } else {\n          result.elesToRestore = param.movedEles.remove();\n          result.movedEles = param.elesToRestore.restore();\n        }\n\n        if (param.callback) {\n          result.callback = param.callback; // keep the provided callback so it can be reused after undo/redo\n\n          param.callback(result.movedEles); // apply the callback on newly created elements\n        }\n\n        return result;\n      } else if (errorCode == \"pd10125\") {\n        result.edge = param.edge.remove();\n        result.newEdge = {};\n        var edgeclass = param.newEdge.edgeParams[\"class\"] ? param.newEdge.edgeParams[\"class\"] : param.newEdge.edgeParams;\n        var validation = elementUtilities.validateArrowEnds(edgeclass, cy.getElementById(param.newEdge.source), cy.getElementById(param.newEdge.target));\n\n        if (validation === 'reverse') {\n          var temp = param.newEdge.source;\n          param.newEdge.source = param.newEdge.target;\n          param.newEdge.target = temp;\n        }\n\n        result.newEdge.id = elementUtilities.addEdge(param.newEdge.source, param.newEdge.target, param.newEdge.edgeParams).id();\n        result.newEdge.source = param.newEdge.source;\n        result.newEdge.target = param.newEdge.target;\n        result.newEdge.edgeParams = param.newEdge.edgeParams;\n        return result;\n      } else if (errorCode == \"pd10142\") {\n        result.edge = param.edge.remove();\n        result.newEdge = {};\n        var edgeclass = param.newEdge.edgeParams[\"class\"] ? param.newEdge.edgeParams[\"class\"] : param.newEdge.edgeParams;\n        var validation = elementUtilities.validateArrowEnds(edgeclass, cy.getElementById(param.newEdge.source), cy.getElementById(param.newEdge.target));\n\n        if (validation === 'reverse') {\n          var temp = param.newEdge.source;\n          param.newEdge.source = param.newEdge.target;\n          param.newEdge.target = temp;\n        }\n\n        result.newEdge.id = elementUtilities.addEdge(param.newEdge.source, param.newEdge.target, param.newEdge.edgeParams).id();\n        result.newEdge.source = param.newEdge.source;\n        result.newEdge.target = param.newEdge.target;\n        result.newEdge.edgeParams = param.newEdge.edgeParams;\n        return result;\n      } else {\n        result.newSource = param.edge.source().id();\n        result.newTarget = param.edge.target().id();\n        result.porttarget = param.edge.data(\"porttarget\");\n        result.edge = param.edge.move({\n          target: param.newTarget,\n          source: param.newSource\n        });\n        elementUtilities.changeData(result.edge, 'porttarget', param.porttarget);\n        return result;\n      }\n    };\n\n    undoRedoActionFunctions.unfixError = function (param) {\n      var errorCode = param.errorCode;\n      var result = {};\n      result.errorCode = errorCode;\n\n      if (errorCode == \"pd10101\" || errorCode == 'pd10102') {\n        result.edge = elementUtilities.reverseEdge(param.edge);\n        return result;\n      } else if (errorCode == \"pd10103\" || errorCode == 'pd10107') {\n        param.newNodes.forEach(function (newNode) {\n          cy.remove(cy.$('#' + newNode.id));\n        });\n        param.node.restore();\n        param.oldEdges.forEach(function (oldEdge) {\n          oldEdge.restore();\n        });\n        cy.animate({\n          duration: 100,\n          easing: 'ease',\n          fit: {\n            eles: {},\n            padding: 20\n          },\n          complete: function complete() {}\n        });\n        return param;\n      } else if (errorCode == \"pd10105\" || errorCode == 'pd10106') {\n        result.edge = elementUtilities.reverseEdge(param.edge);\n        return result;\n      } else if (errorCode == \"pd10140\") {\n        param.node.restore();\n        cy.animate({\n          duration: 100,\n          easing: 'ease',\n          fit: {\n            eles: {},\n            padding: 20\n          },\n          complete: function complete() {}\n        });\n        return param;\n      } else if (errorCode == \"pd10104\") {\n        param.nodes.forEach(function (node) {\n          node.restore();\n        });\n        param.edges.forEach(function (edge) {\n          edge.restore();\n        });\n        return param;\n      } else if (errorCode == \"pd10108\") {\n        param.nodes.forEach(function (node) {\n          node.restore();\n        });\n        param.edges.forEach(function (edge) {\n          edge.restore();\n        });\n        return param;\n      } else if (errorCode == \"pd10111\") {\n        param.edges.forEach(function (edge) {\n          edge.restore();\n        });\n        return param;\n      } else if (errorCode == \"pd10126\") {\n        param.nodes.forEach(function (node) {\n          node.restore();\n        });\n        param.edges.forEach(function (edge) {\n          edge.restore();\n        });\n        return param;\n      } else if (errorCode == \"pd10109\" || errorCode == \"pd10124\") {\n        result.newSource = param.edge.source().id();\n        result.newTarget = param.edge.target().id();\n        result.portsource = param.portsource;\n        result.edge = param.edge.move({\n          target: param.newTarget,\n          source: param.newSource\n        });\n        elementUtilities.changeData(result.edge, 'portsource', param.portsource);\n        return result;\n      } else if (errorCode == \"pd10112\") {\n        // If this is first time we should move the node to its new parent and relocate it by given posDiff params\n        // else we should remove the moved eles and restore the eles to restore\n        if (param.firstTime) {\n          var newParentId = param.parentData == undefined ? null : param.parentData; // These eles includes the nodes and their connected edges and will be removed in nodes.move().\n          // They should be restored in undo\n\n          var withDescendant = param.nodes.union(param.nodes.descendants());\n          result.elesToRestore = withDescendant.union(withDescendant.connectedEdges()); // These are the eles created by nodes.move(), they should be removed in undo.\n\n          result.movedEles = param.nodes.move({\n            \"parent\": newParentId\n          });\n          var posDiff = {\n            x: param.posDiffX,\n            y: param.posDiffY\n          };\n          elementUtilities.moveNodes(posDiff, result.movedEles);\n        } else {\n          result.elesToRestore = param.movedEles.remove();\n          result.movedEles = param.elesToRestore.restore();\n        }\n\n        if (param.callback) {\n          result.callback = param.callback; // keep the provided callback so it can be reused after undo/redo\n\n          param.callback(result.movedEles); // apply the callback on newly created elements\n        }\n\n        return result;\n      } else if (errorCode == \"pd10125\") {\n        cy.$('#' + param.newEdge.id).remove();\n        param.edge = param.edge.restore();\n        return param;\n      } else if (errorCode == \"pd10142\") {\n        cy.$('#' + param.newEdge.id).remove();\n        param.edge = param.edge.restore();\n        return param;\n      } else {\n        result.newSource = param.edge.source().id();\n        result.newTarget = param.edge.target().id();\n        result.porttarget = param.edge.data(\"porttarget\");\n        result.edge = param.edge.move({\n          target: param.newTarget,\n          source: param.newSource\n        });\n        elementUtilities.changeData(result.edge, 'porttarget', param.porttarget);\n        return result;\n      }\n    };\n\n    undoRedoActionFunctions.cloneHighDegreeNode = function (node) {\n      var result = {};\n      var oldX = node.position().x;\n      var oldY = node.position().y;\n\n      var claculateNewClonePosition = function claculateNewClonePosition(sourceEndPointX, sourceEndPointY, targetEndPointX, targetEndPointY, desiredDistance, direction) {\n        var distance = Math.sqrt(Math.pow(targetEndPointY - sourceEndPointY, 2) + Math.pow(targetEndPointX - sourceEndPointX, 2));\n        var ratio = desiredDistance / distance;\n        var result = {};\n\n        if (direction == \"source\") {\n          result.cx = (1 - ratio) * sourceEndPointX + ratio * targetEndPointX;\n          result.cy = (1 - ratio) * sourceEndPointY + ratio * targetEndPointY;\n        } else {\n          result.cx = (1 - ratio) * targetEndPointX + ratio * sourceEndPointX;\n          result.cy = (1 - ratio) * targetEndPointY + ratio * sourceEndPointY;\n        }\n\n        return result;\n      };\n\n      var edges = node.connectedEdges();\n      var desiredDistance = (node.height() > node.width() ? node.height() : node.width()) * 0.1;\n\n      for (var i = 1; i < edges.length; i++) {\n        var edge = edges[i];\n        var index = i;\n        var edgeClone = edge.clone();\n        var startPosition = edge.source().id() == node.id() ? \"source\" : \"target\";\n        var newPosition = claculateNewClonePosition(edge.sourceEndpoint().x, edge.sourceEndpoint().y, edge.targetEndpoint().x, edge.targetEndpoint().y, desiredDistance, startPosition);\n        var newNodeId = node.id() + 'clone-' + index; //edgeClone.data().id = edgeClone.data().id+ \"-\"+newNodeId;\n\n        if (edge.source().id() == node.id()) {\n          edgeClone.data().source = newNodeId;\n          edgeClone.data().portsource = newNodeId;\n        } else {\n          edgeClone.data().target = newNodeId;\n          edgeClone.data().porttarget = newNodeId;\n        }\n\n        var newNode = node.clone();\n        newNode.data().id = newNodeId;\n        cy.add(newNode);\n        edge.remove();\n        cy.add(edgeClone);\n        newNode.position({\n          x: newPosition.cx,\n          y: newPosition.cy\n        });\n        elementUtilities.setCloneMarkerStatus(newNode, true);\n      }\n\n      var newPosition = claculateNewClonePosition(edges[0].sourceEndpoint().x, edges[0].sourceEndpoint().y, edges[0].targetEndpoint().x, edges[0].targetEndpoint().y, desiredDistance, edges[0].source().id() == node.id() ? \"source\" : \"target\");\n      var cloneEdge = edges[0].clone(); //cloneEdge.data().id = cloneEdge.data().id+ \"-\"+node.id()+'clone-0';\n\n      edges[0].remove();\n      cy.add(cloneEdge);\n      elementUtilities.setCloneMarkerStatus(node, true);\n      node.position({\n        x: newPosition.cx,\n        y: newPosition.cy\n      });\n      result.oldX = oldX;\n      result.oldY = oldY;\n      result.node = node;\n      result.numberOfEdges = edges.length;\n      return result;\n    };\n\n    undoRedoActionFunctions.unCloneHighDegreeNode = function (param) {\n      var node = param.node;\n      elementUtilities.setCloneMarkerStatus(node, false);\n      node.position({\n        x: param.oldX,\n        y: param.oldY\n      });\n\n      for (var i = 1; i < param.numberOfEdges; i++) {\n        var cloneId = node.id() + 'clone-' + i;\n        var clone = cy.$(\"#\" + cloneId);\n        var cloneEdge = clone.connectedEdges()[0];\n        var edge = cloneEdge.clone();\n\n        if (edge.data().source == cloneId) {\n          edge.data().source = node.id();\n          edge.data().portsource = node.id();\n        } else {\n          edge.data().target = node.id();\n          edge.data().porttarget = node.id();\n        }\n\n        cloneEdge.remove();\n        clone.remove();\n        cy.add(edge);\n      }\n\n      return node;\n    };\n\n    undoRedoActionFunctions.changeMapType = function (param) {\n      var result = {};\n      var currentMapType = elementUtilities.getMapType();\n      elementUtilities.setMapType(param.mapType);\n      result.mapType = currentMapType;\n      result.callback = param.callback;\n      param.callback();\n      return result;\n    };\n  }\n\n  return undoRedoActionFunctionsExtender;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jaGlzZS8uL3NyYy91dGlsaXRpZXMvdXItYWN0aW9uLWZ1bmN0aW9ucy1leHRlbmRlci1mYWN0b3J5LmpzPzNiNTciXSwibmFtZXMiOlsibGlicyIsInJlcXVpcmUiLCJtb2R1bGUiLCJleHBvcnRzIiwic2JnbnZpekluc3RhbmNlIiwidW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMiLCJlbGVtZW50VXRpbGl0aWVzIiwiY3kiLCJ0b3BvbG9neUdyb3VwaW5nIiwidW5kb1JlZG9BY3Rpb25GdW5jdGlvbnNFeHRlbmRlciIsInBhcmFtIiwic2JnbnZpekluc3RhbmNlVXRpbGl0aWVzIiwiZ2V0SW5zdGFuY2UiLCJnZXRDeSIsInNpZlRvcG9sb2d5R3JvdXBpbmciLCJleHRlbmQiLCJhcHBseVNJRlRvcG9sb2d5R3JvdXBpbmciLCJvbGRFbGVzIiwibmV3RWxlcyIsImZpcnN0VGltZSIsImVsZW1lbnRzIiwiYXBwbHkiLCJ1bmFwcGx5IiwiaXNHcmFwaFRvcG9sb2d5TG9ja2VkIiwidW5sb2NrR3JhcGhUb3BvbG9neSIsImxvY2tHcmFwaFRvcG9sb2d5IiwicmVtb3ZlIiwicmVzdG9yZSIsInRvZ2dsZUFwcGxpZWRGbGFnIiwicmVzdWx0IiwiYWRkTm9kZSIsIm5ld05vZGUiLCJ4IiwieSIsImlkIiwicGFyZW50IiwidmlzaWJpbGl0eSIsInJlc3RvcmVFbGVzIiwiZWxlcyIsImFkZEVkZ2UiLCJuZXdFZGdlIiwic291cmNlIiwidGFyZ2V0IiwiYWRkUHJvY2Vzc1dpdGhDb252ZW5pZW50RWRnZXMiLCJwcm9jZXNzVHlwZSIsImNyZWF0ZUNvbXBvdW5kRm9yR2l2ZW5Ob2RlcyIsIm5vZGVzVG9NYWtlQ29tcG91bmQiLCJyZW1vdmVkRWxlcyIsInVuaW9uIiwiZGVzY2VuZGFudHMiLCJjb25uZWN0ZWRFZGdlcyIsIm9sZFBhcmVudElkIiwiZGF0YSIsImNvbXBvdW5kVHlwZSIsIm1haW50YWluUG9pbnRlciIsImNyZWF0ZVRlbXBsYXRlUmVhY3Rpb24iLCJ0ZW1wbGF0ZVR5cGUiLCJtYWNyb21vbGVjdWxlTGlzdCIsImNvbXBsZXhOYW1lIiwicHJvY2Vzc1Bvc2l0aW9uIiwidGlsaW5nUGFkZGluZ1ZlcnRpY2FsIiwidGlsaW5nUGFkZGluZ0hvcml6b250YWwiLCJlZGdlTGVuZ3RoIiwibGF5b3V0UGFyYW0iLCJhZGQiLCJ1bnNlbGVjdCIsInNlbGVjdCIsImNyZWF0ZUFjdGl2YXRpb25SZWFjdGlvbiIsInByb3RlaW5OYW1lIiwicmV2ZXJzZSIsImNyZWF0ZVRyYW5zbGF0aW9uIiwicmVndWxhdG9yTGFiZWwiLCJvdXRwdXRMYWJlbCIsIm9yaWVudGF0aW9uIiwiY3JlYXRlVHJhbnNjcmlwdGlvbiIsImxhYmVsIiwiY3JlYXRlRGVncmFkYXRpb24iLCJtYWNyb21vbGVjdWxlIiwiY3JlYXRlQ29tcGxleFByb3RlaW5Gb3JtYXRpb24iLCJwcm90ZWluTGFiZWxzIiwiY29tcGxleExhYmVsIiwicmVndWxhdG9yIiwiY3JlYXRlTXVsdGltZXJpemF0aW9uIiwicmVndWxhdG9yTXVsdGltZXIiLCJjcmVhdGVDb252ZXJzaW9uIiwiaW5wdXRJbmZvYm94TGFiZWxzIiwib3V0cHV0SW5mb2JveExhYmVscyIsImNyZWF0ZU1ldGFib2xpY1JlYWN0aW9uIiwiaW5wdXRzIiwib3V0cHV0cyIsInJldmVyc2libGUiLCJjcmVhdGVNZXRhYm9saWNDYXRhbHl0aWNBY3Rpdml0eSIsImlucHV0Tm9kZUxpc3QiLCJvdXRwdXROb2RlTGlzdCIsImNhdGFseXN0TmFtZSIsImNhdGFseXN0VHlwZSIsImNyZWF0ZVRyYW5zY3JpcHRpb25SZWFjdGlvbiIsImdlbmVOYW1lIiwibVJuYU5hbWUiLCJjcmVhdGVUcmFuc2xhdGlvblJlYWN0aW9uIiwiZ2V0Tm9kZVBvc2l0aW9ucyIsInBvc2l0aW9ucyIsIm5vZGVzIiwiZWFjaCIsImVsZSIsImkiLCJwb3NpdGlvbiIsInJldHVyblRvUG9zaXRpb25zIiwiY3VycmVudFBvc2l0aW9ucyIsInBvcyIsInJlc2l6ZU5vZGVzIiwicGVyZm9ybU9wZXJhdGlvbiIsInNpemVNYXAiLCJ1c2VBc3BlY3RSYXRpbyIsInByZXNlcnZlUmVsYXRpdmVQb3MiLCJsZW5ndGgiLCJub2RlIiwiaXNQYXJlbnQiLCJ3IiwiaCIsImJpYXNMIiwiYmlhc1IiLCJiaWFzVCIsImJpYXNCIiwid2lkdGgiLCJoZWlnaHQiLCJzdHlsZSIsInVwZGF0ZSIsImNoYW5nZU5vZGVMYWJlbCIsIl9wcml2YXRlIiwidXBkYXRlSW5mb2JveFN0eWxlIiwiaW5kZXgiLCJuZXdQcm9wcyIsIiQiLCJ1cGRhdGVJbmZvYm94T2JqIiwib2JqIiwiY2hhbmdlRGF0YSIsIm5hbWUiLCJ2YWx1ZU1hcCIsInVwZGF0ZVNldEZpZWxkIiwidXBkYXRlcyIsImZpZWxkTmFtZSIsInRvRGVsZXRlIiwidG9BZGQiLCJjYWxsYmFjayIsImFkZGVkIiwiZGVsZXRlZCIsImNoYW5nZUNzcyIsImNzcyIsImNoYW5nZUZvbnRQcm9wZXJ0aWVzIiwicHJvcCIsInNob3dBbmRQZXJmb3JtTGF5b3V0IiwibGF5b3V0cGFyYW0iLCJ2aWV3VXRpbGl0aWVzIiwic2hvdyIsInVuZG9TaG93QW5kUGVyZm9ybUxheW91dCIsImhpZGUiLCJoaWRlQW5kUGVyZm9ybUxheW91dCIsInVuZG9IaWRlQW5kUGVyZm9ybUxheW91dCIsImRlbGV0ZUFuZFBlcmZvcm1MYXlvdXQiLCJ1bmRvRGVsZXRlQW5kUGVyZm9ybUxheW91dCIsImNoYW5nZVN0YXRlT3JJbmZvQm94IiwidHlwZSIsInRlbXBEYXRhIiwic2F2ZVVuaXRzIiwidmFsdWUiLCJ1bmRlZmluZWQiLCJyZXN0b3JlVW5pdHMiLCJmb3JjZVJlbmRlciIsImFkZFN0YXRlT3JJbmZvQm94IiwibG9jYXRpb25PYmoiLCJyZW1vdmVTdGF0ZU9ySW5mb0JveCIsImZpdFVuaXRzIiwibG9jYXRpb25zIiwiZm9yRWFjaCIsImJveCIsImJib3giLCJvbGRTaWRlIiwiYW5jaG9yU2lkZSIsIm1vZGlmeVVuaXRzIiwic2V0TXVsdGltZXJTdGF0dXMiLCJzdGF0dXMiLCJyZXN1bHRTdGF0dXMiLCJpc011bHRpbWVyIiwiZW5kc1dpdGgiLCJzZXRDbG9uZU1hcmtlclN0YXR1cyIsImN1cnJlbnRTdGF0dXMiLCJzZXREZWZhdWx0UHJvcGVydHkiLCJzYmduY2xhc3MiLCJjbGFzc0RlZmF1bHRzIiwiZ2V0RGVmYXVsdFByb3BlcnRpZXMiLCJoYXNPd25Qcm9wZXJ0eSIsInByb3BNYXAiLCJzZXREZWZhdWx0UHJvcGVydGllcyIsImFkZEJhY2tncm91bmRJbWFnZSIsImJnT2JqIiwidXBkYXRlSW5mbyIsInByb21wdEludmFsaWRJbWFnZSIsInZhbGlkYXRlVVJMIiwicmVtb3ZlQmFja2dyb3VuZEltYWdlIiwidXBkYXRlQmFja2dyb3VuZEltYWdlIiwib2xkQmdPYmoiLCJjaGFuZ2VCYWNrZ3JvdW5kSW1hZ2UiLCJvbGRJbWciLCJuZXdJbWciLCJjb252ZXJ0SW50b1JldmVyc2libGVSZWFjdGlvbiIsImNvbGxlY3Rpb24iLCJtYXBUeXBlIiwiZ2V0TWFwVHlwZSIsInNldE1hcFR5cGUiLCJ2YWwiLCJlZGdlIiwic291cmNlTm9kZSIsInRhcmdldE5vZGUiLCJtb3ZlIiwiY29udmVydGVkRWRnZSIsImdldEVsZW1lbnRCeUlkIiwiZGlzdGFuY2UiLCJtYXAiLCJlbGVtZW50Iiwid2VpZ2h0IiwicG9ydHNvdXJjZSIsInBvcnR0YXJnZXQiLCJwcm9jZXNzSWQiLCJtb3ZlRWRnZSIsImZpeEVycm9yIiwiZXJyb3JDb2RlIiwicmV2ZXJzZUVkZ2UiLCJuZXdOb2RlcyIsIm5ld0VkZ2VzIiwib2xkRWRnZXMiLCJvbGRFZGdlIiwiZWRnZXMiLCJuZXdTb3VyY2UiLCJuZXdUYXJnZXQiLCJjbG9uZWRFZGdlIiwiY2xvbmUiLCJlZGdlUGFyYW1zIiwibGFuZ3VhZ2UiLCJuZXdQYXJlbnRJZCIsInBhcmVudERhdGEiLCJ3aXRoRGVzY2VuZGFudCIsImVsZXNUb1Jlc3RvcmUiLCJtb3ZlZEVsZXMiLCJwb3NEaWZmIiwicG9zRGlmZlgiLCJwb3NEaWZmWSIsIm1vdmVOb2RlcyIsImVkZ2VjbGFzcyIsInZhbGlkYXRpb24iLCJ2YWxpZGF0ZUFycm93RW5kcyIsInRlbXAiLCJ1bmZpeEVycm9yIiwiYW5pbWF0ZSIsImR1cmF0aW9uIiwiZWFzaW5nIiwiZml0IiwicGFkZGluZyIsImNvbXBsZXRlIiwiY2xvbmVIaWdoRGVncmVlTm9kZSIsIm9sZFgiLCJvbGRZIiwiY2xhY3VsYXRlTmV3Q2xvbmVQb3NpdGlvbiIsInNvdXJjZUVuZFBvaW50WCIsInNvdXJjZUVuZFBvaW50WSIsInRhcmdldEVuZFBvaW50WCIsInRhcmdldEVuZFBvaW50WSIsImRlc2lyZWREaXN0YW5jZSIsImRpcmVjdGlvbiIsIk1hdGgiLCJzcXJ0IiwicG93IiwicmF0aW8iLCJjeCIsImVkZ2VDbG9uZSIsInN0YXJ0UG9zaXRpb24iLCJuZXdQb3NpdGlvbiIsInNvdXJjZUVuZHBvaW50IiwidGFyZ2V0RW5kcG9pbnQiLCJuZXdOb2RlSWQiLCJjbG9uZUVkZ2UiLCJudW1iZXJPZkVkZ2VzIiwidW5DbG9uZUhpZ2hEZWdyZWVOb2RlIiwiY2xvbmVJZCIsImNoYW5nZU1hcFR5cGUiLCJjdXJyZW50TWFwVHlwZSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxJQUFJQSxJQUFJLEdBQUdDLHNGQUFBLEVBQVg7O0FBRUFDLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQixZQUFZO0FBRTNCLE1BQUlDLGVBQUosRUFBcUJDLHVCQUFyQixFQUE4Q0MsZ0JBQTlDLEVBQWdFQyxFQUFoRSxFQUFvRUMsZ0JBQXBFOztBQUVBLFdBQVNDLCtCQUFULENBQTBDQyxLQUExQyxFQUFpRDtBQUUvQ04sbUJBQWUsR0FBR00sS0FBSyxDQUFDQyx3QkFBTixDQUErQkMsV0FBL0IsRUFBbEI7QUFDQUwsTUFBRSxHQUFHRyxLQUFLLENBQUNDLHdCQUFOLENBQStCRSxLQUEvQixFQUFMO0FBQ0FSLDJCQUF1QixHQUFHRCxlQUFlLENBQUNDLHVCQUExQztBQUNBQyxvQkFBZ0IsR0FBR0ksS0FBSyxDQUFDSixnQkFBekI7QUFDQUUsb0JBQWdCLEdBQUdFLEtBQUss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QXhCO0FBQ0F0SSxXQUFLLENBQUNzSSxRQUFOO0FBQ0EsYUFBT25ILE1BQVA7QUFDRCxLQVJEO0FBVUM7O0FBRUQsU0FBT3BCLCtCQUFQO0FBQ0QsQ0FoaEREIiwiZmlsZSI6Ii4vc3JjL3V0aWxpdGllcy91ci1hY3Rpb24tZnVuY3Rpb25zLWV4dGVuZGVyLWZhY3RvcnkuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBFeHRlbmRzIHNiZ252aXoudW5kb1JlZG9BY3Rpb25GdW5jdGlvbnNcbnZhciBsaWJzID0gcmVxdWlyZSgnLi9saWItdXRpbGl0aWVzJykuZ2V0TGlicygpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcblxuICB2YXIgc2JnbnZpekluc3RhbmNlLCB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucywgZWxlbWVudFV0aWxpdGllcywgY3ksIHRvcG9sb2d5R3JvdXBpbmc7XG5cbiAgZnVuY3Rpb24gdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnNFeHRlbmRlciAocGFyYW0pIHtcblxuICAgIHNiZ252aXpJbnN0YW5jZSA9IHBhcmFtLnNiZ252aXpJbnN0YW5jZVV0aWxpdGllcy5nZXRJbnN0YW5jZSgpO1xuICAgIGN5ID0gcGFyYW0uc2JnbnZpekluc3RhbmNlVXRpbGl0aWVzLmdldEN5KCk7XG4gICAgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMgPSBzYmdudml6SW5zdGFuY2UudW5kb1JlZG9BY3Rpb25GdW5jdGlvbnM7XG4gICAgZWxlbWVudFV0aWxpdGllcyA9IHBhcmFtLmVsZW1lbnRVdGlsaXRpZXM7XG4gICAgdG9wb2xvZ3lHcm91cGluZyA9IHBhcmFtLnNpZlRvcG9sb2d5R3JvdXBpbmc7XG5cbiAgICBleHRlbmQoKTtcbiAgfVxuXG4gIC8vIEV4dGVuZHMgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMgd2l0aCBjaGlzZSBzcGVjaWZpYyBmZWF0dXJlc1xuICBmdW5jdGlvbiBleHRlbmQgKCkge1xuXG4gICAgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMuYXBwbHlTSUZUb3BvbG9neUdyb3VwaW5nID0gZnVuY3Rpb24ocGFyYW0pIHtcbiAgICAgIHZhciBvbGRFbGVzLCBuZXdFbGVzO1xuICAgICAgaWYgKCBwYXJhbS5maXJzdFRpbWUgKSB7XG4gICAgICAgIG9sZEVsZXMgPSBjeS5lbGVtZW50cygpO1xuXG4gICAgICAgIGlmIChwYXJhbS5hcHBseSkge1xuICAgICAgICAgIHRvcG9sb2d5R3JvdXBpbmcuYXBwbHkoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB0b3BvbG9neUdyb3VwaW5nLnVuYXBwbHkoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5ld0VsZXMgPSBjeS5lbGVtZW50cygpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG9sZEVsZXMgPSBwYXJhbS5vbGRFbGVzO1xuICAgICAgICBuZXdFbGVzID0gcGFyYW0ubmV3RWxlcztcblxuICAgICAgICBpZiAoIGVsZW1lbnRVdGlsaXRpZXMuaXNHcmFwaFRvcG9sb2d5TG9ja2VkKCkgKSB7XG4gICAgICAgICAgZWxlbWVudFV0aWxpdGllcy51bmxvY2tHcmFwaFRvcG9sb2d5KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZWxlbWVudFV0aWxpdGllcy5sb2NrR3JhcGhUb3BvbG9neSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgb2xkRWxlcy5yZW1vdmUoKTtcbiAgICAgICAgbmV3RWxlcy5yZXN0b3JlKCk7XG5cbiAgICAgICAgdG9wb2xvZ3lHcm91cGluZy50b2dnbGVBcHBsaWVkRmxhZygpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVzdWx0ID0geyBvbGRFbGVzOiBuZXdFbGVzLCBuZXdFbGVzOiBvbGRFbGVzIH07XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICAvLyBTZWN0aW9uIFN0YXJ0XG4gICAgLy8gYWRkL3JlbW92ZSBhY3Rpb24gZnVuY3Rpb25zXG5cbiAgICB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5hZGROb2RlID0gZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgICB2YXIgcmVzdWx0O1xuICAgICAgaWYgKHBhcmFtLmZpcnN0VGltZSkge1xuICAgICAgICB2YXIgbmV3Tm9kZSA9IHBhcmFtLm5ld05vZGU7XG4gICAgICAgIHJlc3VsdCA9IGVsZW1lbnRVdGlsaXRpZXMuYWRkTm9kZShuZXdOb2RlLngsIG5ld05vZGUueSwgbmV3Tm9kZS5jbGFzcywgbmV3Tm9kZS5pZCwgbmV3Tm9kZS5wYXJlbnQsIG5ld05vZGUudmlzaWJpbGl0eSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gZWxlbWVudFV0aWxpdGllcy5yZXN0b3JlRWxlcyhwYXJhbSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVsZXM6IHJlc3VsdFxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMuYWRkRWRnZSA9IGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgdmFyIHJlc3VsdDtcbiAgICAgIGlmIChwYXJhbS5maXJzdFRpbWUpIHtcbiAgICAgICAgdmFyIG5ld0VkZ2UgPSBwYXJhbS5uZXdFZGdlO1xuICAgICAgICByZXN1bHQgPSBlbGVtZW50VXRpbGl0aWVzLmFkZEVkZ2UobmV3RWRnZS5zb3VyY2UsIG5ld0VkZ2UudGFyZ2V0LCBuZXdFZGdlLmNsYXNzLCBuZXdFZGdlLmlkLCBuZXdFZGdlLnZpc2liaWxpdHkpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IGVsZW1lbnRVdGlsaXRpZXMucmVzdG9yZUVsZXMocGFyYW0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBlbGVzOiByZXN1bHRcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLmFkZFByb2Nlc3NXaXRoQ29udmVuaWVudEVkZ2VzID0gZnVuY3Rpb24ocGFyYW0pIHtcbiAgICAgIHZhciByZXN1bHQ7XG4gICAgICBpZiAocGFyYW0uZmlyc3RUaW1lKSB7XG4gICAgICAgIHJlc3VsdCA9IGVsZW1lbnRVdGlsaXRpZXMuYWRkUHJvY2Vzc1dpdGhDb252ZW5pZW50RWRnZXMocGFyYW0uc291cmNlLCBwYXJhbS50YXJnZXQsIHBhcmFtLnByb2Nlc3NUeXBlKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBlbGVtZW50VXRpbGl0aWVzLnJlc3RvcmVFbGVzKHBhcmFtKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZWxlczogcmVzdWx0XG4gICAgICB9O1xuICAgIH07XG5cbiAgICB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5jcmVhdGVDb21wb3VuZEZvckdpdmVuTm9kZXMgPSBmdW5jdGlvbiAocGFyYW0pIHtcbiAgICAgIHZhciByZXN1bHQgPSB7fTtcblxuICAgICAgaWYgKHBhcmFtLmZpcnN0VGltZSkge1xuICAgICAgICAvLyBOb2RlcyB0byBtYWtlIGNvbXBvdW5kLCB0aGVpciBkZXNjZW5kYW50cyBhbmQgZWRnZXMgY29ubmVjdGVkIHRvIHRoZW0gd2lsbCBiZSByZW1vdmVkIGR1cmluZyBjcmVhdGVDb21wb3VuZEZvckdpdmVuTm9kZXMgb3BlcmF0aW9uXG4gICAgICAgIC8vIChpbnRlcm5hbGx5IGJ5IGVsZXMubW92ZSgpIG9wZXJhdGlvbiksIHNvIG1hcmsgdGhlbSBhcyByZW1vdmVkIGVsZXMgZm9yIHVuZG8gb3BlcmF0aW9uLlxuICAgICAgICB2YXIgbm9kZXNUb01ha2VDb21wb3VuZCA9IHBhcmFtLm5vZGVzVG9NYWtlQ29tcG91bmQ7XG4gICAgICAgIHZhciByZW1vdmVkRWxlcyA9IG5vZGVzVG9NYWtlQ29tcG91bmQudW5pb24obm9kZXNUb01ha2VDb21wb3VuZC5kZXNjZW5kYW50cygpKTtcbiAgICAgICAgcmVtb3ZlZEVsZXMgPSByZW1vdmVkRWxlcy51bmlvbihyZW1vdmVkRWxlcy5jb25uZWN0ZWRFZGdlcygpKTtcbiAgICAgICAgcmVzdWx0LnJlbW92ZWRFbGVzID0gcmVtb3ZlZEVsZXM7XG4gICAgICAgIC8vIEFzc3VtZSB0aGF0IGFsbCBub2RlcyB0byBtYWtlIGNvbXBvdW5kIGhhdmUgdGhlIHNhbWUgcGFyZW50XG4gICAgICAgIHZhciBvbGRQYXJlbnRJZCA9IG5vZGVzVG9NYWtlQ29tcG91bmRbMF0uZGF0YShcInBhcmVudFwiKTtcbiAgICAgICAgLy8gVGhlIHBhcmVudCBvZiBuZXcgY29tcG91bmQgd2lsbCBiZSB0aGUgb2xkIHBhcmVudCBvZiB0aGUgbm9kZXMgdG8gbWFrZSBjb21wb3VuZFxuICAgICAgICAvLyBOZXcgZWxlcyBpbmNsdWRlcyBuZXcgY29tcG91bmQgYW5kIHRoZSBtb3ZlZCBlbGVzIGFuZCB3aWxsIGJlIHVzZWQgaW4gdW5kbyBvcGVyYXRpb24uXG4gICAgICAgIHJlc3VsdC5uZXdFbGVzID0gZWxlbWVudFV0aWxpdGllcy5jcmVhdGVDb21wb3VuZEZvckdpdmVuTm9kZXMobm9kZXNUb01ha2VDb21wb3VuZCwgcGFyYW0uY29tcG91bmRUeXBlKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQucmVtb3ZlZEVsZXMgPSBwYXJhbS5uZXdFbGVzLnJlbW92ZSgpO1xuICAgICAgICByZXN1bHQubmV3RWxlcyA9IHBhcmFtLnJlbW92ZWRFbGVzLnJlc3RvcmUoKTtcbiAgICAgICAgZWxlbWVudFV0aWxpdGllcy5tYWludGFpblBvaW50ZXIocmVzdWx0Lm5ld0VsZXMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICAvLyBTZWN0aW9uIEVuZFxuICAgIC8vIGFkZC9yZW1vdmUgYWN0aW9uIGZ1bmN0aW9uc1xuXG4gICAgLy8gU2VjdGlvbiBTdGFydFxuICAgIC8vIGVhc3kgY3JlYXRpb24gYWN0aW9uIGZ1bmN0aW9uc1xuXG4gICAgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMuY3JlYXRlVGVtcGxhdGVSZWFjdGlvbiA9IGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgdmFyIGZpcnN0VGltZSA9IHBhcmFtLmZpcnN0VGltZTtcbiAgICAgIHZhciBlbGVzO1xuXG4gICAgICBpZiAoZmlyc3RUaW1lKSB7XG4gICAgICAgIGVsZXMgPSBlbGVtZW50VXRpbGl0aWVzLmNyZWF0ZVRlbXBsYXRlUmVhY3Rpb24ocGFyYW0udGVtcGxhdGVUeXBlLCBwYXJhbS5tYWNyb21vbGVjdWxlTGlzdCwgcGFyYW0uY29tcGxleE5hbWUsIHBhcmFtLnByb2Nlc3NQb3NpdGlvbiwgcGFyYW0udGlsaW5nUGFkZGluZ1ZlcnRpY2FsLCBwYXJhbS50aWxpbmdQYWRkaW5nSG9yaXpvbnRhbCwgcGFyYW0uZWRnZUxlbmd0aCwgcGFyYW0ubGF5b3V0UGFyYW0pXG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZWxlcyA9IHBhcmFtO1xuICAgICAgICBjeS5hZGQoZWxlcyk7XG5cbiAgICAgICAgY3kuZWxlbWVudHMoKS51bnNlbGVjdCgpO1xuICAgICAgICBlbGVzLnNlbGVjdCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBlbGVzOiBlbGVzXG4gICAgICB9O1xuICAgIH07XG5cbiAgICB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5jcmVhdGVBY3RpdmF0aW9uUmVhY3Rpb24gPSBmdW5jdGlvbihwYXJhbSkge1xuICAgICAgdmFyIGZpcnN0VGltZSA9IHBhcmFtLmZpcnN0VGltZTtcbiAgICAgIHZhciBlbGVzO1xuXG4gICAgICBpZiAoZmlyc3RUaW1lKSB7XG4gICAgICAgIGVsZXMgPSBlbGVtZW50VXRpbGl0aWVzLmNyZWF0ZUFjdGl2YXRpb25SZWFjdGlvbihwYXJhbS5wcm90ZWluTmFtZSwgcGFyYW0ucHJvY2Vzc1Bvc2l0aW9uLCBwYXJhbS5lZGdlTGVuZ3RoLCBwYXJhbS5yZXZlcnNlKVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGVsZXMgPSBwYXJhbTtcbiAgICAgICAgY3kuYWRkKGVsZXMpO1xuXG4gICAgICAgIGN5LmVsZW1lbnRzKCkudW5zZWxlY3QoKTtcbiAgICAgICAgZWxlcy5zZWxlY3QoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZWxlczogZWxlc1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMuY3JlYXRlVHJhbnNsYXRpb24gPSBmdW5jdGlvbihwYXJhbSkge1xuICAgICAgbGV0IGZpcnN0VGltZSA9IHBhcmFtLmZpcnN0VGltZTtcbiAgICAgIGxldCBlbGVzO1xuXG4gICAgICBpZiAoZmlyc3RUaW1lKSB7XG4gICAgICAgIGVsZXMgPSBlbGVtZW50VXRpbGl0aWVzLmNyZWF0ZVRyYW5zbGF0aW9uKHBhcmFtLnJlZ3VsYXRvckxhYmVsLCBwYXJhbS5vdXRwdXRMYWJlbCwgcGFyYW0ub3JpZW50YXRpb24pO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGVsZXMgPSBwYXJhbTtcbiAgICAgICAgY3kuYWRkKGVsZXMpO1xuXG4gICAgICAgIGN5LmVsZW1lbnRzKCkudW5zZWxlY3QoKTtcbiAgICAgICAgZWxlcy5zZWxlY3QoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZWxlczogZWxlc1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMuY3JlYXRlVHJhbnNjcmlwdGlvbiA9IGZ1bmN0aW9uKHBhcmFtKSB7XG4gICAgICBsZXQgZmlyc3RUaW1lID0gcGFyYW0uZmlyc3RUaW1lO1xuICAgICAgbGV0IGVsZXM7XG5cbiAgICAgIGlmIChmaXJzdFRpbWUpIHtcbiAgICAgICAgZWxlcyA9IGVsZW1lbnRVdGlsaXRpZXMuY3JlYXRlVHJhbnNjcmlwdGlvbihwYXJhbS5sYWJlbCwgcGFyYW0ub3JpZW50YXRpb24pO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGVsZXMgPSBwYXJhbTtcbiAgICAgICAgY3kuYWRkKGVsZXMpO1xuXG4gICAgICAgIGN5LmVsZW1lbnRzKCkudW5zZWxlY3QoKTtcbiAgICAgICAgZWxlcy5zZWxlY3QoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZWxlczogZWxlc1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMuY3JlYXRlRGVncmFkYXRpb24gPSBmdW5jdGlvbihwYXJhbSkge1xuICAgICAgbGV0IGZpcnN0VGltZSA9IHBhcmFtLmZpcnN0VGltZTtcbiAgICAgIGxldCBlbGVzO1xuXG4gICAgICBpZiAoZmlyc3RUaW1lKSB7XG4gICAgICAgIGVsZXMgPSBlbGVtZW50VXRpbGl0aWVzLmNyZWF0ZURlZ3JhZGF0aW9uKHBhcmFtLm1hY3JvbW9sZWN1bGUsIHBhcmFtLm9yaWVudGF0aW9uKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBlbGVzID0gcGFyYW07XG4gICAgICAgIGN5LmFkZChlbGVzKTtcblxuICAgICAgICBjeS5lbGVtZW50cygpLnVuc2VsZWN0KCk7XG4gICAgICAgIGVsZXMuc2VsZWN0KCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVsZXM6IGVsZXNcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLmNyZWF0ZUNvbXBsZXhQcm90ZWluRm9ybWF0aW9uID0gZnVuY3Rpb24ocGFyYW0pIHtcbiAgICAgIGxldCBmaXJzdFRpbWUgPSBwYXJhbS5maXJzdFRpbWU7XG4gICAgICBsZXQgZWxlcztcblxuICAgICAgaWYgKGZpcnN0VGltZSkge1xuICAgICAgICBlbGVzID0gZWxlbWVudFV0aWxpdGllcy5jcmVhdGVDb21wbGV4UHJvdGVpbkZvcm1hdGlvbihwYXJhbS5wcm90ZWluTGFiZWxzLCBwYXJhbS5jb21wbGV4TGFiZWwsIHBhcmFtLnJlZ3VsYXRvciwgcGFyYW0ub3JpZW50YXRpb24sIHBhcmFtLnJldmVyc2UpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGVsZXMgPSBwYXJhbTtcbiAgICAgICAgY3kuYWRkKGVsZXMpO1xuXG4gICAgICAgIGN5LmVsZW1lbnRzKCkudW5zZWxlY3QoKTtcbiAgICAgICAgZWxlcy5zZWxlY3QoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZWxlczogZWxlc1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMuY3JlYXRlTXVsdGltZXJpemF0aW9uID0gZnVuY3Rpb24ocGFyYW0pIHtcbiAgICAgIGxldCBmaXJzdFRpbWUgPSBwYXJhbS5maXJzdFRpbWU7XG4gICAgICBsZXQgZWxlcztcblxuICAgICAgaWYgKGZpcnN0VGltZSkge1xuICAgICAgICBlbGVzID0gZWxlbWVudFV0aWxpdGllcy5jcmVhdGVNdWx0aW1lcml6YXRpb24ocGFyYW0ubWFjcm9tb2xlY3VsZSwgcGFyYW0ucmVndWxhdG9yLCBwYXJhbS5yZWd1bGF0b3JNdWx0aW1lciwgcGFyYW0ub3JpZW50YXRpb24pO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGVsZXMgPSBwYXJhbTtcbiAgICAgICAgY3kuYWRkKGVsZXMpO1xuXG4gICAgICAgIGN5LmVsZW1lbnRzKCkudW5zZWxlY3QoKTtcbiAgICAgICAgZWxlcy5zZWxlY3QoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZWxlczogZWxlc1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMuY3JlYXRlQ29udmVyc2lvbiA9IGZ1bmN0aW9uKHBhcmFtKSB7XG4gICAgICBsZXQgZmlyc3RUaW1lID0gcGFyYW0uZmlyc3RUaW1lO1xuICAgICAgbGV0IGVsZXM7XG5cbiAgICAgIGlmIChmaXJzdFRpbWUpIHtcbiAgICAgICAgZWxlcyA9IGVsZW1lbnRVdGlsaXRpZXMuY3JlYXRlQ29udmVyc2lvbihwYXJhbS5tYWNyb21vbGVjdWxlLCBwYXJhbS5yZWd1bGF0b3IsIHBhcmFtLnJlZ3VsYXRvck11bHRpbWVyLCBwYXJhbS5vcmllbnRhdGlvbiwgcGFyYW0uaW5wdXRJbmZvYm94TGFiZWxzLCBwYXJhbS5vdXRwdXRJbmZvYm94TGFiZWxzKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBlbGVzID0gcGFyYW07XG4gICAgICAgIGN5LmFkZChlbGVzKTtcblxuICAgICAgICBjeS5lbGVtZW50cygpLnVuc2VsZWN0KCk7XG4gICAgICAgIGVsZXMuc2VsZWN0KCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVsZXM6IGVsZXNcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLmNyZWF0ZU1ldGFib2xpY1JlYWN0aW9uID0gZnVuY3Rpb24ocGFyYW0pIHtcbiAgICAgIGxldCBmaXJzdFRpbWUgPSBwYXJhbS5maXJzdFRpbWU7XG4gICAgICBsZXQgZWxlcztcblxuICAgICAgaWYgKGZpcnN0VGltZSkge1xuICAgICAgICBlbGVzID0gZWxlbWVudFV0aWxpdGllcy5jcmVhdGVNZXRhYm9saWNSZWFjdGlvbihwYXJhbS5pbnB1dHMsIHBhcmFtLm91dHB1dHMsIHBhcmFtLnJldmVyc2libGUsIHBhcmFtLnJlZ3VsYXRvciwgcGFyYW0ucmVndWxhdG9yTXVsdGltZXIsIHBhcmFtLm9yaWVudGF0aW9uKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBlbGVzID0gcGFyYW07XG4gICAgICAgIGN5LmFkZChlbGVzKTtcblxuICAgICAgICBjeS5lbGVtZW50cygpLnVuc2VsZWN0KCk7XG4gICAgICAgIGVsZXMuc2VsZWN0KCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVsZXM6IGVsZXNcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLmNyZWF0ZU1ldGFib2xpY0NhdGFseXRpY0FjdGl2aXR5ID0gZnVuY3Rpb24ocGFyYW0pIHtcbiAgICAgIHZhciBmaXJzdFRpbWUgPSBwYXJhbS5maXJzdFRpbWU7XG4gICAgICB2YXIgZWxlcztcblxuICAgICAgaWYgKGZpcnN0VGltZSkge1xuICAgICAgICBlbGVzID0gZWxlbWVudFV0aWxpdGllcy5jcmVhdGVNZXRhYm9saWNDYXRhbHl0aWNBY3Rpdml0eShwYXJhbS5pbnB1dE5vZGVMaXN0LCBwYXJhbS5vdXRwdXROb2RlTGlzdCwgcGFyYW0uY2F0YWx5c3ROYW1lLCBwYXJhbS5jYXRhbHlzdFR5cGUsIHBhcmFtLnByb2Nlc3NQb3NpdGlvbiwgcGFyYW0udGlsaW5nUGFkZGluZ1ZlcnRpY2FsLCBwYXJhbS50aWxpbmdQYWRkaW5nSG9yaXpvbnRhbCwgcGFyYW0uZWRnZUxlbmd0aClcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBlbGVzID0gcGFyYW07XG4gICAgICAgIGN5LmFkZChlbGVzKTtcblxuICAgICAgICBjeS5lbGVtZW50cygpLnVuc2VsZWN0KCk7XG4gICAgICAgIGVsZXMuc2VsZWN0KCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVsZXM6IGVsZXNcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLmNyZWF0ZVRyYW5zY3JpcHRpb25SZWFjdGlvbiA9IGZ1bmN0aW9uKHBhcmFtKSB7XG4gICAgICB2YXIgZmlyc3RUaW1lID0gcGFyYW0uZmlyc3RUaW1lO1xuICAgICAgdmFyIGVsZXM7XG5cbiAgICAgIGlmIChmaXJzdFRpbWUpIHtcbiAgICAgICAgZWxlcyA9IGVsZW1lbnRVdGlsaXRpZXMuY3JlYXRlVHJhbnNjcmlwdGlvblJlYWN0aW9uKHBhcmFtLmdlbmVOYW1lLCBwYXJhbS5tUm5hTmFtZSwgcGFyYW0ucHJvY2Vzc1Bvc2l0aW9uLCBwYXJhbS5lZGdlTGVuZ3RoKVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGVsZXMgPSBwYXJhbTtcbiAgICAgICAgY3kuYWRkKGVsZXMpO1xuXG4gICAgICAgIGN5LmVsZW1lbnRzKCkudW5zZWxlY3QoKTtcbiAgICAgICAgZWxlcy5zZWxlY3QoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZWxlczogZWxlc1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMuY3JlYXRlVHJhbnNsYXRpb25SZWFjdGlvbiA9IGZ1bmN0aW9uKHBhcmFtKSB7XG4gICAgICB2YXIgZmlyc3RUaW1lID0gcGFyYW0uZmlyc3RUaW1lO1xuICAgICAgdmFyIGVsZXM7XG5cbiAgICAgIGlmIChmaXJzdFRpbWUpIHtcbiAgICAgICAgZWxlcyA9IGVsZW1lbnRVdGlsaXRpZXMuY3JlYXRlVHJhbnNsYXRpb25SZWFjdGlvbihwYXJhbS5tUm5hTmFtZSwgcGFyYW0ucHJvdGVpbk5hbWUsIHBhcmFtLnByb2Nlc3NQb3NpdGlvbiwgcGFyYW0uZWRnZUxlbmd0aClcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBlbGVzID0gcGFyYW07XG4gICAgICAgIGN5LmFkZChlbGVzKTtcblxuICAgICAgICBjeS5lbGVtZW50cygpLnVuc2VsZWN0KCk7XG4gICAgICAgIGVsZXMuc2VsZWN0KCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVsZXM6IGVsZXNcbiAgICAgIH07XG4gICAgfTtcblxuICAgIC8vIFNlY3Rpb24gRW5kXG4gICAgLy8gZWFzeSBjcmVhdGlvbiBhY3Rpb24gZnVuY3Rpb25zXG5cbiAgICAvLyBTZWN0aW9uIFN0YXJ0XG4gICAgLy8gZ2VuZXJhbCBhY3Rpb24gZnVuY3Rpb25zXG5cbiAgICB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5nZXROb2RlUG9zaXRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBvc2l0aW9ucyA9IHt9O1xuICAgICAgdmFyIG5vZGVzID0gY3kubm9kZXMoKTtcblxuICAgICAgbm9kZXMuZWFjaChmdW5jdGlvbihlbGUsIGkpIHtcbiAgICAgICAgaWYodHlwZW9mIGVsZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgIGVsZSA9IGk7XG4gICAgICAgIH1cblxuICAgICAgICBwb3NpdGlvbnNbZWxlLmlkKCldID0ge1xuICAgICAgICAgIHg6IGVsZS5wb3NpdGlvbihcInhcIiksXG4gICAgICAgICAgeTogZWxlLnBvc2l0aW9uKFwieVwiKVxuICAgICAgICB9O1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBwb3NpdGlvbnM7XG4gICAgfTtcblxuICAgIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLnJldHVyblRvUG9zaXRpb25zID0gZnVuY3Rpb24gKHBvc2l0aW9ucykge1xuICAgICAgdmFyIGN1cnJlbnRQb3NpdGlvbnMgPSB7fTtcbiAgICAgIGN5Lm5vZGVzKCkucG9zaXRpb25zKGZ1bmN0aW9uIChlbGUsIGkpIHtcbiAgICAgICAgaWYodHlwZW9mIGVsZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgIGVsZSA9IGk7XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50UG9zaXRpb25zW2VsZS5pZCgpXSA9IHtcbiAgICAgICAgICB4OiBlbGUucG9zaXRpb24oXCJ4XCIpLFxuICAgICAgICAgIHk6IGVsZS5wb3NpdGlvbihcInlcIilcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgcG9zID0gcG9zaXRpb25zW2VsZS5pZCgpXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiBwb3MueCxcbiAgICAgICAgICB5OiBwb3MueVxuICAgICAgICB9O1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBjdXJyZW50UG9zaXRpb25zO1xuICAgIH07XG5cbiAgICB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5yZXNpemVOb2RlcyA9IGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgcGVyZm9ybU9wZXJhdGlvbjogdHJ1ZVxuICAgICAgfTtcblxuICAgICAgdmFyIG5vZGVzID0gcGFyYW0ubm9kZXM7XG5cbiAgICAgIHJlc3VsdC5zaXplTWFwID0ge307XG4gICAgICByZXN1bHQudXNlQXNwZWN0UmF0aW8gPSBmYWxzZTtcbiAgICAgIHJlc3VsdC5wcmVzZXJ2ZVJlbGF0aXZlUG9zID0gcGFyYW0ucHJlc2VydmVSZWxhdGl2ZVBvcztcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICBpZihub2RlLmlzUGFyZW50KCkpe1xuICAgICAgICAgIHJlc3VsdC5zaXplTWFwW25vZGUuaWQoKV0gPSB7XG4gICAgICAgICAgICB3OiBub2RlLmRhdGEoXCJtaW5XaWR0aFwiKSB8fCAwLFxuICAgICAgICAgICAgaDogbm9kZS5kYXRhKFwibWluSGVpZ2h0XCIpIHx8IDAsXG4gICAgICAgICAgICBiaWFzTCA6IG5vZGUuZGF0YShcIm1pbldpZHRoQmlhc0xlZnRcIikgfHwgMCxcbiAgICAgICAgICAgIGJpYXNSIDogbm9kZS5kYXRhKFwibWluV2lkdGhCaWFzUmlnaHRcIikgfHwgMCxcbiAgICAgICAgICAgIGJpYXNUIDogbm9kZS5kYXRhKFwibWluSGVpZ2h0Qmlhc1RvcFwiKSB8fCAwLFxuICAgICAgICAgICAgYmlhc0IgOiBub2RlLmRhdGEoXCJtaW5IZWlnaHRCaWFzQm90dG9tXCIpIHx8IDBcbiAgICAgICAgICAgLy8gdzogbm9kZS5jc3MoXCJtaW5XaWR0aFwiKSAhPSAwPyAgbm9kZS5kYXRhKFwibWluV2lkdGhcIikgOiBub2RlLmNoaWxkcmVuKCkuYm91bmRpbmdCb3goKS53LFxuICAgICAgICAgICAgLy9oOiBub2RlLmNzcyhcIm1pbi1oZWlnaHRcIikgIT0gMD8gIG5vZGUuZGF0YShcIm1pbkhlaWdodFwiKSA6IG5vZGUuY2hpbGRyZW4oKS5ib3VuZGluZ0JveCgpLmhcbiAgICAgICAgICB9O1xuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICByZXN1bHQuc2l6ZU1hcFtub2RlLmlkKCldID0ge1xuICAgICAgICAgICAgdzogbm9kZS53aWR0aCgpLFxuICAgICAgICAgICAgaDogbm9kZS5oZWlnaHQoKVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICB9XG5cbiAgICAgIHJlc3VsdC5ub2RlcyA9IG5vZGVzO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG5cbiAgICAgICAgaWYgKHBhcmFtLnBlcmZvcm1PcGVyYXRpb24pIHtcbiAgICAgICAgICBpZiAocGFyYW0uc2l6ZU1hcCkge1xuICAgICAgICAgICAgLyogaWYgKHBhcmFtLnByZXNlcnZlUmVsYXRpdmVQb3MgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgdmFyIG9sZFdpZHRoID0gbm9kZS5kYXRhKFwiYmJveFwiKS53O1xuICAgICAgICAgICAgICB2YXIgb2xkSGVpZ2h0ID0gbm9kZS5kYXRhKFwiYmJveFwiKS5oO1xuICAgICAgICAgICAgfSAqL1xuXG4gICAgICAgICAgICBpZihub2RlLmlzUGFyZW50KCkpe1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgbm9kZS5kYXRhKFwibWluSGVpZ2h0XCIgLCBwYXJhbS5zaXplTWFwW25vZGUuaWQoKV0uaCk7XG4gICAgICAgICAgICAgIG5vZGUuZGF0YShcIm1pbldpZHRoXCIgLCBwYXJhbS5zaXplTWFwW25vZGUuaWQoKV0udyk7XG4gICAgICAgICAgICAgIG5vZGUuZGF0YShcIm1pbldpZHRoQmlhc0xlZnRcIiwgcGFyYW0uc2l6ZU1hcFtub2RlLmlkKCldLmJpYXNMKTtcbiAgICAgICAgICAgICAgbm9kZS5kYXRhKFwibWluV2lkdGhCaWFzUmlnaHRcIiwgcGFyYW0uc2l6ZU1hcFtub2RlLmlkKCldLmJpYXNSKTtcbiAgICAgICAgICAgICAgbm9kZS5kYXRhKFwibWluSGVpZ2h0Qmlhc1RvcFwiLCBwYXJhbS5zaXplTWFwW25vZGUuaWQoKV0uYmlhc1QpO1xuICAgICAgICAgICAgICBub2RlLmRhdGEoXCJtaW5IZWlnaHRCaWFzQm90dG9tXCIsIHBhcmFtLnNpemVNYXBbbm9kZS5pZCgpXS5iaWFzQik7XG5cbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICBub2RlLmRhdGEoXCJiYm94XCIpLncgPSBwYXJhbS5zaXplTWFwW25vZGUuaWQoKV0udztcbiAgICAgICAgICAgICAgbm9kZS5kYXRhKFwiYmJveFwiKS5oID0gcGFyYW0uc2l6ZU1hcFtub2RlLmlkKCldLmg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgIFxuXG4gICAgICAgICAgICAvKiBpZiAocGFyYW0ucHJlc2VydmVSZWxhdGl2ZVBvcyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICB2YXIgc3RhdGVzYW5kaW5mb3MgPSBub2RlLmRhdGEoJ3N0YXRlc2FuZGluZm9zJyk7XG4gICAgICAgICAgICAgIHZhciB0b3BCb3R0b20gPSBzdGF0ZXNhbmRpbmZvcy5maWx0ZXIoYm94ID0+IChib3guYW5jaG9yU2lkZSA9PT0gXCJ0b3BcIiB8fCBib3guYW5jaG9yU2lkZSA9PT0gXCJib3R0b21cIikpO1xuICAgICAgICAgICAgICB2YXIgcmlnaHRMZWZ0ID0gc3RhdGVzYW5kaW5mb3MuZmlsdGVyKGJveCA9PiAoYm94LmFuY2hvclNpZGUgPT09IFwicmlnaHRcIiB8fCBib3guYW5jaG9yU2lkZSA9PT0gXCJsZWZ0XCIpKTtcblxuICAgICAgICAgICAgICB0b3BCb3R0b20uZm9yRWFjaChmdW5jdGlvbihib3gpe1xuICAgICAgICAgICAgICAgIGlmIChib3guYmJveC54IDwgMCkge1xuICAgICAgICAgICAgICAgICAgYm94LmJib3gueCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGJveC5iYm94LnggPiBvbGRXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgYm94LmJib3gueCA9IG9sZFdpZHRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBib3guYmJveC54ID0gbm9kZS5kYXRhKFwiYmJveFwiKS53ICogYm94LmJib3gueCAvIG9sZFdpZHRoO1xuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICByaWdodExlZnQuZm9yRWFjaChmdW5jdGlvbihib3gpe1xuICAgICAgICAgICAgICAgIGlmIChib3guYmJveC55IDwgMCkge1xuICAgICAgICAgICAgICAgICAgYm94LmJib3gueSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGJveC5iYm94LnkgPiBvbGRIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgIGJveC5iYm94LnkgPSBvbGRIZWlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJveC5iYm94LnkgPSBub2RlLmRhdGEoXCJiYm94XCIpLmggKiBib3guYmJveC55IC8gb2xkSGVpZ2h0O1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gKi9cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbGVtZW50VXRpbGl0aWVzLnJlc2l6ZU5vZGVzKHBhcmFtLm5vZGVzLCBwYXJhbS53aWR0aCwgcGFyYW0uaGVpZ2h0LCBwYXJhbS51c2VBc3BlY3RSYXRpbywgcGFyYW0ucHJlc2VydmVSZWxhdGl2ZVBvcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjeS5zdHlsZSgpLnVwZGF0ZSgpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMuY2hhbmdlTm9kZUxhYmVsID0gZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgfTtcbiAgICAgIHZhciBub2RlcyA9IHBhcmFtLm5vZGVzO1xuICAgICAgcmVzdWx0Lm5vZGVzID0gbm9kZXM7XG4gICAgICByZXN1bHQubGFiZWwgPSB7fTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICByZXN1bHQubGFiZWxbbm9kZS5pZCgpXSA9IG5vZGUuX3ByaXZhdGUuZGF0YS5sYWJlbDtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmFtLmZpcnN0VGltZSkge1xuICAgICAgICBub2Rlcy5kYXRhKCdsYWJlbCcsIHBhcmFtLmxhYmVsKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgICBub2RlLl9wcml2YXRlLmRhdGEubGFiZWwgPSBwYXJhbS5sYWJlbFtub2RlLmlkKCldO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLnVwZGF0ZUluZm9ib3hTdHlsZSA9IGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgIH07XG4gICAgICB2YXIgc3R5bGUgPSBwYXJhbS5ub2RlLmRhdGEoJ3N0YXRlc2FuZGluZm9zJylbcGFyYW0uaW5kZXhdLnN0eWxlO1xuICAgICAgcmVzdWx0Lm5ld1Byb3BzID0gJC5leHRlbmQoIHt9LCBzdHlsZSApO1xuICAgICAgcmVzdWx0Lm5vZGUgPSBwYXJhbS5ub2RlO1xuICAgICAgcmVzdWx0LmluZGV4ID0gcGFyYW0uaW5kZXg7XG5cbiAgICAgIGVsZW1lbnRVdGlsaXRpZXMudXBkYXRlSW5mb2JveFN0eWxlKCBwYXJhbS5ub2RlLCBwYXJhbS5pbmRleCwgcGFyYW0ubmV3UHJvcHMgKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMudXBkYXRlSW5mb2JveE9iaiA9IGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgIH07XG4gICAgICB2YXIgb2JqID0gcGFyYW0ubm9kZS5kYXRhKCdzdGF0ZXNhbmRpbmZvcycpW3BhcmFtLmluZGV4XTtcbiAgICAgIHJlc3VsdC5uZXdQcm9wcyA9ICQuZXh0ZW5kKCB7fSwgb2JqICk7XG4gICAgICByZXN1bHQubm9kZSA9IHBhcmFtLm5vZGU7XG4gICAgICByZXN1bHQuaW5kZXggPSBwYXJhbS5pbmRleDtcblxuICAgICAgZWxlbWVudFV0aWxpdGllcy51cGRhdGVJbmZvYm94T2JqKCBwYXJhbS5ub2RlLCBwYXJhbS5pbmRleCwgcGFyYW0ubmV3UHJvcHMgKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMuY2hhbmdlRGF0YSA9IGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgIH07XG4gICAgICB2YXIgZWxlcyA9IHBhcmFtLmVsZXM7XG4gICAgICByZXN1bHQubmFtZSA9IHBhcmFtLm5hbWU7XG4gICAgICByZXN1bHQudmFsdWVNYXAgPSB7fTtcbiAgICAgIHJlc3VsdC5lbGVzID0gZWxlcztcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgICByZXN1bHQudmFsdWVNYXBbZWxlLmlkKCldID0gZWxlLmRhdGEocGFyYW0ubmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGVsZW1lbnRVdGlsaXRpZXMuY2hhbmdlRGF0YShwYXJhbS5lbGVzLCBwYXJhbS5uYW1lLCBwYXJhbS52YWx1ZU1hcCk7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLnVwZGF0ZVNldEZpZWxkID0gZnVuY3Rpb24oIHBhcmFtICkge1xuICAgICAgdmFyIHVwZGF0ZXMgPSBlbGVtZW50VXRpbGl0aWVzLnVwZGF0ZVNldEZpZWxkKCBwYXJhbS5lbGUsIHBhcmFtLmZpZWxkTmFtZSwgcGFyYW0udG9EZWxldGUsIHBhcmFtLnRvQWRkLCBwYXJhbS5jYWxsYmFjayApO1xuXG4gICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICBlbGU6IHBhcmFtLmVsZSxcbiAgICAgICAgZmllbGROYW1lOiBwYXJhbS5maWVsZE5hbWUsXG4gICAgICAgIGNhbGxiYWNrOiBwYXJhbS5jYWxsYmFjayxcbiAgICAgICAgdG9EZWxldGU6IHVwZGF0ZXMuYWRkZWQsXG4gICAgICAgIHRvQWRkOiB1cGRhdGVzLmRlbGV0ZWRcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLmNoYW5nZUNzcyA9IGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgIH07XG4gICAgICB2YXIgZWxlcyA9IHBhcmFtLmVsZXM7XG4gICAgICByZXN1bHQubmFtZSA9IHBhcmFtLm5hbWU7XG4gICAgICByZXN1bHQudmFsdWVNYXAgPSB7fTtcbiAgICAgIHJlc3VsdC5lbGVzID0gZWxlcztcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgICByZXN1bHQudmFsdWVNYXBbZWxlLmlkKCldID0gZWxlLmNzcyhwYXJhbS5uYW1lKTtcbiAgICAgIH1cblxuICAgICAgZWxlbWVudFV0aWxpdGllcy5jaGFuZ2VDc3MocGFyYW0uZWxlcywgcGFyYW0ubmFtZSwgcGFyYW0udmFsdWVNYXApO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5jaGFuZ2VGb250UHJvcGVydGllcyA9IGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgIH07XG5cbiAgICAgIHZhciBlbGVzID0gcGFyYW0uZWxlcztcbiAgICAgIHJlc3VsdC5kYXRhID0ge307XG4gICAgICByZXN1bHQuZWxlcyA9IGVsZXM7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlID0gZWxlc1tpXTtcblxuICAgICAgICByZXN1bHQuZGF0YVtlbGUuaWQoKV0gPSB7fTtcblxuICAgICAgICB2YXIgZGF0YSA9IHBhcmFtLmZpcnN0VGltZSA/IHBhcmFtLmRhdGEgOiBwYXJhbS5kYXRhW2VsZS5pZCgpXTtcblxuICAgICAgICBmb3IgKHZhciBwcm9wIGluIGRhdGEpIHtcbiAgICAgICAgICByZXN1bHQuZGF0YVtlbGUuaWQoKV1bcHJvcF0gPSBlbGUuZGF0YShwcm9wKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocGFyYW0uZmlyc3RUaW1lKSB7XG4gICAgICAgIGVsZW1lbnRVdGlsaXRpZXMuY2hhbmdlRm9udFByb3BlcnRpZXMoZWxlcywgZGF0YSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG5cbiAgICAgICAgICBlbGVtZW50VXRpbGl0aWVzLmNoYW5nZUZvbnRQcm9wZXJ0aWVzKGVsZSwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgLypcbiAgICAgKiBTaG93IGVsZXMgYW5kIHBlcmZvcm0gbGF5b3V0LlxuICAgICAqL1xuICAgIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLnNob3dBbmRQZXJmb3JtTGF5b3V0ID0gZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgICB2YXIgZWxlcyA9IHBhcmFtLmVsZXM7XG5cbiAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgIHJlc3VsdC5wb3NpdGlvbnMgPSB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5nZXROb2RlUG9zaXRpb25zKCk7XG5cbiAgICAgIGlmIChwYXJhbS5maXJzdFRpbWUpIHtcbiAgICAgICAgcmVzdWx0LmVsZXMgPSBlbGVtZW50VXRpbGl0aWVzLnNob3dBbmRQZXJmb3JtTGF5b3V0KHBhcmFtLmVsZXMsIHBhcmFtLmxheW91dHBhcmFtKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQuZWxlcyA9IGN5LnZpZXdVdGlsaXRpZXMoKS5zaG93KGVsZXMpOyAvLyBTaG93IGdpdmVuIGVsZXNcbiAgICAgICAgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMucmV0dXJuVG9Qb3NpdGlvbnMocGFyYW0ucG9zaXRpb25zKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMudW5kb1Nob3dBbmRQZXJmb3JtTGF5b3V0ID0gZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgICB2YXIgZWxlcyA9IHBhcmFtLmVsZXM7XG5cbiAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgIHJlc3VsdC5wb3NpdGlvbnMgPSB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5nZXROb2RlUG9zaXRpb25zKCk7XG4gICAgICByZXN1bHQuZWxlcyA9IGN5LnZpZXdVdGlsaXRpZXMoKS5oaWRlKGVsZXMpOyAvLyBIaWRlIHByZXZpb3VzbHkgdW5oaWRkZW4gZWxlcztcblxuICAgICAgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMucmV0dXJuVG9Qb3NpdGlvbnMocGFyYW0ucG9zaXRpb25zKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgLypcbiAgICAgKiBIaWRlIGVsZXMgYW5kIHBlcmZvcm0gbGF5b3V0LlxuICAgICAqL1xuICAgIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLmhpZGVBbmRQZXJmb3JtTGF5b3V0ID0gZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgICAgIHZhciBlbGVzID0gcGFyYW0uZWxlcztcblxuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgIHJlc3VsdC5wb3NpdGlvbnMgPSB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5nZXROb2RlUG9zaXRpb25zKCk7XG5cbiAgICAgICAgaWYgKHBhcmFtLmZpcnN0VGltZSkge1xuICAgICAgICAgICAgcmVzdWx0LmVsZXMgPSBlbGVtZW50VXRpbGl0aWVzLmhpZGVBbmRQZXJmb3JtTGF5b3V0KHBhcmFtLmVsZXMsIHBhcmFtLmxheW91dHBhcmFtKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5lbGVzID0gY3kudmlld1V0aWxpdGllcygpLmhpZGUoZWxlcyk7IC8vIEhpZGUgZ2l2ZW4gZWxlc1xuICAgICAgICAgICAgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMucmV0dXJuVG9Qb3NpdGlvbnMocGFyYW0ucG9zaXRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLnVuZG9IaWRlQW5kUGVyZm9ybUxheW91dCA9IGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgICB2YXIgZWxlcyA9IHBhcmFtLmVsZXM7XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICByZXN1bHQucG9zaXRpb25zID0gdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMuZ2V0Tm9kZVBvc2l0aW9ucygpO1xuICAgICAgICByZXN1bHQuZWxlcyA9IGN5LnZpZXdVdGlsaXRpZXMoKS5zaG93KGVsZXMpOyAvLyBTaG93IHByZXZpb3VzbHkgaGlkZGVuIGVsZXNcblxuICAgICAgICB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5yZXR1cm5Ub1Bvc2l0aW9ucyhwYXJhbS5wb3NpdGlvbnMpO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIC8qXG4gICAgICogRGVsZXRlIGVsZXMgYW5kIHBlcmZvcm0gbGF5b3V0LlxuICAgICAqL1xuICAgIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLmRlbGV0ZUFuZFBlcmZvcm1MYXlvdXQgPSBmdW5jdGlvbiAocGFyYW0pIHtcbiAgICAgIHZhciBlbGVzID0gcGFyYW0uZWxlcztcblxuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgcmVzdWx0LnBvc2l0aW9ucyA9IHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLmdldE5vZGVQb3NpdGlvbnMoKTtcblxuICAgICAgaWYgKHBhcmFtLmZpcnN0VGltZSkge1xuICAgICAgICAgIHJlc3VsdC5lbGVzID0gZWxlbWVudFV0aWxpdGllcy5kZWxldGVBbmRQZXJmb3JtTGF5b3V0KHBhcmFtLmVsZXMsIHBhcmFtLmxheW91dHBhcmFtKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgIHJlc3VsdC5lbGVzID0gZWxlcy5yZW1vdmUoKTtcbiAgICAgICAgICB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5yZXR1cm5Ub1Bvc2l0aW9ucyhwYXJhbS5wb3NpdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLnVuZG9EZWxldGVBbmRQZXJmb3JtTGF5b3V0ID0gZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgICB2YXIgZWxlcyA9IHBhcmFtLmVsZXM7XG5cbiAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgIHJlc3VsdC5wb3NpdGlvbnMgPSB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5nZXROb2RlUG9zaXRpb25zKCk7XG4gICAgICByZXN1bHQuZWxlcyA9IGVsZW1lbnRVdGlsaXRpZXMucmVzdG9yZUVsZXMoZWxlcyk7IFxuXG4gICAgICB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5yZXR1cm5Ub1Bvc2l0aW9ucyhwYXJhbS5wb3NpdGlvbnMpO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gICAgLy8gU2VjdGlvbiBFbmRcbiAgICAvLyBnZW5lcmFsIGFjdGlvbiBmdW5jdGlvbnNcblxuICAgIC8vIFNlY3Rpb24gU3RhcnRcbiAgICAvLyBzYmduIGFjdGlvbiBmdW5jdGlvbnNcblxuICAgIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLmNoYW5nZVN0YXRlT3JJbmZvQm94ID0gZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgfTtcbiAgICAgIHJlc3VsdC50eXBlID0gcGFyYW0udHlwZTtcbiAgICAgIHJlc3VsdC5ub2RlcyA9IHBhcmFtLm5vZGVzO1xuICAgICAgcmVzdWx0LmluZGV4ID0gcGFyYW0uaW5kZXg7XG4gICAgICB2YXIgZGF0YSA9IHBhcmFtLmRhdGE7XG5cbiAgICAgIHZhciB0ZW1wRGF0YSA9IGVsZW1lbnRVdGlsaXRpZXMuc2F2ZVVuaXRzKHBhcmFtLm5vZGVzKTtcbiAgICAgIHJlc3VsdC52YWx1ZSA9IGVsZW1lbnRVdGlsaXRpZXMuY2hhbmdlU3RhdGVPckluZm9Cb3gocGFyYW0ubm9kZXMsIHBhcmFtLmluZGV4LCBwYXJhbS52YWx1ZSwgcGFyYW0udHlwZSk7XG4gICAgICAvKiB2YXIgbG9jYXRpb25zID0gZWxlbWVudFV0aWxpdGllcy5jaGVja0ZpdChwYXJhbS5ub2Rlcyk7XG4gICAgICBpZiAobG9jYXRpb25zICE9PSB1bmRlZmluZWQgJiYgbG9jYXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZWxlbWVudFV0aWxpdGllcy5maXRVbml0cyhwYXJhbS5ub2RlcywgbG9jYXRpb25zKTtcbiAgICAgIH0gKi9cbiAgICAgIGlmIChkYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZWxlbWVudFV0aWxpdGllcy5yZXN0b3JlVW5pdHMocGFyYW0ubm9kZXMsIGRhdGEpO1xuICAgICAgfVxuXG4gICAgICBjeS5mb3JjZVJlbmRlcigpO1xuICAgICAgcmVzdWx0LmRhdGEgPSB0ZW1wRGF0YTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLmFkZFN0YXRlT3JJbmZvQm94ID0gZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgICB2YXIgb2JqID0gcGFyYW0ub2JqO1xuICAgICAgdmFyIG5vZGVzID0gcGFyYW0ubm9kZXM7XG4gICAgICB2YXIgZGF0YSA9IHBhcmFtLmRhdGE7XG5cbiAgICAgIHZhciB0ZW1wRGF0YSA9IGVsZW1lbnRVdGlsaXRpZXMuc2F2ZVVuaXRzKG5vZGVzKTtcbiAgICAgIHZhciBsb2NhdGlvbk9iaiA9IGVsZW1lbnRVdGlsaXRpZXMuYWRkU3RhdGVPckluZm9Cb3gobm9kZXMsIG9iaik7XG4gICAgIC8qICB2YXIgbG9jYXRpb25zID0gZWxlbWVudFV0aWxpdGllcy5jaGVja0ZpdChub2Rlcyk7XG4gICAgICBpZiAobG9jYXRpb25zICE9PSB1bmRlZmluZWQgJiYgbG9jYXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZWxlbWVudFV0aWxpdGllcy5maXRVbml0cyhub2RlcywgbG9jYXRpb25zKTtcbiAgICAgIH0gKi9cbiAgICAgIGlmIChkYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZWxlbWVudFV0aWxpdGllcy5yZXN0b3JlVW5pdHMobm9kZXMsIGRhdGEpO1xuICAgICAgfVxuXG4gICAgICBjeS5mb3JjZVJlbmRlcigpO1xuXG4gICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICBub2Rlczogbm9kZXMsXG4gICAgICAgIGxvY2F0aW9uT2JqOiBsb2NhdGlvbk9iaixcbiAgICAgICAgb2JqOiBvYmosXG4gICAgICAgIGRhdGE6IHRlbXBEYXRhXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMucmVtb3ZlU3RhdGVPckluZm9Cb3ggPSBmdW5jdGlvbiAocGFyYW0pIHtcbiAgICAgIHZhciBsb2NhdGlvbk9iaiA9IHBhcmFtLmxvY2F0aW9uT2JqO1xuICAgICAgdmFyIG5vZGVzID0gcGFyYW0ubm9kZXM7XG4gICAgICB2YXIgZGF0YSA9IHBhcmFtLmRhdGE7XG5cbiAgICAgIHZhciB0ZW1wRGF0YSA9IGVsZW1lbnRVdGlsaXRpZXMuc2F2ZVVuaXRzKG5vZGVzKTtcbiAgICAgIHZhciBvYmogPSBlbGVtZW50VXRpbGl0aWVzLnJlbW92ZVN0YXRlT3JJbmZvQm94KG5vZGVzLCBsb2NhdGlvbk9iaik7XG4gICAgICBpZiAoZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVsZW1lbnRVdGlsaXRpZXMucmVzdG9yZVVuaXRzKG5vZGVzLCBkYXRhKTtcbiAgICAgIH1cblxuICAgICAgY3kuZm9yY2VSZW5kZXIoKTtcblxuICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgbm9kZXM6IG5vZGVzLFxuICAgICAgICBvYmo6IG9iaixcbiAgICAgICAgZGF0YTogdGVtcERhdGFcbiAgICAgIH07XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5maXRVbml0cyA9IGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgdmFyIG5vZGUgPSBwYXJhbS5ub2RlO1xuICAgICAgdmFyIGxvY2F0aW9ucyA9IHBhcmFtLmxvY2F0aW9ucztcbiAgICAgIHZhciBvYmogPSBlbGVtZW50VXRpbGl0aWVzLmZpdFVuaXRzKG5vZGUsIGxvY2F0aW9ucyk7XG5cbiAgICAgIGN5LmZvcmNlUmVuZGVyKCk7XG5cbiAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgIG5vZGU6IG5vZGUsXG4gICAgICAgIG9iajogb2JqLFxuICAgICAgICBsb2NhdGlvbnM6IGxvY2F0aW9uc1xuICAgICAgfTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLnJlc3RvcmVVbml0cyA9IGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgdmFyIG5vZGUgPSBwYXJhbS5ub2RlO1xuICAgICAgdmFyIGxvY2F0aW9ucyA9IHBhcmFtLmxvY2F0aW9ucztcbiAgICAgIHZhciBvYmogPSBwYXJhbS5vYmo7XG4gICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgbm9kZS5kYXRhKCdzdGF0ZXNhbmRpbmZvcycpLmZvckVhY2goIGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgdmFyIGJveCA9IG9ialtpbmRleCsrXTtcbiAgICAgICAgZWxlLmJib3gueCA9IGJveC54O1xuICAgICAgICBlbGUuYmJveC55ID0gYm94Lnk7XG4gICAgICAgIHZhciBvbGRTaWRlID0gZWxlLmFuY2hvclNpZGU7XG4gICAgICAgIGVsZS5hbmNob3JTaWRlID0gYm94LmFuY2hvclNpZGU7XG4gICAgICAgIGVsZW1lbnRVdGlsaXRpZXMubW9kaWZ5VW5pdHMobm9kZSwgZWxlLCBvbGRTaWRlKTtcbiAgICAgIH0pO1xuXG4gICAgICBjeS5mb3JjZVJlbmRlcigpO1xuXG4gICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICBsb2NhdGlvbnM6IGxvY2F0aW9uc1xuICAgICAgfTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLnNldE11bHRpbWVyU3RhdHVzID0gZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgICB2YXIgZmlyc3RUaW1lID0gcGFyYW0uZmlyc3RUaW1lO1xuICAgICAgdmFyIG5vZGVzID0gcGFyYW0ubm9kZXM7XG4gICAgICB2YXIgc3RhdHVzID0gcGFyYW0uc3RhdHVzO1xuICAgICAgdmFyIHJlc3VsdFN0YXR1cyA9IHt9O1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIHZhciBpc011bHRpbWVyID0gbm9kZS5kYXRhKCdjbGFzcycpLmVuZHNXaXRoKCcgbXVsdGltZXInKTtcblxuICAgICAgICByZXN1bHRTdGF0dXNbbm9kZS5pZCgpXSA9IGlzTXVsdGltZXI7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoaXMgaXMgdGhlIGZpcnN0IHRpbWUgY2hhbmdlIHRoZSBzdGF0dXMgb2YgYWxsIG5vZGVzIGF0IG9uY2UuXG4gICAgICAvLyBJZiBub3QgY2hhbmdlIHN0YXR1cyBvZiBlYWNoIHNlcGVyYXRlbHkgdG8gdGhlIHZhbHVlcyBtYXBwZWQgdG8gdGhlaXIgaWQuXG4gICAgICBpZiAoZmlyc3RUaW1lKSB7XG4gICAgICAgIGVsZW1lbnRVdGlsaXRpZXMuc2V0TXVsdGltZXJTdGF0dXMobm9kZXMsIHN0YXR1cyk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgICAgICAgZWxlbWVudFV0aWxpdGllcy5zZXRNdWx0aW1lclN0YXR1cyhub2RlLCBzdGF0dXNbbm9kZS5pZCgpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIC8vICBpZiAoIWZpcnN0VGltZSAmJiBfLmlzRXF1YWwobm9kZXMsIGN5Lm5vZGVzKCc6c2VsZWN0ZWQnKSkpIHtcbiAgICAvLyAgICAkKCcjaW5zcGVjdG9yLWlzLW11bHRpbWVyJykuYXR0cihcImNoZWNrZWRcIiwgISQoJyNpbnNwZWN0b3ItaXMtbXVsdGltZXInKS5hdHRyKFwiY2hlY2tlZFwiKSk7XG4gICAgLy8gIH1cblxuICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgc3RhdHVzOiByZXN1bHRTdGF0dXMsXG4gICAgICAgIG5vZGVzOiBub2Rlc1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMuc2V0Q2xvbmVNYXJrZXJTdGF0dXMgPSBmdW5jdGlvbiAocGFyYW0pIHtcbiAgICAgIHZhciBub2RlcyA9IHBhcmFtLm5vZGVzO1xuICAgICAgdmFyIHN0YXR1cyA9IHBhcmFtLnN0YXR1cztcbiAgICAgIHZhciBmaXJzdFRpbWUgPSBwYXJhbS5maXJzdFRpbWU7XG4gICAgICB2YXIgcmVzdWx0U3RhdHVzID0ge307XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgcmVzdWx0U3RhdHVzW25vZGUuaWQoKV0gPSBub2RlLmRhdGEoJ2Nsb25lbWFya2VyJyk7XG4gICAgICAgIHZhciBjdXJyZW50U3RhdHVzID0gZmlyc3RUaW1lID8gc3RhdHVzIDogc3RhdHVzW25vZGUuaWQoKV07XG4gICAgICAgIGVsZW1lbnRVdGlsaXRpZXMuc2V0Q2xvbmVNYXJrZXJTdGF0dXMobm9kZSwgY3VycmVudFN0YXR1cyk7XG4gICAgICB9XG5cbiAgICAvLyAgaWYgKCFmaXJzdFRpbWUgJiYgXy5pc0VxdWFsKG5vZGVzLCBjeS5ub2RlcygnOnNlbGVjdGVkJykpKSB7XG4gICAgLy8gICAgJCgnI2luc3BlY3Rvci1pcy1jbG9uZS1tYXJrZXInKS5hdHRyKFwiY2hlY2tlZFwiLCAhJCgnI2luc3BlY3Rvci1pcy1jbG9uZS1tYXJrZXInKS5hdHRyKFwiY2hlY2tlZFwiKSk7XG4gICAgLy8gIH1cblxuICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgc3RhdHVzOiByZXN1bHRTdGF0dXMsXG4gICAgICAgIG5vZGVzOiBub2Rlc1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgLy8gcGFyYW06IHtjbGFzczogc2JnbmNsYXNzLCBuYW1lOiBwcm9wZXJ0eU5hbWUsIHZhbHVlOiB2YWx1ZX1cbiAgICB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5zZXREZWZhdWx0UHJvcGVydHkgPSBmdW5jdGlvbiAocGFyYW0pIHtcbiAgICAgIHZhciBzYmduY2xhc3MgPSBwYXJhbS5jbGFzcztcbiAgICAgIHZhciBuYW1lID0gcGFyYW0ubmFtZTtcbiAgICAgIHZhciB2YWx1ZSA9IHBhcmFtLnZhbHVlO1xuICAgICAgdmFyIGNsYXNzRGVmYXVsdHMgPSBlbGVtZW50VXRpbGl0aWVzLmdldERlZmF1bHRQcm9wZXJ0aWVzKHNiZ25jbGFzcyk7XG4gICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICBjbGFzczogc2JnbmNsYXNzLFxuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICB2YWx1ZTogY2xhc3NEZWZhdWx0cy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/IGNsYXNzRGVmYXVsdHNbbmFtZV0gOiB1bmRlZmluZWRcbiAgICAgIH07XG5cbiAgICAgIHZhciBwcm9wTWFwID0ge307XG4gICAgICBwcm9wTWFwWyBuYW1lIF0gPSB2YWx1ZTtcblxuICAgICAgZWxlbWVudFV0aWxpdGllcy5zZXREZWZhdWx0UHJvcGVydGllcyggc2JnbmNsYXNzLCBwcm9wTWFwICk7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLmFkZEJhY2tncm91bmRJbWFnZSA9IGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgdmFyIGJnT2JqID0gcGFyYW0uYmdPYmo7XG4gICAgICB2YXIgbm9kZXMgPSBwYXJhbS5ub2RlcztcbiAgICAgIHZhciB1cGRhdGVJbmZvID0gcGFyYW0udXBkYXRlSW5mbztcbiAgICAgIHZhciBwcm9tcHRJbnZhbGlkSW1hZ2UgPSBwYXJhbS5wcm9tcHRJbnZhbGlkSW1hZ2U7XG4gICAgICB2YXIgdmFsaWRhdGVVUkwgPSBwYXJhbS52YWxpZGF0ZVVSTDtcblxuICAgICAgZWxlbWVudFV0aWxpdGllcy5hZGRCYWNrZ3JvdW5kSW1hZ2Uobm9kZXMsIGJnT2JqLCB1cGRhdGVJbmZvLCBwcm9tcHRJbnZhbGlkSW1hZ2UsIHZhbGlkYXRlVVJMKTtcblxuICAgICAgY3kuZm9yY2VSZW5kZXIoKTtcblxuICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgbm9kZXM6IG5vZGVzLFxuICAgICAgICBiZ09iajogYmdPYmosXG4gICAgICAgIHVwZGF0ZUluZm86IHVwZGF0ZUluZm8sXG4gICAgICAgIHByb21wdEludmFsaWRJbWFnZTogcHJvbXB0SW52YWxpZEltYWdlLFxuICAgICAgICB2YWxpZGF0ZVVSTDogdmFsaWRhdGVVUkxcbiAgICAgIH07XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5yZW1vdmVCYWNrZ3JvdW5kSW1hZ2UgPSBmdW5jdGlvbiAocGFyYW0pIHtcbiAgICAgIHZhciBiZ09iaiA9IHBhcmFtLmJnT2JqO1xuICAgICAgdmFyIG5vZGVzID0gcGFyYW0ubm9kZXM7XG5cbiAgICAgIGVsZW1lbnRVdGlsaXRpZXMucmVtb3ZlQmFja2dyb3VuZEltYWdlKG5vZGVzLCBiZ09iaik7XG5cbiAgICAgIGN5LmZvcmNlUmVuZGVyKCk7XG5cbiAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgIG5vZGVzOiBub2RlcyxcbiAgICAgICAgYmdPYmo6IGJnT2JqXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMudXBkYXRlQmFja2dyb3VuZEltYWdlID0gZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgICB2YXIgYmdPYmogPSBwYXJhbS5iZ09iajtcbiAgICAgIHZhciBub2RlcyA9IHBhcmFtLm5vZGVzO1xuXG4gICAgICB2YXIgb2xkQmdPYmogPSBlbGVtZW50VXRpbGl0aWVzLnVwZGF0ZUJhY2tncm91bmRJbWFnZShub2RlcywgYmdPYmopO1xuXG4gICAgICBjeS5mb3JjZVJlbmRlcigpO1xuXG4gICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICBub2Rlczogbm9kZXMsXG4gICAgICAgIGJnT2JqOiBvbGRCZ09ialxuICAgICAgfTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLmNoYW5nZUJhY2tncm91bmRJbWFnZSA9IGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgdmFyIG9sZEltZyA9IHBhcmFtLm9sZEltZztcbiAgICAgIHZhciBuZXdJbWcgPSBwYXJhbS5uZXdJbWc7XG4gICAgICB2YXIgbm9kZXMgPSBwYXJhbS5ub2RlcztcbiAgICAgIHZhciBmaXJzdFRpbWUgPSBwYXJhbS5maXJzdFRpbWU7XG4gICAgICB2YXIgdXBkYXRlSW5mbyA9IHBhcmFtLnVwZGF0ZUluZm87XG4gICAgICB2YXIgcHJvbXB0SW52YWxpZEltYWdlID0gcGFyYW0ucHJvbXB0SW52YWxpZEltYWdlO1xuICAgICAgdmFyIHZhbGlkYXRlVVJMPSBwYXJhbS52YWxpZGF0ZVVSTDtcblxuICAgICAgdmFyIHJlc3VsdCA9IGVsZW1lbnRVdGlsaXRpZXMuY2hhbmdlQmFja2dyb3VuZEltYWdlKG5vZGVzLCBvbGRJbWcsIG5ld0ltZywgZmlyc3RUaW1lLCB1cGRhdGVJbmZvLCBwcm9tcHRJbnZhbGlkSW1hZ2UsIHZhbGlkYXRlVVJMKTtcblxuICAgICAgY3kuZm9yY2VSZW5kZXIoKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgLy8gU2VjdGlvbiBFbmRcbiAgICAvLyBzYmduIGFjdGlvbiBmdW5jdGlvbnNcbiAgICB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5jb252ZXJ0SW50b1JldmVyc2libGVSZWFjdGlvbiA9IGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgbGV0IGNvbGxlY3Rpb24gPSBjeS5jb2xsZWN0aW9uKCk7XG4gICAgICBsZXQgbWFwVHlwZSA9IGVsZW1lbnRVdGlsaXRpZXMuZ2V0TWFwVHlwZSgpO1xuICAgICAgZWxlbWVudFV0aWxpdGllcy5zZXRNYXBUeXBlKHBhcmFtLm1hcFR5cGUpO1xuICAgICAgJCgnI21hcC10eXBlJykudmFsKHBhcmFtLm1hcFR5cGUpO1xuXG4gICAgICBwYXJhbS5jb2xsZWN0aW9uLmZvckVhY2goZnVuY3Rpb24oZWRnZSkge1xuICAgICAgICB2YXIgc291cmNlTm9kZSA9IGVkZ2UuX3ByaXZhdGUuZGF0YS5zb3VyY2U7XG4gICAgICAgIHZhciB0YXJnZXROb2RlID0gZWRnZS5fcHJpdmF0ZS5kYXRhLnRhcmdldDtcblxuICAgICAgICBlZGdlLm1vdmUoe3NvdXJjZTogdGFyZ2V0Tm9kZSwgdGFyZ2V0OiBzb3VyY2VOb2RlfSk7XG5cbiAgICAgICAgbGV0IGNvbnZlcnRlZEVkZ2UgPSBjeS5nZXRFbGVtZW50QnlJZChlZGdlLmlkKCkpO1xuXG4gICAgICAgIGlmKGNvbnZlcnRlZEVkZ2UuZGF0YShcImN5ZWRnZWJlbmRlZGl0aW5nRGlzdGFuY2VzXCIpKXtcbiAgICAgICAgICBsZXQgZGlzdGFuY2UgPSBjb252ZXJ0ZWRFZGdlLmRhdGEoXCJjeWVkZ2ViZW5kZWRpdGluZ0Rpc3RhbmNlc1wiKTtcbiAgICAgICAgICBkaXN0YW5jZSA9IGRpc3RhbmNlLm1hcChmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gLTEqZWxlbWVudDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb252ZXJ0ZWRFZGdlLmRhdGEoXCJjeWVkZ2ViZW5kZWRpdGluZ0Rpc3RhbmNlc1wiLCBkaXN0YW5jZS5yZXZlcnNlKCkpO1xuXG4gICAgICAgICAgbGV0IHdlaWdodCA9IGNvbnZlcnRlZEVkZ2UuZGF0YShcImN5ZWRnZWJlbmRlZGl0aW5nV2VpZ2h0c1wiKTtcbiAgICAgICAgICB3ZWlnaHQgPSB3ZWlnaHQubWFwKGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiAxLWVsZW1lbnQ7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29udmVydGVkRWRnZS5kYXRhKFwiY3llZGdlYmVuZGVkaXRpbmdXZWlnaHRzXCIsIHdlaWdodC5yZXZlcnNlKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoY29udmVydGVkRWRnZS5kYXRhKFwiY3llZGdlY29udHJvbGVkaXRpbmdEaXN0YW5jZXNcIikpe1xuICAgICAgICAgIGxldCBkaXN0YW5jZSA9IGNvbnZlcnRlZEVkZ2UuZGF0YShcImN5ZWRnZWNvbnRyb2xlZGl0aW5nRGlzdGFuY2VzXCIpO1xuICAgICAgICAgIGRpc3RhbmNlID0gZGlzdGFuY2UubWFwKGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiAtMSplbGVtZW50O1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnZlcnRlZEVkZ2UuZGF0YShcImN5ZWRnZWNvbnRyb2xlZGl0aW5nRGlzdGFuY2VzXCIsIGRpc3RhbmNlLnJldmVyc2UoKSk7XG5cbiAgICAgICAgICBsZXQgd2VpZ2h0ID0gY29udmVydGVkRWRnZS5kYXRhKFwiY3llZGdlY29udHJvbGVkaXRpbmdXZWlndGhzXCIpO1xuICAgICAgICAgIHdlaWdodCA9IHdlaWdodC5tYXAoZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIDEtZWxlbWVudDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb252ZXJ0ZWRFZGdlLmRhdGEoXCJjeWVkZ2Vjb250cm9sZWRpdGluZ1dlaWd0aHNcIiwgd2VpZ2h0LnJldmVyc2UoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29udmVydGVkRWRnZS5fcHJpdmF0ZS5kYXRhLmNsYXNzID09PSBcImNvbnN1bXB0aW9uXCIpIHtcbiAgICAgICAgICBjb252ZXJ0ZWRFZGdlLl9wcml2YXRlLmRhdGEuY2xhc3MgPSBcInByb2R1Y3Rpb25cIjtcbiAgICAgICAgICBjb252ZXJ0ZWRFZGdlLl9wcml2YXRlLmRhdGEucG9ydHNvdXJjZSA9IHRhcmdldE5vZGUgKyBcIi4xXCI7XG4gICAgICAgICAgY29udmVydGVkRWRnZS5fcHJpdmF0ZS5kYXRhLnBvcnR0YXJnZXQgPSBzb3VyY2VOb2RlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbnZlcnRlZEVkZ2UuX3ByaXZhdGUuZGF0YS5jbGFzcyA9PT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICBjb252ZXJ0ZWRFZGdlLl9wcml2YXRlLmRhdGEuY2xhc3MgPSBcImNvbnN1bXB0aW9uXCI7XG4gICAgICAgICAgY29udmVydGVkRWRnZS5fcHJpdmF0ZS5kYXRhLnBvcnRzb3VyY2UgPSB0YXJnZXROb2RlO1xuICAgICAgICAgIGNvbnZlcnRlZEVkZ2UuX3ByaXZhdGUuZGF0YS5wb3J0dGFyZ2V0ID0gc291cmNlTm9kZSArIFwiLjFcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbGxlY3Rpb24gPSBjb2xsZWN0aW9uLmFkZChjb252ZXJ0ZWRFZGdlKTtcbiAgICAgICAgY3kuc3R5bGUoKS51cGRhdGUoKTtcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICBjb2xsZWN0aW9uOiBjb2xsZWN0aW9uLFxuICAgICAgICBtYXBUeXBlOiBtYXBUeXBlLFxuICAgICAgICBwcm9jZXNzSWQ6IHBhcmFtLnByb2Nlc3NJZFxuICAgICAgfTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgdW5kb1JlZG9BY3Rpb25GdW5jdGlvbnMubW92ZUVkZ2UgPSBmdW5jdGlvbiAocGFyYW0pIHtcbiAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICB9O1xuICAgICAgdmFyIGVkZ2UgPSBwYXJhbS5lZGdlO1xuICAgICAgcmVzdWx0Lm5hbWUgPSBwYXJhbS5uYW1lOyAgICAgIFxuICAgICBcblxuICAgICAgcmVzdWx0LnNvdXJjZSA9IGVkZ2Uuc291cmNlKCkuaWQoKTtcbiAgICAgIHJlc3VsdC50YXJnZXQgPSBlZGdlLnRhcmdldCgpLmlkKCk7ICAgICAgXG4gICAgICByZXN1bHQucG9ydHNvdXJjZSAgPWVkZ2UuZGF0YShcInBvcnRzb3VyY2VcIik7XG4gICAgICByZXN1bHQucG9ydHRhcmdldCA9IGVkZ2UuZGF0YShcInBvcnR0YXJnZXRcIik7XG4gICAgICBlbGVtZW50VXRpbGl0aWVzLmNoYW5nZURhdGEoZWRnZSwgJ3NvdXJjZScsIHBhcmFtLnNvdXJjZSk7XG4gICAgICBlbGVtZW50VXRpbGl0aWVzLmNoYW5nZURhdGEoZWRnZSwgJ3RhcmdldCcsIHBhcmFtLnRhcmdldCk7XG4gICAgICBlbGVtZW50VXRpbGl0aWVzLmNoYW5nZURhdGEoZWRnZSwgJ3BvcnRzb3VyY2UnLCBwYXJhbS5wb3J0c291cmNlKTtcbiAgICAgIGVsZW1lbnRVdGlsaXRpZXMuY2hhbmdlRGF0YShlZGdlLCAncG9ydHRhcmdldCcsIHBhcmFtLnBvcnR0YXJnZXQpOyBcbiAgICAgIGVkZ2UgPSBlZGdlLm1vdmUoe1xuICAgICAgICB0YXJnZXQ6IHBhcmFtLnRhcmdldCxcbiAgICAgICAgc291cmNlIDogcGFyYW0uc291cmNlXG4gICAgXG4gICAgIH0pO1xuXG4gICAgIHJlc3VsdC5lZGdlID0gZWRnZTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLmZpeEVycm9yID0gZnVuY3Rpb24ocGFyYW0pe1xuICAgICAgXG4gICAgICB2YXIgZXJyb3JDb2RlID0gcGFyYW0uZXJyb3JDb2RlO1xuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgcmVzdWx0LmVycm9yQ29kZSA9IGVycm9yQ29kZTtcbiAgICAgIGlmKGVycm9yQ29kZSA9PSBcInBkMTAxMDFcIiB8fCBlcnJvckNvZGUgPT0gJ3BkMTAxMDInKXtcblxuICAgICAgICByZXN1bHQuZWRnZSA9IGVsZW1lbnRVdGlsaXRpZXMucmV2ZXJzZUVkZ2UocGFyYW0uZWRnZSk7XG5cbiAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9ZWxzZSBpZihlcnJvckNvZGUgPT0gXCJwZDEwMTAzXCIgfHwgZXJyb3JDb2RlID09ICdwZDEwMTA3Jyl7XG5cbiAgICAgICBcbiAgICAgICAgXG4gICAgICAgIHBhcmFtLm5ld05vZGVzLmZvckVhY2goZnVuY3Rpb24obmV3Tm9kZSl7XG4gICAgICAgICBlbGVtZW50VXRpbGl0aWVzLmFkZE5vZGUobmV3Tm9kZS54LCBuZXdOb2RlLnksIG5ld05vZGUuY2xhc3MsIG5ld05vZGUuaWQsIHVuZGVmaW5lZCk7XG5cbiAgICAgICAgICBcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcGFyYW0ubmV3RWRnZXMuZm9yRWFjaChmdW5jdGlvbihuZXdFZGdlKXsgICAgICAgICAgXG4gICAgICAgICAgZWxlbWVudFV0aWxpdGllcy5hZGRFZGdlKG5ld0VkZ2Uuc291cmNlLG5ld0VkZ2UudGFyZ2V0LG5ld0VkZ2UuY2xhc3MpO1xuICAgICAgICB9KTtcblxuICAgICAgICBwYXJhbS5vbGRFZGdlcy5mb3JFYWNoKGZ1bmN0aW9uKG9sZEVkZ2Upe1xuICAgICAgICAgIGN5LmVsZW1lbnRzKCkudW5zZWxlY3QoKTtcbiAgICAgICAgICAvL3JldHVybiBcbiAgICAgICAgICBvbGRFZGdlLnJlbW92ZSgpO1xuICAgICAgICB9KTtcblxuICAgICAgICBwYXJhbS5ub2RlLnJlbW92ZSgpO1xuXG4gICAgICAgIHJldHVybiBwYXJhbTtcblxuICAgICAgfWVsc2UgaWYoZXJyb3JDb2RlID09IFwicGQxMDEwNVwiIHx8IGVycm9yQ29kZSA9PSAncGQxMDEwNicpe1xuICAgXG4gICAgICAgIHJlc3VsdC5lZGdlID0gZWxlbWVudFV0aWxpdGllcy5yZXZlcnNlRWRnZShwYXJhbS5lZGdlKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1lbHNlIGlmKGVycm9yQ29kZSA9PSBcInBkMTAxNDBcIil7XG4gICAgICAgIHBhcmFtLm5vZGUucmVtb3ZlKCk7XG4gICAgICAgIHJldHVybiBwYXJhbTtcbiAgICAgIH1lbHNlIGlmKGVycm9yQ29kZSA9PSBcInBkMTAxMDRcIikge1xuICAgICAgICBcbiAgICAgICAgcGFyYW0uZWRnZXMuZm9yRWFjaChmdW5jdGlvbihlZGdlKXtcbiAgICAgICAgICBlZGdlLnJlbW92ZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcGFyYW0ubm9kZXMuZm9yRWFjaChmdW5jdGlvbihub2RlKXtcbiAgICAgICAgICBub2RlLnJlbW92ZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBhcmFtO1xuICAgICAgfWVsc2UgaWYoZXJyb3JDb2RlID09IFwicGQxMDEwOFwiKXtcbiAgICAgICAgcGFyYW0uZWRnZXMuZm9yRWFjaChmdW5jdGlvbihlZGdlKXtcbiAgICAgICAgICBlZGdlLnJlbW92ZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcGFyYW0ubm9kZXMuZm9yRWFjaChmdW5jdGlvbihub2RlKXtcbiAgICAgICAgICBub2RlLnJlbW92ZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBhcmFtO1xuICAgICAgfWVsc2UgaWYoZXJyb3JDb2RlID09IFwicGQxMDExMVwiKXtcbiAgICAgICAgcGFyYW0uZWRnZXMuZm9yRWFjaChmdW5jdGlvbihlZGdlKXtcbiAgICAgICAgICBlZGdlLnJlbW92ZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBhcmFtO1xuICAgICAgfWVsc2UgaWYoZXJyb3JDb2RlID09IFwicGQxMDEyNlwiKXtcbiAgICAgICAgcGFyYW0uZWRnZXMuZm9yRWFjaChmdW5jdGlvbihlZGdlKXtcbiAgICAgICAgICBlZGdlLnJlbW92ZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcGFyYW0ubm9kZXMuZm9yRWFjaChmdW5jdGlvbihub2RlKXtcbiAgICAgICAgICBub2RlLnJlbW92ZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBhcmFtO1xuICAgICAgfWVsc2UgaWYoZXJyb3JDb2RlID09IFwicGQxMDEwOVwiIHx8IGVycm9yQ29kZSA9PSBcInBkMTAxMjRcIikge1xuICAgICAgICBcbiAgICAgICAgcmVzdWx0Lm5ld1NvdXJjZSA9IHBhcmFtLmVkZ2UuZGF0YSgpLnNvdXJjZTtcbiAgICAgICAgcmVzdWx0Lm5ld1RhcmdldCA9IHBhcmFtLmVkZ2UuZGF0YSgpLnRhcmdldDtcbiAgICAgICAgcmVzdWx0LnBvcnRzb3VyY2UgPSBwYXJhbS5lZGdlLmRhdGEoKS5wb3J0c291cmNlO1xuICAgICAgICB2YXIgY2xvbmVkRWRnZSA9IHBhcmFtLmVkZ2UuY2xvbmUoKTtcbiAgICAgICBcbiAgICAgICAgdmFyIGVkZ2VQYXJhbXMgPSB7Y2xhc3MgOiBjbG9uZWRFZGdlLmRhdGEoKS5jbGFzcywgbGFuZ3VhZ2UgOmNsb25lZEVkZ2UuZGF0YSgpLmxhbmd1YWdlfTtcbiAgICAgICAgY2xvbmVkRWRnZS5kYXRhKCkuc291cmNlID0gcGFyYW0ubmV3U291cmNlO1xuICAgICAgICBjbG9uZWRFZGdlLmRhdGEoKS50YXJnZXQgPSBwYXJhbS5uZXdUYXJnZXQ7XG4gICAgICAgIGN5LnJlbW92ZShwYXJhbS5lZGdlKTtcbiAgICAgICAgcmVzdWx0LmVkZ2UgPSBlbGVtZW50VXRpbGl0aWVzLmFkZEVkZ2UocGFyYW0ubmV3U291cmNlLHBhcmFtLm5ld1RhcmdldCxlZGdlUGFyYW1zLCBjbG9uZWRFZGdlLmRhdGEoKS5pZCk7ICAgICAgXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICAgIH1lbHNlIGlmKGVycm9yQ29kZSA9PSBcInBkMTAxMTJcIikgeyAgICBcbiAgICAgICAgXG4gICAgICAgIHBhcmFtLmNhbGxiYWNrID0gZWxlbWVudFV0aWxpdGllcy5tYWludGFpblBvaW50ZXI7ICBcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBmaXJzdCB0aW1lIHdlIHNob3VsZCBtb3ZlIHRoZSBub2RlIHRvIGl0cyBuZXcgcGFyZW50IGFuZCByZWxvY2F0ZSBpdCBieSBnaXZlbiBwb3NEaWZmIHBhcmFtc1xuICAgICAgICAvLyBlbHNlIHdlIHNob3VsZCByZW1vdmUgdGhlIG1vdmVkIGVsZXMgYW5kIHJlc3RvcmUgdGhlIGVsZXMgdG8gcmVzdG9yZVxuICAgICAgICBpZiAocGFyYW0uZmlyc3RUaW1lKSB7XG4gICAgICAgICAgdmFyIG5ld1BhcmVudElkID0gcGFyYW0ucGFyZW50RGF0YSA9PSB1bmRlZmluZWQgPyBudWxsIDogcGFyYW0ucGFyZW50RGF0YTtcbiAgICAgICAgICAvLyBUaGVzZSBlbGVzIGluY2x1ZGVzIHRoZSBub2RlcyBhbmQgdGhlaXIgY29ubmVjdGVkIGVkZ2VzIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gbm9kZXMubW92ZSgpLlxuICAgICAgICAgIC8vIFRoZXkgc2hvdWxkIGJlIHJlc3RvcmVkIGluIHVuZG9cbiAgICAgICAgICB2YXIgd2l0aERlc2NlbmRhbnQgPSBwYXJhbS5ub2Rlcy51bmlvbihwYXJhbS5ub2Rlcy5kZXNjZW5kYW50cygpKTtcbiAgICAgICAgICByZXN1bHQuZWxlc1RvUmVzdG9yZSA9IHdpdGhEZXNjZW5kYW50LnVuaW9uKHdpdGhEZXNjZW5kYW50LmNvbm5lY3RlZEVkZ2VzKCkpO1xuICAgICAgICAgIC8vIFRoZXNlIGFyZSB0aGUgZWxlcyBjcmVhdGVkIGJ5IG5vZGVzLm1vdmUoKSwgdGhleSBzaG91bGQgYmUgcmVtb3ZlZCBpbiB1bmRvLlxuICAgICAgICAgIHJlc3VsdC5tb3ZlZEVsZXMgPSBwYXJhbS5ub2Rlcy5tb3ZlKHtcInBhcmVudFwiOiBuZXdQYXJlbnRJZH0pO1xuXG4gICAgICAgICAgdmFyIHBvc0RpZmYgPSB7XG4gICAgICAgICAgICB4OiBwYXJhbS5wb3NEaWZmWCxcbiAgICAgICAgICAgIHk6IHBhcmFtLnBvc0RpZmZZXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGVsZW1lbnRVdGlsaXRpZXMubW92ZU5vZGVzKHBvc0RpZmYsIHJlc3VsdC5tb3ZlZEVsZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJlc3VsdC5lbGVzVG9SZXN0b3JlID0gcGFyYW0ubW92ZWRFbGVzLnJlbW92ZSgpO1xuICAgICAgICAgIHJlc3VsdC5tb3ZlZEVsZXMgPSBwYXJhbS5lbGVzVG9SZXN0b3JlLnJlc3RvcmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJhbS5jYWxsYmFjaykge1xuICAgICAgICAgIHJlc3VsdC5jYWxsYmFjayA9IHBhcmFtLmNhbGxiYWNrOyAvLyBrZWVwIHRoZSBwcm92aWRlZCBjYWxsYmFjayBzbyBpdCBjYW4gYmUgcmV1c2VkIGFmdGVyIHVuZG8vcmVkb1xuICAgICAgICAgIHBhcmFtLmNhbGxiYWNrKHJlc3VsdC5tb3ZlZEVsZXMpOyAvLyBhcHBseSB0aGUgY2FsbGJhY2sgb24gbmV3bHkgY3JlYXRlZCBlbGVtZW50c1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIFxuICAgICAgfWVsc2UgaWYoZXJyb3JDb2RlID09IFwicGQxMDEyNVwiKSB7XG5cbiAgICAgICByZXN1bHQuZWRnZSA9IHBhcmFtLmVkZ2UucmVtb3ZlKCk7ICAgICAgIFxuICAgICAgIHJlc3VsdC5uZXdFZGdlID17fTtcbiAgICAgICB2YXIgZWRnZWNsYXNzID0gcGFyYW0ubmV3RWRnZS5lZGdlUGFyYW1zLmNsYXNzID8gcGFyYW0ubmV3RWRnZS5lZGdlUGFyYW1zLmNsYXNzIDogcGFyYW0ubmV3RWRnZS5lZGdlUGFyYW1zO1xuICAgICAgIHZhciB2YWxpZGF0aW9uID0gZWxlbWVudFV0aWxpdGllcy52YWxpZGF0ZUFycm93RW5kcyhlZGdlY2xhc3MsIGN5LmdldEVsZW1lbnRCeUlkKHBhcmFtLm5ld0VkZ2Uuc291cmNlKSwgY3kuZ2V0RWxlbWVudEJ5SWQocGFyYW0ubmV3RWRnZS50YXJnZXQpKTtcblxuICAgICAgIGlmICh2YWxpZGF0aW9uID09PSAncmV2ZXJzZScpIHtcbiAgICAgICAgdmFyIHRlbXAgPSBwYXJhbS5uZXdFZGdlLnNvdXJjZTtcbiAgICAgICAgcGFyYW0ubmV3RWRnZS5zb3VyY2UgPSBwYXJhbS5uZXdFZGdlLnRhcmdldDtcbiAgICAgICAgcGFyYW0ubmV3RWRnZS50YXJnZXQgPSB0ZW1wO1xuICAgICAgfVxuICAgICAgIHJlc3VsdC5uZXdFZGdlLmlkID1lbGVtZW50VXRpbGl0aWVzLmFkZEVkZ2UocGFyYW0ubmV3RWRnZS5zb3VyY2UscGFyYW0ubmV3RWRnZS50YXJnZXQscGFyYW0ubmV3RWRnZS5lZGdlUGFyYW1zKS5pZCgpO1xuICAgICAgIHJlc3VsdC5uZXdFZGdlLnNvdXJjZSA9IHBhcmFtLm5ld0VkZ2Uuc291cmNlO1xuICAgICAgIHJlc3VsdC5uZXdFZGdlLnRhcmdldCA9IHBhcmFtLm5ld0VkZ2UudGFyZ2V0O1xuICAgICAgIHJlc3VsdC5uZXdFZGdlLmVkZ2VQYXJhbXMgPSBwYXJhbS5uZXdFZGdlLmVkZ2VQYXJhbXM7XG4gICAgICAgXG4gICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgICAgICBcbiAgICAgIH1lbHNlIGlmKGVycm9yQ29kZSA9PSBcInBkMTAxNDJcIikge1xuICAgICAgICByZXN1bHQuZWRnZSA9IHBhcmFtLmVkZ2UucmVtb3ZlKCk7ICAgICAgIFxuICAgICAgICByZXN1bHQubmV3RWRnZSA9e307XG4gICAgICAgIHZhciBlZGdlY2xhc3MgPSBwYXJhbS5uZXdFZGdlLmVkZ2VQYXJhbXMuY2xhc3MgPyBwYXJhbS5uZXdFZGdlLmVkZ2VQYXJhbXMuY2xhc3MgOiBwYXJhbS5uZXdFZGdlLmVkZ2VQYXJhbXM7XG4gICAgICAgIHZhciB2YWxpZGF0aW9uID0gZWxlbWVudFV0aWxpdGllcy52YWxpZGF0ZUFycm93RW5kcyhlZGdlY2xhc3MsIGN5LmdldEVsZW1lbnRCeUlkKHBhcmFtLm5ld0VkZ2Uuc291cmNlKSwgY3kuZ2V0RWxlbWVudEJ5SWQocGFyYW0ubmV3RWRnZS50YXJnZXQpKTtcblxuICAgICAgICBpZiAodmFsaWRhdGlvbiA9PT0gJ3JldmVyc2UnKSB7XG4gICAgICAgICB2YXIgdGVtcCA9IHBhcmFtLm5ld0VkZ2Uuc291cmNlO1xuICAgICAgICAgcGFyYW0ubmV3RWRnZS5zb3VyY2UgPSBwYXJhbS5uZXdFZGdlLnRhcmdldDtcbiAgICAgICAgIHBhcmFtLm5ld0VkZ2UudGFyZ2V0ID0gdGVtcDtcbiAgICAgICB9XG4gICAgICAgIHJlc3VsdC5uZXdFZGdlLmlkID1lbGVtZW50VXRpbGl0aWVzLmFkZEVkZ2UocGFyYW0ubmV3RWRnZS5zb3VyY2UscGFyYW0ubmV3RWRnZS50YXJnZXQscGFyYW0ubmV3RWRnZS5lZGdlUGFyYW1zKS5pZCgpO1xuICAgICAgICByZXN1bHQubmV3RWRnZS5zb3VyY2UgPSBwYXJhbS5uZXdFZGdlLnNvdXJjZTtcbiAgICAgICAgcmVzdWx0Lm5ld0VkZ2UudGFyZ2V0ID0gcGFyYW0ubmV3RWRnZS50YXJnZXQ7XG4gICAgICAgIHJlc3VsdC5uZXdFZGdlLmVkZ2VQYXJhbXMgPSBwYXJhbS5uZXdFZGdlLmVkZ2VQYXJhbXM7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfWVsc2Uge1xuXG4gICAgICAgIHJlc3VsdC5uZXdTb3VyY2UgPSBwYXJhbS5lZGdlLnNvdXJjZSgpLmlkKCk7XG4gICAgICAgIHJlc3VsdC5uZXdUYXJnZXQgPSBwYXJhbS5lZGdlLnRhcmdldCgpLmlkKCk7XG4gICAgICAgIHJlc3VsdC5wb3J0dGFyZ2V0ID0gcGFyYW0uZWRnZS5kYXRhKFwicG9ydHRhcmdldFwiKTtcbiAgICAgICAgcmVzdWx0LmVkZ2UgPSBwYXJhbS5lZGdlLm1vdmUoe1xuICAgICAgICAgIHRhcmdldDogcGFyYW0ubmV3VGFyZ2V0LFxuICAgICAgICAgIHNvdXJjZSA6IHBhcmFtLm5ld1NvdXJjZSAgICAgIFxuICAgICAgICB9KTtcblxuICAgICAgICBlbGVtZW50VXRpbGl0aWVzLmNoYW5nZURhdGEocmVzdWx0LmVkZ2UsICdwb3J0dGFyZ2V0JywgcGFyYW0ucG9ydHRhcmdldCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIFxuICAgICAgfVxuICAgICAgXG4gIH1cbiAgXG4gIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLnVuZml4RXJyb3IgPSBmdW5jdGlvbihwYXJhbSl7XG4gICAgdmFyIGVycm9yQ29kZSA9IHBhcmFtLmVycm9yQ29kZTtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgcmVzdWx0LmVycm9yQ29kZSA9IGVycm9yQ29kZTtcbiAgICBpZihlcnJvckNvZGUgPT0gXCJwZDEwMTAxXCIgfHwgZXJyb3JDb2RlID09ICdwZDEwMTAyJyl7XG4gICAgIFxuICAgICAgICByZXN1bHQuZWRnZSA9IGVsZW1lbnRVdGlsaXRpZXMucmV2ZXJzZUVkZ2UocGFyYW0uZWRnZSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1lbHNlIGlmKGVycm9yQ29kZSA9PSBcInBkMTAxMDNcIiB8fCBlcnJvckNvZGUgPT0gJ3BkMTAxMDcnKXtcblxuICAgICAgcGFyYW0ubmV3Tm9kZXMuZm9yRWFjaChmdW5jdGlvbihuZXdOb2RlKXsgICAgXG4gICAgICAgIGN5LnJlbW92ZShjeS4kKCcjJytuZXdOb2RlLmlkKSkgICAgICBcbiAgICAgICAgXG4gICAgICB9KTtcblxuICAgICAgcGFyYW0ubm9kZS5yZXN0b3JlKCk7XG5cbiAgICAgIHBhcmFtLm9sZEVkZ2VzLmZvckVhY2goZnVuY3Rpb24ob2xkRWRnZSl7ICBcbiAgICAgICAgb2xkRWRnZS5yZXN0b3JlKCk7XG4gICAgICB9KTtcblxuICAgICAgY3kuYW5pbWF0ZSh7XG4gICAgICAgIGR1cmF0aW9uOiAxMDAsXG4gICAgICAgIGVhc2luZzogJ2Vhc2UnLFxuICAgICAgICBmaXQgOntlbGVzOnt9LHBhZGRpbmc6MjB9LCBcbiAgICAgICAgY29tcGxldGU6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgIFxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHBhcmFtO1xuXG4gICAgfWVsc2UgaWYoZXJyb3JDb2RlID09IFwicGQxMDEwNVwiIHx8IGVycm9yQ29kZSA9PSAncGQxMDEwNicpeyAgXG5cbiAgICAgIHJlc3VsdC5lZGdlID0gZWxlbWVudFV0aWxpdGllcy5yZXZlcnNlRWRnZShwYXJhbS5lZGdlKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICB9ZWxzZSBpZihlcnJvckNvZGUgPT0gXCJwZDEwMTQwXCIpe1xuICAgICAgcGFyYW0ubm9kZS5yZXN0b3JlKCk7XG4gICAgICBjeS5hbmltYXRlKHtcbiAgICAgICAgZHVyYXRpb246IDEwMCxcbiAgICAgICAgZWFzaW5nOiAnZWFzZScsXG4gICAgICAgIGZpdCA6e2VsZXM6e30scGFkZGluZzoyMH0sIFxuICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHBhcmFtO1xuICAgIH1lbHNlIGlmKGVycm9yQ29kZSA9PSBcInBkMTAxMDRcIikge1xuICAgICAgXG4gICAgICBwYXJhbS5ub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKG5vZGUpe1xuICAgICAgICBub2RlLnJlc3RvcmUoKTtcbiAgICAgIH0pO1xuICAgICAgcGFyYW0uZWRnZXMuZm9yRWFjaChmdW5jdGlvbihlZGdlKXtcbiAgICAgICAgZWRnZS5yZXN0b3JlKCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBwYXJhbTtcbiAgICB9ZWxzZSBpZihlcnJvckNvZGUgPT0gXCJwZDEwMTA4XCIpe1xuICAgICAgXG4gICAgICBwYXJhbS5ub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKG5vZGUpe1xuICAgICAgICBub2RlLnJlc3RvcmUoKTtcbiAgICAgIH0pO1xuICAgICAgcGFyYW0uZWRnZXMuZm9yRWFjaChmdW5jdGlvbihlZGdlKXtcbiAgICAgICAgZWRnZS5yZXN0b3JlKCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBwYXJhbTtcbiAgICB9ZWxzZSBpZihlcnJvckNvZGUgPT0gXCJwZDEwMTExXCIpe1xuICAgICAgcGFyYW0uZWRnZXMuZm9yRWFjaChmdW5jdGlvbihlZGdlKXtcbiAgICAgICAgZWRnZS5yZXN0b3JlKCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBwYXJhbTtcbiAgICB9ZWxzZSBpZihlcnJvckNvZGUgPT0gXCJwZDEwMTI2XCIpe1xuICAgICAgcGFyYW0ubm9kZXMuZm9yRWFjaChmdW5jdGlvbihub2RlKXtcbiAgICAgICAgbm9kZS5yZXN0b3JlKCk7XG4gICAgICB9KTtcbiAgICAgIHBhcmFtLmVkZ2VzLmZvckVhY2goZnVuY3Rpb24oZWRnZSl7XG4gICAgICAgIGVkZ2UucmVzdG9yZSgpO1xuICAgICAgfSk7ICAgICAgIFxuICAgICAgcmV0dXJuIHBhcmFtO1xuICAgIH1lbHNlIGlmKGVycm9yQ29kZSA9PSBcInBkMTAxMDlcIiB8fCBlcnJvckNvZGUgPT0gXCJwZDEwMTI0XCIpIHtcblxuICAgICAgcmVzdWx0Lm5ld1NvdXJjZSA9IHBhcmFtLmVkZ2Uuc291cmNlKCkuaWQoKTtcbiAgICAgIHJlc3VsdC5uZXdUYXJnZXQgPSBwYXJhbS5lZGdlLnRhcmdldCgpLmlkKCk7XG4gICAgICByZXN1bHQucG9ydHNvdXJjZSA9IHBhcmFtLnBvcnRzb3VyY2U7XG4gICAgICByZXN1bHQuZWRnZSA9IHBhcmFtLmVkZ2UubW92ZSh7XG4gICAgICAgIHRhcmdldDogcGFyYW0ubmV3VGFyZ2V0LFxuICAgICAgICBzb3VyY2UgOiBwYXJhbS5uZXdTb3VyY2UgICAgICBcbiAgICAgIH0pO1xuXG4gICAgICBlbGVtZW50VXRpbGl0aWVzLmNoYW5nZURhdGEocmVzdWx0LmVkZ2UsICdwb3J0c291cmNlJywgcGFyYW0ucG9ydHNvdXJjZSk7IFxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9ZWxzZSBpZihlcnJvckNvZGUgPT0gXCJwZDEwMTEyXCIpIHtcbiAgICAgXG4gICAgICAvLyBJZiB0aGlzIGlzIGZpcnN0IHRpbWUgd2Ugc2hvdWxkIG1vdmUgdGhlIG5vZGUgdG8gaXRzIG5ldyBwYXJlbnQgYW5kIHJlbG9jYXRlIGl0IGJ5IGdpdmVuIHBvc0RpZmYgcGFyYW1zXG4gICAgICAvLyBlbHNlIHdlIHNob3VsZCByZW1vdmUgdGhlIG1vdmVkIGVsZXMgYW5kIHJlc3RvcmUgdGhlIGVsZXMgdG8gcmVzdG9yZVxuICAgICAgaWYgKHBhcmFtLmZpcnN0VGltZSkge1xuICAgICAgICB2YXIgbmV3UGFyZW50SWQgPSBwYXJhbS5wYXJlbnREYXRhID09IHVuZGVmaW5lZCA/IG51bGwgOiBwYXJhbS5wYXJlbnREYXRhO1xuICAgICAgICAvLyBUaGVzZSBlbGVzIGluY2x1ZGVzIHRoZSBub2RlcyBhbmQgdGhlaXIgY29ubmVjdGVkIGVkZ2VzIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gbm9kZXMubW92ZSgpLlxuICAgICAgICAvLyBUaGV5IHNob3VsZCBiZSByZXN0b3JlZCBpbiB1bmRvXG4gICAgICAgIHZhciB3aXRoRGVzY2VuZGFudCA9IHBhcmFtLm5vZGVzLnVuaW9uKHBhcmFtLm5vZGVzLmRlc2NlbmRhbnRzKCkpO1xuICAgICAgICByZXN1bHQuZWxlc1RvUmVzdG9yZSA9IHdpdGhEZXNjZW5kYW50LnVuaW9uKHdpdGhEZXNjZW5kYW50LmNvbm5lY3RlZEVkZ2VzKCkpO1xuICAgICAgICAvLyBUaGVzZSBhcmUgdGhlIGVsZXMgY3JlYXRlZCBieSBub2Rlcy5tb3ZlKCksIHRoZXkgc2hvdWxkIGJlIHJlbW92ZWQgaW4gdW5kby5cbiAgICAgICAgcmVzdWx0Lm1vdmVkRWxlcyA9IHBhcmFtLm5vZGVzLm1vdmUoe1wicGFyZW50XCI6IG5ld1BhcmVudElkfSk7XG5cbiAgICAgICAgdmFyIHBvc0RpZmYgPSB7XG4gICAgICAgICAgeDogcGFyYW0ucG9zRGlmZlgsXG4gICAgICAgICAgeTogcGFyYW0ucG9zRGlmZllcbiAgICAgICAgfTtcblxuICAgICAgICBlbGVtZW50VXRpbGl0aWVzLm1vdmVOb2Rlcyhwb3NEaWZmLCByZXN1bHQubW92ZWRFbGVzKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQuZWxlc1RvUmVzdG9yZSA9IHBhcmFtLm1vdmVkRWxlcy5yZW1vdmUoKTtcbiAgICAgICAgcmVzdWx0Lm1vdmVkRWxlcyA9IHBhcmFtLmVsZXNUb1Jlc3RvcmUucmVzdG9yZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyYW0uY2FsbGJhY2spIHtcbiAgICAgICAgcmVzdWx0LmNhbGxiYWNrID0gcGFyYW0uY2FsbGJhY2s7IC8vIGtlZXAgdGhlIHByb3ZpZGVkIGNhbGxiYWNrIHNvIGl0IGNhbiBiZSByZXVzZWQgYWZ0ZXIgdW5kby9yZWRvXG4gICAgICAgIHBhcmFtLmNhbGxiYWNrKHJlc3VsdC5tb3ZlZEVsZXMpOyAvLyBhcHBseSB0aGUgY2FsbGJhY2sgb24gbmV3bHkgY3JlYXRlZCBlbGVtZW50c1xuICAgICAgfVxuXG4gICAgIFxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIFxuICAgIH1lbHNlIGlmKGVycm9yQ29kZSA9PSBcInBkMTAxMjVcIikge1xuXG4gICAgICBjeS4kKCcjJytwYXJhbS5uZXdFZGdlLmlkKS5yZW1vdmUoKTtcbiAgICAgIHBhcmFtLmVkZ2UgPSBwYXJhbS5lZGdlLnJlc3RvcmUoKTtcblxuICAgIFxuICAgICAgcmV0dXJuIHBhcmFtO1xuICAgICAgXG4gICAgfWVsc2UgaWYoZXJyb3JDb2RlID09IFwicGQxMDE0MlwiKSB7XG4gICAgICBjeS4kKCcjJytwYXJhbS5uZXdFZGdlLmlkKS5yZW1vdmUoKTtcbiAgICAgIHBhcmFtLmVkZ2UgPSBwYXJhbS5lZGdlLnJlc3RvcmUoKTtcblxuICAgIFxuICAgICAgcmV0dXJuIHBhcmFtO1xuICAgIH1lbHNlIHtcblxuICAgICAgcmVzdWx0Lm5ld1NvdXJjZSA9IHBhcmFtLmVkZ2Uuc291cmNlKCkuaWQoKTtcbiAgICAgIHJlc3VsdC5uZXdUYXJnZXQgPSBwYXJhbS5lZGdlLnRhcmdldCgpLmlkKCk7XG4gICAgICByZXN1bHQucG9ydHRhcmdldCA9IHBhcmFtLmVkZ2UuZGF0YShcInBvcnR0YXJnZXRcIik7XG4gICAgICByZXN1bHQuZWRnZSA9IHBhcmFtLmVkZ2UubW92ZSh7XG4gICAgICAgIHRhcmdldDogcGFyYW0ubmV3VGFyZ2V0LFxuICAgICAgICBzb3VyY2UgOiBwYXJhbS5uZXdTb3VyY2UgICAgICBcbiAgICAgIH0pO1xuXG4gICAgICBlbGVtZW50VXRpbGl0aWVzLmNoYW5nZURhdGEocmVzdWx0LmVkZ2UsICdwb3J0dGFyZ2V0JywgcGFyYW0ucG9ydHRhcmdldCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgICBcbiAgICB9XG4gICAgXG4gIH1cblxuICB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9ucy5jbG9uZUhpZ2hEZWdyZWVOb2RlID0gZnVuY3Rpb24obm9kZSl7XG5cbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgdmFyIG9sZFggPSBub2RlLnBvc2l0aW9uKCkueDtcbiAgICB2YXIgb2xkWSA9IG5vZGUucG9zaXRpb24oKS55O1xuICAgIFxuICAgIFxuICAgIHZhciBjbGFjdWxhdGVOZXdDbG9uZVBvc2l0aW9uID0gZnVuY3Rpb24oc291cmNlRW5kUG9pbnRYLHNvdXJjZUVuZFBvaW50WSx0YXJnZXRFbmRQb2ludFgsdGFyZ2V0RW5kUG9pbnRZLGRlc2lyZWREaXN0YW5jZSxkaXJlY3Rpb24pe1xuICAgICAgdmFyIGRpc3RhbmNlID0gTWF0aC5zcXJ0KE1hdGgucG93KHRhcmdldEVuZFBvaW50WS1zb3VyY2VFbmRQb2ludFksMikrIE1hdGgucG93KHRhcmdldEVuZFBvaW50WC1zb3VyY2VFbmRQb2ludFgsMikpO1xuICAgICAgdmFyIHJhdGlvID0gZGVzaXJlZERpc3RhbmNlL2Rpc3RhbmNlO1xuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgaWYoZGlyZWN0aW9uID09IFwic291cmNlXCIpeyBcbiAgICAgICAgcmVzdWx0LmN4ID0gKCgxLXJhdGlvKSAqIHNvdXJjZUVuZFBvaW50WCkgICsgKHJhdGlvICogdGFyZ2V0RW5kUG9pbnRYKTtcbiAgICAgICAgcmVzdWx0LmN5ID0gKCgxLXJhdGlvKSAqIHNvdXJjZUVuZFBvaW50WSkgICsgKHJhdGlvICogdGFyZ2V0RW5kUG9pbnRZKTtcbiAgICAgIH1lbHNleyAgICAgIFxuICAgICAgICByZXN1bHQuY3ggPSAoKDEtcmF0aW8pICogdGFyZ2V0RW5kUG9pbnRYKSAgKyAocmF0aW8gKiBzb3VyY2VFbmRQb2ludFgpO1xuICAgICAgICByZXN1bHQuY3kgPSAoKDEtcmF0aW8pICogdGFyZ2V0RW5kUG9pbnRZKSAgKyAocmF0aW8gKiBzb3VyY2VFbmRQb2ludFkpO1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07ICAgXG4gICAgdmFyIGVkZ2VzID0gbm9kZS5jb25uZWN0ZWRFZGdlcygpO1xuICAgIHZhciBkZXNpcmVkRGlzdGFuY2UgPSAobm9kZS5oZWlnaHQoKSA+IG5vZGUud2lkdGgoKT8gbm9kZS5oZWlnaHQoKTogbm9kZS53aWR0aCgpKSogMC4xO1xuICAgIGZvcih2YXIgaSA9IDEgOyBpIDwgZWRnZXMubGVuZ3RoIDsgaSsrKXtcbiAgICAgIHZhciBlZGdlID0gZWRnZXNbaV07XG4gICAgICB2YXIgaW5kZXggPSBpO1xuICAgICAgdmFyIGVkZ2VDbG9uZSA9IGVkZ2UuY2xvbmUoKTtcbiAgICAgIHZhciBzdGFydFBvc2l0aW9uID0gZWRnZS5zb3VyY2UoKS5pZCgpID09IG5vZGUuaWQoKSA/IFwic291cmNlXCIgOiBcInRhcmdldFwiOyAgICBcbiAgICAgIHZhciBuZXdQb3NpdGlvbiA9IGNsYWN1bGF0ZU5ld0Nsb25lUG9zaXRpb24oZWRnZS5zb3VyY2VFbmRwb2ludCgpLngsZWRnZS5zb3VyY2VFbmRwb2ludCgpLnksZWRnZS50YXJnZXRFbmRwb2ludCgpLngsZWRnZS50YXJnZXRFbmRwb2ludCgpLnksZGVzaXJlZERpc3RhbmNlLHN0YXJ0UG9zaXRpb24pOyBcbiAgICAgIHZhciBuZXdOb2RlSWQgPSBub2RlLmlkKCkrJ2Nsb25lLScraW5kZXg7XG4gICAgICAvL2VkZ2VDbG9uZS5kYXRhKCkuaWQgPSBlZGdlQ2xvbmUuZGF0YSgpLmlkKyBcIi1cIituZXdOb2RlSWQ7XG4gICAgICBpZihlZGdlLnNvdXJjZSgpLmlkKCkgPT0gbm9kZS5pZCgpKXsgICAgICAgIFxuICAgICAgICBlZGdlQ2xvbmUuZGF0YSgpLnNvdXJjZSA9IG5ld05vZGVJZDtcbiAgICAgICAgZWRnZUNsb25lLmRhdGEoKS5wb3J0c291cmNlID0gbmV3Tm9kZUlkOyAgICBcbiAgICAgIH1lbHNle1xuICAgICAgICAgIFxuICAgICAgICBlZGdlQ2xvbmUuZGF0YSgpLnRhcmdldCA9IG5ld05vZGVJZDtcbiAgICAgICAgZWRnZUNsb25lLmRhdGEoKS5wb3J0dGFyZ2V0ID0gbmV3Tm9kZUlkOyAgICBcbiAgICAgIH1cbiAgICAgIHZhciBuZXdOb2RlID0gbm9kZS5jbG9uZSgpO1xuICAgICAgbmV3Tm9kZS5kYXRhKCkuaWQgPSBuZXdOb2RlSWQ7XG4gICAgICBjeS5hZGQobmV3Tm9kZSk7XG4gICAgIFxuICAgICAgZWRnZS5yZW1vdmUoKTtcbiAgICAgIGN5LmFkZChlZGdlQ2xvbmUpO1xuICAgICAgbmV3Tm9kZS5wb3NpdGlvbih7XG4gICAgICAgIHg6IG5ld1Bvc2l0aW9uLmN4LFxuICAgICAgICB5OiBuZXdQb3NpdGlvbi5jeVxuICAgICAgfSk7XG4gICAgICBlbGVtZW50VXRpbGl0aWVzLnNldENsb25lTWFya2VyU3RhdHVzKG5ld05vZGUsIHRydWUpO1xuICAgICAgXG4gICAgfSAgXG4gICAgXG4gICAgdmFyIG5ld1Bvc2l0aW9uID0gY2xhY3VsYXRlTmV3Q2xvbmVQb3NpdGlvbihcbiAgICAgIGVkZ2VzWzBdLnNvdXJjZUVuZHBvaW50KCkueCxcbiAgICAgIGVkZ2VzWzBdLnNvdXJjZUVuZHBvaW50KCkueSxcbiAgICAgIGVkZ2VzWzBdLnRhcmdldEVuZHBvaW50KCkueCxcbiAgICAgIGVkZ2VzWzBdLnRhcmdldEVuZHBvaW50KCkueSxcbiAgICAgIGRlc2lyZWREaXN0YW5jZSxlZGdlc1swXS5zb3VyY2UoKS5pZCgpID09IG5vZGUuaWQoKSA/IFwic291cmNlXCIgOiBcInRhcmdldFwiXG4gICAgICApO1xuICBcbiAgICB2YXIgY2xvbmVFZGdlID0gZWRnZXNbMF0uY2xvbmUoKTtcbiAgICAvL2Nsb25lRWRnZS5kYXRhKCkuaWQgPSBjbG9uZUVkZ2UuZGF0YSgpLmlkKyBcIi1cIitub2RlLmlkKCkrJ2Nsb25lLTAnO1xuICAgIFxuICAgIGVkZ2VzWzBdLnJlbW92ZSgpO1xuICAgIGN5LmFkZChjbG9uZUVkZ2UpO1xuICAgIGVsZW1lbnRVdGlsaXRpZXMuc2V0Q2xvbmVNYXJrZXJTdGF0dXMobm9kZSx0cnVlKTtcbiAgICBub2RlLnBvc2l0aW9uKHtcbiAgICAgIHg6IG5ld1Bvc2l0aW9uLmN4LFxuICAgICAgeTogbmV3UG9zaXRpb24uY3lcbiAgICB9KTtcbiAgXG4gICAgcmVzdWx0Lm9sZFggPSBvbGRYOyAgICBcbiAgICByZXN1bHQub2xkWSA9IG9sZFk7XG4gICAgcmVzdWx0Lm5vZGUgPSBub2RlO1xuICAgIHJlc3VsdC5udW1iZXJPZkVkZ2VzID0gZWRnZXMubGVuZ3RoO1xuICAgIHJldHVybiByZXN1bHQ7XG5cbiAgfVxuXG4gIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLnVuQ2xvbmVIaWdoRGVncmVlTm9kZSA9IGZ1bmN0aW9uKHBhcmFtKXtcblxuICAgIHZhciBub2RlID0gcGFyYW0ubm9kZTtcbiAgICBlbGVtZW50VXRpbGl0aWVzLnNldENsb25lTWFya2VyU3RhdHVzKG5vZGUsZmFsc2UpO1xuICAgIG5vZGUucG9zaXRpb24oe1xuICAgICAgeDogcGFyYW0ub2xkWCxcbiAgICAgIHk6IHBhcmFtLm9sZFlcbiAgICB9KTtcbiAgXG4gICAgZm9yKHZhciBpID0gMSA7IGkgPCBwYXJhbS5udW1iZXJPZkVkZ2VzIDsgaSsrKXtcbiAgICAgIHZhciBjbG9uZUlkID0gbm9kZS5pZCgpKydjbG9uZS0nK2k7XG4gICAgICB2YXIgY2xvbmUgPSBjeS4kKFwiI1wiK2Nsb25lSWQpO1xuICAgICAgdmFyIGNsb25lRWRnZSA9IGNsb25lLmNvbm5lY3RlZEVkZ2VzKClbMF07XG4gICAgICB2YXIgZWRnZSA9IGNsb25lRWRnZS5jbG9uZSgpO1xuICAgICAgXG4gICAgXG4gICAgICBpZihlZGdlLmRhdGEoKS5zb3VyY2UgPT0gY2xvbmVJZCl7ICAgICAgICBcbiAgICAgICAgZWRnZS5kYXRhKCkuc291cmNlID0gbm9kZS5pZCgpO1xuICAgICAgICBlZGdlLmRhdGEoKS5wb3J0c291cmNlID0gIG5vZGUuaWQoKTsgICAgXG4gICAgICB9ZWxzZXsgICAgICAgICAgXG4gICAgICAgIGVkZ2UuZGF0YSgpLnRhcmdldCA9ICBub2RlLmlkKCk7XG4gICAgICAgIGVkZ2UuZGF0YSgpLnBvcnR0YXJnZXQgPSAgbm9kZS5pZCgpOyAgICBcbiAgICAgIH1cblxuICAgICAgY2xvbmVFZGdlLnJlbW92ZSgpO1xuICAgICAgY2xvbmUucmVtb3ZlKCk7XG4gICAgICBcbiAgICAgIGN5LmFkZChlZGdlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIHVuZG9SZWRvQWN0aW9uRnVuY3Rpb25zLmNoYW5nZU1hcFR5cGUgPSBmdW5jdGlvbihwYXJhbSl7XG4gICAgdmFyIHJlc3VsdCA9e307XG4gICAgdmFyIGN1cnJlbnRNYXBUeXBlID0gZWxlbWVudFV0aWxpdGllcy5nZXRNYXBUeXBlKCk7XG4gICAgZWxlbWVudFV0aWxpdGllcy5zZXRNYXBUeXBlKHBhcmFtLm1hcFR5cGUpO1xuICAgIHJlc3VsdC5tYXBUeXBlID0gY3VycmVudE1hcFR5cGU7XG4gICAgcmVzdWx0LmNhbGxiYWNrID0gcGFyYW0uY2FsbGJhY2s7XG4gICAgcGFyYW0uY2FsbGJhY2soKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgfVxuXG4gIHJldHVybiB1bmRvUmVkb0FjdGlvbkZ1bmN0aW9uc0V4dGVuZGVyO1xufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/utilities/ur-action-functions-extender-factory.js\n");

/***/ }),

/***/ "./node_modules/lodash.isequal/index.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash.isequal/index.js ***!
  \**********************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n/**\n * Lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright JS Foundation and other contributors <https://js.foundation/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    asyncTag = '[object AsyncFunction]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    nullTag = '[object Null]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    proxyTag = '[object Proxy]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]',\n    undefinedTag = '[object Undefined]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Detect free variable `exports`. */\nvar freeExports =  true && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && \"object\" == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * A specialized version of `_.filter` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction arrayFilter(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      resIndex = 0,\n      result = [];\n\n  while (++index < length) {\n    var value = array[index];\n    if (predicate(value, index, array)) {\n      result[resIndex++] = value;\n    }\n  }\n  return result;\n}\n\n/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\n/**\n * A specialized version of `_.some` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n */\nfunction arraySome(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (predicate(array[index], index, array)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\n/**\n * Checks if a `cache` value for `key` exists.\n *\n * @private\n * @param {Object} cache The cache to query.\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction cacheHas(cache, key) {\n  return cache.has(key);\n}\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Converts `map` to its key-value pairs.\n *\n * @private\n * @param {Object} map The map to convert.\n * @returns {Array} Returns the key-value pairs.\n */\nfunction mapToArray(map) {\n  var index = -1,\n      result = Array(map.size);\n\n  map.forEach(function(value, key) {\n    result[++index] = [key, value];\n  });\n  return result;\n}\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\n/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined,\n    Symbol = root.Symbol,\n    Uint8Array = root.Uint8Array,\n    propertyIsEnumerable = objectProto.propertyIsEnumerable,\n    splice = arrayProto.splice,\n    symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols,\n    nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,\n    nativeKeys = overArg(Object.keys, Object);\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView'),\n    Map = getNative(root, 'Map'),\n    Promise = getNative(root, 'Promise'),\n    Set = getNative(root, 'Set'),\n    WeakMap = getNative(root, 'WeakMap'),\n    nativeCreate = getNative(Object, 'create');\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n *\n * Creates an array cache object to store unique values.\n *\n * @private\n * @constructor\n * @param {Array} [values] The values to cache.\n */\nfunction SetCache(values) {\n  var index = -1,\n      length = values == null ? 0 : values.length;\n\n  this.__data__ = new MapCache;\n  while (++index < length) {\n    this.add(values[index]);\n  }\n}\n\n/**\n * Adds `value` to the array cache.\n *\n * @private\n * @name add\n * @memberOf SetCache\n * @alias push\n * @param {*} value The value to cache.\n * @returns {Object} Returns the cache instance.\n */\nfunction setCacheAdd(value) {\n  this.__data__.set(value, HASH_UNDEFINED);\n  return this;\n}\n\n/**\n * Checks if `value` is in the array cache.\n *\n * @private\n * @name has\n * @memberOf SetCache\n * @param {*} value The value to search for.\n * @returns {number} Returns `true` if `value` is found, else `false`.\n */\nfunction setCacheHas(value) {\n  return this.__data__.has(value);\n}\n\n// Add methods to `SetCache`.\nSetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\nSetCache.prototype.has = setCacheHas;\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  var data = this.__data__ = new ListCache(entries);\n  this.size = data.size;\n}\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  var data = this.__data__,\n      result = data['delete'](key);\n\n  this.size = data.size;\n  return result;\n}\n\n/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\n/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var data = this.__data__;\n  if (data instanceof ListCache) {\n    var pairs = data.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      this.size = ++data.size;\n      return this;\n    }\n    data = this.__data__ = new MapCache(pairs);\n  }\n  data.set(key, value);\n  this.size = data.size;\n  return this;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n}\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\n/**\n * The base implementation of `_.isEqual` which supports partial comparisons\n * and tracks traversed objects.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Unordered comparison\n *  2 - Partial comparison\n * @param {Function} [customizer] The function to customize comparisons.\n * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n */\nfunction baseIsEqual(value, other, bitmask, customizer, stack) {\n  if (value === other) {\n    return true;\n  }\n  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {\n    return value !== value && other !== other;\n  }\n  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n}\n\n/**\n * A specialized version of `baseIsEqual` for arrays and objects which performs\n * deep comparisons and tracks traversed objects enabling objects with circular\n * references to be compared.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n  var objIsArr = isArray(object),\n      othIsArr = isArray(other),\n      objTag = objIsArr ? arrayTag : getTag(object),\n      othTag = othIsArr ? arrayTag : getTag(other);\n\n  objTag = objTag == argsTag ? objectTag : objTag;\n  othTag = othTag == argsTag ? objectTag : othTag;\n\n  var objIsObj = objTag == objectTag,\n      othIsObj = othTag == objectTag,\n      isSameTag = objTag == othTag;\n\n  if (isSameTag && isBuffer(object)) {\n    if (!isBuffer(other)) {\n      return false;\n    }\n    objIsArr = true;\n    objIsObj = false;\n  }\n  if (isSameTag && !objIsObj) {\n    stack || (stack = new Stack);\n    return (objIsArr || isTypedArray(object))\n      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)\n      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n  }\n  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {\n    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n    if (objIsWrapped || othIsWrapped) {\n      var objUnwrapped = objIsWrapped ? object.value() : object,\n          othUnwrapped = othIsWrapped ? other.value() : other;\n\n      stack || (stack = new Stack);\n      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n    }\n  }\n  if (!isSameTag) {\n    return false;\n  }\n  stack || (stack = new Stack);\n  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for arrays with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Array} array The array to compare.\n * @param {Array} other The other array to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `array` and `other` objects.\n * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n */\nfunction equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      arrLength = array.length,\n      othLength = other.length;\n\n  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n    return false;\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(array);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var index = -1,\n      result = true,\n      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;\n\n  stack.set(array, other);\n  stack.set(other, array);\n\n  // Ignore non-index properties.\n  while (++index < arrLength) {\n    var arrValue = array[index],\n        othValue = other[index];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, arrValue, index, other, array, stack)\n        : customizer(arrValue, othValue, index, array, other, stack);\n    }\n    if (compared !== undefined) {\n      if (compared) {\n        continue;\n      }\n      result = false;\n      break;\n    }\n    // Recursively compare arrays (susceptible to call stack limits).\n    if (seen) {\n      if (!arraySome(other, function(othValue, othIndex) {\n            if (!cacheHas(seen, othIndex) &&\n                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n              return seen.push(othIndex);\n            }\n          })) {\n        result = false;\n        break;\n      }\n    } else if (!(\n          arrValue === othValue ||\n            equalFunc(arrValue, othValue, bitmask, customizer, stack)\n        )) {\n      result = false;\n      break;\n    }\n  }\n  stack['delete'](array);\n  stack['delete'](other);\n  return result;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for comparing objects of\n * the same `toStringTag`.\n *\n * **Note:** This function only supports comparing values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {string} tag The `toStringTag` of the objects to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n  switch (tag) {\n    case dataViewTag:\n      if ((object.byteLength != other.byteLength) ||\n          (object.byteOffset != other.byteOffset)) {\n        return false;\n      }\n      object = object.buffer;\n      other = other.buffer;\n\n    case arrayBufferTag:\n      if ((object.byteLength != other.byteLength) ||\n          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n        return false;\n      }\n      return true;\n\n    case boolTag:\n    case dateTag:\n    case numberTag:\n      // Coerce booleans to `1` or `0` and dates to milliseconds.\n      // Invalid dates are coerced to `NaN`.\n      return eq(+object, +other);\n\n    case errorTag:\n      return object.name == other.name && object.message == other.message;\n\n    case regexpTag:\n    case stringTag:\n      // Coerce regexes to strings and treat strings, primitives and objects,\n      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n      // for more details.\n      return object == (other + '');\n\n    case mapTag:\n      var convert = mapToArray;\n\n    case setTag:\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;\n      convert || (convert = setToArray);\n\n      if (object.size != other.size && !isPartial) {\n        return false;\n      }\n      // Assume cyclic values are equal.\n      var stacked = stack.get(object);\n      if (stacked) {\n        return stacked == other;\n      }\n      bitmask |= COMPARE_UNORDERED_FLAG;\n\n      // Recursively compare objects (susceptible to call stack limits).\n      stack.set(object, other);\n      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n      stack['delete'](object);\n      return result;\n\n    case symbolTag:\n      if (symbolValueOf) {\n        return symbolValueOf.call(object) == symbolValueOf.call(other);\n      }\n  }\n  return false;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for objects with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      objProps = getAllKeys(object),\n      objLength = objProps.length,\n      othProps = getAllKeys(other),\n      othLength = othProps.length;\n\n  if (objLength != othLength && !isPartial) {\n    return false;\n  }\n  var index = objLength;\n  while (index--) {\n    var key = objProps[index];\n    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n      return false;\n    }\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(object);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var result = true;\n  stack.set(object, other);\n  stack.set(other, object);\n\n  var skipCtor = isPartial;\n  while (++index < objLength) {\n    key = objProps[index];\n    var objValue = object[key],\n        othValue = other[key];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, objValue, key, other, object, stack)\n        : customizer(objValue, othValue, key, object, other, stack);\n    }\n    // Recursively compare objects (susceptible to call stack limits).\n    if (!(compared === undefined\n          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))\n          : compared\n        )) {\n      result = false;\n      break;\n    }\n    skipCtor || (skipCtor = key == 'constructor');\n  }\n  if (result && !skipCtor) {\n    var objCtor = object.constructor,\n        othCtor = other.constructor;\n\n    // Non `Object` object instances with different constructors are not equal.\n    if (objCtor != othCtor &&\n        ('constructor' in object && 'constructor' in other) &&\n        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n          typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n      result = false;\n    }\n  }\n  stack['delete'](object);\n  stack['delete'](other);\n  return result;\n}\n\n/**\n * Creates an array of own enumerable property names and symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeys(object) {\n  return baseGetAllKeys(object, keys, getSymbols);\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\n/**\n * Creates an array of the own enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbols = !nativeGetSymbols ? stubArray : function(object) {\n  if (object == null) {\n    return [];\n  }\n  object = Object(object);\n  return arrayFilter(nativeGetSymbols(object), function(symbol) {\n    return propertyIsEnumerable.call(object, symbol);\n  });\n};\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = baseGetTag(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : '';\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  length = length == null ? MAX_SAFE_INTEGER : length;\n  return !!length &&\n    (typeof value == 'number' || reIsUint.test(value)) &&\n    (value > -1 && value % 1 == 0 && value < length);\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\n/**\n * Performs a deep comparison between two values to determine if they are\n * equivalent.\n *\n * **Note:** This method supports comparing arrays, array buffers, booleans,\n * date objects, error objects, maps, numbers, `Object` objects, regexes,\n * sets, strings, symbols, and typed arrays. `Object` objects are compared\n * by their own, not inherited, enumerable properties. Functions and DOM\n * nodes are compared by strict equality, i.e. `===`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.isEqual(object, other);\n * // => true\n *\n * object === other;\n * // => false\n */\nfunction isEqual(value, other) {\n  return baseIsEqual(value, other);\n}\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\n/**\n * This method returns a new empty array.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {Array} Returns the new empty array.\n * @example\n *\n * var arrays = _.times(2, _.stubArray);\n *\n * console.log(arrays);\n * // => [[], []]\n *\n * console.log(arrays[0] === arrays[1]);\n * // => false\n */\nfunction stubArray() {\n  return [];\n}\n\n/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = isEqual;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jaGlzZS8uL25vZGVfbW9kdWxlcy9sb2Rhc2guaXNlcXVhbC9pbmRleC5qcz81ZGExIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQzs7QUFFcEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixxQkFBTSxnQkFBZ0IscUJBQU0sSUFBSSxxQkFBTSxzQkFBc0IscUJBQU07O0FBRTFGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixLQUEwQjs7QUFFNUM7QUFDQSxnQ0FBZ0MsUUFBYTs7QUFFN0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsU0FBUztBQUNwQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxNQUFNO0FB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QUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsT0FBTztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixXQUFXLE9BQU87QUFDbEIs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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbG9kYXNoLmlzZXF1YWwvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIExvZGFzaCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IEpTIEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyA8aHR0cHM6Ly9qcy5mb3VuZGF0aW9uLz5cbiAqIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqL1xuXG4vKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbnZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGFzeW5jVGFnID0gJ1tvYmplY3QgQXN5bmNGdW5jdGlvbl0nLFxuICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICBudWxsVGFnID0gJ1tvYmplY3QgTnVsbF0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHByb21pc2VUYWcgPSAnW29iamVjdCBQcm9taXNlXScsXG4gICAgcHJveHlUYWcgPSAnW29iamVjdCBQcm94eV0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nLFxuICAgIHVuZGVmaW5lZFRhZyA9ICdbb2JqZWN0IFVuZGVmaW5lZF0nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKipcbiAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcbiAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcGF0dGVybnMpLlxuICovXG52YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSkuICovXG52YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xudmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXFxkKikkLztcblxuLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgb2YgdHlwZWQgYXJyYXlzLiAqL1xudmFyIHR5cGVkQXJyYXlUYWdzID0ge307XG50eXBlZEFycmF5VGFnc1tmbG9hdDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Zsb2F0NjRUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDhUYWddID0gdHlwZWRBcnJheVRhZ3NbaW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50OENsYW1wZWRUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbnR5cGVkQXJyYXlUYWdzW2FyZ3NUYWddID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlUYWddID1cbnR5cGVkQXJyYXlUYWdzW2FycmF5QnVmZmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Jvb2xUYWddID1cbnR5cGVkQXJyYXlUYWdzW2RhdGFWaWV3VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2RhdGVUYWddID1cbnR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Z1bmNUYWddID1cbnR5cGVkQXJyYXlUYWdzW21hcFRhZ10gPSB0eXBlZEFycmF5VGFnc1tudW1iZXJUYWddID1cbnR5cGVkQXJyYXlUYWdzW29iamVjdFRhZ10gPSB0eXBlZEFycmF5VGFnc1tyZWdleHBUYWddID1cbnR5cGVkQXJyYXlUYWdzW3NldFRhZ10gPSB0eXBlZEFycmF5VGFnc1tzdHJpbmdUYWddID1cbnR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG52YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG52YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHByb2Nlc3NgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlUHJvY2VzcyA9IG1vZHVsZUV4cG9ydHMgJiYgZnJlZUdsb2JhbC5wcm9jZXNzO1xuXG4vKiogVXNlZCB0byBhY2Nlc3MgZmFzdGVyIE5vZGUuanMgaGVscGVycy4gKi9cbnZhciBub2RlVXRpbCA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZnJlZVByb2Nlc3MgJiYgZnJlZVByb2Nlc3MuYmluZGluZyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nKCd1dGlsJyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc1R5cGVkQXJyYXkgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1R5cGVkQXJyYXk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZpbHRlcmAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheUZpbHRlcihhcnJheSwgcHJlZGljYXRlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICByZXNJbmRleCA9IDAsXG4gICAgICByZXN1bHQgPSBbXTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBBcHBlbmRzIHRoZSBlbGVtZW50cyBvZiBgdmFsdWVzYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gYXBwZW5kLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5UHVzaChhcnJheSwgdmFsdWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgIG9mZnNldCA9IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W29mZnNldCArIGluZGV4XSA9IHZhbHVlc1tpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zb21lYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAqIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlTb21lKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuYXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIHN0b3JpbmcgbWV0YWRhdGEuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlVW5hcnkoZnVuYykge1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnVuYyh2YWx1ZSk7XG4gIH07XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgYGNhY2hlYCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gY2FjaGUgVGhlIGNhY2hlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGNhY2hlSGFzKGNhY2hlLCBrZXkpIHtcbiAgcmV0dXJuIGNhY2hlLmhhcyhrZXkpO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBnZXRWYWx1ZShvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgbWFwYCB0byBpdHMga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUga2V5LXZhbHVlIHBhaXJzLlxuICovXG5mdW5jdGlvbiBtYXBUb0FycmF5KG1hcCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG1hcC5zaXplKTtcblxuICBtYXAuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gW2tleSwgdmFsdWVdO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7XG4gIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XG4gIH07XG59XG5cbi8qKlxuICogQ29udmVydHMgYHNldGAgdG8gYW4gYXJyYXkgb2YgaXRzIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNldCBUaGUgc2V0IHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gc2V0VG9BcnJheShzZXQpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShzZXQuc2l6ZSk7XG5cbiAgc2V0LmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSB2YWx1ZTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlLFxuICAgIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvdmVycmVhY2hpbmcgY29yZS1qcyBzaGltcy4gKi9cbnZhciBjb3JlSnNEYXRhID0gcm9vdFsnX19jb3JlLWpzX3NoYXJlZF9fJ107XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtZXRob2RzIG1hc3F1ZXJhZGluZyBhcyBuYXRpdmUuICovXG52YXIgbWFza1NyY0tleSA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHVpZCA9IC9bXi5dKyQvLmV4ZWMoY29yZUpzRGF0YSAmJiBjb3JlSnNEYXRhLmtleXMgJiYgY29yZUpzRGF0YS5rZXlzLklFX1BST1RPIHx8ICcnKTtcbiAgcmV0dXJuIHVpZCA/ICgnU3ltYm9sKHNyYylfMS4nICsgdWlkKSA6ICcnO1xufSgpKTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG52YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICBmdW5jVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSkucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxuICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbik7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZCxcbiAgICBTeW1ib2wgPSByb290LlN5bWJvbCxcbiAgICBVaW50OEFycmF5ID0gcm9vdC5VaW50OEFycmF5LFxuICAgIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGUsXG4gICAgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2UsXG4gICAgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVHZXRTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyxcbiAgICBuYXRpdmVJc0J1ZmZlciA9IEJ1ZmZlciA/IEJ1ZmZlci5pc0J1ZmZlciA6IHVuZGVmaW5lZCxcbiAgICBuYXRpdmVLZXlzID0gb3ZlckFyZyhPYmplY3Qua2V5cywgT2JqZWN0KTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIERhdGFWaWV3ID0gZ2V0TmF0aXZlKHJvb3QsICdEYXRhVmlldycpLFxuICAgIE1hcCA9IGdldE5hdGl2ZShyb290LCAnTWFwJyksXG4gICAgUHJvbWlzZSA9IGdldE5hdGl2ZShyb290LCAnUHJvbWlzZScpLFxuICAgIFNldCA9IGdldE5hdGl2ZShyb290LCAnU2V0JyksXG4gICAgV2Vha01hcCA9IGdldE5hdGl2ZShyb290LCAnV2Vha01hcCcpLFxuICAgIG5hdGl2ZUNyZWF0ZSA9IGdldE5hdGl2ZShPYmplY3QsICdjcmVhdGUnKTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1hcHMsIHNldHMsIGFuZCB3ZWFrbWFwcy4gKi9cbnZhciBkYXRhVmlld0N0b3JTdHJpbmcgPSB0b1NvdXJjZShEYXRhVmlldyksXG4gICAgbWFwQ3RvclN0cmluZyA9IHRvU291cmNlKE1hcCksXG4gICAgcHJvbWlzZUN0b3JTdHJpbmcgPSB0b1NvdXJjZShQcm9taXNlKSxcbiAgICBzZXRDdG9yU3RyaW5nID0gdG9Tb3VyY2UoU2V0KSxcbiAgICB3ZWFrTWFwQ3RvclN0cmluZyA9IHRvU291cmNlKFdlYWtNYXApO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVmFsdWVPZiA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udmFsdWVPZiA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgaGFzaCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIEhhc2goZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgSGFzaFxuICovXG5mdW5jdGlvbiBoYXNoQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuYXRpdmVDcmVhdGUgPyBuYXRpdmVDcmVhdGUobnVsbCkgOiB7fTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtPYmplY3R9IGhhc2ggVGhlIGhhc2ggdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBoYXNoIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGhhc2hHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKG5hdGl2ZUNyZWF0ZSkge1xuICAgIHZhciByZXN1bHQgPSBkYXRhW2tleV07XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gSEFTSF9VTkRFRklORUQgPyB1bmRlZmluZWQgOiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KSA/IGRhdGFba2V5XSA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBoYXNoIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoSGFzKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHJldHVybiBuYXRpdmVDcmVhdGUgPyAoZGF0YVtrZXldICE9PSB1bmRlZmluZWQpIDogaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIGhhc2ggYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBoYXNoIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBoYXNoU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICB0aGlzLnNpemUgKz0gdGhpcy5oYXMoa2V5KSA/IDAgOiAxO1xuICBkYXRhW2tleV0gPSAobmF0aXZlQ3JlYXRlICYmIHZhbHVlID09PSB1bmRlZmluZWQpID8gSEFTSF9VTkRFRklORUQgOiB2YWx1ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBIYXNoYC5cbkhhc2gucHJvdG90eXBlLmNsZWFyID0gaGFzaENsZWFyO1xuSGFzaC5wcm90b3R5cGVbJ2RlbGV0ZSddID0gaGFzaERlbGV0ZTtcbkhhc2gucHJvdG90eXBlLmdldCA9IGhhc2hHZXQ7XG5IYXNoLnByb3RvdHlwZS5oYXMgPSBoYXNoSGFzO1xuSGFzaC5wcm90b3R5cGUuc2V0ID0gaGFzaFNldDtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGxpc3QgY2FjaGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBMaXN0Q2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUNsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gW107XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBsYXN0SW5kZXggPSBkYXRhLmxlbmd0aCAtIDE7XG4gIGlmIChpbmRleCA9PSBsYXN0SW5kZXgpIHtcbiAgICBkYXRhLnBvcCgpO1xuICB9IGVsc2Uge1xuICAgIHNwbGljZS5jYWxsKGRhdGEsIGluZGV4LCAxKTtcbiAgfVxuICAtLXRoaXMuc2l6ZTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICByZXR1cm4gaW5kZXggPCAwID8gdW5kZWZpbmVkIDogZGF0YVtpbmRleF1bMV07XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBhc3NvY0luZGV4T2YodGhpcy5fX2RhdGFfXywga2V5KSA+IC0xO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIGxpc3QgY2FjaGUgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGxpc3QgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgICsrdGhpcy5zaXplO1xuICAgIGRhdGEucHVzaChba2V5LCB2YWx1ZV0pO1xuICB9IGVsc2Uge1xuICAgIGRhdGFbaW5kZXhdWzFdID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBMaXN0Q2FjaGVgLlxuTGlzdENhY2hlLnByb3RvdHlwZS5jbGVhciA9IGxpc3RDYWNoZUNsZWFyO1xuTGlzdENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBsaXN0Q2FjaGVEZWxldGU7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmdldCA9IGxpc3RDYWNoZUdldDtcbkxpc3RDYWNoZS5wcm90b3R5cGUuaGFzID0gbGlzdENhY2hlSGFzO1xuTGlzdENhY2hlLnByb3RvdHlwZS5zZXQgPSBsaXN0Q2FjaGVTZXQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hcCBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBNYXBDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuc2l6ZSA9IDA7XG4gIHRoaXMuX19kYXRhX18gPSB7XG4gICAgJ2hhc2gnOiBuZXcgSGFzaCxcbiAgICAnbWFwJzogbmV3IChNYXAgfHwgTGlzdENhY2hlKSxcbiAgICAnc3RyaW5nJzogbmV3IEhhc2hcbiAgfTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpWydkZWxldGUnXShrZXkpO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbWFwIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUdldChrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5nZXQoa2V5KTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBtYXAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5oYXMoa2V5KTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBtYXAgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbWFwIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLFxuICAgICAgc2l6ZSA9IGRhdGEuc2l6ZTtcblxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplICs9IGRhdGEuc2l6ZSA9PSBzaXplID8gMCA6IDE7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTWFwQ2FjaGVgLlxuTWFwQ2FjaGUucHJvdG90eXBlLmNsZWFyID0gbWFwQ2FjaGVDbGVhcjtcbk1hcENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBtYXBDYWNoZURlbGV0ZTtcbk1hcENhY2hlLnByb3RvdHlwZS5nZXQgPSBtYXBDYWNoZUdldDtcbk1hcENhY2hlLnByb3RvdHlwZS5oYXMgPSBtYXBDYWNoZUhhcztcbk1hcENhY2hlLnByb3RvdHlwZS5zZXQgPSBtYXBDYWNoZVNldDtcblxuLyoqXG4gKlxuICogQ3JlYXRlcyBhbiBhcnJheSBjYWNoZSBvYmplY3QgdG8gc3RvcmUgdW5pcXVlIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTZXRDYWNoZSh2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMgPT0gbnVsbCA/IDAgOiB2YWx1ZXMubGVuZ3RoO1xuXG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGU7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdGhpcy5hZGQodmFsdWVzW2luZGV4XSk7XG4gIH1cbn1cblxuLyoqXG4gKiBBZGRzIGB2YWx1ZWAgdG8gdGhlIGFycmF5IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBhZGRcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICogQGFsaWFzIHB1c2hcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNhY2hlLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIHNldENhY2hlQWRkKHZhbHVlKSB7XG4gIHRoaXMuX19kYXRhX18uc2V0KHZhbHVlLCBIQVNIX1VOREVGSU5FRCk7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGluIHRoZSBhcnJheSBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHNldENhY2hlSGFzKHZhbHVlKSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyh2YWx1ZSk7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBTZXRDYWNoZWAuXG5TZXRDYWNoZS5wcm90b3R5cGUuYWRkID0gU2V0Q2FjaGUucHJvdG90eXBlLnB1c2ggPSBzZXRDYWNoZUFkZDtcblNldENhY2hlLnByb3RvdHlwZS5oYXMgPSBzZXRDYWNoZUhhcztcblxuLyoqXG4gKiBDcmVhdGVzIGEgc3RhY2sgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gU3RhY2soZW50cmllcykge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlKGVudHJpZXMpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqL1xuZnVuY3Rpb24gc3RhY2tDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGU7XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICByZXN1bHQgPSBkYXRhWydkZWxldGUnXShrZXkpO1xuXG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBzdGFjayB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tHZXQoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmdldChrZXkpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIHN0YWNrIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc3RhY2tIYXMoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyhrZXkpO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIHN0YWNrIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIHN0YWNrIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzdGFja1NldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBMaXN0Q2FjaGUpIHtcbiAgICB2YXIgcGFpcnMgPSBkYXRhLl9fZGF0YV9fO1xuICAgIGlmICghTWFwIHx8IChwYWlycy5sZW5ndGggPCBMQVJHRV9BUlJBWV9TSVpFIC0gMSkpIHtcbiAgICAgIHBhaXJzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgIHRoaXMuc2l6ZSA9ICsrZGF0YS5zaXplO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlKHBhaXJzKTtcbiAgfVxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFN0YWNrYC5cblN0YWNrLnByb3RvdHlwZS5jbGVhciA9IHN0YWNrQ2xlYXI7XG5TdGFjay5wcm90b3R5cGVbJ2RlbGV0ZSddID0gc3RhY2tEZWxldGU7XG5TdGFjay5wcm90b3R5cGUuZ2V0ID0gc3RhY2tHZXQ7XG5TdGFjay5wcm90b3R5cGUuaGFzID0gc3RhY2tIYXM7XG5TdGFjay5wcm90b3R5cGUuc2V0ID0gc3RhY2tTZXQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiB0aGUgYXJyYXktbGlrZSBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5oZXJpdGVkIFNwZWNpZnkgcmV0dXJuaW5nIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lcy5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TGlrZUtleXModmFsdWUsIGluaGVyaXRlZCkge1xuICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKSxcbiAgICAgIGlzQXJnID0gIWlzQXJyICYmIGlzQXJndW1lbnRzKHZhbHVlKSxcbiAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiAhaXNBcmcgJiYgaXNCdWZmZXIodmFsdWUpLFxuICAgICAgaXNUeXBlID0gIWlzQXJyICYmICFpc0FyZyAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheSh2YWx1ZSksXG4gICAgICBza2lwSW5kZXhlcyA9IGlzQXJyIHx8IGlzQXJnIHx8IGlzQnVmZiB8fCBpc1R5cGUsXG4gICAgICByZXN1bHQgPSBza2lwSW5kZXhlcyA/IGJhc2VUaW1lcyh2YWx1ZS5sZW5ndGgsIFN0cmluZykgOiBbXSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKChpbmhlcml0ZWQgfHwgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkgJiZcbiAgICAgICAgIShza2lwSW5kZXhlcyAmJiAoXG4gICAgICAgICAgIC8vIFNhZmFyaSA5IGhhcyBlbnVtZXJhYmxlIGBhcmd1bWVudHMubGVuZ3RoYCBpbiBzdHJpY3QgbW9kZS5cbiAgICAgICAgICAga2V5ID09ICdsZW5ndGgnIHx8XG4gICAgICAgICAgIC8vIE5vZGUuanMgMC4xMCBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiBidWZmZXJzLlxuICAgICAgICAgICAoaXNCdWZmICYmIChrZXkgPT0gJ29mZnNldCcgfHwga2V5ID09ICdwYXJlbnQnKSkgfHxcbiAgICAgICAgICAgLy8gUGhhbnRvbUpTIDIgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gdHlwZWQgYXJyYXlzLlxuICAgICAgICAgICAoaXNUeXBlICYmIChrZXkgPT0gJ2J1ZmZlcicgfHwga2V5ID09ICdieXRlTGVuZ3RoJyB8fCBrZXkgPT0gJ2J5dGVPZmZzZXQnKSkgfHxcbiAgICAgICAgICAgLy8gU2tpcCBpbmRleCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICBpc0luZGV4KGtleSwgbGVuZ3RoKVxuICAgICAgICApKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgYGtleWAgaXMgZm91bmQgaW4gYGFycmF5YCBvZiBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSBrZXkgVGhlIGtleSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYXNzb2NJbmRleE9mKGFycmF5LCBrZXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgaWYgKGVxKGFycmF5W2xlbmd0aF1bMF0sIGtleSkpIHtcbiAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0QWxsS2V5c2AgYW5kIGBnZXRBbGxLZXlzSW5gIHdoaWNoIHVzZXNcbiAqIGBrZXlzRnVuY2AgYW5kIGBzeW1ib2xzRnVuY2AgdG8gZ2V0IHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZFxuICogc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN5bWJvbHNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXNGdW5jLCBzeW1ib2xzRnVuYykge1xuICB2YXIgcmVzdWx0ID0ga2V5c0Z1bmMob2JqZWN0KTtcbiAgcmV0dXJuIGlzQXJyYXkob2JqZWN0KSA/IHJlc3VsdCA6IGFycmF5UHVzaChyZXN1bHQsIHN5bWJvbHNGdW5jKG9iamVjdCkpO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgfVxuICByZXR1cm4gKHN5bVRvU3RyaW5nVGFnICYmIHN5bVRvU3RyaW5nVGFnIGluIE9iamVjdCh2YWx1ZSkpXG4gICAgPyBnZXRSYXdUYWcodmFsdWUpXG4gICAgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNBcmd1bWVudHNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqL1xuZnVuY3Rpb24gYmFzZUlzQXJndW1lbnRzKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGFyZ3NUYWc7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNFcXVhbGAgd2hpY2ggc3VwcG9ydHMgcGFydGlhbCBjb21wYXJpc29uc1xuICogYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuXG4gKiAgMSAtIFVub3JkZXJlZCBjb21wYXJpc29uXG4gKiAgMiAtIFBhcnRpYWwgY29tcGFyaXNvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGB2YWx1ZWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spIHtcbiAgaWYgKHZhbHVlID09PSBvdGhlcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsIHx8IG90aGVyID09IG51bGwgfHwgKCFpc09iamVjdExpa2UodmFsdWUpICYmICFpc09iamVjdExpa2Uob3RoZXIpKSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyO1xuICB9XG4gIHJldHVybiBiYXNlSXNFcXVhbERlZXAodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBiYXNlSXNFcXVhbCwgc3RhY2spO1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxgIGZvciBhcnJheXMgYW5kIG9iamVjdHMgd2hpY2ggcGVyZm9ybXNcbiAqIGRlZXAgY29tcGFyaXNvbnMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcbiAqIHJlZmVyZW5jZXMgdG8gYmUgY29tcGFyZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0VxdWFsRGVlcChvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBvYmpJc0FyciA9IGlzQXJyYXkob2JqZWN0KSxcbiAgICAgIG90aElzQXJyID0gaXNBcnJheShvdGhlciksXG4gICAgICBvYmpUYWcgPSBvYmpJc0FyciA/IGFycmF5VGFnIDogZ2V0VGFnKG9iamVjdCksXG4gICAgICBvdGhUYWcgPSBvdGhJc0FyciA/IGFycmF5VGFnIDogZ2V0VGFnKG90aGVyKTtcblxuICBvYmpUYWcgPSBvYmpUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG9ialRhZztcbiAgb3RoVGFnID0gb3RoVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvdGhUYWc7XG5cbiAgdmFyIG9iaklzT2JqID0gb2JqVGFnID09IG9iamVjdFRhZyxcbiAgICAgIG90aElzT2JqID0gb3RoVGFnID09IG9iamVjdFRhZyxcbiAgICAgIGlzU2FtZVRhZyA9IG9ialRhZyA9PSBvdGhUYWc7XG5cbiAgaWYgKGlzU2FtZVRhZyAmJiBpc0J1ZmZlcihvYmplY3QpKSB7XG4gICAgaWYgKCFpc0J1ZmZlcihvdGhlcikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgb2JqSXNBcnIgPSB0cnVlO1xuICAgIG9iaklzT2JqID0gZmFsc2U7XG4gIH1cbiAgaWYgKGlzU2FtZVRhZyAmJiAhb2JqSXNPYmopIHtcbiAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgIHJldHVybiAob2JqSXNBcnIgfHwgaXNUeXBlZEFycmF5KG9iamVjdCkpXG4gICAgICA/IGVxdWFsQXJyYXlzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spXG4gICAgICA6IGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgb2JqVGFnLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgfVxuICBpZiAoIShiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcpKSB7XG4gICAgdmFyIG9iaklzV3JhcHBlZCA9IG9iaklzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCAnX193cmFwcGVkX18nKSxcbiAgICAgICAgb3RoSXNXcmFwcGVkID0gb3RoSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwgJ19fd3JhcHBlZF9fJyk7XG5cbiAgICBpZiAob2JqSXNXcmFwcGVkIHx8IG90aElzV3JhcHBlZCkge1xuICAgICAgdmFyIG9ialVud3JhcHBlZCA9IG9iaklzV3JhcHBlZCA/IG9iamVjdC52YWx1ZSgpIDogb2JqZWN0LFxuICAgICAgICAgIG90aFVud3JhcHBlZCA9IG90aElzV3JhcHBlZCA/IG90aGVyLnZhbHVlKCkgOiBvdGhlcjtcblxuICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICAgIHJldHVybiBlcXVhbEZ1bmMob2JqVW53cmFwcGVkLCBvdGhVbndyYXBwZWQsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFpc1NhbWVUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgcmV0dXJuIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hdGl2ZWAgd2l0aG91dCBiYWQgc2hpbSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNOYXRpdmUodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkgfHwgaXNNYXNrZWQodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwYXR0ZXJuID0gaXNGdW5jdGlvbih2YWx1ZSkgPyByZUlzTmF0aXZlIDogcmVJc0hvc3RDdG9yO1xuICByZXR1cm4gcGF0dGVybi50ZXN0KHRvU291cmNlKHZhbHVlKSk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNUeXBlZEFycmF5YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc1R5cGVkQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiZcbiAgICBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICEhdHlwZWRBcnJheVRhZ3NbYmFzZUdldFRhZyh2YWx1ZSldO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNgIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYmFzZUtleXMob2JqZWN0KSB7XG4gIGlmICghaXNQcm90b3R5cGUob2JqZWN0KSkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzKG9iamVjdCk7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYga2V5ICE9ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBhcnJheXMgd2l0aCBzdXBwb3J0IGZvclxuICogcGFydGlhbCBkZWVwIGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7QXJyYXl9IG90aGVyIFRoZSBvdGhlciBhcnJheSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgYXJyYXlgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFycmF5cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbEFycmF5cyhhcnJheSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRyxcbiAgICAgIGFyckxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIG90aExlbmd0aCA9IG90aGVyLmxlbmd0aDtcblxuICBpZiAoYXJyTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhKGlzUGFydGlhbCAmJiBvdGhMZW5ndGggPiBhcnJMZW5ndGgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQoYXJyYXkpO1xuICBpZiAoc3RhY2tlZCAmJiBzdGFjay5nZXQob3RoZXIpKSB7XG4gICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gIH1cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSB0cnVlLFxuICAgICAgc2VlbiA9IChiaXRtYXNrICYgQ09NUEFSRV9VTk9SREVSRURfRkxBRykgPyBuZXcgU2V0Q2FjaGUgOiB1bmRlZmluZWQ7XG5cbiAgc3RhY2suc2V0KGFycmF5LCBvdGhlcik7XG4gIHN0YWNrLnNldChvdGhlciwgYXJyYXkpO1xuXG4gIC8vIElnbm9yZSBub24taW5kZXggcHJvcGVydGllcy5cbiAgd2hpbGUgKCsraW5kZXggPCBhcnJMZW5ndGgpIHtcbiAgICB2YXIgYXJyVmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgIG90aFZhbHVlID0gb3RoZXJbaW5kZXhdO1xuXG4gICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIGFyclZhbHVlLCBpbmRleCwgb3RoZXIsIGFycmF5LCBzdGFjaylcbiAgICAgICAgOiBjdXN0b21pemVyKGFyclZhbHVlLCBvdGhWYWx1ZSwgaW5kZXgsIGFycmF5LCBvdGhlciwgc3RhY2spO1xuICAgIH1cbiAgICBpZiAoY29tcGFyZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGNvbXBhcmVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBpZiAoc2Vlbikge1xuICAgICAgaWYgKCFhcnJheVNvbWUob3RoZXIsIGZ1bmN0aW9uKG90aFZhbHVlLCBvdGhJbmRleCkge1xuICAgICAgICAgICAgaWYgKCFjYWNoZUhhcyhzZWVuLCBvdGhJbmRleCkgJiZcbiAgICAgICAgICAgICAgICAoYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNlZW4ucHVzaChvdGhJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkpIHtcbiAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIShcbiAgICAgICAgICBhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHxcbiAgICAgICAgICAgIGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKVxuICAgICAgICApKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBzdGFja1snZGVsZXRlJ10oYXJyYXkpO1xuICBzdGFja1snZGVsZXRlJ10ob3RoZXIpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgY29tcGFyaW5nIG9iamVjdHMgb2ZcbiAqIHRoZSBzYW1lIGB0b1N0cmluZ1RhZ2AuXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjb21wYXJpbmcgdmFsdWVzIHdpdGggdGFncyBvZlxuICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgb3IgYFN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGB0b1N0cmluZ1RhZ2Agb2YgdGhlIG9iamVjdHMgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIHRhZywgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgZGF0YVZpZXdUYWc6XG4gICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XG4gICAgICAgICAgKG9iamVjdC5ieXRlT2Zmc2V0ICE9IG90aGVyLmJ5dGVPZmZzZXQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIG9iamVjdCA9IG9iamVjdC5idWZmZXI7XG4gICAgICBvdGhlciA9IG90aGVyLmJ1ZmZlcjtcblxuICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XG4gICAgICAgICAgIWVxdWFsRnVuYyhuZXcgVWludDhBcnJheShvYmplY3QpLCBuZXcgVWludDhBcnJheShvdGhlcikpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgY2FzZSBib29sVGFnOlxuICAgIGNhc2UgZGF0ZVRhZzpcbiAgICBjYXNlIG51bWJlclRhZzpcbiAgICAgIC8vIENvZXJjZSBib29sZWFucyB0byBgMWAgb3IgYDBgIGFuZCBkYXRlcyB0byBtaWxsaXNlY29uZHMuXG4gICAgICAvLyBJbnZhbGlkIGRhdGVzIGFyZSBjb2VyY2VkIHRvIGBOYU5gLlxuICAgICAgcmV0dXJuIGVxKCtvYmplY3QsICtvdGhlcik7XG5cbiAgICBjYXNlIGVycm9yVGFnOlxuICAgICAgcmV0dXJuIG9iamVjdC5uYW1lID09IG90aGVyLm5hbWUgJiYgb2JqZWN0Lm1lc3NhZ2UgPT0gb3RoZXIubWVzc2FnZTtcblxuICAgIGNhc2UgcmVnZXhwVGFnOlxuICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgLy8gQ29lcmNlIHJlZ2V4ZXMgdG8gc3RyaW5ncyBhbmQgdHJlYXQgc3RyaW5ncywgcHJpbWl0aXZlcyBhbmQgb2JqZWN0cyxcbiAgICAgIC8vIGFzIGVxdWFsLiBTZWUgaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXJlZ2V4cC5wcm90b3R5cGUudG9zdHJpbmdcbiAgICAgIC8vIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICByZXR1cm4gb2JqZWN0ID09IChvdGhlciArICcnKTtcblxuICAgIGNhc2UgbWFwVGFnOlxuICAgICAgdmFyIGNvbnZlcnQgPSBtYXBUb0FycmF5O1xuXG4gICAgY2FzZSBzZXRUYWc6XG4gICAgICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHO1xuICAgICAgY29udmVydCB8fCAoY29udmVydCA9IHNldFRvQXJyYXkpO1xuXG4gICAgICBpZiAob2JqZWN0LnNpemUgIT0gb3RoZXIuc2l6ZSAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgICAgIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gICAgICBpZiAoc3RhY2tlZCkge1xuICAgICAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGJpdG1hc2sgfD0gQ09NUEFSRV9VTk9SREVSRURfRkxBRztcblxuICAgICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICBzdGFjay5zZXQob2JqZWN0LCBvdGhlcik7XG4gICAgICB2YXIgcmVzdWx0ID0gZXF1YWxBcnJheXMoY29udmVydChvYmplY3QpLCBjb252ZXJ0KG90aGVyKSwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gICAgICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICBjYXNlIHN5bWJvbFRhZzpcbiAgICAgIGlmIChzeW1ib2xWYWx1ZU9mKSB7XG4gICAgICAgIHJldHVybiBzeW1ib2xWYWx1ZU9mLmNhbGwob2JqZWN0KSA9PSBzeW1ib2xWYWx1ZU9mLmNhbGwob3RoZXIpO1xuICAgICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIG9iamVjdHMgd2l0aCBzdXBwb3J0IGZvclxuICogcGFydGlhbCBkZWVwIGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRyxcbiAgICAgIG9ialByb3BzID0gZ2V0QWxsS2V5cyhvYmplY3QpLFxuICAgICAgb2JqTGVuZ3RoID0gb2JqUHJvcHMubGVuZ3RoLFxuICAgICAgb3RoUHJvcHMgPSBnZXRBbGxLZXlzKG90aGVyKSxcbiAgICAgIG90aExlbmd0aCA9IG90aFByb3BzLmxlbmd0aDtcblxuICBpZiAob2JqTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBpbmRleCA9IG9iakxlbmd0aDtcbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICB2YXIga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgIGlmICghKGlzUGFydGlhbCA/IGtleSBpbiBvdGhlciA6IGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsIGtleSkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcbiAgaWYgKHN0YWNrZWQgJiYgc3RhY2suZ2V0KG90aGVyKSkge1xuICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICB9XG4gIHZhciByZXN1bHQgPSB0cnVlO1xuICBzdGFjay5zZXQob2JqZWN0LCBvdGhlcik7XG4gIHN0YWNrLnNldChvdGhlciwgb2JqZWN0KTtcblxuICB2YXIgc2tpcEN0b3IgPSBpc1BhcnRpYWw7XG4gIHdoaWxlICgrK2luZGV4IDwgb2JqTGVuZ3RoKSB7XG4gICAga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2tleV07XG5cbiAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgb2JqVmFsdWUsIGtleSwgb3RoZXIsIG9iamVjdCwgc3RhY2spXG4gICAgICAgIDogY3VzdG9taXplcihvYmpWYWx1ZSwgb3RoVmFsdWUsIGtleSwgb2JqZWN0LCBvdGhlciwgc3RhY2spO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBpZiAoIShjb21wYXJlZCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgPyAob2JqVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhvYmpWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSlcbiAgICAgICAgICA6IGNvbXBhcmVkXG4gICAgICAgICkpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHNraXBDdG9yIHx8IChza2lwQ3RvciA9IGtleSA9PSAnY29uc3RydWN0b3InKTtcbiAgfVxuICBpZiAocmVzdWx0ICYmICFza2lwQ3Rvcikge1xuICAgIHZhciBvYmpDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yLFxuICAgICAgICBvdGhDdG9yID0gb3RoZXIuY29uc3RydWN0b3I7XG5cbiAgICAvLyBOb24gYE9iamVjdGAgb2JqZWN0IGluc3RhbmNlcyB3aXRoIGRpZmZlcmVudCBjb25zdHJ1Y3RvcnMgYXJlIG5vdCBlcXVhbC5cbiAgICBpZiAob2JqQ3RvciAhPSBvdGhDdG9yICYmXG4gICAgICAgICgnY29uc3RydWN0b3InIGluIG9iamVjdCAmJiAnY29uc3RydWN0b3InIGluIG90aGVyKSAmJlxuICAgICAgICAhKHR5cGVvZiBvYmpDdG9yID09ICdmdW5jdGlvbicgJiYgb2JqQ3RvciBpbnN0YW5jZW9mIG9iakN0b3IgJiZcbiAgICAgICAgICB0eXBlb2Ygb3RoQ3RvciA9PSAnZnVuY3Rpb24nICYmIG90aEN0b3IgaW5zdGFuY2VvZiBvdGhDdG9yKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHN0YWNrWydkZWxldGUnXShvYmplY3QpO1xuICBzdGFja1snZGVsZXRlJ10ob3RoZXIpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGdldEFsbEtleXMob2JqZWN0KSB7XG4gIHJldHVybiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXMsIGdldFN5bWJvbHMpO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGRhdGEgZm9yIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hcCBkYXRhLlxuICovXG5mdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG4gIHZhciBkYXRhID0gbWFwLl9fZGF0YV9fO1xuICByZXR1cm4gaXNLZXlhYmxlKGtleSlcbiAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgIDogZGF0YS5tYXA7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShvYmplY3QsIGtleSk7XG4gIHJldHVybiBiYXNlSXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlR2V0VGFnYCB3aGljaCBpZ25vcmVzIGBTeW1ib2wudG9TdHJpbmdUYWdgIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByYXcgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gZ2V0UmF3VGFnKHZhbHVlKSB7XG4gIHZhciBpc093biA9IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHN5bVRvU3RyaW5nVGFnKSxcbiAgICAgIHRhZyA9IHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcblxuICB0cnkge1xuICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHVuZGVmaW5lZDtcbiAgICB2YXIgdW5tYXNrZWQgPSB0cnVlO1xuICB9IGNhdGNoIChlKSB7fVxuXG4gIHZhciByZXN1bHQgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgaWYgKHVubWFza2VkKSB7XG4gICAgaWYgKGlzT3duKSB7XG4gICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB0YWc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBzeW1ib2xzLlxuICovXG52YXIgZ2V0U3ltYm9scyA9ICFuYXRpdmVHZXRTeW1ib2xzID8gc3R1YkFycmF5IDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgcmV0dXJuIGFycmF5RmlsdGVyKG5hdGl2ZUdldFN5bWJvbHMob2JqZWN0KSwgZnVuY3Rpb24oc3ltYm9sKSB7XG4gICAgcmV0dXJuIHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob2JqZWN0LCBzeW1ib2wpO1xuICB9KTtcbn07XG5cbi8qKlxuICogR2V0cyB0aGUgYHRvU3RyaW5nVGFnYCBvZiBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbnZhciBnZXRUYWcgPSBiYXNlR2V0VGFnO1xuXG4vLyBGYWxsYmFjayBmb3IgZGF0YSB2aWV3cywgbWFwcywgc2V0cywgYW5kIHdlYWsgbWFwcyBpbiBJRSAxMSBhbmQgcHJvbWlzZXMgaW4gTm9kZS5qcyA8IDYuXG5pZiAoKERhdGFWaWV3ICYmIGdldFRhZyhuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDEpKSkgIT0gZGF0YVZpZXdUYWcpIHx8XG4gICAgKE1hcCAmJiBnZXRUYWcobmV3IE1hcCkgIT0gbWFwVGFnKSB8fFxuICAgIChQcm9taXNlICYmIGdldFRhZyhQcm9taXNlLnJlc29sdmUoKSkgIT0gcHJvbWlzZVRhZykgfHxcbiAgICAoU2V0ICYmIGdldFRhZyhuZXcgU2V0KSAhPSBzZXRUYWcpIHx8XG4gICAgKFdlYWtNYXAgJiYgZ2V0VGFnKG5ldyBXZWFrTWFwKSAhPSB3ZWFrTWFwVGFnKSkge1xuICBnZXRUYWcgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciByZXN1bHQgPSBiYXNlR2V0VGFnKHZhbHVlKSxcbiAgICAgICAgQ3RvciA9IHJlc3VsdCA9PSBvYmplY3RUYWcgPyB2YWx1ZS5jb25zdHJ1Y3RvciA6IHVuZGVmaW5lZCxcbiAgICAgICAgY3RvclN0cmluZyA9IEN0b3IgPyB0b1NvdXJjZShDdG9yKSA6ICcnO1xuXG4gICAgaWYgKGN0b3JTdHJpbmcpIHtcbiAgICAgIHN3aXRjaCAoY3RvclN0cmluZykge1xuICAgICAgICBjYXNlIGRhdGFWaWV3Q3RvclN0cmluZzogcmV0dXJuIGRhdGFWaWV3VGFnO1xuICAgICAgICBjYXNlIG1hcEN0b3JTdHJpbmc6IHJldHVybiBtYXBUYWc7XG4gICAgICAgIGNhc2UgcHJvbWlzZUN0b3JTdHJpbmc6IHJldHVybiBwcm9taXNlVGFnO1xuICAgICAgICBjYXNlIHNldEN0b3JTdHJpbmc6IHJldHVybiBzZXRUYWc7XG4gICAgICAgIGNhc2Ugd2Vha01hcEN0b3JTdHJpbmc6IHJldHVybiB3ZWFrTWFwVGFnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIgOiBsZW5ndGg7XG4gIHJldHVybiAhIWxlbmd0aCAmJlxuICAgICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgfHwgcmVJc1VpbnQudGVzdCh2YWx1ZSkpICYmXG4gICAgKHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGgpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciB1c2UgYXMgdW5pcXVlIG9iamVjdCBrZXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNLZXlhYmxlKHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gKHR5cGUgPT0gJ3N0cmluZycgfHwgdHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nKVxuICAgID8gKHZhbHVlICE9PSAnX19wcm90b19fJylcbiAgICA6ICh2YWx1ZSA9PT0gbnVsbCk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgaXRzIHNvdXJjZSBtYXNrZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNNYXNrZWQoZnVuYykge1xuICByZXR1cm4gISFtYXNrU3JjS2V5ICYmIChtYXNrU3JjS2V5IGluIGZ1bmMpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhIHByb3RvdHlwZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm90b3R5cGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNQcm90b3R5cGUodmFsdWUpIHtcbiAgdmFyIEN0b3IgPSB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvcixcbiAgICAgIHByb3RvID0gKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUpIHx8IG9iamVjdFByb3RvO1xuXG4gIHJldHVybiB2YWx1ZSA9PT0gcHJvdG87XG59XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYGZ1bmNgIHRvIGl0cyBzb3VyY2UgY29kZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNvdXJjZSBjb2RlLlxuICovXG5mdW5jdGlvbiB0b1NvdXJjZShmdW5jKSB7XG4gIGlmIChmdW5jICE9IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZ1bmNUb1N0cmluZy5jYWxsKGZ1bmMpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAoZnVuYyArICcnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBQZXJmb3JtcyBhXG4gKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICpcbiAqIF8uZXEob2JqZWN0LCBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEob2JqZWN0LCBvdGhlcik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoJ2EnLCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEoJ2EnLCBPYmplY3QoJ2EnKSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoTmFOLCBOYU4pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBlcSh2YWx1ZSwgb3RoZXIpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBvdGhlciB8fCAodmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcik7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FyZ3VtZW50cyA9IGJhc2VJc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA/IGJhc2VJc0FyZ3VtZW50cyA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJlxuICAgICFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJyk7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG4gKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjMuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgQnVmZmVyKDIpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBVaW50OEFycmF5KDIpKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0J1ZmZlciA9IG5hdGl2ZUlzQnVmZmVyIHx8IHN0dWJGYWxzZTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIGRlZXAgY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlXG4gKiBlcXVpdmFsZW50LlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBzdXBwb3J0cyBjb21wYXJpbmcgYXJyYXlzLCBhcnJheSBidWZmZXJzLCBib29sZWFucyxcbiAqIGRhdGUgb2JqZWN0cywgZXJyb3Igb2JqZWN0cywgbWFwcywgbnVtYmVycywgYE9iamVjdGAgb2JqZWN0cywgcmVnZXhlcyxcbiAqIHNldHMsIHN0cmluZ3MsIHN5bWJvbHMsIGFuZCB0eXBlZCBhcnJheXMuIGBPYmplY3RgIG9iamVjdHMgYXJlIGNvbXBhcmVkXG4gKiBieSB0aGVpciBvd24sIG5vdCBpbmhlcml0ZWQsIGVudW1lcmFibGUgcHJvcGVydGllcy4gRnVuY3Rpb25zIGFuZCBET01cbiAqIG5vZGVzIGFyZSBjb21wYXJlZCBieSBzdHJpY3QgZXF1YWxpdHksIGkuZS4gYD09PWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICpcbiAqIF8uaXNFcXVhbChvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBvYmplY3QgPT09IG90aGVyO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNFcXVhbCh2YWx1ZSwgb3RoZXIpIHtcbiAgcmV0dXJuIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlcik7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0xlbmd0aCgzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aCgnMycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJlxuICAgIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KG5ldyBVaW50OEFycmF5KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShbXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNUeXBlZEFycmF5ID0gbm9kZUlzVHlwZWRBcnJheSA/IGJhc2VVbmFyeShub2RlSXNUeXBlZEFycmF5KSA6IGJhc2VJc1R5cGVkQXJyYXk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuIFNlZSB0aGVcbiAqIFtFUyBzcGVjXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIF8ua2V5cygnaGknKTtcbiAqIC8vID0+IFsnMCcsICcxJ11cbiAqL1xuZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCkgOiBiYXNlS2V5cyhvYmplY3QpO1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgZW1wdHkgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBlbXB0eSBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIGFycmF5cyA9IF8udGltZXMoMiwgXy5zdHViQXJyYXkpO1xuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5cyk7XG4gKiAvLyA9PiBbW10sIFtdXVxuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5c1swXSA9PT0gYXJyYXlzWzFdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIHN0dWJBcnJheSgpIHtcbiAgcmV0dXJuIFtdO1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYGZhbHNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5zdHViRmFsc2UpO1xuICogLy8gPT4gW2ZhbHNlLCBmYWxzZV1cbiAqL1xuZnVuY3Rpb24gc3R1YkZhbHNlKCkge1xuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNFcXVhbDtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/lodash.isequal/index.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});